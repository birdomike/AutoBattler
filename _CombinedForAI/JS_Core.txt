

===== FILE: BattleBehaviors.js =====
/**
 * BattleBehaviors.js (FALLBACK VERSION)
 * 
 * Simple non-ES Module version of the battle behavior system.
 * This file provides basic functionality without requiring complex imports.
 */

// Define a global variable to store the battle behaviors
window.battleBehaviors = window.battleBehaviors || {
    /**
     * Selects a target for an ability or action based on targeting logic
     * @param {string|null} targetingLogic - Name of targeting logic to use
     * @param {object} context - Targeting context
     * @returns {Character|Character[]|null} - Selected target(s) or null if no valid target
     */
    selectTarget: function(targetingLogic, context) {
        console.log(`Using targeting logic: ${targetingLogic}`);
        
        // Default targeting - find random enemy
        const targets = context.potentialTargets.filter(t => 
            t.team !== context.actor.team && t.currentHp > 0
        );
        
        // Decide based on targeting type
        switch(targetingLogic) {
            case 'targetLowestHpEnemy':
                // Find enemy with lowest HP
                if (targets.length === 0) return null;
                return targets.sort((a, b) => 
                    (a.currentHp / a.stats.hp) - (b.currentHp / b.stats.hp)
                )[0];
                
            case 'targetLowestHpAlly':
                // Find ally with lowest HP
                const allies = context.potentialTargets.filter(t => 
                    t.team === context.actor.team && t.currentHp > 0 && t.currentHp < t.stats.hp
                );
                if (allies.length === 0) {
                    // If no injured allies, target self
                    return context.actor;
                }
                return allies.sort((a, b) => 
                    (a.currentHp / a.stats.hp) - (b.currentHp / b.stats.hp)
                )[0];
                
            case 'targetSelf':
                // Target self
                return context.actor;
                
            default:
                // Random enemy
                return targets.length > 0 ? 
                    targets[Math.floor(Math.random() * targets.length)] : null;
        }
    },
    
    /**
     * Decides which ability to use (or basic attack)
     * @param {string|null} decisionLogic - Name of action decision logic to use
     * @param {object} context - Action decision context
     * @returns {object|null} - Selected ability or null for basic attack
     */
    decideAction: function(decisionLogic, context) {
        console.log(`Using action decision logic: ${decisionLogic}`);
        
        // Check if there are any available abilities
        if (!context.availableAbilities || context.availableAbilities.length === 0) {
            return null; // Use basic attack
        }
        
        // Decide based on logic type
        switch(decisionLogic) {
            case 'alwaysUseAbilities':
                // Always use an ability if available
                return context.availableAbilities[
                    Math.floor(Math.random() * context.availableAbilities.length)
                ];
                
            case 'prioritizeHealing':
                // Check for healing abilities if there are injured allies
                const healingAbilities = context.availableAbilities.filter(a => 
                    a.isHealing || a.damageType === 'healing'
                );
                
                // Check if there are injured allies
                const allies = context.actor.team === 'player' ? 
                    context.battleManager.playerTeam : context.battleManager.enemyTeam;
                const injuredAllies = allies.filter(a => 
                    a.currentHp > 0 && a.currentHp < a.stats.hp * 0.7
                );
                
                // If there are healing abilities and injured allies, use one
                if (healingAbilities.length > 0 && injuredAllies.length > 0) {
                    return healingAbilities[
                        Math.floor(Math.random() * healingAbilities.length)
                    ];
                }
                
                // Otherwise, 50% chance to use a damage ability
                return Math.random() > 0.5 && context.availableAbilities.length > 0 ? 
                    context.availableAbilities[
                        Math.floor(Math.random() * context.availableAbilities.length)
                    ] : null;
                
            case 'defaultActionDecision':
            default:
                // 50% chance to use ability
                return Math.random() > 0.5 && context.availableAbilities.length > 0 ? 
                    context.availableAbilities[
                        Math.floor(Math.random() * context.availableAbilities.length)
                    ] : null;
        }
    },
    
    /**
     * Processes a passive ability
     * @param {string} passiveName - Name of passive behavior to execute
     * @param {object} context - Passive context
     * @returns {object} - Result of the passive ability
     */
    processPassive: function(passiveName, context) {
        console.log(`Processing passive: ${passiveName} for trigger: ${context.trigger}`);
        return { executed: true, message: 'Passive ability activated' };
    },
    
    /**
     * Executes a passive behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executePassiveBehavior: function(name, context) {
        // Implementations for common passive behaviors
        switch(name) {
            case 'passive_ApplyRegenOnTurnStart':
                if (context.trigger === 'onTurnStart' && Math.random() < 0.5) {
                    context.battleManager.addStatusEffect(context.actor, 'status_regen', 2);
                    return { executed: true, message: 'Grants Regeneration!' };
                }
                return { executed: false };
                
            case 'passive_DamageReflectOnHit':
                if (context.trigger === 'onDamageTaken' && context.additionalData.source) {
                    const reflectAmount = Math.round(context.additionalData.damageAmount * 0.2);
                    if (reflectAmount > 0) {
                        context.battleManager.applyDamage(
                            context.additionalData.source, // target
                            reflectAmount, // damage
                            context.actor, // source
                            null, // ability
                            'reflected' // damageType
                        );
                        return { executed: true, message: `Reflects ${reflectAmount} damage back to attacker!` };
                    }
                }
                return { executed: false };
                
            case 'passive_ApplyStatusOnHit':
                if (context.trigger === 'onDamageTaken' && 
                    context.additionalData.source && 
                    Math.random() < 0.3) {
                    
                    const statusId = context.ability.passiveData?.statusId || 'status_spd_down';
                    const duration = context.ability.passiveData?.duration || 2;
                    
                    context.battleManager.addStatusEffect(
                        context.additionalData.source,
                        statusId,
                        duration
                    );
                    return { executed: true, message: 'Inflicts a status effect on the attacker!' };
                }
                return { executed: false };
                
            case 'passive_TeamBuffOnBattleStart':
                if (context.trigger === 'onBattleStart') {
                    const statusId = context.ability.passiveData?.statusId || 'status_atk_up';
                    const duration = context.ability.passiveData?.duration || 3;
                    
                    const allies = context.battleManager.getAllCharacters().filter(character => 
                        character.team === context.actor.team && !character.isDead
                    );
                    
                    allies.forEach(ally => {
                        context.battleManager.addStatusEffect(ally, statusId, duration);
                    });
                    
                    return { executed: true, message: 'Buffs the team at the start of battle!' };
                }
                return { executed: false };
                
            default:
                // For unknown passives, log and return a generic result
                console.log(`No specific handling for passive '${name}', using generic behavior.`);
                return { executed: true, message: 'Activated!' };
        }
    },
    
    /**
     * Utility function to check if a specific behavior exists
     * @param {string} behaviorName - Name of the behavior to check
     * @returns {boolean} - Whether the behavior exists
     */
    hasBehavior: function(behaviorName) {
        // We'll assume we have these behaviors for simplicity
        const knownBehaviors = [
            'targetRandomEnemy',
            'targetLowestHpEnemy',
            'targetLowestHpAlly',
            'targetSelf',
            'defaultActionDecision',
            'alwaysUseAbilities',
            'prioritizeHealing'
        ];
        
        return knownBehaviors.includes(behaviorName);
    },
    
    /**
     * Utility function to get the default targeting behavior
     * @returns {string} - Name of the default targeting behavior
     */
    getDefaultTargetingBehavior: function() {
        return 'targetRandomEnemy';
    },
    
    /**
     * Utility function to get the default action decision behavior
     * @returns {string} - Name of the default action decision behavior
     */
    getDefaultActionDecisionBehavior: function() {
        return 'defaultActionDecision';
    },
    
    /**
     * Maps targetType strings to targeting behavior names
     * @param {string} targetType - Type of targeting from ability data
     * @returns {string} - Name of the corresponding targeting behavior
     */
    getTargetingBehaviorFromType: function(targetType) {
        const mapping = {
            'SingleEnemy': 'targetRandomEnemy',
            'AllEnemies': 'targetRandomEnemy', // Simplified
            'Self': 'targetSelf',
            'SingleAlly': 'targetLowestHpAlly',
            'AllAllies': 'targetLowestHpAlly', // Simplified
            'LowestHpEnemy': 'targetLowestHpEnemy',
            'HighestHpEnemy': 'targetRandomEnemy', // Simplified
            'LowestHpAlly': 'targetLowestHpAlly'
        };
        
        return mapping[targetType] || 'targetRandomEnemy';
    }
};

// Let the console know this loaded
console.log('Fallback BattleBehaviors.js loaded successfully');


===== FILE: SafetyLoader.js =====
/**
 * SafetyLoader.js
 * 
 * This script ensures that the BattleManager is properly initialized
 * even if there are timing issues with script loading.
 */

(function() {
    console.log('Safety loader activated...');
    
    // Check periodically until BattleManager is available
    const maxAttempts = 10;
    let attempts = 0;
    
    function checkAndFixBattleManager() {
        attempts++;
        console.log(`Checking BattleManager availability (attempt ${attempts}/${maxAttempts})...`);
        
        if (typeof window.BattleManager === 'function') {
            console.log('BattleManager is properly defined!');
            return;
        }
        
        if (typeof BattleManager === 'function') {
            console.log('BattleManager exists but is not properly assigned to window - fixing...');
            window.BattleManager = BattleManager;
            return;
        }
        
        if (attempts >= maxAttempts) {
            console.error('Failed to find BattleManager after multiple attempts');
            return;
        }
        
        // Try again in a moment
        setTimeout(checkAndFixBattleManager, 500);
    }
    
    // Start checking after a short delay
    setTimeout(checkAndFixBattleManager, 100);
    
    // Also check when the page is fully loaded
    window.addEventListener('load', function() {
        console.log('Window loaded - doing final BattleManager check...');
        
        if (typeof window.BattleManager !== 'function' && typeof BattleManager === 'function') {
            console.log('Window loaded but BattleManager not assigned - fixing...');
            window.BattleManager = BattleManager;
        }
    });
})();


===== FILE: StatusEffectFixes.js =====
/**
 * StatusEffectFixes.js
 * 
 * This script patches the BattleManager's status effect handling
 * to ensure it works properly in the absence of actual status_effects.json
 */

(function() {
    console.log('Applying status effect fixes...');
    
    // Check if BattleManager exists
    if (typeof window.BattleManager !== 'function') {
        console.error('BattleManager not found when applying status effect fixes!');
        return;
    }
    
    // Create a backup of the original loadStatusEffectDefinitions method
    const originalLoadMethod = window.BattleManager.prototype.loadStatusEffectDefinitions;
    
    // Replace with our enhanced version that has better fallbacks
    window.BattleManager.prototype.loadStatusEffectDefinitions = async function() {
        console.log('Enhanced loadStatusEffectDefinitions running...');
        
        try {
            // Check if definitions are already loaded
            if (this.statusEffectDefinitions) {
                return this.statusEffectDefinitions;
            }
            
            console.log('Attempting to fetch status effect definitions...');
            
            // First try the original method
            try {
                // Call the original method
                const result = await originalLoadMethod.call(this);
                if (result && Object.keys(result).length > 0) {
                    console.log('Original status effect loading succeeded!');
                    return result;
                }
                throw new Error('Original method returned empty result');
            } catch (originalError) {
                console.warn('Original status effect loading failed:', originalError);
                
                // Create default status effect definitions
                console.log('Creating default status effect definitions as fallback');
                const defaultDefinitions = {
                    'burn': {
                        id: 'burn',
                        name: 'Burn',
                        description: 'Taking fire damage over time',
                        icon: 'assets/images/icons/status/burn.png',
                        type: 'DoT',
                        defaultDuration: 2,
                        maxStacks: 1,
                        behavior: {
                            trigger: 'onTurnStart',
                            action: 'Damage',
                            valueType: 'PercentMaxHP',
                            value: 0.08,
                            damageType: 'fire'
                        }
                    },
                    'regen': {
                        id: 'regen',
                        name: 'Regeneration',
                        description: 'Healing over time',
                        icon: 'assets/images/icons/status/regen.png',
                        type: 'HoT',
                        defaultDuration: 3,
                        maxStacks: 1,
                        behavior: {
                            trigger: 'onTurnStart',
                            action: 'Heal',
                            valueType: 'PercentMaxHP',
                            value: 0.05
                        }
                    },
                    'stun': {
                        id: 'stun',
                        name: 'Stunned',
                        description: 'Unable to take actions',
                        icon: 'assets/images/icons/status/stun.png',
                        type: 'Control',
                        defaultDuration: 1,
                        maxStacks: 1,
                        behavior: {
                            modifier: 'PreventAction',
                            value: true
                        }
                    },
                    'attack_up': {
                        id: 'attack_up',
                        name: 'Attack Up',
                        description: 'Attack increased by 50%',
                        icon: 'assets/images/icons/status/attack_up.png',
                        type: 'Buff',
                        defaultDuration: 3,
                        maxStacks: 1,
                        behavior: {
                            modifier: 'StatModification',
                            stat: 'Attack',
                            value: 0.5,
                            isMultiplier: true
                        }
                    },
                    'defense_up': {
                        id: 'defense_up',
                        name: 'Defense Up',
                        description: 'Defense increased by 50%',
                        icon: 'assets/images/icons/status/defense_up.png',
                        type: 'Buff',
                        defaultDuration: 3,
                        maxStacks: 1,
                        behavior: {
                            modifier: 'StatModification',
                            stat: 'Defense',
                            value: 0.5,
                            isMultiplier: true
                        }
                    }
                };
                
                this.statusEffectDefinitions = defaultDefinitions;
                console.log('Using default status effect definitions');
                return defaultDefinitions;
            }
        } catch (error) {
            console.error('Unexpected error loading status effect definitions:', error);
            // Return an empty object as fallback
            this.statusEffectDefinitions = {};
            return {};
        }
    };
    
    console.log('Status effect fixes applied successfully');
})();


===== FILE: ActionDecisionBehaviors.js =====
/**
 * ActionDecisionBehaviors.js
 * 
 * Collection of action decision behavior functions for the battle system.
 * These functions determine how characters decide which ability to use (or basic attack).
 */

import behaviorRegistry from './BehaviorRegistry.js';

/**
 * Context object expected for action decision behaviors:
 * {
 *   actor: Character,              // The character taking the action
 *   availableAbilities: Object[],  // List of abilities with cooldown === 0
 *   battleManager: BattleManager,  // Reference to BattleManager for battle state
 *   teamManager: TeamManager       // Reference to TeamManager for team data
 * }
 */

/**
 * Default 50% chance to use an ability if available (matches original behavior)
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_Random50Percent(context) {
    const { availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null; // Null indicates basic attack
    }
    
    // 50% chance to use an ability (from original BattleManager)
    if (Math.random() > 0.5) {
        // Select random ability from available ones
        const randomIndex = Math.floor(Math.random() * availableAbilities.length);
        return availableAbilities[randomIndex];
    }
    
    // Use basic attack
    return null;
}

/**
 * Uses weighted random selection for ability choice
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_WeightedRandomAbility(context) {
    const { actor, availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null; // Null indicates basic attack
    }
    
    // Use character's abilityAffinity if defined, or default to 0.7 (70% chance to consider ability)
    const abilityAffinity = actor.abilityAffinity || 0.7;
    
    // Check if we should consider using an ability at all
    if (Math.random() < abilityAffinity) {
        // Calculate total weight of all available abilities
        let totalWeight = 0;
        for (const ability of availableAbilities) {
            // Use ability's selectionWeight or default to 1.0
            const weight = ability.selectionWeight || 1.0;
            totalWeight += weight;
        }
        
        // Generate random weight
        let randomWeight = Math.random() * totalWeight;
        
        // Find the ability that corresponds to this weight
        for (const ability of availableAbilities) {
            const weight = ability.selectionWeight || 1.0;
            randomWeight -= weight;
            
            if (randomWeight <= 0) {
                return ability;
            }
        }
        
        // Fallback in case of rounding errors
        return availableAbilities[availableAbilities.length - 1];
    }
    
    // Use basic attack
    return null;
}

/**
 * Prioritizes healing abilities when allies are below health threshold
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_PrioritizeHeal(context) {
    const { actor, availableAbilities, teamManager, battleManager } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Get actor's team
    const actorTeam = teamManager.getCharacterTeam(actor);
    
    // Check team health status
    const allCharacters = battleManager.getAllCharacters();
    const allies = allCharacters.filter(character => 
        teamManager.getCharacterTeam(character) === actorTeam && !character.defeated
    );
    
    // Calculate average health percentage of team
    let totalHealthPercent = 0;
    allies.forEach(ally => {
        totalHealthPercent += (ally.currentHp / ally.stats.hp);
    });
    const avgHealthPercent = totalHealthPercent / allies.length;
    
    // Check if any ally is below 50% health
    const needsHealing = allies.some(ally => (ally.currentHp / ally.stats.hp) < 0.5);
    
    // If healing is needed
    if (needsHealing) {
        // Find healing abilities
        const healingAbilities = availableAbilities.filter(ability => 
            ability.isHealing || ability.damageType === 'healing'
        );
        
        if (healingAbilities.length > 0) {
            // Get the healing ability with highest selectionWeight
            return healingAbilities.reduce((best, current) => {
                const currentWeight = current.selectionWeight || 1.0;
                const bestWeight = best.selectionWeight || 1.0;
                return currentWeight > bestWeight ? current : best;
            }, healingAbilities[0]);
        }
    }
    
    // If team is healthy or no healing abilities available
    // Use weighted random selection like normal
    return decideAction_WeightedRandomAbility(context);
}

/**
 * Always prioritizes offensive abilities
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_PrioritizeOffense(context) {
    const { availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Filter out healing/utility abilities
    const offensiveAbilities = availableAbilities.filter(ability => 
        !ability.isHealing && ability.damageType !== 'healing' && ability.damageType !== 'utility'
    );
    
    if (offensiveAbilities.length > 0) {
        // Select the offensive ability with highest selectionWeight
        return offensiveAbilities.reduce((best, current) => {
            const currentWeight = current.selectionWeight || 1.0;
            const bestWeight = best.selectionWeight || 1.0;
            return currentWeight > bestWeight ? current : best;
        }, offensiveAbilities[0]);
    }
    
    // If no offensive abilities available, fall back to weighted random selection
    return decideAction_WeightedRandomAbility(context);
}

/**
 * Prioritizes defensive abilities, especially when health is low
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_Defensive(context) {
    const { actor, availableAbilities, teamManager, battleManager } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Calculate health percentage
    const healthPercent = actor.currentHp / actor.stats.hp;
    
    // Check if health is below 50%
    const isLowHealth = healthPercent < 0.5;
    
    // Higher chance to use abilities when health is low
    const abilityAffinity = isLowHealth ? 0.9 : 0.7;
    
    // First check if we should consider using an ability at all
    if (Math.random() < abilityAffinity) {
        // Categorize available abilities
        const defensiveAbilities = availableAbilities.filter(ability => {
            // Consider abilities that provide shields, healing, or defensive buffs
            if (ability.isHealing || ability.damageType === 'healing') return true;
            if (ability.damageType === 'utility') return true;
            
            // Check for defensive effects in the effects array
            if (ability.effects && Array.isArray(ability.effects)) {
                return ability.effects.some(effect => 
                    (effect.type === 'ApplyStatus' && 
                    ['status_def_up', 'status_shield', 'status_regen', 'status_evade'].includes(effect.statusEffectId)) ||
                    (effect.type === 'StatBuff' && 
                    ['Defense', 'MaxHP'].includes(effect.targetStat))
                );
            }
            
            return false;
        });
        
        // If low health and defensive abilities available, use them
        if (isLowHealth && defensiveAbilities.length > 0) {
            // Select defensive ability with highest weight
            return defensiveAbilities.reduce((best, current) => {
                const currentWeight = current.selectionWeight || 1.0;
                const bestWeight = best.selectionWeight || 1.0;
                return currentWeight > bestWeight ? current : best;
            }, defensiveAbilities[0]);
        }
        
        // Otherwise use weighted selection from all abilities
        // Calculate total weight with higher weight for defensive abilities
        let totalWeight = 0;
        for (const ability of availableAbilities) {
            let weight = ability.selectionWeight || 1.0;
            
            // Increase weight for defensive abilities
            if (defensiveAbilities.includes(ability)) {
                weight *= 1.5; // 50% higher weight for defensive abilities
            }
            
            totalWeight += weight;
        }
        
        // Generate random weight
        let randomWeight = Math.random() * totalWeight;
        
        // Find the ability that corresponds to this weight
        for (const ability of availableAbilities) {
            let weight = ability.selectionWeight || 1.0;
            
            // Increase weight for defensive abilities
            if (defensiveAbilities.includes(ability)) {
                weight *= 1.5;
            }
            
            randomWeight -= weight;
            
            if (randomWeight <= 0) {
                return ability;
            }
        }
        
        // Fallback in case of rounding errors
        return availableAbilities[availableAbilities.length - 1];
    }
    
    // Use basic attack
    return null;
}

/**
 * Always tries to use abilities if available, prioritizing by selection weight
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_AlwaysUseAbilities(context) {
    const { availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Select the ability with highest selectionWeight
    return availableAbilities.reduce((best, current) => {
        const currentWeight = current.selectionWeight || 1.0;
        const bestWeight = best.selectionWeight || 1.0;
        return currentWeight > bestWeight ? current : best;
    }, availableAbilities[0]);
}

// Register all action decision behaviors
behaviorRegistry.registerActionDecisionBehavior('decideAction_Random50Percent', decideAction_Random50Percent, true); // Set as default
behaviorRegistry.registerActionDecisionBehavior('decideAction_WeightedRandomAbility', decideAction_WeightedRandomAbility);
behaviorRegistry.registerActionDecisionBehavior('decideAction_PrioritizeHeal', decideAction_PrioritizeHeal);
behaviorRegistry.registerActionDecisionBehavior('decideAction_PrioritizeOffense', decideAction_PrioritizeOffense);
behaviorRegistry.registerActionDecisionBehavior('decideAction_AlwaysUseAbilities', decideAction_AlwaysUseAbilities);
behaviorRegistry.registerActionDecisionBehavior('decideAction_Defensive', decideAction_Defensive);

// Export individual behaviors for direct use if needed
export {
    decideAction_Random50Percent,
    decideAction_WeightedRandomAbility,
    decideAction_PrioritizeHeal,
    decideAction_PrioritizeOffense,
    decideAction_AlwaysUseAbilities,
    decideAction_Defensive
};


===== FILE: BattleBehaviors.js =====
/**
 * BattleBehaviors.js
 * 
 * Main entry point for the battle behavior system.
 * Imports and re-exports all behavior functionality.
 */

import behaviorRegistry from './BehaviorRegistry.js';

// Import all behaviors to ensure they're registered
import * as targetingBehaviors from './TargetingBehaviors.js';
import * as actionDecisionBehaviors from './ActionDecisionBehaviors.js';
import * as passiveBehaviors from './PassiveBehaviors.js';

/**
 * A centralized interface for executing behavior functions
 */
class BattleBehaviors {
    constructor() {
        this.registry = behaviorRegistry;
    }
    
    /**
     * Selects a target for an ability or action based on targeting logic
     * @param {string|null} targetingLogic - Name of targeting logic to use
     * @param {object} context - Targeting context
     * @returns {Character|Character[]|null} - Selected target(s) or null if no valid target
     */
    selectTarget(targetingLogic, context) {
        return this.registry.executeTargetingBehavior(targetingLogic, context);
    }
    
    /**
     * Decides which ability to use (or basic attack)
     * @param {string|null} decisionLogic - Name of action decision logic to use
     * @param {object} context - Action decision context
     * @returns {object|null} - Selected ability or null for basic attack
     */
    decideAction(decisionLogic, context) {
        return this.registry.executeActionDecisionBehavior(decisionLogic, context);
    }
    
    /**
     * Processes a passive ability
     * @param {string} passiveName - Name of passive behavior to execute
     * @param {object} context - Passive context
     * @returns {object} - Result of the passive ability
     */
    executePassiveBehavior(passiveName, context) {
        return this.registry.executePassiveBehavior(passiveName, context);
    }
    
    /**
     * Utility function to check if a specific behavior exists
     * @param {string} behaviorName - Name of the behavior to check
     * @returns {boolean} - Whether the behavior exists
     */
    hasBehavior(behaviorName) {
        return !!this.registry.allBehaviors[behaviorName];
    }
    
    /**
     * Utility function to get the default targeting behavior
     * @returns {string} - Name of the default targeting behavior
     */
    getDefaultTargetingBehavior() {
        return this.registry.defaultTargetingBehavior;
    }
    
    /**
     * Utility function to get the default action decision behavior
     * @returns {string} - Name of the default action decision behavior
     */
    getDefaultActionDecisionBehavior() {
        return this.registry.defaultActionDecisionBehavior;
    }
    
    /**
     * Maps targetType strings to targeting behavior names
     * @param {string} targetType - Type of targeting from ability data
     * @returns {string} - Name of the corresponding targeting behavior
     */
    getTargetingBehaviorFromType(targetType) {
        const mapping = {
            'SingleEnemy': 'targetRandomEnemy',
            'AllEnemies': 'targetAllEnemies',
            'Self': 'targetSelf',
            'SingleAlly': 'targetLowestHpAlly',
            'AllAllies': 'targetAllAllies',
            'LowestHpEnemy': 'targetLowestHpEnemy',
            'HighestHpEnemy': 'targetHighestHpEnemy',
            'LowestHpAlly': 'targetLowestHpAlly'
        };
        
        return mapping[targetType] || this.registry.defaultTargetingBehavior;
    }
}

// Create and export singleton instance
const battleBehaviors = new BattleBehaviors();
export default battleBehaviors;

// Re-export everything for convenience
export {
    behaviorRegistry,
    targetingBehaviors,
    actionDecisionBehaviors,
    passiveBehaviors
};


===== FILE: BehaviorRegistry.js =====
/**
 * BehaviorRegistry.js
 * 
 * Centralized registry for all behavior functions used in the battle system.
 * This enables a flexible "behavior delegation" pattern where specific logic
 * can be referenced by name and dynamically executed.
 */

class BehaviorRegistry {
    constructor() {
        // Initialize registries for different behavior types
        this.targetingBehaviors = {};
        this.actionDecisionBehaviors = {};
        this.passiveBehaviors = {};
        
        // Track all registered behaviors for debugging
        this.allBehaviors = {};
        
        // Default behaviors
        this.defaultTargetingBehavior = null;
        this.defaultActionDecisionBehavior = null;
    }

    /**
     * Register a targeting behavior function
     * @param {string} name - Unique name to reference this behavior
     * @param {Function} behaviorFn - The behavior function
     * @param {boolean} isDefault - Whether this should be the default behavior
     * @returns {BehaviorRegistry} - For method chaining
     */
    registerTargetingBehavior(name, behaviorFn, isDefault = false) {
        this.targetingBehaviors[name] = behaviorFn;
        this.allBehaviors[name] = { type: 'targeting', fn: behaviorFn };
        
        if (isDefault) {
            this.defaultTargetingBehavior = name;
        }
        
        return this;
    }

    /**
     * Register an action decision behavior function
     * @param {string} name - Unique name to reference this behavior
     * @param {Function} behaviorFn - The behavior function
     * @param {boolean} isDefault - Whether this should be the default behavior
     * @returns {BehaviorRegistry} - For method chaining
     */
    registerActionDecisionBehavior(name, behaviorFn, isDefault = false) {
        this.actionDecisionBehaviors[name] = behaviorFn;
        this.allBehaviors[name] = { type: 'actionDecision', fn: behaviorFn };
        
        if (isDefault) {
            this.defaultActionDecisionBehavior = name;
        }
        
        return this;
    }

    /**
     * Register a passive behavior function
     * @param {string} name - Unique name to reference this behavior
     * @param {Function} behaviorFn - The behavior function
     * @returns {BehaviorRegistry} - For method chaining
     */
    registerPassiveBehavior(name, behaviorFn) {
        this.passiveBehaviors[name] = behaviorFn;
        this.allBehaviors[name] = { type: 'passive', fn: behaviorFn };
        
        return this;
    }

    /**
     * Get a targeting behavior function by name
     * @param {string} name - Name of the behavior to retrieve
     * @returns {Function|null} - The behavior function or null if not found
     */
    getTargetingBehavior(name) {
        // If name is null/undefined or behavior doesn't exist, return default
        if (!name || !this.targetingBehaviors[name]) {
            if (this.defaultTargetingBehavior) {
                return this.targetingBehaviors[this.defaultTargetingBehavior];
            }
            console.warn(`No targeting behavior found for '${name}' and no default set`);
            return null;
        }
        
        return this.targetingBehaviors[name];
    }

    /**
     * Get an action decision behavior function by name
     * @param {string} name - Name of the behavior to retrieve
     * @returns {Function|null} - The behavior function or null if not found
     */
    getActionDecisionBehavior(name) {
        // If name is null/undefined or behavior doesn't exist, return default
        if (!name || !this.actionDecisionBehaviors[name]) {
            if (this.defaultActionDecisionBehavior) {
                return this.actionDecisionBehaviors[this.defaultActionDecisionBehavior];
            }
            console.warn(`No action decision behavior found for '${name}' and no default set`);
            return null;
        }
        
        return this.actionDecisionBehaviors[name];
    }

    /**
     * Get a passive behavior function by name
     * @param {string} name - Name of the behavior to retrieve
     * @returns {Function|null} - The behavior function or null if not found
     */
    getPassiveBehavior(name) {
        // If name is null/undefined or behavior doesn't exist, return null
        if (!name || !this.passiveBehaviors[name]) {
            console.warn(`No passive behavior found for '${name}'`);
            return null;
        }
        
        return this.passiveBehaviors[name];
    }

    /**
     * Execute a targeting behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executeTargetingBehavior(name, context) {
        const behaviorFn = this.getTargetingBehavior(name);
        if (!behaviorFn) return null;
        
        try {
            return behaviorFn(context);
        } catch (error) {
            console.error(`Error executing targeting behavior '${name}':`, error);
            // Fall back to default if available
            if (name !== this.defaultTargetingBehavior && this.defaultTargetingBehavior) {
                console.warn(`Falling back to default targeting behavior`);
                return this.executeTargetingBehavior(this.defaultTargetingBehavior, context);
            }
            return null;
        }
    }

    /**
     * Execute an action decision behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executeActionDecisionBehavior(name, context) {
        const behaviorFn = this.getActionDecisionBehavior(name);
        if (!behaviorFn) return null;
        
        try {
            return behaviorFn(context);
        } catch (error) {
            console.error(`Error executing action decision behavior '${name}':`, error);
            // Fall back to default if available
            if (name !== this.defaultActionDecisionBehavior && this.defaultActionDecisionBehavior) {
                console.warn(`Falling back to default action decision behavior`);
                return this.executeActionDecisionBehavior(this.defaultActionDecisionBehavior, context);
            }
            return null;
        }
    }

    /**
     * Execute a passive behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executePassiveBehavior(name, context) {
        const behaviorFn = this.getPassiveBehavior(name);
        if (!behaviorFn) return null;
        
        try {
            return behaviorFn(context);
        } catch (error) {
            console.error(`Error executing passive behavior '${name}':`, error);
            return null;
        }
    }

    /**
     * Utility method to list all registered behaviors
     * @returns {object} - Map of all registered behaviors by type
     */
    listAllBehaviors() {
        return {
            targeting: Object.keys(this.targetingBehaviors),
            actionDecision: Object.keys(this.actionDecisionBehaviors),
            passive: Object.keys(this.passiveBehaviors),
            defaultTargeting: this.defaultTargetingBehavior,
            defaultActionDecision: this.defaultActionDecisionBehavior
        };
    }
}

// Create singleton instance
const behaviorRegistry = new BehaviorRegistry();

// Export singleton
export default behaviorRegistry;


===== FILE: BehaviorRegistryTest.js =====
/**
 * BehaviorRegistryTest.js
 * 
 * A simple test utility to validate the behavior registry system.
 * This can be run directly in the browser console.
 */

import battleBehaviors from './BattleBehaviors.js';

/**
 * Test mock character
 */
class MockCharacter {
    constructor(name, team, hp = 100, attk = 10, def = 5, spd = 10) {
        this.name = name;
        this.team = team;
        this.stats = { hp, attack: attk, defense: def, speed: spd };
        this.currentHp = hp;
        this.defeated = false;
    }
}

/**
 * Test mock TeamManager
 */
class MockTeamManager {
    constructor() {
        this.characterTeams = new Map();
    }
    
    getCharacterTeam(character) {
        return character.team;
    }
    
    addCharacter(character, team) {
        character.team = team;
        this.characterTeams.set(character, team);
    }
}

/**
 * Test mock BattleManager
 */
class MockBattleManager {
    constructor() {
        this.characters = [];
        this.statusEffects = new Map();
    }
    
    getAllCharacters() {
        return this.characters;
    }
    
    addCharacter(character) {
        this.characters.push(character);
    }
    
    addStatusEffect(character, statusId, duration) {
        if (!this.statusEffects.has(character)) {
            this.statusEffects.set(character, []);
        }
        
        this.statusEffects.get(character).push({
            id: statusId,
            duration,
            appliedAt: Date.now()
        });
        
        console.log(`Added status ${statusId} to ${character.name} for ${duration} turns`);
    }
    
    applyDamage(target, amount, source, ability, type) {
        console.log(`${source.name} deals ${amount} ${type || ''} damage to ${target.name}`);
        target.currentHp -= amount;
        if (target.currentHp <= 0) {
            target.defeated = true;
            console.log(`${target.name} is defeated!`);
        }
    }
}

/**
 * Run tests for targeting behaviors
 */
function testTargetingBehaviors() {
    console.log("=== Testing Targeting Behaviors ===");
    
    // Setup test data
    const teamManager = new MockTeamManager();
    const actor = new MockCharacter("Hero", "ally", 100, 10, 5, 10);
    const enemy1 = new MockCharacter("Enemy1", "enemy", 100, 10, 5, 10);
    const enemy2 = new MockCharacter("Enemy2", "enemy", 50, 15, 3, 12);
    const ally1 = new MockCharacter("Ally1", "ally", 30, 8, 4, 9);
    
    const potentialTargets = [actor, enemy1, enemy2, ally1];
    
    // Test context
    const context = {
        actor,
        potentialTargets,
        teamManager,
        ability: { name: "Test Ability" }
    };
    
    // Test targeting behaviors
    console.log("targetRandomEnemy:", battleBehaviors.selectTarget('targetRandomEnemy', context)?.name);
    console.log("targetLowestHpEnemy:", battleBehaviors.selectTarget('targetLowestHpEnemy', context)?.name);
    console.log("targetHighestHpEnemy:", battleBehaviors.selectTarget('targetHighestHpEnemy', context)?.name);
    console.log("targetAllEnemies:", battleBehaviors.selectTarget('targetAllEnemies', context)?.map(t => t.name));
    console.log("targetLowestHpAlly:", battleBehaviors.selectTarget('targetLowestHpAlly', context)?.name);
    console.log("targetAllAllies:", battleBehaviors.selectTarget('targetAllAllies', context)?.map(t => t.name));
    console.log("targetSelf:", battleBehaviors.selectTarget('targetSelf', context)?.name);
    
    // Test targetType to behavior mapping
    console.log("Behavior for 'SingleEnemy':", battleBehaviors.getTargetingBehaviorFromType('SingleEnemy'));
    console.log("Behavior for 'AllEnemies':", battleBehaviors.getTargetingBehaviorFromType('AllEnemies'));
    console.log("Behavior for 'LowestHpAlly':", battleBehaviors.getTargetingBehaviorFromType('LowestHpAlly'));
    
    // Test default behavior
    console.log("Default targeting behavior:", battleBehaviors.getDefaultTargetingBehavior());
    console.log("Using default for unknown behavior:", battleBehaviors.selectTarget('nonexistent', context)?.name);
}

/**
 * Run tests for action decision behaviors
 */
function testActionDecisionBehaviors() {
    console.log("=== Testing Action Decision Behaviors ===");
    
    // Setup test data
    const actor = new MockCharacter("Hero", "ally", 100, 10, 5, 10);
    const battleManager = new MockBattleManager();
    const teamManager = new MockTeamManager();
    
    const availableAbilities = [
        {
            id: "ability1",
            name: "Fireball",
            damageType: "spell",
            isHealing: false,
            selectionWeight: 1.0
        },
        {
            id: "ability2",
            name: "Heal",
            damageType: "healing",
            isHealing: true,
            selectionWeight: 1.2
        },
        {
            id: "ability3",
            name: "Shield",
            damageType: "utility",
            isHealing: false,
            selectionWeight: 0.8
        }
    ];
    
    // Test context
    const context = {
        actor,
        availableAbilities,
        battleManager,
        teamManager
    };
    
    // Test multiple times to observe randomness
    console.log("=== decideAction_Random50Percent (multiple runs) ===");
    for (let i = 0; i < 5; i++) {
        const result = battleBehaviors.decideAction('decideAction_Random50Percent', context);
        console.log(`Run ${i + 1}:`, result ? result.name : "Basic Attack");
    }
    
    console.log("=== decideAction_WeightedRandomAbility (multiple runs) ===");
    for (let i = 0; i < 5; i++) {
        const result = battleBehaviors.decideAction('decideAction_WeightedRandomAbility', context);
        console.log(`Run ${i + 1}:`, result ? result.name : "Basic Attack");
    }
    
    console.log("=== decideAction_PrioritizeOffense ===");
    const offensiveResult = battleBehaviors.decideAction('decideAction_PrioritizeOffense', context);
    console.log("Result:", offensiveResult ? offensiveResult.name : "Basic Attack");
    
    console.log("=== decideAction_AlwaysUseAbilities ===");
    const alwaysAbilityResult = battleBehaviors.decideAction('decideAction_AlwaysUseAbilities', context);
    console.log("Result:", alwaysAbilityResult ? alwaysAbilityResult.name : "Basic Attack");
    
    // Test with healing priority when allies are injured
    console.log("=== decideAction_PrioritizeHeal (allies need healing) ===");
    
    // Create injured allies
    const ally1 = new MockCharacter("InjuredAlly", "ally", 100, 10, 5, 10);
    ally1.currentHp = 30; // 30% health
    
    battleManager.addCharacter(actor);
    battleManager.addCharacter(ally1);
    teamManager.addCharacter(actor, "ally");
    teamManager.addCharacter(ally1, "ally");
    
    const healingResult = battleBehaviors.decideAction('decideAction_PrioritizeHeal', context);
    console.log("Result:", healingResult ? healingResult.name : "Basic Attack");
}

/**
 * Run tests for passive behaviors
 */
function testPassiveBehaviors() {
    console.log("=== Testing Passive Behaviors ===");
    
    // Setup test data
    const actor = new MockCharacter("Hero", "ally", 100, 10, 5, 10);
    const enemy = new MockCharacter("Enemy", "enemy", 100, 10, 5, 10);
    const battleManager = new MockBattleManager();
    const teamManager = new MockTeamManager();
    
    // Add characters
    battleManager.addCharacter(actor);
    battleManager.addCharacter(enemy);
    teamManager.addCharacter(actor, "ally");
    teamManager.addCharacter(enemy, "enemy");
    
    // Test passive_ApplyRegenOnTurnStart
    console.log("=== passive_ApplyRegenOnTurnStart ===");
    
    const regenContext = {
        actor,
        ability: { name: "Regeneration", passiveType: "onTurnStart" },
        battleManager,
        teamManager,
        trigger: 'onTurnStart'
    };
    
    const regenResult = battleBehaviors.processPassive('passive_ApplyRegenOnTurnStart', regenContext);
    console.log("Result:", regenResult);
    
    // Test passive_DamageReflectOnHit
    console.log("=== passive_DamageReflectOnHit ===");
    
    const reflectContext = {
        actor,
        ability: { name: "Thorns", passiveType: "onDamageTaken" },
        battleManager,
        teamManager,
        trigger: 'onDamageTaken',
        additionalData: {
            source: enemy,
            damageAmount: 20
        }
    };
    
    const reflectResult = battleBehaviors.processPassive('passive_DamageReflectOnHit', reflectContext);
    console.log("Result:", reflectResult);
    
    // Test passive_TeamBuffOnBattleStart
    console.log("=== passive_TeamBuffOnBattleStart ===");
    
    const buffContext = {
        actor,
        ability: { 
            name: "Team Spirit", 
            passiveType: "onBattleStart",
            passiveData: {
                statusId: "status_atk_up",
                duration: 3
            }
        },
        battleManager,
        teamManager,
        trigger: 'onBattleStart'
    };
    
    const buffResult = battleBehaviors.processPassive('passive_TeamBuffOnBattleStart', buffContext);
    console.log("Result:", buffResult);
}

/**
 * Run all tests
 */
function runAllTests() {
    console.log("======= BEHAVIOR REGISTRY TEST =======");
    
    // List all registered behaviors
    console.log("=== REGISTERED BEHAVIORS ===");
    console.log(battleBehaviors.registry.listAllBehaviors());
    
    // Run individual tests
    testTargetingBehaviors();
    testActionDecisionBehaviors();
    testPassiveBehaviors();
    
    console.log("======= TEST COMPLETE =======");
}

// Export test functions
export {
    runAllTests,
    testTargetingBehaviors,
    testActionDecisionBehaviors,
    testPassiveBehaviors
};

// Automatically run tests when imported directly
if (typeof window !== 'undefined') {
    window.runBehaviorTests = runAllTests;
    console.log("Test utility loaded. Run tests with window.runBehaviorTests()");
}


===== FILE: index.js =====
/**
 * Index file for the battle logic system
 * Provides a central point for importing all battle behavior components
 */

// Export main interface
export { default as battleBehaviors } from './BattleBehaviors.js';

// Export registry and individual behavior collections
export { default as behaviorRegistry } from './BehaviorRegistry.js';
export * as targetingBehaviors from './TargetingBehaviors.js';
export * as actionDecisionBehaviors from './ActionDecisionBehaviors.js';
export * as passiveBehaviors from './PassiveBehaviors.js';

// Export test utilities
export * as behaviorTesting from './BehaviorRegistryTest.js';

// For direct script inclusion, attach to window
if (typeof window !== 'undefined') {
    // Import and set up on window for direct browser usage
    import('./BattleBehaviors.js').then(module => {
        window.battleBehaviors = module.default;
        console.log('Battle Behaviors system loaded and available at window.battleBehaviors');
    });
}


===== FILE: PassiveBehaviors.js =====
/**
 * PassiveBehaviors.js
 * 
 * Collection of passive behavior functions for the battle system.
 * These functions define how passive abilities trigger and what effects they apply.
 */

import behaviorRegistry from './BehaviorRegistry.js';

/**
 * Context object expected for passive behaviors:
 * {
 *   actor: Character,              // The character with the passive ability
 *   ability: Object,               // The passive ability being triggered
 *   battleManager: BattleManager,  // Reference to BattleManager for battle state
 *   teamManager: TeamManager,      // Reference to TeamManager for team data
 *   trigger: String,               // What triggered this passive (onTurnStart, onHit, etc.)
 *   additionalData: Object         // Contextual data based on the trigger (damage amount, source, etc.)
 * }
 */

/**
 * -----------------------------------------------
 * Passive Trigger Types Reference
 * -----------------------------------------------
 * onBattleStart    - When battle begins
 * onBattleEnd      - When battle ends
 * onTurnStart      - At start of a new turn
 * onTurnEnd        - At end of a turn
 * onActionStart    - Before an action is executed
 * onActionEnd      - After an action is executed
 * onDamageDealt    - After dealing damage to a target
 * onDamageTaken    - After taking damage from a source
 * onHealed         - After being healed
 * onHealingDone    - After healing a target
 * onKill           - After defeating an enemy
 * onDefeat         - When character is defeated
 * onRevive         - When character is revived
 * onStatusApplied  - When a status effect is applied to character
 * onStatusRemoved  - When a status effect expires or is removed
 * -----------------------------------------------
 */

/**
 * Applies regeneration status effect at the start of the turn
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_ApplyRegenOnTurnStart(context) {
    const { actor, battleManager, trigger } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onTurnStart') return { executed: false };
    
    // Verify character has valid health before proceeding
    if (!actor || !actor.stats || !actor.stats.hp || isNaN(actor.currentHp)) {
        console.error('Cannot apply regen to character with invalid health state:', actor);
        return { executed: false };
    }
    
    // Apply regeneration status effect
    battleManager.addStatusEffect(actor, 'status_regen', 2);
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability grants Regeneration!`
    };
}

/**
 * Reflects a portion of damage back to the attacker when hit
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_DamageReflectOnHit(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and additional data is provided
    if (trigger !== 'onDamageTaken' || !additionalData) return { executed: false };
    
    const { source, damageAmount, reflectionDepth = 0 } = additionalData;
    
    // Limit reflection depth to prevent infinite chains
    if (reflectionDepth >= 2) { // Maximum of 2 reflection cycles (initial hit + 2 reflections)
        console.debug(`Max reflection depth (${reflectionDepth}) reached, stopping reflection chain`);
        return { executed: false };
    }
    
    // Do nothing if source is not defined or it's self-damage
    if (!source || source === actor) return { executed: false };
    
    // Validate damage amount before calculations
    if (typeof damageAmount !== 'number' || isNaN(damageAmount) || damageAmount <= 0) {
        console.error('Invalid damage amount for reflection:', damageAmount);
        return { executed: false };
    }
    
    // Check if source is valid
    if (!source || !source.currentHp || isNaN(source.currentHp)) {
        console.error('Invalid source for damage reflection');
        return { executed: false };
    }
    
    // Check if source and actor are on different teams (prevent friendly fire)
    if (source.team === actor.team) {
        console.debug(`Skipping damage reflection to ${source.name} as they are on the same team as ${actor.name}`);
        return { executed: false };
    }
    
    // Calculate reflected damage (20% of damage taken)
    const reflectAmount = Math.round(Math.max(1, damageAmount * 0.2));
    
    // Implement a minimum threshold for reflection to prevent endless small reflections
    if (reflectAmount <= 2 && reflectionDepth > 0) {
        console.debug(`Reflection amount (${reflectAmount}) too small for secondary reflection, stopping chain`);
        return { executed: false };
    }
    
    // Apply reflected damage with increased reflection depth
    battleManager.applyDamage(
        source,                 // target (the original attacker)
        reflectAmount,          // damage amount
        actor,                  // source (self)
        null,                   // no ability
        'reflected',            // damage type
        { reflectionDepth: reflectionDepth + 1 } // Track reflection depth
    );
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability reflects ${reflectAmount} damage back to ${source.name}!`
    };
}

/**
 * Has a chance to apply a status effect to the attacker when hit
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_ApplyStatusOnHit(context) {
    const { actor, ability, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and additional data is provided
    if (trigger !== 'onDamageTaken' || !additionalData) return { executed: false };
    
    const { source } = additionalData;
    
    // Do nothing if source is not defined or it's self-damage
    if (!source || source === actor) return { executed: false };
    
    // Check for ability-specific configuration
    const statusId = ability.passiveData?.statusId || 'status_spd_down';
    const chance = ability.passiveData?.chance || 0.25;
    const duration = ability.passiveData?.duration || 2;
    
    // Random chance to apply status
    if (Math.random() < chance) {
        battleManager.addStatusEffect(source, statusId, duration);
        
        return {
            executed: true,
            message: `${actor.name}'s passive ability applies a status effect to ${source.name}!`
        };
    }
    
    return { executed: false };
}

/**
 * Provides a buff to allies at the start of battle
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_TeamBuffOnBattleStart(context) {
    const { actor, ability, battleManager, teamManager, trigger } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onBattleStart') return { executed: false };
    
    // Get all allies
    const actorTeam = teamManager.getCharacterTeam(actor);
    const allies = battleManager.getAllCharacters().filter(character => 
        teamManager.getCharacterTeam(character) === actorTeam && !character.defeated
    );
    
    // Check for ability-specific configuration
    let statusId = 'status_atk_up';
    let duration = 3;
    
    // Safely extract passiveData if it exists
    if (ability && ability.passiveData) {
        statusId = ability.passiveData.statusId || statusId;
        duration = ability.passiveData.duration || duration;
    }
    
    // Apply buff to all allies
    let applied = 0;
    allies.forEach(ally => {
        // Skip if ally has invalid health
        if (!ally || isNaN(ally.currentHp)) {
            console.warn('Skipping buff application to ally with invalid health:', ally);
            return;
        }
        
        battleManager.addStatusEffect(ally, statusId, duration);
        applied++;
    });
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability buffs the team at the start of battle!`,
        affected: applied
    };
}

/**
 * Increases critical hit chance after landing a critical hit
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_CriticalMomentum(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and was a critical hit
    if (trigger !== 'onDamageDealt' || !additionalData || !additionalData.wasCritical) {
        return { executed: false };
    }
    
    // Apply critical chance buff
    battleManager.addStatusEffect(actor, 'status_crit_up', 2);
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability increases critical chance after landing a critical hit!`
    };
}

/**
 * Applies a damage buff after killing an enemy
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_KillBuff(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onKill') return { executed: false };
    
    // Apply attack up buff after a kill
    battleManager.addStatusEffect(actor, 'status_atk_up', 2);
    
    return {
        executed: true,
        message: `${actor.name}'s bloodlust increases attack after defeating an enemy!`
    };
}

/**
 * Applies a healing effect to the character when their HP falls below a threshold
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_LastStand(context) {
    const { actor, ability, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and has damage data
    if (trigger !== 'onDamageTaken' || !additionalData) return { executed: false };
    
    // Check health threshold (default 30% of max HP)
    const threshold = ability.passiveData?.threshold || 0.3;
    const healthPercent = actor.currentHp / actor.stats.hp;
    
    // Check if we crossed the threshold with this damage
    const previousHealth = actor.currentHp + additionalData.damageAmount;
    const previousPercent = previousHealth / actor.stats.hp;
    
    if (previousPercent >= threshold && healthPercent < threshold) {
        // We just crossed the threshold, trigger the heal
        const healAmount = Math.floor(actor.stats.hp * 0.15); // Heal for 15% of max HP
        
        // Apply healing
        battleManager.applyHealing(actor, healAmount, actor, null, 'passive');
        
        // Apply defense buff
        battleManager.addStatusEffect(actor, 'status_def_up', 2);
        
        return {
            executed: true,
            message: `${actor.name}'s last stand activates at low health, granting healing and defense!`
        };
    }
    
    return { executed: false };
}

/**
 * Applies a shield to allies at low health
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_ProtectiveInstinct(context) {
    const { actor, battleManager, teamManager, trigger } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onTurnStart') return { executed: false };
    
    // Get all allies
    const actorTeam = teamManager.getCharacterTeam(actor);
    const allies = battleManager.getAllCharacters().filter(character => 
        teamManager.getCharacterTeam(character) === actorTeam && 
        character !== actor && // Not self
        !character.defeated && 
        (character.currentHp / character.stats.hp) < 0.4 // Below 40% health
    );
    
    // If there are low-health allies, protect them
    if (allies.length > 0) {
        let protectedCount = 0;
        
        // Apply shield to up to 2 allies
        for (let i = 0; i < Math.min(2, allies.length); i++) {
            battleManager.addStatusEffect(allies[i], 'status_shield', 1);
            protectedCount++;
        }
        
        if (protectedCount > 0) {
            return {
                executed: true,
                message: `${actor.name}'s protective instinct shields ${protectedCount} injured ${protectedCount === 1 ? 'ally' : 'allies'}!`,
                affected: protectedCount
            };
        }
    }
    
    return { executed: false };
}

/**
 * Provides a counter-attack when taking damage
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_Counterattack(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onDamageTaken' || !additionalData || !additionalData.source) {
        return { executed: false };
    }
    
    // Get the attacker
    const attacker = additionalData.source;
    
    // Check if attacker is valid and still alive
    if (!attacker || attacker.isDead || attacker.currentHp <= 0) {
        return { executed: false };
    }
    
    // Counter with 40% of strength as damage
    const counterDamage = Math.floor(actor.stats.strength * 0.4);
    
    // Apply counter damage
    const result = battleManager.applyDamage(
        attacker,           // target (original attacker)
        counterDamage,      // damage amount
        actor,              // source (self)
        null,               // no ability
        'counter'           // damage type
    );
    
    return {
        executed: true,
        message: `${actor.name} counters the attack, dealing ${counterDamage} damage to ${attacker.name}!`,
        damage: result.damage
    };
}

/**
 * Applies a debuff to enemies when the turn starts
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_Intimidate(context) {
    const { actor, ability, battleManager, teamManager, trigger } = context;
    
    // Only execute on turn start and with 25% chance
    if (trigger !== 'onTurnStart' || Math.random() > 0.25) {
        return { executed: false };
    }
    
    // Get enemies
    const actorTeam = teamManager.getCharacterTeam(actor);
    const enemies = battleManager.getAllCharacters().filter(character => 
        teamManager.getCharacterTeam(character) !== actorTeam && 
        !character.defeated
    );
    
    // If there are enemies, intimidate them
    if (enemies.length > 0) {
        // Choose a random enemy
        const target = enemies[Math.floor(Math.random() * enemies.length)];
        
        // Check for ability-specific configuration
        const statusId = ability.passiveData?.statusId || 'status_atk_down';
        const duration = ability.passiveData?.duration || 1;
        
        // Apply status effect
        battleManager.addStatusEffect(target, statusId, duration);
        
        return {
            executed: true,
            message: `${actor.name}'s intimidating presence weakens ${target.name}!`
        };
    }
    
    return { executed: false };
}

/**
 * Apply an effect when killing an enemy
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_OnKillEffect(context) {
    const { actor, battleManager, trigger, additionalData, ability } = context;
    
    // Only execute if trigger matches and has defeated data
    if (trigger !== 'onKill' || !additionalData || !additionalData.defeated) {
        return { executed: false };
    }
    
    // Get the defeated enemy
    const defeated = additionalData.defeated;
    
    // Get effect data from passive configuration
    const effectType = ability.passiveData?.effectType || 'heal';
    const effectValue = ability.passiveData?.value || 0.1; // Default to 10% of max HP
    const statusId = ability.passiveData?.statusId || 'status_atk_up';
    const duration = ability.passiveData?.duration || 2;
    
    // Apply different effects based on configuration
    switch (effectType) {
        case 'heal':
            // Heal self based on max HP
            const healAmount = Math.floor(actor.stats.hp * effectValue);
            battleManager.applyHealing(actor, healAmount, actor, null, 'passive');
            
            return {
                executed: true,
                message: `${actor.name} absorbs life essence, healing for ${healAmount} HP!`
            };
            
        case 'buff':
            // Apply a status buff to self
            battleManager.addStatusEffect(actor, statusId, duration);
            
            return {
                executed: true,
                message: `${actor.name}'s power grows after defeating ${defeated.name}!`
            };
            
        case 'aoe_damage':
            // Apply AoE damage to all enemies
            const enemyTeam = defeated.team === 'player' ? battleManager.playerTeam : battleManager.enemyTeam;
            const damageAmount = Math.floor(actor.stats.strength * 0.2); // Base on strength
            let damageCount = 0;
            
            enemyTeam.forEach(enemy => {
                if (enemy.currentHp > 0 && enemy !== defeated) {
                    battleManager.applyDamage(enemy, damageAmount, actor, null, 'passive');
                    damageCount++;
                }
            });
            
            if (damageCount > 0) {
                return {
                    executed: true,
                    message: `${actor.name}'s power explodes, dealing ${damageAmount} damage to nearby enemies!`
                };
            }
            break;
    }
    
    return { executed: false };
}

/**
 * Increases critical hit chance after certain triggers
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_CriticalHitBoost(context) {
    const { actor, battleManager, trigger, additionalData, ability } = context;
    
    // Get configuration
    const triggers = ability.passiveData?.triggers || ['onDamageDealt'];
    const duration = ability.passiveData?.duration || 2;
    const bonusAmount = ability.passiveData?.bonusAmount || 0.15; // 15% increased crit chance
    
    // Check if this trigger is in our list of valid triggers
    if (!triggers.includes(trigger)) {
        return { executed: false };
    }
    
    // Add validation for specific trigger conditions
    if (trigger === 'onDamageDealt') {
        // Only trigger on significant damage (more than 15% of target's max HP)
        if (!additionalData || !additionalData.target || !additionalData.damageAmount) {
            return { executed: false };
        }
        
        const target = additionalData.target;
        const damage = additionalData.damageAmount;
        const damagePercent = target.stats.hp > 0 ? damage / target.stats.hp : 0;
        
        if (damagePercent < 0.15) {
            return { executed: false };
        }
    }
    
    // Apply critical hit buff
    battleManager.addStatusEffect(actor, 'status_crit_up', duration, { value: bonusAmount });
    
    return {
        executed: true,
        message: `${actor.name}'s critical hit chance increases!`
    };
}

/**
 * Applies a status effect to targets when hitting them
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_StatusOnHit(context) {
    const { actor, battleManager, trigger, additionalData, ability } = context;
    
    // Only execute on damage dealt
    if (trigger !== 'onDamageDealt' || !additionalData || !additionalData.target) {
        return { executed: false };
    }
    
    const target = additionalData.target;
    
    // Skip if target is already defeated
    if (target.currentHp <= 0 || target.isDead) {
        return { executed: false };
    }
    
    // Get configuration from passive data
    const statusId = ability.passiveData?.statusId || 'status_bleed';
    const chance = ability.passiveData?.chance || 0.25; // 25% chance by default
    const duration = ability.passiveData?.duration || 2;
    
    // Roll for chance
    if (Math.random() < chance) {
        // Apply the status effect
        battleManager.addStatusEffect(target, statusId, duration);
        
        // Get a readable name for the status
        let statusName = statusId;
        if (statusId.startsWith('status_')) {
            statusName = statusId.replace('status_', '').replace('_', ' ');
            // Capitalize first letter
            statusName = statusName.charAt(0).toUpperCase() + statusName.slice(1);
        }
        
        return {
            executed: true,
            message: `${actor.name}'s attack inflicts ${statusName} on ${target.name}!`
        };
    }
    
    return { executed: false };
}

// Register all passive behaviors
behaviorRegistry.registerPassiveBehavior('passive_ApplyRegenOnTurnStart', passive_ApplyRegenOnTurnStart);
behaviorRegistry.registerPassiveBehavior('passive_DamageReflectOnHit', passive_DamageReflectOnHit);
behaviorRegistry.registerPassiveBehavior('passive_ApplyStatusOnHit', passive_ApplyStatusOnHit);
behaviorRegistry.registerPassiveBehavior('passive_TeamBuffOnBattleStart', passive_TeamBuffOnBattleStart);
behaviorRegistry.registerPassiveBehavior('passive_CriticalMomentum', passive_CriticalMomentum);
behaviorRegistry.registerPassiveBehavior('passive_KillBuff', passive_KillBuff);
behaviorRegistry.registerPassiveBehavior('passive_LastStand', passive_LastStand);
behaviorRegistry.registerPassiveBehavior('passive_ProtectiveInstinct', passive_ProtectiveInstinct);
behaviorRegistry.registerPassiveBehavior('passive_Counterattack', passive_Counterattack);
behaviorRegistry.registerPassiveBehavior('passive_Intimidate', passive_Intimidate);
behaviorRegistry.registerPassiveBehavior('passive_OnKillEffect', passive_OnKillEffect);
behaviorRegistry.registerPassiveBehavior('passive_CriticalHitBoost', passive_CriticalHitBoost);
behaviorRegistry.registerPassiveBehavior('passive_StatusOnHit', passive_StatusOnHit);

// Export individual behaviors for direct use if needed
export {
    passive_ApplyRegenOnTurnStart,
    passive_DamageReflectOnHit,
    passive_ApplyStatusOnHit,
    passive_TeamBuffOnBattleStart,
    passive_CriticalMomentum,
    passive_KillBuff,
    passive_LastStand,
    passive_ProtectiveInstinct,
    passive_Counterattack,
    passive_Intimidate,
    passive_OnKillEffect,
    passive_CriticalHitBoost,
    passive_StatusOnHit
};


===== FILE: TargetingBehaviors.js =====
/**
 * TargetingBehaviors.js
 * 
 * Collection of targeting behavior functions for the battle system.
 * These functions determine how characters select targets for their actions.
 */

import behaviorRegistry from './BehaviorRegistry.js';

/**
 * Context object expected for targeting behaviors:
 * {
 *   actor: Character,              // The character taking the action
 *   potentialTargets: Character[], // List of possible targets
 *   teamManager: TeamManager,      // Reference to TeamManager for team data
 *   ability: Object,               // The ability being used (if applicable)
 *   battleManager: BattleManager   // Reference to BattleManager for battle state
 * }
 */

/**
 * Targets a random enemy (default behavior)
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetRandomEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Select random target
    const randomIndex = Math.floor(Math.random() * validTargets.length);
    return validTargets[randomIndex];
}

/**
 * Targets the enemy with the lowest HP
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetLowestHpEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with lowest HP
    return validTargets.reduce((lowestTarget, currentTarget) => {
        return (currentTarget.currentHp < lowestTarget.currentHp) ? currentTarget : lowestTarget;
    }, validTargets[0]);
}

/**
 * Targets the enemy with the highest HP
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetHighestHpEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with highest HP
    return validTargets.reduce((highestTarget, currentTarget) => {
        return (currentTarget.currentHp > highestTarget.currentHp) ? currentTarget : highestTarget;
    }, validTargets[0]);
}

/**
 * Targets all enemies
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAllEnemies(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    return validTargets;
}

/**
 * Targets the ally with the lowest HP
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetLowestHpAlly(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find ally with lowest HP
    return validTargets.reduce((lowestTarget, currentTarget) => {
        return (currentTarget.currentHp < lowestTarget.currentHp) ? currentTarget : lowestTarget;
    }, validTargets[0]);
}

/**
 * Targets all allies
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAllAllies(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    return validTargets;
}

/**
 * Targets self
 * @param {object} context - Targeting context
 * @returns {Character} - The actor
 */
function targetSelf(context) {
    return context.actor;
}

/**
 * Targets the enemy with the highest attack
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetHighestAttackEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with highest attack
    return validTargets.reduce((highestTarget, currentTarget) => {
        return (currentTarget.stats.attack > highestTarget.stats.attack) ? currentTarget : highestTarget;
    }, validTargets[0]);
}

/**
 * Targets the enemy with the highest intellect
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetHighestIntellectEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with highest intellect
    return validTargets.reduce((highestTarget, currentTarget) => {
        return (currentTarget.stats.intellect > highestTarget.stats.intellect) ? currentTarget : highestTarget;
    }, validTargets[0]);
}

/**
 * Targets adjacent enemies (main target plus adjacent ones)
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAdjacentEnemies(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Get primary target (usually the one with lowest HP or random)
    const primaryTarget = validTargets.reduce((lowestTarget, currentTarget) => {
        return (currentTarget.currentHp < lowestTarget.currentHp) ? currentTarget : lowestTarget;
    }, validTargets[0]);
    
    // Get adjacent targets (implementation depends on how character positions are stored)
    // For this basic implementation, we'll just get up to 2 additional random enemies
    const otherTargets = validTargets.filter(target => target !== primaryTarget);
    const adjacentTargets = [primaryTarget];
    
    // Add up to 2 more random enemies if available
    if (otherTargets.length > 0) {
        // Shuffle other targets
        const shuffled = [...otherTargets].sort(() => 0.5 - Math.random());
        // Add up to 2 more
        for (let i = 0; i < Math.min(2, shuffled.length); i++) {
            adjacentTargets.push(shuffled[i]);
        }
    }
    
    return adjacentTargets;
}

/**
 * Targets a random ally excluding self
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetRandomAlly(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies (excluding self) that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               target !== actor && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Select random ally
    const randomIndex = Math.floor(Math.random() * validTargets.length);
    return validTargets[randomIndex];
}

/**
 * Targets the most injured ally (lowest HP percentage)
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetMostInjuredAlly(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find ally with lowest HP percentage
    return validTargets.reduce((mostInjured, current) => {
        const currentHpPercent = current.currentHp / current.stats.hp;
        const mostInjuredHpPercent = mostInjured.currentHp / mostInjured.stats.hp;
        return (currentHpPercent < mostInjuredHpPercent) ? current : mostInjured;
    }, validTargets[0]);
}

/**
 * Targets all characters but marks team relationships
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAllCharacters(context) {
    const { actor, potentialTargets, teamManager } = context;
    const actorTeam = actor.team || teamManager.getCharacterTeam(actor);
    
    // Filter living characters and add team relationship info
    const validTargets = potentialTargets.filter(target => !target.defeated).map(target => {
        // Add this crucial property to identify team relationship
        const targetTeam = target.team || teamManager.getCharacterTeam(target);
        target.isAllyOf = targetTeam === actorTeam;
        return target;
    });
    
    if (validTargets.length === 0) return null;
    
    return validTargets;
}

// Register all targeting behaviors
behaviorRegistry.registerTargetingBehavior('targetRandomEnemy', targetRandomEnemy, true);  // Set as default
behaviorRegistry.registerTargetingBehavior('targetLowestHpEnemy', targetLowestHpEnemy);
behaviorRegistry.registerTargetingBehavior('targetHighestHpEnemy', targetHighestHpEnemy);
behaviorRegistry.registerTargetingBehavior('targetAllEnemies', targetAllEnemies);
behaviorRegistry.registerTargetingBehavior('targetLowestHpAlly', targetLowestHpAlly);
behaviorRegistry.registerTargetingBehavior('targetAllAllies', targetAllAllies);
behaviorRegistry.registerTargetingBehavior('targetSelf', targetSelf);
// Register new targeting behaviors
behaviorRegistry.registerTargetingBehavior('targetHighestAttackEnemy', targetHighestAttackEnemy);
behaviorRegistry.registerTargetingBehavior('targetHighestIntellectEnemy', targetHighestIntellectEnemy);
behaviorRegistry.registerTargetingBehavior('targetAdjacentEnemies', targetAdjacentEnemies);
behaviorRegistry.registerTargetingBehavior('targetRandomAlly', targetRandomAlly);
behaviorRegistry.registerTargetingBehavior('targetMostInjuredAlly', targetMostInjuredAlly);
behaviorRegistry.registerTargetingBehavior('targetAllCharacters', targetAllCharacters);

// Export individual behaviors for direct use if needed
export {
    targetRandomEnemy,
    targetLowestHpEnemy,
    targetHighestHpEnemy,
    targetAllEnemies,
    targetLowestHpAlly,
    targetAllAllies,
    targetSelf,
    // Export new targeting behaviors
    targetHighestAttackEnemy,
    targetHighestIntellectEnemy,
    targetAdjacentEnemies,
    targetRandomAlly,
    targetMostInjuredAlly,
    targetAllCharacters
};


===== FILE: Ability.js =====
/**
 * Ability Class
 * Represents special abilities that characters can use in battle
 */

class Ability {
    /**
     * Create a new Ability
     * @param {string} name - The name of the ability
     * @param {number} damage - Base damage or healing amount
     * @param {number} cooldown - Number of turns before ability can be used again
     * @param {boolean} isHealing - Whether ability heals or damages
     * @param {object} effects - Additional effects (status effects, buffs, etc.)
     */
    constructor(name, damage, cooldown, isHealing = false, effects = {}) {
        this.name = name;
        this.damage = damage;
        this.cooldown = cooldown;
        this.currentCooldown = 0;
        this.isHealing = isHealing;
        this.effects = effects;
    }

    // Methods to be implemented
}


===== FILE: Character.js =====
/**
 * Character Class
 * Base class for all battling units in the AutoBattler game
 */

class Character {
    /**
     * Create a new Character
     * @param {string} name - Character name
     * @param {string} type - Element/type (fire, water, etc.)
     * @param {number} hp - Health points
     * @param {number} attack - Attack power
     * @param {number} defense - Defense value
     * @param {number} x - X position on screen
     * @param {number} y - Y position on screen
     * @param {number} color - Color representation (hexadecimal)
     */
    constructor(name, type, hp, attack, defense, x, y, color) {
        this.name = name;
        this.type = type;
        this.maxHp = hp;
        this.currentHp = hp;
        this.attack = attack;
        this.defense = defense;
        this.x = x;
        this.y = y;
        this.color = color;
        this.sprite = null;
        this.text = null;
        this.abilities = [];
        this.abilityCooldowns = {};
    }

    // Methods to be implemented
}


===== FILE: BattleManager.js =====
/**
 * Battle Manager
 * Controls the flow of battle and combat logic
 * Updated to work with the Tailwind CSS-based BattleUI
 * Version 0.5.1.2b - Added CHARACTER_ACTION event dispatching for action indicators
 */

class BattleManager {
    /**
     * Create a new Battle Manager
     * @param {Phaser.Scene} scene - The Phaser scene for the battle
     * @param {string} battleLogId - ID of the HTML element for battle log
     */
    constructor(scene, battleLogId) {
        this.scene = scene;
        this.battleLogId = battleLogId;
        this.playerTeam = [];
        this.enemyTeam = [];
        this.currentTurn = 0;
        this.isAutoBattle = true;
        this.battleActive = false;
        this.isPaused = false;
        this.turnDelay = 6000; // Delay between turns (ms) - doubled from 3000ms for slower pace
        this.actionDelay = 3200; // Delay between actions (ms) - doubled from 1600ms for slower pace
        this.speedMultiplier = 1; // Battle speed (1x, 2x, 4x)
        this.battleUI = null;
        this.turnTimer = null;
        this.activeCharacterIndex = 0;
        this.actionQueue = [];
        this.turnActions = [];
        this.turnInProgress = false;
        this.statusEffects = {}; // Store status effects by character ID
        this.battleBehaviors = null; // Will hold the behavior system when loaded
        this.statusEffectDefinitions = null; // Will hold status effect definitions from JSON
        this.uiMode = "dom"; // UI mode: "dom" or "phaser"
        
        // Create a simple teamManager for compatibility with behavior system
        this.teamManager = {
            getCharacterTeam: (character) => character.team
        };
    }
    
    /**
     * Display a summary of all characters' health at the end of a turn
     */
    displayTurnSummary() {
        this.logMessage('------ END OF TURN SUMMARY ------', 'info');
        
        // Show player team summary
        this.logMessage('Player Team:', 'info');
        this.playerTeam.forEach(character => {
            const status = character.isDead ? 'ðŸ’€ DEFEATED' : `HP: ${character.currentHp}/${character.stats.hp}`;
            const statusColor = character.isDead ? 'error' : 
                               (character.currentHp < character.stats.hp * 0.3) ? 'error' :
                               (character.currentHp < character.stats.hp * 0.7) ? 'action' : 'success';
            this.logMessage(`  ${character.name}: ${status}`, statusColor);
        });
        
        // Show enemy team summary
        this.logMessage('Enemy Team:', 'info');
        this.enemyTeam.forEach(character => {
            const status = character.isDead ? 'ðŸ’€ DEFEATED' : `HP: ${character.currentHp}/${character.stats.hp}`;
            const statusColor = character.isDead ? 'error' : 
                               (character.currentHp < character.stats.hp * 0.3) ? 'error' :
                               (character.currentHp < character.stats.hp * 0.7) ? 'action' : 'success';
            this.logMessage(`  ${character.name}: ${status}`, statusColor);
        });
        
        this.logMessage('--------------------------------', 'info');
    }
    
    /**
     * Load status effect definitions from JSON file
     */
    async loadStatusEffectDefinitions() {
        try {
            // First try to load from data directory
            console.log('Attempting to load status effect definitions from data directory...');
            try {
                const response = await fetch('data/status_effects.json');
                if (!response.ok) {
                    throw new Error(`Failed to load data/status_effects.json: ${response.status}`);
                }
                const data = await response.json();
                this.statusEffectDefinitions = {};
                
                // Process each status effect
                if (data && data.status_effects && Array.isArray(data.status_effects)) {
                    data.status_effects.forEach(effect => {
                        if (effect && effect.id) {
                            this.statusEffectDefinitions[effect.id] = effect;
                        }
                    });
                }
                
                console.log(`Loaded ${Object.keys(this.statusEffectDefinitions).length} status effect definitions from data directory`);
            } catch (e) {
                console.warn('Failed to load from data directory:', e.message);
                // Try fallback to root directory
                try {
                    const response = await fetch('status_effects.json');
                    if (!response.ok) {
                        throw new Error(`Failed to load status_effects.json: ${response.status}`);
                    }
                    const data = await response.json();
                    this.statusEffectDefinitions = {};
                    
                    // Process each status effect
                    if (data && data.status_effects && Array.isArray(data.status_effects)) {
                        data.status_effects.forEach(effect => {
                            if (effect && effect.id) {
                                this.statusEffectDefinitions[effect.id] = effect;
                            }
                        });
                    }
                    
                    console.log(`Loaded ${Object.keys(this.statusEffectDefinitions).length} status effect definitions from root directory`);
                } catch (fallbackError) {
                    console.warn('Failed to load from root directory:', fallbackError.message);
                    throw e;
                }
            }
        } catch (error) {
            console.error('Error loading status effect definitions:', error);
            // Create basic fallback definitions
            this.setupFallbackStatusEffects();
            throw error;
        }
    }
    
    /**
     * Setup fallback status effect definitions if loading fails
     */
    setupFallbackStatusEffects() {
        console.log('Setting up fallback status effect definitions');
        this.statusEffectDefinitions = {
            'status_burn': {
                id: 'status_burn',
                name: 'Burn',
                description: 'Taking fire damage over time',
                type: 'DoT',
                defaultDuration: 2,
                maxStacks: 1,
                behavior: {
                    trigger: 'onTurnStart',
                    action: 'Damage',
                    valueType: 'PercentMaxHP',
                    value: 0.05
                }
            },
            'status_regen': {
                id: 'status_regen',
                name: 'Regeneration',
                description: 'Healing over time',
                type: 'HoT',
                defaultDuration: 3,
                maxStacks: 1,
                behavior: {
                    trigger: 'onTurnStart',
                    action: 'Heal',
                    valueType: 'PercentMaxHP',
                    value: 0.05
                }
            }
        };
    }

    /**
     * Initialize the battle manager
     */
    async initialize() {
        console.log('BattleManager: Initializing...');
        
        try {
            // Load status effect definitions
            try {
                await this.loadStatusEffectDefinitions();
                console.log('BattleManager: Status effect definitions loaded');
            } catch (error) {
                console.warn('BattleManager: Status effect definitions not available, using fallback behavior:', error);
            }
            
            // Initialize behavior system if available
            try {
                await this.initializeBehaviorSystem();
                console.log('BattleManager: Behavior system initialized');
            } catch (error) {
                console.warn('BattleManager: Behavior system not available, using legacy behavior:', error);
            }
                        
            console.log('BattleManager: Initialized');
        } catch (e) {
            console.error('Error initializing battle UI:', e);
            
            // Try a fallback approach for debugging
            console.log('Checking available UI classes:', {
                'window.BattleUI': typeof window.BattleUI,
                'global BattleUI': typeof BattleUI
            });
        }
    }
    
    /**
     * Start a battle with the given teams
     * @param {Array} playerTeam - Array of player characters
     * @param {Array} enemyTeam - Array of enemy characters
     */
    async startBattle(playerTeam, enemyTeam) {
        // Make sure status effect definitions are loaded
        if (!this.statusEffectDefinitions) {
            try {
                await this.loadStatusEffectDefinitions();
            } catch (error) {
                console.warn('Could not load status effect definitions:', error);
            }
        }
        
        // Make sure behavior system is loaded
        if (!this.battleBehaviors) {
            try {
                await this.initializeBehaviorSystem();
            } catch (error) {
                console.warn('Could not initialize behavior system:', error);
            }
        }
        // Make sure the UI is initialized and ready
        if (!this.battleUI || !this.battleUI.isSetup) {
            console.log('Re-initializing battle UI before battle start, uiMode:', this.uiMode);
            try {
                // Check UI mode to determine which UI to initialize
                if (this.uiMode === "phaser") {
                    console.log('Using Phaser scene for battle visualization, skipping DOM UI initialization');
                } else {
                    // Initialize DOM UI for "dom" mode
                    if (!this.battleUI) {
                        if (typeof window.BattleUI === 'undefined') {
                            console.error('BattleUI class is not defined! Cannot create BattleUI instance.');
                            throw new Error('BattleUI class is not defined!');
                        }
                        console.log('Creating new DOM BattleUI instance');
                        this.battleUI = new window.BattleUI(this.scene, this);
                    }
                    this.battleUI.initialize();
                }
            } catch (error) {
                console.error('Failed to initialize BattleUI:', error);
                throw error;
            }
        }

        // Validate playerTeam and ensure it's an array
        if (!playerTeam || !Array.isArray(playerTeam)) {
            console.warn('Invalid playerTeam provided to startBattle, using empty array');
            playerTeam = [];
        }
        
        // Deep copy the player team to avoid reference issues
        const playerTeamCopy = playerTeam.length > 0 ? JSON.parse(JSON.stringify(playerTeam)) : [];
        console.log(`PlayerTeam before preparation: ${playerTeamCopy.length} heroes`);
        this.playerTeam = this.prepareTeamForBattle(playerTeamCopy);
        console.log(`PlayerTeam after preparation: ${this.playerTeam.length} heroes`);
        
        // Validate player team was prepared correctly
        if (this.playerTeam.length === 0 && playerTeam.length > 0) {
            console.error('Failed to prepare player team properly. Original length:', playerTeam.length);
        }
        
        // Check if enemy team is empty or undefined and generate one if needed
        if (!enemyTeam || enemyTeam.length === 0) {
            console.log('No enemy team provided, generating a random one');
            // Create a simple enemy team for testing
            enemyTeam = [
                {
                    id: 4,
                    name: "Vaelgor",
                    type: "dark",
                    role: "Knight",
                    stats: {
                        hp: 120,
                        attack: 18,
                        defense: 12
                    },
                    abilities: [
                        {
                            name: "Shadow Strike",
                            damage: 28,
                            cooldown: 3,
                            isHealing: false,
                            description: "Attacks from the shadows for heavy damage"
                        },
                        {
                            name: "Void Barrier",
                            damage: 20,
                            cooldown: 4,
                            isHealing: true,
                            description: "Creates a barrier of dark energy that absorbs damage"
                        }
                    ]
                },
                {
                    id: 3,
                    name: "Sylvanna",
                    type: "nature",
                    role: "Ranger",
                    stats: {
                        hp: 90,
                        attack: 15,
                        defense: 15
                    },
                    abilities: [
                        {
                            name: "Vine Whip",
                            damage: 20,
                            cooldown: 2,
                            isHealing: false,
                            description: "Strikes with vines that can ensnare the target"
                        },
                        {
                            name: "Nature's Blessing",
                            damage: 25,
                            cooldown: 4,
                            isHealing: true,
                            description: "Channels the power of nature to heal wounds"
                        }
                    ]
                },
                {
                    id: 5,
                    name: "Lumina",
                    type: "light",
                    role: "Cleric",
                    stats: {
                        hp: 85,
                        attack: 16,
                        defense: 14
                    },
                    abilities: [
                        {
                            name: "Holy Smite",
                            damage: 22,
                            cooldown: 3,
                            isHealing: false,
                            description: "Channels divine light into a powerful attack"
                        },
                        {
                            name: "Divine Protection",
                            damage: 26,
                            cooldown: 4,
                            isHealing: true,
                            description: "Surrounds an ally with divine light, healing wounds"
                        }
                    ]
                }
            ];
        }
        
        // Validate enemyTeam and ensure it's an array
        if (!enemyTeam || !Array.isArray(enemyTeam)) {
            console.warn('Invalid enemyTeam provided to startBattle, using empty array');
            enemyTeam = [];
        }
        
        // Deep copy the enemy team to avoid reference issues
        const enemyTeamCopy = enemyTeam.length > 0 ? JSON.parse(JSON.stringify(enemyTeam)) : [];
        console.log(`EnemyTeam before preparation: ${enemyTeamCopy.length} enemies`);
        this.enemyTeam = this.prepareTeamForBattle(enemyTeamCopy);
        console.log(`EnemyTeam after preparation: ${this.enemyTeam.length} enemies`);
        
        // Validate enemy team was prepared correctly
        if (this.enemyTeam.length === 0 && enemyTeam.length > 0) {
            console.error('Failed to prepare enemy team properly. Original length:', enemyTeam.length);
        }
        
        // Reset battle state
        this.currentTurn = 0;
        this.battleActive = true;
        this.isPaused = false;
        this.activeCharacterIndex = 0;
        this.actionQueue = [];
        this.turnActions = [];
        this.turnInProgress = false;
        this.statusEffects = {};
        
        // Initialize passive trigger tracking at battle level
        this.passiveTriggersThisBattle = new Map();
        
        // Render characters on UI
        if (this.battleUI) {
            this.battleUI.renderCharacters(this.playerTeam, this.enemyTeam);
        }
        
        // Log battle start
        this.logMessage('Battle started!');
        this.logMessage(`${this.playerTeam.length} heroes vs ${this.enemyTeam.length} enemies`);
        console.log('Battle started with teams:', this.playerTeam, this.enemyTeam);
        
        // Process battle start passive abilities for all characters
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            if (character.currentHp > 0) {
                this.processPassiveAbilities('onBattleStart', character);
            }
        });
        
        // Start first turn
        this.startNextTurn();
    }
    
    /**
     * Prepare a team for battle by setting initial values
     * @param {Array} team - Array of character objects
     * @returns {Array} - Prepared team for battle
     */
    prepareTeamForBattle(team) {
        // Check if this is a player team based on current context
        const isPlayerTeam = !this.playerTeam || this.playerTeam.length === 0 || 
                          (this.playerTeam.length > 0 && this.enemyTeam && this.enemyTeam.length > 0);
        const teamType = isPlayerTeam ? 'player' : 'enemy';
        
        console.log(`Preparing ${teamType} team with ${team.length} characters`);
        
        // Validation check
        if (!team || !Array.isArray(team)) {
            console.error(`Invalid team provided for ${teamType}, using empty array`);
            return [];
        }
        
        // Map characters to battle-ready format and filter out nulls
        const preparedTeam = team.map((character, index) => {
            // Character validation
            if (!character) {
                console.error(`Null character at index ${index} in ${teamType} team`);
                return null;
            }
            
            // No need for deep copy since we already copied at the higher level
            const battleChar = character;
            
            // Set battle-specific properties
            battleChar.currentHp = battleChar.stats.hp;
            battleChar.isDead = false;
            
            // Ensure character has a unique ID
            if (!battleChar.id) {
                battleChar.id = this.generateCharacterId();
            }
            
            // Create a more robust uniqueId that includes team info and name
            battleChar.uniqueId = `${teamType}_${battleChar.name}_${battleChar.id}`;
            
            // Store team info on the character
            battleChar.team = teamType;
            
            // Initialize ability cooldowns and identify passive abilities
            if (battleChar.abilities) {
                battleChar.passiveAbilities = [];
                
                battleChar.abilities.forEach(ability => {
                    // Initialize cooldown for active abilities
                    ability.currentCooldown = 0;
                    
                    // Identify passive abilities and store them separately for quick reference
                    if (ability.abilityType === 'Passive') {
                        battleChar.passiveAbilities.push(ability);
                    }
                });
            }
            
            return battleChar;
        }).filter(char => char !== null); // Filter out any null entries
        
        console.log(`Finished preparing ${teamType} team: ${preparedTeam.length} valid characters`);
        return preparedTeam;
    }
    
    /**
     * Generate a unique ID for a character
     * @returns {string} A unique ID
     */
    generateCharacterId() {
        return 'char_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Start the next turn
     */
    startNextTurn() {
        if (!this.battleActive || this.isPaused || this.turnInProgress) return;
        
        this.currentTurn++;
        console.log('[BattleManager] Attempting to dispatch TURN_STARTED event...');
        this.logMessage(`Turn ${this.currentTurn} started`, 'info');
        this.turnInProgress = true;
        
        // Reset passive ability trigger tracking for the new turn
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            character.passiveTriggeredThisTurn = {};
        });
        
        // Update UI
        if (this.battleUI) {
            this.battleUI.update();
        }
        
        // Process turn start passive abilities for all characters
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            if (character.currentHp > 0) {
                this.processPassiveAbilities('onTurnStart', character, { turnNumber: this.currentTurn });
            }
        });
        
        // Process status effects at start of turn
        this.processStatusEffects();
        
        // Clear previous actions
        this.actionQueue = [];
        this.turnActions = [];
        
        // Generate actions for this turn
        this.generateTurnActions();
        
        // Execute the first action
        setTimeout(() => {
            this.executeNextAction();
        }, 500); // Short delay before first action
    }
    
    /**
     * Process status effects for all characters
     */
    processStatusEffects() {
        // Process each character's status effects
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            if (character.currentHp <= 0) return; // Skip dead characters
            
            // Use uniqueId if available for character identification
            const characterId = character.uniqueId || character.id;
            const characterEffects = this.statusEffects[characterId];
            if (!characterEffects) return;
            
            // Add team identifier for logging
            const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
            
            // Process each effect
            Object.entries(characterEffects).forEach(([statusId, effect]) => {
                // Get the effect definition if available
                const definition = this.statusEffectDefinitions ? this.statusEffectDefinitions[statusId] : null;
                const effectName = definition ? definition.name : statusId;
                const stackText = effect.stacks > 1 ? ` (${effect.stacks} stacks)` : '';
                
                // Check if we should process effect at turn start
                if (definition && definition.behavior && definition.behavior.trigger === 'onTurnStart') {
                    // Process based on behavior action
                    switch (definition.behavior.action) {
                        case 'Damage':
                        case 'damage':
                            // Calculate damage based on behavior valueType
                            let damage = 0;
                            if (definition.behavior.valueType === 'PercentMaxHP') {
                                damage = Math.floor(character.stats.hp * definition.behavior.value * effect.stacks);
                            } else if (definition.behavior.valueType === 'PercentCurrentHP') {
                                damage = Math.floor(character.currentHp * definition.behavior.value * effect.stacks);
                            } else {
                                damage = definition.behavior.value * effect.stacks;
                            }
                            
                            // Apply damage using the applyDamage utility
                            const damageResult = this.applyDamage(
                                character,           // target
                                Math.max(1, damage), // damage amount (minimum 1)
                                null,                // source (null for status effects)
                                null,                // ability (null for status effects)
                                definition.behavior.damageType || 'status' // damage type
                            );
                            
                            // No need to check death or update UI as applyDamage handles it
                            break;
                            
                        case 'Heal':
                        case 'heal':
                            // Calculate healing based on behavior valueType
                            let healing = 0;
                            if (definition.behavior.valueType === 'PercentMaxHP') {
                                healing = Math.floor(character.stats.hp * definition.behavior.value * effect.stacks);
                            } else if (definition.behavior.valueType === 'PercentMissingHP') {
                                healing = Math.floor((character.stats.hp - character.currentHp) * definition.behavior.value * effect.stacks);
                            } else {
                                healing = definition.behavior.value * effect.stacks;
                            }
                            
                            // Apply healing using the applyHealing utility
                            const healingResult = this.applyHealing(
                                character,           // target
                                Math.max(0, healing), // healing amount
                                null,                // source (null for status effects)
                                null,                // ability (null for status effects)
                                statusId             // heal type based on status ID
                            );
                            
                            // No need to check resurrection or update UI as applyHealing handles it
                            break;
                    }
                }
                
                // Special case for legacy status effects without definitions
                if (!definition) {
                    // Simple hardcoded behaviors for backward compatibility
                    switch (statusId) {
                        case 'regen':
                    case 'status_regen':
                            const healAmount = Math.floor(character.stats.hp * 0.05); // 5% HP regen
                            character.currentHp = Math.min(character.stats.hp, character.currentHp + healAmount);
                            this.logMessage(`${character.name}${teamIdentifier} regenerates ${healAmount} HP (HP: ${character.currentHp}/${character.stats.hp})`, 'success');
                            
                            // Update UI
                            if (this.battleUI) {
                                this.battleUI.updateCharacterHealth(character, healAmount, true);
                            }
                            
                            // Check if character was resurrected
                            this.checkAndResetDeathStatus(character);
                            break;
                            
                        case 'burn':
                    case 'status_burn':
                            const burnDamage = Math.floor(character.stats.hp * 0.08); // 8% HP burn
                            character.currentHp = Math.max(0, character.currentHp - burnDamage);
                            this.logMessage(`${character.name}${teamIdentifier} takes ${burnDamage} burn damage (HP: ${character.currentHp}/${character.stats.hp})`, 'error');
                            
                            // Update UI
                            if (this.battleUI) {
                                this.battleUI.updateCharacterHealth(character, burnDamage, false);
                            }
                            break;
                    }
                }
                
                // Reduce duration and remove if expired
                effect.duration--;
                if (effect.duration <= 0) {
                    delete characterEffects[statusId];
                    this.logMessage(`${effectName} effect wore off from ${character.name}${teamIdentifier}`, 'info');
                    this.updateStatusIcons(character);
                }
            });
            
            // If all effects are gone, remove the character entry
            if (Object.keys(characterEffects).length === 0) {
                delete this.statusEffects[characterId];
            }
        });
    }
    
    /**
     * Add a status effect to a character
     * @param {Object} character - Character to affect
     * @param {string} statusId - ID of the status effect
     * @param {number} duration - Number of turns the effect lasts (optional, uses default if not specified)
     * @param {number|Object} value - Value for the effect (if applicable)
     */
    addStatusEffect(character, statusId, duration, value) {
        // Use uniqueId if available for character identification
        const characterId = character.uniqueId || character.id;
        
        // Initialize character's status effects if not exist
        if (!this.statusEffects[characterId]) {
            this.statusEffects[characterId] = {};
        }
        
        // Get status effect definition if available
        const definition = this.statusEffectDefinitions ? this.statusEffectDefinitions[statusId] : null;
        
        // Use default duration from definition or provided duration or fallback to 2 turns
        let effectDuration = duration;
        if (effectDuration === undefined) {
            effectDuration = definition ? definition.defaultDuration : 2;
        }
        
        // Check if character already has this status effect
        if (this.statusEffects[characterId][statusId]) {
            // Check if we should stack or just refresh duration
            if (definition && definition.maxStacks > 1) {
                // Stackable effect - increase stack count up to max
                const currentStacks = this.statusEffects[characterId][statusId].stacks || 1;
                const newStacks = Math.min(currentStacks + 1, definition.maxStacks);
                
                this.statusEffects[characterId][statusId] = {
                    duration: effectDuration,
                    stacks: newStacks,
                    value: value,
                    definitionId: statusId
                };
                
                // Log stack increase
                const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
                this.logMessage(`${character.name}${teamIdentifier}'s ${definition.name || statusId} increased to ${newStacks} stacks for ${effectDuration} turns`, 'info');
            } else {
                // Non-stacking effect - refresh duration
                this.statusEffects[characterId][statusId].duration = effectDuration;
                
                // Optionally update value
                if (value !== undefined) {
                    this.statusEffects[characterId][statusId].value = value;
                }
                
                // Log refresh
                const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
                const effectName = definition ? definition.name : statusId;
                this.logMessage(`${character.name}${teamIdentifier}'s ${effectName} refreshed for ${effectDuration} turns`, 'info');
            }
        } else {
            // New status effect - create instance
            this.statusEffects[characterId][statusId] = {
                duration: effectDuration,
                stacks: 1,
                value: value,
                definitionId: statusId
            };
            
            // Include team identifier in the log message
            const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
            // Format display name - prefer definition name, fallback to capitalized ID without prefix
            const effectName = definition ? definition.name : statusId.replace('status_', '').charAt(0).toUpperCase() + statusId.replace('status_', '').slice(1);
            this.logMessage(`${character.name}${teamIdentifier} is affected by ${effectName} for ${effectDuration} turns`, 'info');
        }
        
        // Update status icons
        this.updateStatusIcons(character);
    }
    
    /**
     * Update status icons for a character
     * @param {Object} character - Character to update icons for
     */
    updateStatusIcons(character) {
        // Use uniqueId if available for character identification
        const characterId = character.uniqueId || character.id;
        const statusContainer = document.getElementById(`status-icons-${characterId}`);
        if (!statusContainer) return;
        
        // Clear current icons
        statusContainer.innerHTML = '';
        
        // If character has no effects, return
        if (!this.statusEffects[characterId]) return;
        
        // Add icon for each effect
        Object.entries(this.statusEffects[characterId]).forEach(([statusId, effect]) => {
        // Get effect definition if available
        const definition = this.statusEffectDefinitions ? this.statusEffectDefinitions[statusId] : null;
        
        // Format display name - prefer definition name, fallback to capitalized ID without prefix
        const displayName = definition ? definition.name : statusId.replace('status_', '').charAt(0).toUpperCase() + statusId.replace('status_', '').slice(1);
        
        const icon = document.createElement('span');
        icon.className = 'status-icon';
        
        let tooltipContent = '';
        let iconHTML = '';
        let cssClass = '';
            
            // Try to set background image from status-icons subfolder
            const iconId = statusId.replace('status_', '');
            const iconPath = `assets/images/icons/status/status-icons/${iconId}.png`;
            
            // Create an image object to check if the icon exists
            const img = new Image();
            img.onload = () => {
                // Icon loaded successfully, set it as background
                icon.style.backgroundImage = `url(${iconPath})`;
                icon.style.backgroundSize = 'cover';
                icon.style.backgroundPosition = 'center';
                // Clear any inner HTML/text content
                icon.innerHTML = '';
            };
            img.onerror = () => {
                console.warn(`Could not load icon for ${statusId}`);
                // Icon failed to load, use the emoji fallback below
                // The switch statement below will set the iconHTML
            };
            img.src = iconPath;
            
            // Initially set background properties in case image loads
            icon.style.backgroundSize = 'cover';
            icon.style.backgroundPosition = 'center';
            
            // If we have a definition, use it
            if (definition) {
                // Add the stack count if more than 1
                const stackText = effect.stacks > 1 ? ` x${effect.stacks}` : '';
                
                // Determine icon and class based on effect type
                switch (definition.type) {
                    case 'Buff':
                    case 'buff':
                        cssClass = 'bg-blue-500';
                        iconHTML = 'â¬†ï¸' + stackText;
                        break;
                        
                    case 'Debuff':
                    case 'debuff':
                        cssClass = 'bg-orange-500';
                        iconHTML = 'â¬‡ï¸' + stackText;
                        break;
                        
                    case 'DoT':
                    case 'dot':
                        cssClass = 'bg-red-700';
                        iconHTML = 'ðŸ”¥' + stackText;
                        break;
                        
                    case 'HoT':
                    case 'hot':
                        cssClass = 'bg-green-500';
                        iconHTML = 'ðŸ’š' + stackText;
                        break;
                        
                    case 'Control':
                    case 'control':
                        cssClass = 'bg-purple-600';
                        iconHTML = 'âš¡' + stackText;
                        break;
                        
                    case 'Shield':
                    case 'shield':
                        cssClass = 'bg-gray-400';
                        iconHTML = 'ðŸ›¡ï¸' + stackText;
                        break;
                        
                    default:
                        cssClass = 'bg-gray-500';
                        iconHTML = 'â“' + stackText;
                }
                
                // Create tooltip content from definition
                tooltipContent = `
                    <div class="tooltip-title">${displayName}</div>
                    <div class="tooltip-content">
                        <div>${definition.description}</div>
                        <div>Duration: ${effect.duration} turns</div>
                        ${effect.stacks > 1 ? `<div>Stacks: ${effect.stacks}</div>` : ''}
                    </div>
                `;
            } else {
                // Fallback for legacy status effects
                switch (statusId) {
                    case 'regen':
                        cssClass = 'bg-yellow-300';
                        iconHTML = 'âž•';
                        tooltipContent = `
                            <div class="tooltip-title">Regeneration</div>
                            <div class="tooltip-content">
                                <div>Restores 5% of max HP each turn</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                        break;
                    case 'burn':
                        cssClass = 'bg-red-700';
                        iconHTML = 'ðŸ”¥';
                        tooltipContent = `
                            <div class="tooltip-title">Burn</div>
                            <div class="tooltip-content">
                                <div>Takes 8% of max HP as damage each turn</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                        break;
                    case 'stun':
                    case 'status_stun':
                        cssClass = 'bg-gray-400';
                        iconHTML = 'âš¡';
                        tooltipContent = `
                            <div class="tooltip-title">Stunned</div>
                            <div class="tooltip-content">
                                <div>Cannot perform actions while stunned</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                        break;
                    case 'defense_up':
                    case 'status_def_up':
                        cssClass = 'bg-blue-500';
                        iconHTML = 'ðŸ›¡ï¸';
                        tooltipContent = `
                            <div class="tooltip-title">Defense Up</div>
                            <div class="tooltip-content">
                                <div>Defense increased by 50%</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                        break;
                    case 'attack_up':
                    case 'status_atk_up':
                        cssClass = 'bg-orange-500';
                        iconHTML = 'âš”ï¸';
                        tooltipContent = `
                            <div class="tooltip-title">Attack Up</div>
                            <div class="tooltip-content">
                                <div>Attack increased by 50%</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                        break;
                    case 'slow':
                    case 'status_spd_down':
                        cssClass = 'bg-gray-400';
                        iconHTML = 'â³';
                        tooltipContent = `
                            <div class="tooltip-title">Slowed</div>
                            <div class="tooltip-content">
                                <div>Takes actions later in the turn order</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                        break;
                    default:
                        cssClass = 'bg-gray-500';
                        iconHTML = 'â“';
                        tooltipContent = `
                            <div class="tooltip-title">${displayName}</div>
                            <div class="tooltip-content">
                                <div>${statusId.includes('status_') ? 'Status effect' : 'Effect'}</div>
                                <div>Duration: ${effect.duration} turns</div>
                            </div>
                        `;
                }
            }
            
            // Add class and icon
            icon.classList.add(cssClass);
            icon.innerHTML = iconHTML;
            
            // Add to container
            statusContainer.appendChild(icon);
            
            // Use our custom tooltip method in BattleUI instead of global tooltipManager
            if (this.battleUI) {
                this.battleUI.addStatusTooltip(icon, tooltipContent);
            }
        });
    }
    
    /**
     * Generate a set of actions for the current turn
     */
    generateTurnActions() {
        // For each living character, generate an action
        // First player team actions
        this.playerTeam.forEach(character => {
            if (character.currentHp > 0) {
                const action = this.generateCharacterAction(character, 'player');
                if (action) this.turnActions.push(action);
            }
        });
        
        // Then enemy team actions
        this.enemyTeam.forEach(character => {
            if (character.currentHp > 0) {
                const action = this.generateCharacterAction(character, 'enemy');
                if (action) this.turnActions.push(action);
            }
        });
        
        // Sort actions by speed (highest speed goes first)
        this.turnActions.sort((a, b) => {
            return b.actor.stats.speed - a.actor.stats.speed;
        });
        
        // Queue up the actions
        this.actionQueue = [...this.turnActions];
    }
    
    /**
     * Import the behavior system if it wasn't already imported
     * This allows backward compatibility with existing code
     */
    async initializeBehaviorSystem() {
        if (!this.battleBehaviors) {
            try {
                // Try dynamic import if ESM is supported
                // Check if the file exists at various potential locations
                console.log('Attempting to load Battle Behaviors system...');
                let module;
                try {
                    module = await import('../battle_logic/BattleBehaviors.js');
                    console.log('Loaded BattleBehaviors from ../battle_logic/BattleBehaviors.js');
                } catch (e) {
                    console.warn('Failed to load from ../battle_logic/', e.message);
                    try {
                        module = await import('/js/battle_logic/BattleBehaviors.js');
                        console.log('Loaded BattleBehaviors from /js/battle_logic/BattleBehaviors.js');
                    } catch (e2) {
                        console.warn('Failed to load from absolute path', e2.message);
                        throw e2;
                    }
                }
                
                this.battleBehaviors = module.default;
                console.log('Battle Behaviors system loaded successfully');
            } catch (error) {
                // Fallback to global if already loaded via script tag
                if (window.battleBehaviors) {
                    this.battleBehaviors = window.battleBehaviors;
                    console.log('Battle Behaviors system loaded from window');
                } else {
                    console.warn('Battle Behaviors system not available:', error);
                    console.log('Using default behavior when system is not available');
                    // Create a simple default behavior system
                    this.battleBehaviors = {
                        hasBehavior: (name) => false,
                        decideAction: (name, context) => null,
                        selectTarget: (name, context) => {
                            // Simple targeting - find living enemy
                            const targets = context.potentialTargets.filter(t => 
                                t.team !== context.actor.team && t.currentHp > 0
                            );
                            return targets.length > 0 ? targets[0] : null;
                        },
                        getDefaultActionDecisionBehavior: () => 'defaultActionDecision',
                        getDefaultTargetingBehavior: () => 'defaultTargeting',
                        getTargetingBehaviorFromType: (type) => 'defaultTargeting'
                    };
                }
            }
        }
        return this.battleBehaviors;
    }
    
    /**
     * Generate an action for a character
     * @param {Object} character - The character
     * @param {string} team - 'player' or 'enemy'
     * @returns {Object|null} The action or null
     */
    generateCharacterAction(character, team) {
        // If character is dead, no action
        if (character.isDead || character.currentHp <= 0) return null;
        
        // Assign team to character if not already set
        character.team = team;
        
        // Check if character is stunned
        if (this.statusEffects[character.uniqueId || character.id]?.stun) {
            this.logMessage(`${character.name} is stunned and cannot act!`, 'info');
            return null;
        }
        
        // Determine targets based on team
        const possibleTargets = team === 'player' ? this.enemyTeam : this.playerTeam;
        
        // Filter for living targets
        const livingTargets = possibleTargets.filter(target => target.currentHp > 0);
        
        // If no living targets, no action
        if (livingTargets.length === 0) return null;
        
        // Initialize variables with defaults
        let target = null;
        let useAbility = false;
        let selectedAbility = null;
        
        // Try to use the behavior system if available
        if (this.battleBehaviors) {
            // STEP 1: DECIDE WHICH ABILITY TO USE (OR BASIC ATTACK)
            // ---------------------------------------------
            
            // Get all available abilities (not on cooldown and NOT passive)
            const availableAbilities = character.abilities?.filter(ability => {
                // Skip if ability is undefined or null
                if (!ability) return false;
                
                // Skip passive abilities explicitly marked as such
                if (ability.abilityType === 'Passive' || ability.abilityType === 'passive') return false;
                
                // Also skip abilities with passive-specific properties
                if (ability.passiveTrigger || ability.passiveBehavior) return false;
                
                // Only include abilities not on cooldown
                return ability.currentCooldown === 0;
            }) || [];
            
            // Log available abilities for debugging
            if (availableAbilities.length > 0) {
                console.debug(`${character.name} has ${availableAbilities.length} available active abilities`);
            }
            
            // Create context for action decision
            const decisionContext = {
                actor: character,
                availableAbilities: availableAbilities,
                battleManager: this,
                teamManager: { getCharacterTeam: (char) => char.team }
            };
            
            // Check -> Delegate -> Default pattern
            try {
                // Check: Does the character have a specific actionDecisionLogic?
                const decisionLogic = character.actionDecisionLogic;
                
                // Delegate: If yes, use that behavior
                if (decisionLogic && this.battleBehaviors.hasBehavior(decisionLogic)) {
                    selectedAbility = this.battleBehaviors.decideAction(decisionLogic, decisionContext);
                } else {
                    // Default: Fall back to default behavior
                    selectedAbility = this.battleBehaviors.decideAction(
                        this.battleBehaviors.getDefaultActionDecisionBehavior(),
                        decisionContext
                    );
                }
            } catch (error) {
                console.error('Error in action decision behavior:', error);
                // Proceed with fallback logic on error
                selectedAbility = null;
            }
            
            // STEP 2: DETERMINE THE TARGET
            // -------------------------------
            if (selectedAbility) {
                useAbility = true;
                
                // Create context for targeting
                const targetingContext = {
                    actor: character,
                    potentialTargets: [...this.playerTeam, ...this.enemyTeam],
                    teamManager: { getCharacterTeam: (char) => char.team },
                    ability: selectedAbility,
                    battleManager: this
                };
                
                try {
                    // Check: Does the ability have specific targetingLogic?
                    const targetingLogic = selectedAbility.targetingLogic || 
                                           (selectedAbility.targetType ? 
                                             this.battleBehaviors.getTargetingBehaviorFromType(selectedAbility.targetType) :
                                             null);
                    
                    // Use appropriate targeting behavior based on ability type
                    const isHealing = selectedAbility.isHealing || selectedAbility.damageType === 'healing';
                    const isBuff = false; // TODO: Implement buff detection
                    
                    // Force ally targeting for healing abilities
                    let effectiveTargetingLogic = targetingLogic;
                    if (isHealing && !effectiveTargetingLogic) {
                        // Healing abilities should target allies by default
                        effectiveTargetingLogic = 'targetLowestHpAlly';
                        console.debug(`Forcing ally targeting for healing ability: ${selectedAbility.name}`);
                    }
                    
                    // Delegate: If yes, use that behavior
                    if (effectiveTargetingLogic && this.battleBehaviors.hasBehavior(effectiveTargetingLogic)) {
                        target = this.battleBehaviors.selectTarget(effectiveTargetingLogic, targetingContext);
                    } else {
                        // Default: Fall back to default targeting
                        target = this.battleBehaviors.selectTarget(
                            this.battleBehaviors.getDefaultTargetingBehavior(),
                            targetingContext
                        );
                    }
                    
                    // If target is an array (multi-target ability), use first target for now
                    // Future enhancement: Handle multi-target abilities properly
                    if (Array.isArray(target) && target.length > 0) {
                        target = target[0];
                    }
                    
                    // If no valid target found, use default targeting
                    if (!target) {
                        target = livingTargets[Math.floor(Math.random() * livingTargets.length)];
                    }
                    
                    // Set cooldown for the ability
                    selectedAbility.currentCooldown = selectedAbility.cooldown || 3;
                } catch (error) {
                    console.error('Error in targeting behavior:', error);
                    // Use random targeting as fallback
                    target = livingTargets[Math.floor(Math.random() * livingTargets.length)];
                }
            } else {
                // Basic attack - use default targeting
                target = livingTargets[Math.floor(Math.random() * livingTargets.length)];
            }
        } else {
            // FALLBACK: Use legacy behavior when behavior system is not available
            // ---------------------------------------------------------------------
            
            // Select a random target initially
            target = livingTargets[Math.floor(Math.random() * livingTargets.length)];
            
            // Legacy ability selection logic
            if (character.abilities && character.abilities.length > 0) {
                // Get available abilities (not on cooldown)
                const availableAbilities = character.abilities.filter(ability => 
                    ability.currentCooldown === 0
                );
                
                if (availableAbilities.length > 0 && Math.random() > 0.5) {
                    // 50% chance to use an ability if available
                    useAbility = true;
                    selectedAbility = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                    
                    // If it's a healing ability, find a friendly target instead
                    if (selectedAbility.isHealing || selectedAbility.damageType === 'healing') {
                        const friendlyTargets = team === 'player' ? this.playerTeam : this.enemyTeam;
                        const injuredTargets = friendlyTargets.filter(t => 
                            t.currentHp > 0 && t.currentHp < t.stats.hp
                        );
                        
                        if (injuredTargets.length > 0) {
                            // Target the most injured friendly
                            injuredTargets.sort((a, b) => 
                                (a.currentHp / a.stats.hp) - (b.currentHp / b.stats.hp)
                            );
                            target = injuredTargets[0];
                        } else if (friendlyTargets.some(t => t.currentHp > 0)) {
                            // If no injured targets, pick any living friendly
                            const livingFriendlies = friendlyTargets.filter(t => t.currentHp > 0);
                            target = livingFriendlies[Math.floor(Math.random() * livingFriendlies.length)];
                        }
                    }
                    
                    // Handle utility abilities specifically
                    if (selectedAbility.damageType === 'utility') {
                        // For utility abilities like buffs or evasion, target self
                        target = character;
                    }
                    
                    // Set cooldown
                    selectedAbility.currentCooldown = selectedAbility.cooldown;
                }
            }
        }
        
        // Calculate damage for the selected action
        const damageResult = this.calculateDamage(character, target, selectedAbility);
        
        // Create the action object
        return {
            actor: character,
            target: target,
            team: team,
            useAbility: useAbility,
            ability: selectedAbility,
            damage: damageResult.damage,
            scalingText: damageResult.scalingText,
            scalingStat: damageResult.scalingStat,
            damageType: damageResult.damageType
        };
    }
    
    /**
     * Execute the next action in the queue
     */
    executeNextAction() {
        if (!this.battleActive || this.isPaused) {
            this.turnInProgress = false;
            return;
        }
        
        if (this.actionQueue.length === 0) {
            this.finishTurn();
            return;
        }
        
        const action = this.actionQueue.shift();
        
        // Check if the actor is still alive before proceeding
        if (action.actor.isDead || action.actor.currentHp <= 0) {
            console.log(`Skipping action for defeated character: ${action.actor.name}`);
            // Skip to next action
            this.executeNextAction();
            return;
        }
        
        // Check if the target is still alive (unless it's a healing ability)
        const isHealing = action.ability && (action.ability.isHealing || action.ability.damageType === 'healing');
        if (!isHealing && (action.target.isDead || action.target.currentHp <= 0)) {
            // Target is defeated, find a new target
            console.log(`Original target defeated, finding new target for ${action.actor.name}`);
            
            // Determine possible targets based on team
            const possibleTargets = action.team === 'player' ? this.enemyTeam : this.playerTeam;
            
            // Filter for living targets
            const livingTargets = possibleTargets.filter(target => !target.isDead && target.currentHp > 0);
            
            if (livingTargets.length === 0) {
                // No valid targets left, skip this action
                console.log(`No valid targets left for ${action.actor.name}, skipping action`);
                this.executeNextAction();
                return;
            }
            
            // Select a new random target
            action.target = livingTargets[Math.floor(Math.random() * livingTargets.length)];
            console.log(`New target selected: ${action.target.name}`);
            
            // Recalculate damage for the new target
            const { damage, scalingText, scalingStat } = this.calculateDamage(action.actor, action.target, action.ability);
            action.damage = damage;
            action.scalingText = scalingText;
            action.scalingStat = scalingStat;
        }
        
        // Add team to actor and target if not set
        if (!action.actor.team) {
            action.actor.team = action.team;
        }
        
        if (!action.target.team) {
            action.target.team = action.team === 'player' ? 'enemy' : 'player';
        }
        
        // Generate uniqueId for actor and target if needed
        if (!action.actor.uniqueId) {
            action.actor.uniqueId = `${action.actor.team}_${action.actor.id}`;
        }
        
        if (!action.target.uniqueId) {
            action.target.uniqueId = `${action.target.team}_${action.target.id}`;
        }
        
        // Log the action
        let message;
        // Add team info to actor and target names for better clarity
        const actorName = `${action.actor.name}${action.team === 'player' ? ' (ally)' : ' (enemy)'}`;
        const targetName = `${action.target.name}${action.team === 'player' ? ' (enemy)' : ' (ally)'}`;
        
        if (action.useAbility) {
            // Handle different ability types in log message
            if (action.ability.isHealing || action.ability.damageType === 'healing') {
                message = `${actorName} uses [${action.ability.name}] to heal ${targetName}!`;
            } else if (action.ability.damageType === 'utility') {
                message = `${actorName} uses [${action.ability.name}]!`;
            } else {
                message = `${actorName} uses [${action.ability.name}] on ${targetName}!`;
            }
        } else {
            message = `${actorName} attacks ${targetName} for ${action.damage} damage!`;
        }
        this.logMessage(message, 'action');
        
        // Dispatch CHARACTER_ACTION event via BattleBridge if available
        if (this.uiMode === "phaser" && window.battleBridge) {
            try {
                console.log(`BattleManager: Dispatching CHARACTER_ACTION event for ${action.actor.name}`);
                if (action.useAbility) {
                    // For ability actions
                    window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_ACTION, {
                        character: action.actor,
                        action: {
                            type: 'ability',
                            name: action.ability.name,
                            abilityName: action.ability.name,
                            target: action.target
                        }
                    });
                } else {
                    // For auto-attack actions
                    window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_ACTION, {
                        character: action.actor,
                        action: {
                            type: 'autoAttack',
                            name: 'Auto Attack',
                            target: action.target
                        }
                    });
                }
            } catch (error) {
                console.error('BattleManager: Error dispatching CHARACTER_ACTION event:', error);
            }
        }
        
        // Set active character in UI
        if (this.battleUI) {
            this.battleUI.setActiveCharacter(action.actor);
            
            // Slight delay before showing animation
            setTimeout(() => {
                // Show attack animation
                this.battleUI.showAttackAnimation(action.actor, action.target, action.ability);
                
                // Apply damage/healing to target
                this.applyActionEffect(action);
                
                // Check for battle end
                if (this.checkBattleEnd()) {
                    return; // Battle ended, don't continue
                }
                
                // Random chance to apply status effect
                if (action.useAbility && !action.ability.isHealing && action.ability.damageType !== 'utility' && Math.random() < 0.3) {
                    // 30% chance to apply an effect with an ability
                    this.applyRandomStatusEffect(action.target);
                }
                
                // Schedule next action
                const actualDelay = this.actionDelay / this.speedMultiplier;
                setTimeout(() => this.executeNextAction(), actualDelay);
                
            }, 300);
        } else {
            // No UI, just process the action immediately
            this.applyActionEffect(action);
            
            // Check for battle end
            if (this.checkBattleEnd()) {
                return; // Battle ended, don't continue
            }
            
            // Schedule next action
            const actualDelay = this.actionDelay / this.speedMultiplier;
            setTimeout(() => this.executeNextAction(), actualDelay);
        }
    }
    
    /**
     * Apply a random status effect to a character
     * @param {Object} target - The character to affect
     */
    applyRandomStatusEffect(target) {
        // Get all damage over time effects from definitions if available
        let possibleEffects = [];
        
        if (this.statusEffectDefinitions) {
            // Get all DoT effects from the definitions
            const dotEffects = Object.entries(this.statusEffectDefinitions)
                .filter(([id, def]) => def.type === 'DoT' || def.type === 'Debuff')
                .map(([id, def]) => ({ id, duration: def.defaultDuration || 2 }));
            
            if (dotEffects.length > 0) {
                possibleEffects = dotEffects;
            }
        }
        
        // Fallback to hardcoded effects if no definitions or filtered list is empty
        if (possibleEffects.length === 0) {
            possibleEffects = [
                { id: 'status_burn', duration: 2 },
                { id: 'status_stun', duration: 1 },
                { id: 'status_spd_down', duration: 2 }
            ];
        }
        
        // Select a random effect
        const randomEffect = possibleEffects[Math.floor(Math.random() * possibleEffects.length)];
        
        // Apply the effect
        this.addStatusEffect(target, randomEffect.id, randomEffect.duration);
    }
    
    /**
     * Apply the effect of an action to its target
     * @param {Object} action - The action to apply
     */
    applyActionEffect(action) {
        // Get team info for clearer logging
        const actorTeam = action.team;
        const targetTeam = actorTeam === 'player' ? 'enemy' : 'player';
        
        // Handle array of targets (for multi-target abilities)
        if (Array.isArray(action.target)) {
            // Process each target individually
            action.target.forEach(target => {
                // Create a single-target version of the action
                const singleAction = {...action, target};
                this.applyActionEffect(singleAction);
            });
            return;
        }
        
        // Check if this is an action with the new effects array
        if (action.ability && action.ability.effects && Array.isArray(action.ability.effects) && action.ability.effects.length > 0) {
            // New effect system - process each effect in the array
            action.ability.effects.forEach(effect => {
                this.processEffect(effect, action.actor, action.target, action.ability);
            });
            return;
        }
        
        // Legacy action processing
        if (action.ability && (action.ability.isHealing || action.ability.damageType === 'healing')) {
            // Healing ability
            const healAmount = action.damage;
            const previousHp = action.target.currentHp;
            action.target.currentHp = Math.min(
            action.target.currentHp + healAmount,
            action.target.stats.hp
            );
            
            // Calculate actual healing done (may be less than healAmount if at max HP)
            const actualHealing = action.target.currentHp - previousHp;
            
            // Include team info in the log message for healing too
            const targetTeam = action.target.team;
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Add scaling information to healing message
            if (action.scalingText) {
                this.logMessage(`${targetInfo} is healed for ${healAmount} HP ${action.scalingText}! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, 'success');
            } else {
                this.logMessage(`${targetInfo} is healed for ${healAmount} HP! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, 'success');
            }
            
            // Process healing-related passive abilities
            
            // 1. onHealed for the target
            if (actualHealing > 0) {
                this.processPassiveAbilities('onHealed', action.target, {
                    source: action.actor,
                    healAmount: actualHealing,
                    ability: action.ability,
                    healPercent: action.target.stats.hp > 0 ? actualHealing / action.target.stats.hp : 0 // Add healing percentage
                });
                
                // Show passive trigger visual feedback if using BattleUI
                if (this.battleUI && this.battleUI.showPassiveEffect) {
                    this.battleUI.showPassiveEffect(action.target, 'Healing received');
                }
            }
            
            // 2. onHealingDone for the healer
            if (actualHealing > 0 && action.actor !== action.target) { // Only trigger for healing others
                this.processPassiveAbilities('onHealingDone', action.actor, {
                    target: action.target,
                    healAmount: actualHealing,
                    ability: action.ability,
                    healPercent: action.target.stats.hp > 0 ? actualHealing / action.target.stats.hp : 0 // Add healing percentage
                });
                
                // Show passive trigger visual feedback if using BattleUI
                if (this.battleUI && this.battleUI.showPassiveEffect) {
                    this.battleUI.showPassiveEffect(action.actor, 'Healing done');
                }
            }
            
            // Check if target was dead and should be revived
            const wasRevived = this.checkAndResetDeathStatus(action.target);
            
            // Process revival passive if character was revived
            if (wasRevived) {
                this.processPassiveAbilities('onRevive', action.target, {
                    reviver: action.actor,
                    ability: action.ability
                });
            }
            
            // Add regeneration status if it's a healing ability
            if (Math.random() < 0.5) { // 50% chance
                this.addStatusEffect(action.target, 'regen', 2);
            }
        } else if (action.ability && action.ability.damageType === 'utility') {
            // Utility ability - special effects instead of damage
            const targetTeam = action.target.team;
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Handle different utility effects
            if (action.ability.name === "Evasive Maneuver") {
                // Add evasion effect (this is just a placeholder, evasion mechanic would need to be implemented)
                this.logMessage(`${targetInfo} becomes harder to hit!`, 'info');
                this.addStatusEffect(action.target, 'defense_up', 2);
            } else {
                // Generic utility effect message
                this.logMessage(`${targetInfo} is affected by ${action.ability.name}!`, 'info');
            }
        } else {
            // Damaging action
            const previousHp = action.target.currentHp;
            action.target.currentHp = Math.max(0, action.target.currentHp - action.damage);
            
            // Calculate actual damage dealt (may be less than action.damage if target had low HP)
            const actualDamage = previousHp - action.target.currentHp;
            
            // Include team info in the log message for clarity when characters share names
            // For targets, we need to use opposite team designation from the actor
            const targetTeam = action.team === 'player' ? 'enemy' : 'player';
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Add scaling information to damage message
            if (action.scalingText) {
                this.logMessage(`${targetInfo} takes ${action.damage} damage ${action.scalingText}! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, action.useAbility ? 'error' : 'default');
            } else {
                this.logMessage(`${targetInfo} takes ${action.damage} damage! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, action.useAbility ? 'error' : 'default');
            }
            
            // Process damage-related passive abilities
            
            // 1. onDamageTaken for the target
            if (actualDamage > 0) {
                this.processPassiveAbilities('onDamageTaken', action.target, {
                    source: action.actor,
                    damageAmount: actualDamage,
                    ability: action.ability,
                    wasCritical: false, // TODO: Add critical hit tracking
                    reflectionDepth: 0 // Initialize reflection depth tracking
                });
            }
            
            // 2. onDamageDealt for the attacker
            if (actualDamage > 0) {
                this.processPassiveAbilities('onDamageDealt', action.actor, {
                    target: action.target,
                    damageAmount: actualDamage,
                    ability: action.ability,
                    wasCritical: false, // TODO: Add critical hit tracking
                    damagePercent: action.target.stats.hp > 0 ? actualDamage / action.target.stats.hp : 0 // Add damage percentage
                });
            }
            
            // Check if target died
            if (action.target.currentHp <= 0) {
                action.target.isDead = true;
                action.target.currentHp = 0; // Ensure HP doesn't go below 0
                // Use the same targetInfo for defeat message
                this.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error'); // Added coffin emoji for visibility
                
                // Process defeat passive abilities
                this.processPassiveAbilities('onDefeat', action.target, {
                    killer: action.actor,
                    ability: action.ability
                });
                
                // Process on-kill passive ability with visual feedback
                const killResults = this.processPassiveAbilities('onKill', action.actor, {
                    defeated: action.target,
                    ability: action.ability
                });
                
                // Show visual feedback for kill effects if there were executed passives
                if (killResults && killResults.length > 0 && this.battleUI && this.battleUI.showPassiveEffect) {
                    const passiveNames = killResults
                        .filter(result => result.executed)
                        .map(result => {
                            // Extract passive name from message if available
                            if (result.message && result.message.includes("'s")) {
                                return result.message.split("'s")[1].trim();
                            }
                            return 'Kill Effect';
                        });
                    
                    if (passiveNames.length > 0) {
                        // Show the passive effect visualization
                        this.battleUI.showPassiveEffect(action.actor, passiveNames[0]);
                    }
                }
            }
        }
    }
    
    /**
     * Process a single effect from an ability's effects array
     * @param {Object} effect - The effect to process
     * @param {Object} actor - The character using the ability
     * @param {Object} target - The target of the effect
     * @param {Object} ability - The ability being used
     */
    processEffect(effect, actor, target, ability) {
        // Get team identifiers for logging
        const actorTeamId = actor.team === 'player' ? ' (ally)' : ' (enemy)';
        const targetTeamId = target.team === 'player' ? ' (ally)' : ' (enemy)';
        const actorInfo = `${actor.name}${actorTeamId}`;
        const targetInfo = `${target.name}${targetTeamId}`;
        
        // Check if this effect should apply based on team relationships
        const isTargetAlly = target.team === actor.team || target.isAllyOf === true;
        
        // Skip if effect shouldn't apply to allies but target is an ally
        if (effect.targetAllies === false && isTargetAlly) {
            console.debug(`Skipping effect on ${target.name}: ally=${isTargetAlly}, effect allows allies: false`);
            return; // Skip this effect
        }
        
        // Skip if effect shouldn't apply to enemies but target is an enemy
        if (effect.targetEnemies === false && !isTargetAlly) {
            console.debug(`Skipping effect on ${target.name}: ally=${isTargetAlly}, effect allows enemies: false`);
            return; // Skip this effect
        }
        
        console.debug(`Processing effect on ${target.name}: isAlly=${isTargetAlly}, effect allows allies: ${effect.targetAllies !== false}, effect allows enemies: ${effect.targetEnemies !== false}`);
        
        // Handle different effect types
        switch (effect.type) {
            case 'Damage':
            case 'damage':
                // Only apply damage if target is an enemy or area damage specifically allows allies
                if (!isTargetAlly || effect.targetAllies === true) {
                    // Calculate damage for this specific effect
                    const damageResult = this.calculateDamage(actor, target, ability, effect);
                    const damage = damageResult.damage;
                    
                    // Apply damage to target
                    target.currentHp = Math.max(0, target.currentHp - damage);
                    
                    // Log the damage
                    if (damageResult.scalingText) {
                        this.logMessage(`${targetInfo} takes ${damage} damage ${damageResult.scalingText}! (HP: ${target.currentHp}/${target.stats.hp})`, 'error');
                    } else {
                        this.logMessage(`${targetInfo} takes ${damage} damage! (HP: ${target.currentHp}/${target.stats.hp})`, 'error');
                    }
                    
                    // Check if target died
                    if (target.currentHp <= 0) {
                        target.isDead = true;
                        target.currentHp = 0; // Ensure HP doesn't go below 0
                        this.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error');
                    }
                }
                break;
                
            case 'Healing':
            case 'healing':
                // Only apply healing if target is an ally or area healing specifically allows enemies
                if (isTargetAlly || effect.targetEnemies === true) {
                    // Calculate healing amount for this specific effect
                    const healResult = this.calculateDamage(actor, target, ability, effect);
                    const healAmount = healResult.damage; // We reuse damage calculation for healing
                    
                    // Apply healing to target
                    target.currentHp = Math.min(target.stats.hp, target.currentHp + healAmount);
                    
                    // Log the healing
                    if (healResult.scalingText) {
                        this.logMessage(`${targetInfo} is healed for ${healAmount} HP ${healResult.scalingText}! (HP: ${target.currentHp}/${target.stats.hp})`, 'success');
                    } else {
                        this.logMessage(`${targetInfo} is healed for ${healAmount} HP! (HP: ${target.currentHp}/${target.stats.hp})`, 'success');
                    }
                    
                    // Check if target was dead but now has HP
                    this.checkAndResetDeathStatus(target);
                }
                break;
                
            case 'ApplyStatus':
            case 'applyStatus':
                // Apply status based on team relationships
                // Buffs typically go to allies, debuffs to enemies
                const statusId = effect.statusEffectId;
                const duration = effect.duration || 2;
                let applyStatus = true;
                
                // Get the definition to check if it's a buff or debuff
                const statusDef = this.statusEffectDefinitions ? this.statusEffectDefinitions[statusId] : null;
                const isBuffType = statusDef && (statusDef.type === 'Buff' || statusDef.type === 'HoT' || statusDef.type === 'Shield');
                const isDebuffType = statusDef && (statusDef.type === 'Debuff' || statusDef.type === 'DoT' || statusDef.type === 'Control');
                
                // Check default targeting behavior if not explicitly specified
                // By default, buffs go to allies and debuffs go to enemies
                if (effect.targetAllies === undefined && effect.targetEnemies === undefined) {
                    if (isBuffType && !isTargetAlly) applyStatus = false;
                    if (isDebuffType && isTargetAlly) applyStatus = false;
                }
                
                // Check if the status effect has a chance component
                if (effect.chance && effect.chance < 1.0) {
                    // Only apply if random roll succeeds
                    applyStatus = applyStatus && (Math.random() < effect.chance);
                    if (!applyStatus) {
                        this.logMessage(`${actorInfo}'s attempt to inflict ${statusId} failed!`, 'info');
                    }
                }
                
                // Apply the status effect if applicable
                if (applyStatus) {
                    this.addStatusEffect(target, statusId, duration);
                }
                break;
                
            case 'StatBuff':
            case 'statBuff':
                // Apply stat buffs based on team relationships
                // By default, positive stat mods go to allies, negative to enemies
                const isPositiveMod = !effect.value || effect.value > 0;
                
                // Skip if doesn't match team targeting rules
                if ((isPositiveMod && !isTargetAlly && effect.targetEnemies !== true) ||
                    (!isPositiveMod && isTargetAlly && effect.targetAllies !== true)) {
                    break;
                }
                
                // Not fully implemented yet, will add in Pass 6 with status effect system refactor
                this.logMessage(`${targetInfo} receives a stat modification from ${actorInfo}!`, 'info');
                
                // For now, map common stat buffs to existing status effects
                if (effect.targetStat === 'Attack') {
                    this.addStatusEffect(target, isPositiveMod ? 'status_atk_up' : 'status_atk_down', effect.duration || 3);
                } else if (effect.targetStat === 'Defense') {
                    this.addStatusEffect(target, isPositiveMod ? 'status_def_up' : 'status_def_down', effect.duration || 3);
                }
                break;
                
            default:
                // Unknown effect type
                this.logMessage(`Unknown effect type: ${effect.type}`, 'info');
        }
    }
    
    /**
     * Calculate damage for an action
     * @param {Object} attacker - The attacking character
     * @param {Object} target - The target character
     * @param {Object|null} ability - The ability used (if any)
     * @param {Object|null} effect - The specific effect from an ability's effects array (if any)
     * @returns {Object} The calculated damage, scaling text, and scaling stat
     */
    /**
     * Process passive abilities for a specific trigger event
     * @param {string} trigger - The trigger event (e.g., 'onTurnStart', 'onDamageTaken')
     * @param {Object} character - The character whose passives should be checked
     * @param {Object} additionalData - Additional context data for the passive
     * @returns {Array} Array of executed passive results
     */
    processPassiveAbilities(trigger, character, additionalData = {}) {
        // Skip if character is defeated or has no passive abilities
        if (!character || character.isDead || character.currentHp <= 0 || !character.passiveAbilities || !character.passiveAbilities.length) {
            return [];
        }
        
        // Initialize tracking object if it doesn't exist
        if (!character.passiveTriggeredThisTurn) {
            character.passiveTriggeredThisTurn = {};
        }
        
        // Initialize battle-level tracking if needed
        if (!this.passiveTriggersThisBattle) {
            this.passiveTriggersThisBattle = new Map();
        }
        
        // Will store results from executed passives
        const results = [];
        
        // Skip if we don't have the behavior system
        if (!this.battleBehaviors) {
            return results;
        }
        
        // Process each passive ability
        character.passiveAbilities.forEach(ability => {
            // Skip if this passive has already been triggered this turn for this trigger type
            const passiveId = ability.id || ability.name;
            const triggerKey = `${passiveId}_${trigger}`;
            
            if (character.passiveTriggeredThisTurn[triggerKey]) {
                console.debug(`Skipping duplicate trigger of ${passiveId} for ${character.name}, already triggered this turn`);
                return; // Skip this passive ability
            }
            
            // Special handling for onBattleStart trigger - needs battle-level tracking
            if (trigger === 'onBattleStart') {
                // Create a unique key for this ability trigger in this battle
                const battleTriggerKey = `${character.uniqueId || character.id}_${passiveId}_${trigger}`;
                
                // Check if this has already been triggered in this battle
                if (this.passiveTriggersThisBattle.has(battleTriggerKey)) {
                    console.debug(`Skipping duplicate battle start trigger: ${ability.name} for ${character.name}`);
                    return; // Skip this passive ability
                }
                
                // Mark as triggered for this battle
                this.passiveTriggersThisBattle.set(battleTriggerKey, true);
            }
            
            // Check if this passive has a trigger that matches the current trigger
            if (ability.passiveTrigger === trigger) {
                // Create context for the passive behavior
                const passiveContext = {
                    actor: character,
                    ability: ability,
                    battleManager: this,
                    teamManager: this.teamManager,
                    trigger: trigger,
                    additionalData: additionalData
                };
                
                // Get the behavior function name
                const behaviorName = ability.passiveBehavior;
                
                // If the passive has a behavior function and our system has it registered
                if (behaviorName && this.battleBehaviors.hasBehavior(behaviorName)) {
                    try {
                        // Execute the passive behavior
                        const result = this.battleBehaviors.executePassiveBehavior(behaviorName, passiveContext);
                        
                        // If passive executed successfully, add to results and log message
                        if (result && result.executed) {
                            // Mark this passive as triggered for this turn and trigger type
                            character.passiveTriggeredThisTurn[triggerKey] = true;
                            
                            results.push(result);
                            
                            // Log the passive activation if a message was provided
                            if (result.message) {
                                const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
                                this.logMessage(`${character.name}${teamIdentifier}'s passive ability: ${result.message}`, 'action');
                            }
                        }
                    } catch (error) {
                        console.error(`Error executing passive ability '${ability.name}':`, error);
                    }
                }
            }
        });
        
        return results;
    }
    
    calculateDamage(attacker, target, ability, effect = null) {
        let baseDamage;
        let scalingStat = 0;
        let scalingText = '';
        let scalingStatName = '';
        let damageType = '';
        
        // Determine if we're using the enhanced effect system or traditional ability properties
        const useEffectSystem = effect && typeof effect === 'object';
        
        if (ability) {
            // First determine effect type (damage, healing, or utility)
            let effectType = useEffectSystem ? effect.type : 
                            (ability.isHealing || ability.damageType === 'healing') ? 'Healing' : 
                            (ability.damageType === 'utility') ? 'Utility' : 'Damage';
            
            // Get base damage/healing value
            baseDamage = useEffectSystem ? (effect.value || ability.damage) : ability.damage;
            
            // Get damage type (for type effectiveness)
            damageType = useEffectSystem ? (effect.damageType || ability.damageType) : ability.damageType;
            
            // Determine scaling based on damage type
            if (effectType === 'Damage' || effectType === 'damage') {
                if (damageType === 'physical') {
                    // Get scaling stat and factor
                    const scaleFactor = useEffectSystem ? (effect.scaleFactor || 0.5) : 0.5;
                    scalingStat = Math.floor(attacker.stats.strength * scaleFactor);
                    scalingStatName = 'Strength';
                    scalingText = `(+${scalingStat} from Strength)`;
                    baseDamage += scalingStat;
                } else if (damageType === 'spell') {
                    // Spell abilities scale with Intellect
                    const scaleFactor = useEffectSystem ? (effect.scaleFactor || 0.5) : 0.5;
                    scalingStat = Math.floor(attacker.stats.intellect * scaleFactor);
                    scalingStatName = 'Intellect';
                    scalingText = `(+${scalingStat} from Intellect)`;
                    baseDamage += scalingStat;
                }
            } else if (effectType === 'Healing' || effectType === 'healing') {
                // Healing effects scale with Spirit
                const scaleFactor = useEffectSystem ? (effect.scaleFactor || 0.5) : 0.5;
                scalingStat = Math.floor(attacker.stats.spirit * scaleFactor);
                scalingStatName = 'Spirit';
                scalingText = `(+${scalingStat} from Spirit)`;
                baseDamage += scalingStat;
                
                // Log healing with scaling info
                this.logMessage(`Ability scales with Spirit: ${baseDamage - scalingStat} base + ${scalingStat} = ${baseDamage} total healing`, 'info');
                return { damage: baseDamage, scalingText, scalingStat, scalingStatName, damageType };
            } else if (effectType === 'Utility' || effectType === 'utility' || 
                      effectType === 'ApplyStatus' || effectType === 'StatBuff') {
                // Utility effects might scale with Spirit
                const scaleFactor = useEffectSystem ? (effect.scaleFactor || 0.3) : 0.3;
                scalingStat = Math.floor(attacker.stats.spirit * scaleFactor);
                scalingStatName = 'Spirit';
                scalingText = `(boosted by Spirit)`;
                
                // For utility effects, return 0 damage but track Spirit scaling
                this.logMessage(`Utility effect scales with Spirit: ${scalingStat} bonus effectiveness`, 'info');
                return { damage: 0, scalingText, scalingStat, scalingStatName, damageType };
            }
        } else {
            // Basic attack damage
            baseDamage = attacker.stats.attack;
            damageType = 'physical'; // Basic attacks are physical
        }
        
        // Apply defense reduction
        let defense = target.stats.defense;
        
        // Get character IDs for status effects
        const attackerId = attacker.uniqueId || attacker.id;
        const targetId = target.uniqueId || target.id;
        
        // Check for defense_up status effect (legacy check - will be updated in Pass 6)
        if (this.statusEffects[targetId]?.defense_up) {
            defense = Math.floor(defense * 1.5); // 50% more defense
        }
        
        let damage = Math.max(1, baseDamage - (defense / 2));
        
        // Check for attack_up status effect (legacy check - will be updated in Pass 6)
        if (this.statusEffects[attackerId]?.attack_up) {
            damage = Math.floor(damage * 1.5); // 50% more damage
        }
        
        // Apply type advantage/disadvantage
        const typeMultiplier = this.calculateTypeMultiplier(attacker.type, target.type);
        damage = Math.round(damage * typeMultiplier);
        
        // Apply random variance (Â±20%)
        const variance = 0.8 + (Math.random() * 0.4); // 0.8 to 1.2
        damage = Math.round(damage * variance);
        
        // Miss chance (5%)
        if (Math.random() < 0.05) {
            this.logMessage(`${attacker.name}'s attack missed!`, 'info');
            return { damage: 0, scalingText: '', scalingStat: 0, scalingStatName: '', damageType };
        }
        
        // Critical hit chance (10%)
        if (Math.random() < 0.1) {
            damage = Math.round(damage * 1.5);
            this.logMessage(`Critical hit!`, 'success');
        }
        
        // Log ability scaling information if it's not a basic attack
        if (ability && this.battleUI) {
            if (scalingStatName) {
                this.logMessage(`Ability scales with ${scalingStatName}: ${ability.damage} base + ${scalingStat} = ${baseDamage} pre-defense damage`, 'info');
            }
        }
        
        return { 
            damage: Math.max(1, damage), 
            scalingText, 
            scalingStat,
            scalingStatName,
            damageType
        };
    }
    
    /**
     * Calculate type advantage multiplier
     * @param {string} attackerType - Attacker's type
     * @param {string} defenderType - Defender's type
     * @returns {number} Damage multiplier
     */
    calculateTypeMultiplier(attackerType, defenderType) {
        // Type advantage chart
        const advantages = {
            fire: 'nature',    // Fire is strong against Nature
            water: 'fire',     // Water is strong against Fire
            nature: 'water',   // Nature is strong against Water
            light: 'dark',     // Light is strong against Dark
            dark: 'light',     // Dark is strong against Light
            air: 'earth'       // Air is strong against Earth (not used yet)
        };
        
        if (advantages[attackerType] === defenderType) {
            // Attacker has advantage
            this.logMessage(`${attackerType.charAt(0).toUpperCase() + attackerType.slice(1)} is super effective against ${defenderType}!`, 'success');
            return 1.5;
        } else if (advantages[defenderType] === attackerType) {
            // Defender has advantage
            this.logMessage(`${attackerType.charAt(0).toUpperCase() + attackerType.slice(1)} is not very effective against ${defenderType}.`, 'info');
            return 0.75;
        }
        
        return 1.0; // No advantage
    }
    
    /**
     * Finish the current turn
     */
    finishTurn() {
        this.turnInProgress = false;
        
        // Reduce ability cooldowns
        this.playerTeam.concat(this.enemyTeam).forEach(character => {
            if (character.abilities) {
                character.abilities.forEach(ability => {
                    if (ability.currentCooldown > 0) {
                        ability.currentCooldown--;
                    }
                });
            }
            
            // Process turn end passive abilities
            if (character.currentHp > 0) {
                this.processPassiveAbilities('onTurnEnd', character, { turnNumber: this.currentTurn });
            }
            
            // Random chance to apply a buff at the end of turn
            if (character.currentHp > 0 && Math.random() < 0.1) { // 10% chance
                const buffs = [
                    { type: 'defense_up', duration: 2 },
                    { type: 'attack_up', duration: 2 },
                    { type: 'regen', duration: 2 }
                ];
                
                const randomBuff = buffs[Math.floor(Math.random() * buffs.length)];
                this.addStatusEffect(character, randomBuff.type, randomBuff.duration);
            }
        });
        
        // Display end of turn summary
        this.displayTurnSummary();
        
        // Check for battle end
        if (this.checkBattleEnd()) {
            return;
        }
        
        // Schedule next turn
        const actualDelay = this.turnDelay / this.speedMultiplier;
        this.turnTimer = setTimeout(() => this.startNextTurn(), actualDelay);
    }
    
    /**
     * Check if the battle is over
     * @returns {boolean} True if the battle is over
     */
    checkBattleEnd() {
        // Count characters that are actually dead (isDead flag or hp <= 0)
        const playerDeadCount = this.playerTeam.filter(char => char.isDead || char.currentHp <= 0).length;
        const enemyDeadCount = this.enemyTeam.filter(char => char.isDead || char.currentHp <= 0).length;
        
        // Check if all characters on either team are dead
        const allPlayersDead = playerDeadCount === this.playerTeam.length;
        const allEnemiesDead = enemyDeadCount === this.enemyTeam.length;
        
        // Log the current dead counts for debugging
        if (playerDeadCount > 0 || enemyDeadCount > 0) {
            console.log(`Dead count - Players: ${playerDeadCount}/${this.playerTeam.length}, Enemies: ${enemyDeadCount}/${this.enemyTeam.length}`);
        }
        
        if (allPlayersDead || allEnemiesDead) {
            if (allPlayersDead && allEnemiesDead) {
                this.endBattle('draw');
            } else if (allPlayersDead) {
                this.endBattle('defeat');
            } else {
                this.endBattle('victory');
            }
            return true;
        }
        
        return false;
    }
    
    /**
     * Toggle pause state
     * @returns {boolean} - New pause state
     */
    togglePause() {
        this.isPaused = !this.isPaused;
        
        if (this.isPaused) {
            // Clear any pending turn timer
            if (this.turnTimer) {
                clearTimeout(this.turnTimer);
                this.turnTimer = null;
            }
            this.logMessage('Battle paused', 'info');
        } else {
            // Resume battle
            this.logMessage('Battle resumed', 'info');
            if (!this.turnInProgress) {
                this.startNextTurn();
            } else {
                this.executeNextAction();
            }
        }
        
        return this.isPaused;
    }
    
    /**
     * Pause the battle
     * @returns {boolean} - Current pause state (should be true)
     */
    pauseBattle() {
        if (!this.isPaused) {
            // Only log and clear timer if we're actually changing state
            this.isPaused = true;
            
            // Clear any pending turn timer
            if (this.turnTimer) {
                clearTimeout(this.turnTimer);
                this.turnTimer = null;
            }
            this.logMessage('Battle paused', 'info');
        }
        
        return this.isPaused;
    }
    
    /**
     * Resume the battle
     * @returns {boolean} - Current pause state (should be false)
     */
    resumeBattle() {
        if (this.isPaused) {
            // Only log and restart if we're actually changing state
            this.isPaused = false;
            
            this.logMessage('Battle resumed', 'info');
            if (!this.turnInProgress) {
                this.startNextTurn();
            } else {
                this.executeNextAction();
            }
        }
        
        return this.isPaused;
    }
    
    /**
     * Set battle speed
     * @param {number} multiplier - Speed multiplier (1, 2, or 3)
     */
    setSpeed(multiplier) {
        const validMultipliers = [1, 2, 3]; // Match UI options
        if (validMultipliers.includes(multiplier)) {
            // Store previous and new value for comparison
            const previousSpeed = this.speedMultiplier;
            this.speedMultiplier = multiplier;
            
            // Base timing values - doubled from original values for slower pace
            const BASE_TURN_DELAY = 6000;
            const BASE_ACTION_DELAY = 3200;
            
            // Update timing values
            this.turnDelay = BASE_TURN_DELAY / multiplier;
            this.actionDelay = BASE_ACTION_DELAY / multiplier;
            
            // Log speed change if it actually changed
            if (previousSpeed !== multiplier) {
                this.logMessage(`Battle speed set to ${multiplier}x`, 'info');
            }
            
            // Notify UI components via bridge
            if (window.battleBridge && this.uiMode === "phaser") {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_UI_INTERACTION, {
                    action: 'speed_change',
                    speed: multiplier,
                    previousSpeed: previousSpeed,
                    turnDelay: this.turnDelay,
                    actionDelay: this.actionDelay
                });
            }
        }
    }
    
    /**
     * Log a message to the battle log
     * @param {string} message - The message to log
     * @param {string} type - The type of message (default, info, success, action, error)
     */
    logMessage(message, type = 'default') {
        // Log to console for debugging
        console.log(`[BattleLog ${type}]: ${message}`);
        
        // Dispatch event through BattleBridge if available
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG, {
                    message: message,
                    type: type,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                console.warn('Failed to dispatch battle log event:', error);
            }
        }
        
        // Set default type if not provided or invalid
        const validTypes = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy'];
        if (!validTypes.includes(type)) {
            type = 'default';
        }
        
        // Add to DOM battle log if in DOM mode and battleUI is available
        if (this.uiMode === "dom" && this.battleUI) {
            try {
                this.battleUI.addLogMessage(message, type);
            } catch (error) {
                console.error('Error adding message to battle UI:', error);
            }
        }
        
        // Send event to battle bridge if available
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG, {
                    message: message,
                    type: type,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                console.error('Error dispatching battle log event:', error);
            }
        }
    }
    
    /**
     * End the battle
     * @param {string} result - Battle result ('victory', 'defeat', 'draw')
     */
    endBattle(result) {
        this.battleActive = false;
        this.turnInProgress = false;
        
        // Clear any pending turn timer
        if (this.turnTimer) {
            clearTimeout(this.turnTimer);
            this.turnTimer = null;
        }
        
        // Process battle end passive abilities for all living characters
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            if (character.currentHp > 0) {
                this.processPassiveAbilities('onBattleEnd', character, { result });
            }
        });
        
        // Count defeated characters for detailed result message
        const playerDeadCount = this.playerTeam.filter(char => char.isDead || char.currentHp <= 0).length;
        const enemyDeadCount = this.enemyTeam.filter(char => char.isDead || char.currentHp <= 0).length;
        
        // Log battle end with detailed reason
        switch (result) {
            case 'victory':
                this.logMessage(`\nðŸ† VICTORY! Your team has won the battle! ðŸ†`, 'success');
                this.logMessage(`${enemyDeadCount}/${this.enemyTeam.length} enemy characters defeated.`, 'success');
                if (playerDeadCount > 0) {
                    this.logMessage(`${playerDeadCount}/${this.playerTeam.length} of your characters were lost in battle.`, 'info');
                } else {
                    this.logMessage(`Amazing! All of your characters survived the battle!`, 'success');
                }
                break;
            case 'defeat':
                this.logMessage(`\nðŸ”´ DEFEAT! Your team has been defeated. ðŸ”´`, 'error');
                this.logMessage(`${playerDeadCount}/${this.playerTeam.length} of your characters were defeated.`, 'error');
                if (enemyDeadCount > 0) {
                    this.logMessage(`${enemyDeadCount}/${this.enemyTeam.length} enemy characters were defeated before your loss.`, 'info');
                } else {
                    this.logMessage(`Your team was completely overwhelmed!`, 'error');
                }
                break;
            case 'draw':
                this.logMessage(`\nðŸŒŠ THE BATTLE ENDED IN A DRAW. ðŸŒŠ`, 'info');
                this.logMessage(`All characters on both teams have been defeated!`, 'info');
                break;
            default:
                this.logMessage('The battle has ended.', 'info');
        }
        
        // Show final health summary
        this.logMessage('------ FINAL BATTLE SUMMARY ------', 'info');
        
        // Show player team summary
        this.logMessage('Player Team:', 'info');
        this.playerTeam.forEach(character => {
            const status = character.isDead ? 'ðŸ’€ DEFEATED' : `HP: ${character.currentHp}/${character.stats.hp}`;
            const statusColor = character.isDead ? 'error' : 
                               (character.currentHp < character.stats.hp * 0.3) ? 'error' :
                               (character.currentHp < character.stats.hp * 0.7) ? 'action' : 'success';
            this.logMessage(`  ${character.name}: ${status}`, statusColor);
        });
        
        // Show enemy team summary
        this.logMessage('Enemy Team:', 'info');
        this.enemyTeam.forEach(character => {
            const status = character.isDead ? 'ðŸ’€ DEFEATED' : `HP: ${character.currentHp}/${character.stats.hp}`;
            const statusColor = character.isDead ? 'error' : 
                               (character.currentHp < character.stats.hp * 0.3) ? 'error' :
                               (character.currentHp < character.stats.hp * 0.7) ? 'action' : 'success';
            this.logMessage(`  ${character.name}: ${status}`, statusColor);
        });
        
        this.logMessage('--------------------------------', 'info');
        
        // Show battle result in UI
        if (this.battleUI) {
            setTimeout(() => {
                this.battleUI.showBattleResult(result);
            }, 1000);
        }
    }
    
    /**
     * Log a message to the battle log
     * @param {string} message - Message to log
     * @param {string} type - Message type (default, success, error, etc.)
     */
    logMessage(message, type = 'default') {
        // Log to console
        console.log(`[Battle] ${message}`);
        
        // Log to UI
        if (this.battleUI) {
            this.battleUI.addLogMessage(message, type);
        }
    }
    
    /**
     * Reset character's dead status if they are healed
     * @param {Object} character - Character to check
     */
    /**
     * Reset character's dead status if they are healed
     * @param {Object} character - Character to check
     * @returns {boolean} - True if character was revived, false otherwise
     */
    checkAndResetDeathStatus(character) {
        // If character was marked as dead but now has HP, reset death status
        if (character.isDead && character.currentHp > 0) {
            character.isDead = false;
            // Add team identifier for clarity
            const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
            this.logMessage(`${character.name}${teamIdentifier} has been revived!`, 'success');
            
            // Update UI if present
            if (this.battleUI) {
                this.battleUI.updateCharacterHealth(character, 0, true);
            }
            
            return true; // Character was revived
        }
        
        return false; // No revival occurred
    }
    
    /**
     * Shuffle an array randomly
     * @param {Array} array - The array to shuffle
     * @returns {Array} The shuffled array
     */
    /**
     * Apply direct damage to a target (for passive abilities, reflections, etc.)
     * @param {Object} target - The character taking damage
     * @param {number} amount - Amount of damage to deal
     * @param {Object} source - Character causing the damage (optional)
     * @param {Object} ability - Ability associated with the damage (optional)
     * @param {string} damageType - Type of damage (e.g., 'reflected', 'passive') (optional)
     * @returns {Object} - Result containing the actual damage dealt and if it killed the target
     */
    applyDamage(target, amount, source = null, ability = null, damageType = 'normal', additionalParams = {}) {
        // Validate inputs
        if (!target) {
            console.error(`Invalid target: null in applyDamage`);
            return { damage: 0, killed: false };
        }
        
        if (typeof amount !== 'number' || isNaN(amount) || amount < 0) {
            console.error(`Invalid damage amount: ${amount} (${typeof amount}) for ${target.name}`);
            return { damage: 0, killed: false };
        }
        
        // Validate target health
        if (isNaN(target.currentHp)) {
            console.error(`Target has invalid health: ${target.name}, hp=${target.currentHp}`);
            // Try to recover by resetting health to a valid value
            target.currentHp = target.stats.hp > 0 ? Math.min(target.stats.hp, Math.max(0, target.currentHp || 0)) : 0;
            
            // If still invalid, abort damage
            if (isNaN(target.currentHp)) {
                console.error(`Failed to recover target health, aborting damage`);
                return { damage: 0, killed: false };
            }
        }
        
        // Store previous state to calculate actual damage
        const previousHp = target.currentHp;
        const wasAlreadyDefeated = target.isDead || target.currentHp <= 0;
        
        // Apply damage, ensuring health doesn't go below 0
        target.currentHp = Math.max(0, target.currentHp - amount);
        
        // Calculate actual damage dealt (may be less than amount if target had low HP)
        const actualDamage = previousHp - target.currentHp;
        
        // Add team info to log message for clarity
        const targetTeam = target.team;
        const targetInfo = `${target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;        
        const sourceInfo = source ? `${source.name}${source.team === 'player' ? ' (ally)' : ' (enemy)'}` : 'Effect';
        
        // Format message based on damage source
        let message = '';
        if (source) {
            message = `${targetInfo} takes ${actualDamage} damage from ${sourceInfo}'s ${damageType}! (HP: ${target.currentHp}/${target.stats.hp})`;
        } else {
            message = `${targetInfo} takes ${actualDamage} damage from ${damageType}! (HP: ${target.currentHp}/${target.stats.hp})`;
        }
        this.logMessage(message, 'error');
        
        // Update UI
        if (this.battleUI) {
            this.battleUI.updateCharacterHealth(target, actualDamage, false);
        }
        
        // Check if target was defeated
        let wasKilled = false;
        if (target.currentHp <= 0 && !wasAlreadyDefeated) {
            target.isDead = true;
            this.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error');
            wasKilled = true;
            
            // Trigger onDefeat passive ability
            if (source) {
                this.processPassiveAbilities('onDefeat', target, {
                    killer: source,
                    ability: ability,
                    damageType: damageType,
                    reflectionDepth: additionalParams && additionalParams.reflectionDepth ? additionalParams.reflectionDepth : 0
                });
                
                // Trigger onKill passive ability for the source
                this.processPassiveAbilities('onKill', source, {
                    defeated: target,
                    ability: ability,
                    damageType: damageType,
                    reflectionDepth: additionalParams && additionalParams.reflectionDepth ? additionalParams.reflectionDepth : 0
                });
            }
        }
        
        return {
            damage: actualDamage,
            killed: wasKilled
        };
    }
    /**
    * Apply direct healing to a target (for passive abilities, etc.)
    * @param {Object} target - The character receiving healing
    * @param {number} amount - Amount of healing to apply
    * @param {Object} source - Character causing the healing (optional)
    * @param {Object} ability - Ability associated with the healing (optional)
    * @param {string} healType - Type of healing (e.g., 'passive', 'regen') (optional)
    * @returns {Object} - Result containing the actual healing done and if it revived the target
    */
    applyHealing(target, amount, source = null, ability = null, healType = 'passive') {
    // Validate inputs
    if (!target || !amount || isNaN(amount) || amount <= 0) {
        console.error(`Invalid healing parameters: target=${target?.name || 'null'}, amount=${amount}`);
        return { healing: 0, revived: false };
    }
    
    // Validate target health
    if (isNaN(target.currentHp)) {
        console.error(`Target has invalid health: ${target.name}, hp=${target.currentHp}`);
        // Try to recover by resetting health to a valid value
        target.currentHp = target.currentHp > 0 ? target.currentHp : 0;
        // If still invalid, abort healing
        if (isNaN(target.currentHp)) {
            console.error(`Failed to recover target health, aborting healing`);
            return { healing: 0, revived: false };
        }
    }
    
    // Store previous HP to calculate actual healing done
    const previousHp = target.currentHp;
    const wasDefeated = target.isDead || target.currentHp <= 0;
    
    // Apply healing with validation
    target.currentHp = Math.min(target.stats.hp, target.currentHp + amount);
    
    // Verify resulting health is valid
    if (isNaN(target.currentHp)) {
        console.error(`Healing resulted in invalid health: ${target.name}`);
        // Revert to previous health
        target.currentHp = previousHp;
        return { healing: 0, revived: false };
    }
    
    const actualHealing = target.currentHp - previousHp;
    
    // Log the healing with team identifiers
    const targetTeam = target.team;
    const targetInfo = `${target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;        
    const sourceInfo = source ? `${source.name}${source.team === 'player' ? ' (ally)' : ' (enemy)'}` : 'Effect';
    
    // Format the message based on whether we have a source
    const message = source
    ? `${targetInfo} is healed for ${actualHealing} HP from ${sourceInfo}'s ${healType}! (HP: ${target.currentHp}/${target.stats.hp})`
    : `${targetInfo} is healed for ${actualHealing} HP from ${healType}! (HP: ${target.currentHp}/${target.stats.hp})`;
    
    this.logMessage(message, 'success');
    
    // Update UI
    if (this.battleUI) {
    this.battleUI.updateCharacterHealth(target, actualHealing, true);
    }
    
    // Check if target was revived
    const revived = wasDefeated && this.checkAndResetDeathStatus(target);
    
    // Process passive for healing received
    if (actualHealing > 0) {
    this.processPassiveAbilities('onHealed', target, {
        source: source,
            healAmount: actualHealing,
            ability: ability,
            healType: healType
            });
            
            // If there's a source and it's not self-healing, trigger healing done passive
            if (source && source !== target) {
                this.processPassiveAbilities('onHealingDone', source, {
                    target: target,
                    healAmount: actualHealing,
                    ability: ability,
                    healType: healType
                });
            }
            
            // If character was revived, trigger revival passive
            if (revived) {
                this.processPassiveAbilities('onRevive', target, {
                    reviver: source,
                    ability: ability,
                    healType: healType
                });
            }
        }
        
        return { healing: actualHealing, revived };
    }
    
    applyDamage(target, amount, source = null, ability = null, damageType = 'passive') {
        if (!target || target.isDead || target.currentHp <= 0 || amount <= 0) {
            return { damage: 0, killed: false };
        }
        
        // Store previous HP to calculate actual damage dealt
        const previousHp = target.currentHp;
        
        // Apply damage
        target.currentHp = Math.max(0, target.currentHp - amount);
        const actualDamage = previousHp - target.currentHp;
        
        // Log the damage with team identifiers
        const targetTeam = target.team;
        const targetInfo = `${target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
        const sourceInfo = source ? `${source.name}${source.team === 'player' ? ' (ally)' : ' (enemy)'}` : 'Effect';
        
        // Format the message based on whether we have a source
        const message = source
            ? `${targetInfo} takes ${actualDamage} ${damageType} damage from ${sourceInfo}! (HP: ${target.currentHp}/${target.stats.hp})`
            : `${targetInfo} takes ${actualDamage} ${damageType} damage! (HP: ${target.currentHp}/${target.stats.hp})`;
            
        this.logMessage(message, 'error');
        
        // Update UI
        if (this.battleUI) {
            this.battleUI.updateCharacterHealth(target, actualDamage, false);
        }
        
        // Process passive for damage taken
        if (actualDamage > 0) {
            this.processPassiveAbilities('onDamageTaken', target, {
                source: source,
                damageAmount: actualDamage,
                ability: ability,
                damageType: damageType
            });
        }
        
        // Check if target died
        let killed = false;
        if (target.currentHp <= 0) {
            target.isDead = true;
            target.currentHp = 0; // Ensure HP doesn't go below 0
            killed = true;
            
            // Log defeat
            this.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error');
            
            // Process passive abilities for defeat/kill
            if (source) {
                this.processPassiveAbilities('onKill', source, {
                    defeated: target,
                    ability: ability,
                    damageType: damageType
                });
            }
            
            this.processPassiveAbilities('onDefeat', target, {
                killer: source,
                ability: ability,
                damageType: damageType
            });
        }
        
        return { damage: actualDamage, killed };
    }
    
    /**
     * Get all characters from both teams
     * @returns {Array} Array of all characters in the battle
     */
    getAllCharacters() {
        return [...this.playerTeam, ...this.enemyTeam];
    }
    
    shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
}

// Export for use in other modules
window.BattleManager = BattleManager;

// Debug check for BattleManager
console.log("BattleManager class defined:", typeof BattleManager);
console.log("window.BattleManager assigned:", typeof window.BattleManager);

// Force assignment if needed
if (typeof BattleManager === 'function' && typeof window.BattleManager !== 'function') {
    console.log("Fixing window.BattleManager assignment");
    window.BattleManager = BattleManager;
}


===== FILE: TeamManager.js =====
/**
 * Team Manager
 * Manages team composition and character selection
 */

class TeamManager {
    /**
     * Create a new Team Manager
     */
    constructor() {
        this.availableCharacters = [];
        this.playerTeam = [];
        this.enemyTeam = [];
        this.maxTeamSize = 3;
    }

    /**
     * Set the player's team
     * @param {Array} team - Array of hero objects
     */
    setPlayerTeam(team) {
        this.playerTeam = team;
        console.log('Player team set:', this.playerTeam);
    }

    /**
     * Set a custom enemy team chosen by the player
     * @param {Array} team - Array of enemy characters
     */
    setCustomEnemyTeam(team) {
        // Make deep copies of the characters to avoid modifying original data
        this.enemyTeam = team.map(character => {
            // Create a deep copy
            const characterCopy = JSON.parse(JSON.stringify(character));
            
            // Add a small amount of variance to make battles less predictable
            // This is similar to what we do in generateRandomTeam
            const statVariance = 0.1; // 10% variance - lower than random opponents
            characterCopy.stats.hp = Math.floor(characterCopy.stats.hp * (1 + (Math.random() * statVariance * 2 - statVariance)));
            characterCopy.stats.attack = Math.floor(characterCopy.stats.attack * (1 + (Math.random() * statVariance * 2 - statVariance)));
            characterCopy.stats.defense = Math.floor(characterCopy.stats.defense * (1 + (Math.random() * statVariance * 2 - statVariance)));
            
            return characterCopy;
        });
        
        console.log('Custom enemy team set:', this.enemyTeam);
    }

    /**
     * Generate an enemy team based on battle mode
     * @param {string} mode - Battle mode ('random', 'custom', 'campaign')
     * @returns {Promise} - Promise that resolves when enemy team generation is complete
     */
    async generateEnemyTeam(mode) {
        this.enemyTeam = [];

        let generationPromise;

        switch (mode) {
            case 'random':
                generationPromise = this.generateRandomTeam();
                break;
            case 'custom':
                // Custom teams are now set directly via setCustomEnemyTeam
                // If we reach here, fall back to random (shouldn't happen with UI changes)
                generationPromise = this.generateRandomTeam();
                break;
            case 'campaign':
                // TODO: Implement campaign enemy teams
                generationPromise = this.generateRandomTeam(); // Use random for now
                break;
            default:
                generationPromise = this.generateRandomTeam();
        }

        // Wait for team generation to complete
        await generationPromise;
        
        console.log('Enemy team generation complete:', this.enemyTeam);
        return this.enemyTeam;
    }

    /**
     * Generate a random enemy team
     */
    async generateRandomTeam() {
        try {
            // Always refresh the characters to ensure we have the full pool
            try {
                const response = await fetch('data/characters.json');
                const data = await response.json();
                this.availableCharacters = data.characters;
            } catch (err) {
                console.error('Failed to fetch characters.json:', err);
                // Use hardcoded characters as fallback
                this.availableCharacters = [
                    {
                        id: 4,
                        name: "Vaelgar",
                        type: "dark",
                        role: "Knight",
                        rarity: "Epic",
                        stats: {
                            hp: 120,
                            attack: 18,
                            defense: 12
                        },
                        abilities: [
                            {
                                name: "Shadow Strike",
                                damage: 28,
                                cooldown: 3,
                                isHealing: false,
                                description: "Attacks from the shadows for heavy damage"
                            },
                            {
                                name: "Void Barrier",
                                damage: 20,
                                cooldown: 4,
                                isHealing: true,
                                description: "Creates a barrier of dark energy that absorbs damage"
                            }
                        ]
                    },
                    {
                        id: 3,
                        name: "Sylvanna",
                        type: "nature",
                        role: "Ranger",
                        rarity: "Uncommon",
                        stats: {
                            hp: 90,
                            attack: 15,
                            defense: 15
                        },
                        abilities: [
                            {
                                name: "Vine Whip",
                                damage: 20,
                                cooldown: 2,
                                isHealing: false,
                                description: "Strikes with vines that can ensnare the target"
                            },
                            {
                                name: "Nature's Blessing",
                                damage: 25,
                                cooldown: 4,
                                isHealing: true,
                                description: "Channels the power of nature to heal wounds"
                            }
                        ]
                    }
                ];
            }

            // Clear enemy team
            this.enemyTeam = [];
            
            // Safety check
            if (!this.availableCharacters || this.availableCharacters.length === 0) {
                console.error('No characters available to generate a team');
                return;
            }

            console.log(`Generating random team from ${this.availableCharacters.length} available characters`);

            // Always use max team size (3) for consistent 3v3 battles
            const teamSize = this.maxTeamSize;

            // Select random heroes, with duplicate prevention if possible
            const availableHeroes = [...this.availableCharacters];
            // If we have fewer heroes than needed for a full team, allow duplicates
            const allowDuplicates = availableHeroes.length < teamSize;
            
            for (let i = 0; i < teamSize; i++) {
                // If we run out of unique heroes but still need more, reset the pool
                if (availableHeroes.length === 0) {
                    if (allowDuplicates) {
                        // Reset the available heroes pool to allow duplicates
                        availableHeroes.push(...this.availableCharacters);
                    } else {
                        break;
                    }
                }

                const randomIndex = Math.floor(Math.random() * availableHeroes.length);
                const selectedHero = availableHeroes.splice(randomIndex, 1)[0];
                
                // Create a copy of the hero to avoid modifying the original
                const heroCopy = JSON.parse(JSON.stringify(selectedHero));
                
                // Add some randomness to stats
                const statVariance = 0.2; // 20% variance
                heroCopy.stats.hp = Math.floor(heroCopy.stats.hp * (1 + (Math.random() * statVariance * 2 - statVariance)));
                heroCopy.stats.attack = Math.floor(heroCopy.stats.attack * (1 + (Math.random() * statVariance * 2 - statVariance)));
                heroCopy.stats.defense = Math.floor(heroCopy.stats.defense * (1 + (Math.random() * statVariance * 2 - statVariance)));
                
                this.enemyTeam.push(heroCopy);
            }
            
            // Fallback if no team was generated
            if (this.enemyTeam.length === 0) {
                console.warn('No enemies were generated, using fallback');
                // Add at least one hero as fallback
                const fallbackHero = JSON.parse(JSON.stringify(this.availableCharacters[0]));
                this.enemyTeam.push(fallbackHero);
            }
        } catch (error) {
            console.error('Error generating random team:', error);
            // Use a fallback enemy
            this.enemyTeam = [
                {
                    id: 4,
                    name: "Vaelgar",
                    type: "dark",
                    role: "Knight",
                    stats: {
                        hp: 120,
                        attack: 18,
                        defense: 12
                    },
                    abilities: [
                        {
                            name: "Shadow Strike",
                            damage: 28,
                            cooldown: 3,
                            isHealing: false,
                            description: "Attacks from the shadows for heavy damage"
                        }
                    ]
                }
            ];
        }
        
        console.log('Generated enemy team:', this.enemyTeam);
    }
}


===== FILE: PhaserSoundManager.js =====
/**
 * PhaserSoundManager.js
 * 
 * Manages audio for the Phaser-based battle system. Handles loading,
 * playing, and configuring sounds based on game events.
 */

class PhaserSoundManager {
    constructor(scene) {
        // Check for existing instance
        if (scene.soundManager) {
            console.warn('A sound manager already exists for this scene. Returning existing instance.');
            return scene.soundManager;
        }

        this.scene = scene;
        this.sounds = {};
        this.categories = {
            attack: [], // slap sounds
            ability: [], // splash sounds
            movement: [], // woosh sounds
            ui: [] // UI sounds
        };
        this.config = {
            masterVolume: 0.8,  // Default at 80%
            muted: false,
            categoryVolumes: {
                attack: 0.9,
                ability: 1.0,
                movement: 0.7,
                ui: 0.6
            }
        };
        
        // Initialize the sound manager
        this.initialize();
    }
    
    /**
     * Initialize the sound manager
     */
    initialize() {
        console.log('Initializing Phaser Sound Manager');
        
        // Load default sounds if not already loaded
        this.loadDefaultSounds();
        
        // Set up event listeners
        this.setupEventListeners();
    }
    
    /**
     * Load default battle sounds
     */
    loadDefaultSounds() {

===== FILE: BattleBridge.js =====
/**
 * BattleBridge.js
 * Handles communication between BattleManager and Phaser Battle Scene
 * 
 * Version 0.5.1.2d - 2025-05-04
 */

class BattleBridge {
    constructor() {
        this.battleManager = null;
        this.battleScene = null;
        
        // Event listeners for all battle events
        this.eventListeners = {};
        
        // Define all event types
        this.eventTypes = {
            BATTLE_INITIALIZED: 'battle_initialized',
            BATTLE_STARTED: 'battle_started',
            BATTLE_ENDED: 'battle_ended',
            TURN_STARTED: 'turn_started',
            TURN_ENDED: 'turn_ended',
            CHARACTER_ACTION: 'character_action',
            CHARACTER_DAMAGED: 'character_damaged',
            CHARACTER_HEALED: 'character_healed',
            CHARACTER_DEFEATED: 'character_defeated',
            STATUS_EFFECT_APPLIED: 'status_effect_applied',
            STATUS_EFFECT_REMOVED: 'status_effect_removed',
            ABILITY_USED: 'ability_used',
            PASSIVE_TRIGGERED: 'passive_triggered',
            BATTLE_UI_INTERACTION: 'battle_ui_interaction',
            BATTLE_LOG: 'battle_log' // Event type for battle log messages
        };
        
        console.log('BattleBridge: Constructor called, registering global class');
    }
    
    /**
     * Initialize the bridge with necessary references
     * @param {Object} battleManager - The BattleManager instance
     * @param {Object} battleScene - The Phaser BattleScene
     */
    initialize(battleManager, battleScene) {
        console.log('BattleBridge: Initializing...');
        
        this.battleManager = battleManager;
        this.battleScene = battleScene;
        
        // Set UI mode to phaser
        if (this.battleManager) {
            console.log('BattleBridge: Setting battleManager.uiMode to "phaser"');
            this.battleManager.uiMode = "phaser";
        } else {
            console.warn('BattleBridge: battleManager is null, cannot set uiMode');
        }
        
        // Set up listeners
        this.setupEventListeners();
        
        // Patch BattleManager to emit events
        this.patchBattleManager();
        
        console.log('BattleBridge: Initialized successfully');
        
        // Dispatch initialization event
        this.dispatchEvent(this.eventTypes.BATTLE_INITIALIZED, {
            battleManager,
            battleScene
        });
        
        return this;
    }
    
    /**
     * Set up event listeners for the bridge
     */
    setupEventListeners() {
        // Initialize event listeners for all event types
        Object.values(this.eventTypes).forEach(type => {
            this.eventListeners[type] = [];
        });
        
        console.log('BattleBridge: Event listeners initialized');
    }
    
    /**
     * Add an event listener
     * @param {string} eventType - The event type to listen for
     * @param {Function} callback - The callback function
     */
    addEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) {
            console.warn(`BattleBridge: Unknown event type "${eventType}"`);
            this.eventListeners[eventType] = [];
        }
        
        this.eventListeners[eventType].push(callback);
        return this;
    }
    
    /**
     * Remove an event listener
     * @param {string} eventType - The event type
     * @param {Function} callback - The callback function to remove
     */
    removeEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) return this;
        
        const index = this.eventListeners[eventType].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[eventType].splice(index, 1);
        }
        
        return this;
    }
    
    /**
     * Dispatch an event to all listeners
     * @param {string} eventType - The event type to dispatch
     * @param {Object} data - The event data
     */
    dispatchEvent(eventType, data) {
        console.log(`BattleBridge: Dispatching event ${eventType}`, data);
        
        if (!this.eventListeners[eventType]) {
            console.warn(`BattleBridge: No listeners for event "${eventType}"`);
            return;
        }
        
        // Log listener count for debugging
        console.log(`BattleBridge: Found ${this.eventListeners[eventType].length} listeners for ${eventType}`);
        
        // Add event type to data for reference
        const eventData = {
            ...data,
            type: eventType,
            timestamp: Date.now()
        };
        
        try {
            this.eventListeners[eventType].forEach((callback, index) => {
                try {
                    console.log(`BattleBridge: Calling listener ${index} for ${eventType}`);
                    callback(eventData);
                    console.log(`BattleBridge: Listener ${index} completed successfully`);
                } catch (error) {
                    console.error(`BattleBridge: Error in event listener ${index} for "${eventType}":`, error);
                }
            });
        } catch (error) {
            console.error(`BattleBridge: Error dispatching event "${eventType}":`, error);
        }
    }
    
    /**
     * Patch the BattleManager methods to emit events
     */
    patchBattleManager() {
        if (!this.battleManager) {
            console.error('BattleBridge: No BattleManager to patch');
            return this;
        }
        
        try {
            console.log('BattleBridge: Patching BattleManager methods...');
            
            // Store original methods
            const originalStartBattle = this.battleManager.startBattle;
            const originalEndBattle = this.battleManager.endBattle;
            const originalStartNextTurn = this.battleManager.startNextTurn;  // UPDATED: correct method name
            const originalEndTurn = this.battleManager.endTurn;
            const originalGenerateCharacterAction = this.battleManager.generateCharacterAction;
            const originalProcessAbility = this.battleManager.processAbility;
            const originalApplyDamage = this.battleManager.applyDamage;
            const originalApplyHealing = this.battleManager.applyHealing;
            const originalAddStatusEffect = this.battleManager.addStatusEffect;
            const originalRemoveStatusEffect = this.battleManager.removeStatusEffect;
            
            // Store 'this' reference for use in patched methods
            const self = this;
            
            // Patch startBattle
            if (originalStartBattle) {
                this.battleManager.startBattle = function() {
                    const result = originalStartBattle.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.BATTLE_STARTED, {
                        playerTeam: this.playerTeam,
                        enemyTeam: this.enemyTeam
                    });
                    return result;
                };
            }
            
            // Patch endBattle
            if (originalEndBattle) {
                this.battleManager.endBattle = function() {
                    const result = originalEndBattle.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.BATTLE_ENDED, {
                        winner: this.winner,
                        playerTeam: this.playerTeam,
                        enemyTeam: this.enemyTeam
                    });
                    return result;
                };
            }
            
            // Patch startNextTurn
            if (originalStartNextTurn) {
                this.battleManager.startNextTurn = function() {
                    console.log('BattleBridge: startNextTurn patched method called');
                    const result = originalStartNextTurn.apply(this, arguments);
                    // Get the active character (often the first character in the action queue)
                    const currentChar = this.actionQueue && this.actionQueue.length > 0 ? 
                                        this.actionQueue[0]?.actor : null;
                    console.log('BattleBridge: Current character for turn:', currentChar?.name || 'Unknown');
                    console.log('[BattleBridge Patch] Preparing to dispatch TURN_STARTED event.');
                    self.dispatchEvent(self.eventTypes.TURN_STARTED, {
                        character: currentChar,  // Use 'character' as the property name for consistency
                        currentCharacter: currentChar,  // Keep 'currentCharacter' for backward compatibility
                        turnNumber: this.currentTurn
                    });
                    return result;
                };
            }
            
            // Patch endTurn
            if (originalEndTurn) {
                this.battleManager.endTurn = function() {
                    const result = originalEndTurn.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.TURN_ENDED, {
                        currentCharacter: this.currentCharacter,
                        turnNumber: this.turnNumber
                    });
                    return result;
                };
            }
            
            // Patch generateCharacterAction
            if (originalGenerateCharacterAction) {
                this.battleManager.generateCharacterAction = function(character) {
                    const action = originalGenerateCharacterAction.apply(this, arguments);
                    // Removed CHARACTER_ACTION dispatch from here - it should only happen during execution, not generation
                    // This prevents simultaneous auto-attack indicators at battle start
                    return action;
                };
            }
            
            // Patch processAbility
            if (originalProcessAbility) {
                this.battleManager.processAbility = function(character, ability, targets) {
                    console.log('BattleBridge: processAbility patched method called with:', character?.name, ability?.name);
                    const result = originalProcessAbility.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.ABILITY_USED, {
                        source: character,  // Using 'source' for consistency
                        ability,
                        targets,
                        result
                    });
                    return result;
                };
            }
            
            // Patch applyDamage
            if (originalApplyDamage) {
                this.battleManager.applyDamage = function(target, amount, source) {
                    console.log('BattleBridge: applyDamage patched method called with:', target?.name, amount, source?.name);
                    const result = originalApplyDamage.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.CHARACTER_DAMAGED, {
                        target,
                        amount,
                        source,
                        result,
                        newHealth: target.currentHp
                    });
                    
                    // Check for defeat
                    if (target.currentHp <= 0) {  // Fixed: checking currentHp instead of stats.hp
                        self.dispatchEvent(self.eventTypes.CHARACTER_DEFEATED, {
                            character: target,
                            source
                        });
                    }
                    
                    return result;
                };
            }
            
            // Patch applyHealing
            if (originalApplyHealing) {
                this.battleManager.applyHealing = function(target, amount, source) {
                    console.log('BattleBridge: applyHealing patched method called with:', target?.name, amount, source?.name);
                    const result = originalApplyHealing.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.CHARACTER_HEALED, {
                        target,
                        amount,
                        source,
                        result,
                        newHealth: target.currentHp
                    });
                    return result;
                };
            }
            
            // Patch addStatusEffect
            if (originalAddStatusEffect) {
                this.battleManager.addStatusEffect = function(target, effect, source) {
                    const result = originalAddStatusEffect.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.STATUS_EFFECT_APPLIED, {
                        target,
                        effect,
                        source,
                        result
                    });
                    return result;
                };
            }
            
            // Patch removeStatusEffect
            if (originalRemoveStatusEffect) {
                this.battleManager.removeStatusEffect = function(target, effectId) {
                    const result = originalRemoveStatusEffect.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.STATUS_EFFECT_REMOVED, {
                        target,
                        effectId,
                        result
                    });
                    return result;
                };
            }
            
            // Add patch for passive triggers if the method exists
            if (this.battleManager.triggerPassive) {
                const originalTriggerPassive = this.battleManager.triggerPassive;
                this.battleManager.triggerPassive = function(character, triggerType, data) {
                    const result = originalTriggerPassive.apply(this, arguments);
                    if (result && result.triggered) {
                        self.dispatchEvent(self.eventTypes.PASSIVE_TRIGGERED, {
                            character,
                            triggerType,
                            passiveData: data,
                            result
                        });
                    }
                    return result;
                };
            }
            
            // Patch applyActionEffect which is the main function that applies damage/healing
            const originalApplyActionEffect = this.battleManager.applyActionEffect;
            if (originalApplyActionEffect) {
                this.battleManager.applyActionEffect = function(action) {
                    console.log('BattleBridge: applyActionEffect patched method called for:', 
                               action?.actor?.name, 'targeting', action?.target?.name);
                    
                    // Dispatch CHARACTER_ACTION event before applying the effect
                    if (action.actor && action.actionType) {
                        console.log(`BattleBridge: Dispatching CHARACTER_ACTION event for ${action.actor.name} performing ${action.actionType}`);
                        self.dispatchEvent(self.eventTypes.CHARACTER_ACTION, {
                            character: action.actor,
                            action: {
                                type: action.actionType,
                                name: action.abilityName || action.actionType,
                                abilityName: action.abilityName, // Include raw ability name
                                target: action.target
                            }
                        });
                    }
                    
                    // Store pre-action health for calculating actual change
                    const targetPreHealth = action.target ? action.target.currentHp : 0;
                    
                    // Apply the original effect
                    const result = originalApplyActionEffect.apply(this, arguments);
                    
                    // Calculate actual health change for direct targets
                    if (action.target) {
                        const targetPostHealth = action.target.currentHp;
                        const healthChange = targetPostHealth - targetPreHealth;
                        
                        // Dispatch appropriate event based on damage or healing
                        if (healthChange < 0) {
                            // Damage event
                            console.log(`BattleBridge: Dispatching CHARACTER_DAMAGED event for ${action.target.name} with new health ${targetPostHealth}`);
                            self.dispatchEvent(self.eventTypes.CHARACTER_DAMAGED, {
                                character: action.target, // IMPORTANT: Use 'character' instead of 'target' to match event handler
                                target: action.target,    // Keep 'target' for backward compatibility
                                amount: Math.abs(healthChange),
                                source: action.actor,
                                ability: action.ability,
                                newHealth: targetPostHealth
                            });
                        } else if (healthChange > 0) {
                            // Healing event
                            console.log(`BattleBridge: Dispatching CHARACTER_HEALED event for ${action.target.name} with new health ${targetPostHealth}`);
                            self.dispatchEvent(self.eventTypes.CHARACTER_HEALED, {
                                character: action.target, // IMPORTANT: Use 'character' instead of 'target' to match event handler
                                target: action.target,    // Keep 'target' for backward compatibility
                                amount: healthChange,
                                source: action.actor,
                                ability: action.ability,
                                newHealth: targetPostHealth
                            });
                        }
                    }
                    
                    return result;
                };
                console.log('BattleBridge: Successfully patched applyActionEffect method');
            } else {
                console.warn('BattleBridge: Could not patch applyActionEffect, method not found');
            }
            
            console.log('BattleBridge: BattleManager successfully patched');

            // Also patch autoAttack to dispatch CHARACTER_ACTION
            if (this.battleManager.autoAttack) {
                const originalAutoAttack = this.battleManager.autoAttack;
                this.battleManager.autoAttack = function(attacker, target) {
                    console.log('BattleBridge: autoAttack patched method called with:', attacker?.name, target?.name);
                    
                    // Dispatch CHARACTER_ACTION event before applying the auto attack
                    self.dispatchEvent(self.eventTypes.CHARACTER_ACTION, {
                        character: attacker,
                        action: {
                            type: 'autoAttack',
                            name: 'Auto Attack',
                            target: target
                        }
                    });
                    
                    return originalAutoAttack.apply(this, arguments);
                };
                console.log('BattleBridge: Successfully patched autoAttack method');
            } else {
                console.warn('BattleBridge: Could not patch autoAttack, method not found');
            }
            
            // Also patch executeNextAction to dispatch TURN_STARTED for each character's action
            if (this.battleManager.executeNextAction) {
                const originalExecuteNextAction = this.battleManager.executeNextAction;
                this.battleManager.executeNextAction = function() {
                    console.log('BattleBridge: executeNextAction patched method called');
                    
                    // If there are actions in the queue, dispatch TURN_STARTED for the next action
                    if (this.actionQueue && this.actionQueue.length > 0) {
                        const nextAction = this.actionQueue[0];
                        console.log('BattleBridge: Next action is for character:', nextAction?.actor?.name);
                        console.log('[BattleBridge Patch] Preparing to dispatch TURN_STARTED event for individual character action.');
                        
                        // Dispatch TURN_STARTED event for this character's action
                        self.dispatchEvent(self.eventTypes.TURN_STARTED, {
                            character: nextAction.actor,
                            currentCharacter: nextAction.actor,
                            turnNumber: this.currentTurn
                        });
                    }
                    
                    // Call original method
                    return originalExecuteNextAction.apply(this, arguments);
                };
                console.log('BattleBridge: Successfully patched executeNextAction method');
            } else {
                console.warn('BattleBridge: Could not patch executeNextAction, method not found');
            }
        } catch (error) {
            console.error('BattleBridge: Error patching BattleManager:', error);
        }
        
        return this;
    }
    
    /**
     * Get a reference to the player team
     * @returns {Array} The player team array
     */
    getPlayerTeam() {
        return this.battleManager ? this.battleManager.playerTeam : [];
    }
    
    /**
     * Get a reference to the enemy team
     * @returns {Array} The enemy team array
     */
    getEnemyTeam() {
        return this.battleManager ? this.battleManager.enemyTeam : [];
    }
    
    /**
     * Start the battle
     * This initiates the battle flow in BattleManager
     * @param {Array} playerTeam - Optional player team data
     * @param {Array} enemyTeam - Optional enemy team data
     */
    startBattle(playerTeam, enemyTeam) {
        if (!this.battleManager) {
            console.error('BattleBridge: No BattleManager available to start battle');
            return;
        }
        
        console.log('BattleBridge: Starting battle via BattleManager');
        console.log(`BattleBridge: Using provided teams - Player: ${playerTeam?.length || 0} characters, Enemy: ${enemyTeam?.length || 0} characters`);
        
        try {
            // Start the battle via BattleManager with team data
            this.battleManager.startBattle(playerTeam, enemyTeam);
            
            // Dispatch UI interaction event
            this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { 
                action: 'start_battle',
                source: 'bridge',
                playerTeamSize: playerTeam?.length || 0,
                enemyTeamSize: enemyTeam?.length || 0
            });
        } catch (error) {
            console.error('BattleBridge: Error starting battle:', error);
        }
    }

    /**
     * Request a character to take their turn
     * @param {Object} character - The character to act
     */
    requestCharacterAction(character) {
        if (!this.battleManager) return;
        
        this.battleManager.processCharacterTurn(character);
    }
    
    /**
     * Request the battle to pause
     */
    requestPause() {
        if (!this.battleManager) return;
        
        this.battleManager.pauseBattle();
        this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { action: 'pause' });
    }
    
    /**
     * Request the battle to resume
     */
    requestResume() {
        if (!this.battleManager) return;
        
        this.battleManager.resumeBattle();
        this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { action: 'resume' });
    }
    
    /**
     * Set battle speed in the battle manager
     * @param {number} speed - The battle speed multiplier
     * @returns {boolean} - Success status
     */
    setBattleSpeed(speed) {
        if (this.battleManager && this.battleManager.setSpeed) {
            this.battleManager.setSpeed(speed);
            return true;
        } else {
            console.error('BattleBridge: battleManager.setSpeed method not found');
            return false;
        }
    }
    
    /**
     * Request to change battle speed
     * @param {number} speed - The battle speed multiplier
     */
    requestSpeedChange(speed) {
        if (!this.battleManager) return;
        
        // Call the correct method
        const success = this.setBattleSpeed(speed);
        
        // Always dispatch the event, even if method call failed
        this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { 
            action: 'speed_change', 
            speed,
            success
        });
    }
}

// Ensure the class is globally accessible
window.BattleBridge = BattleBridge;

// Log that the class has been defined
console.log('BattleBridge.js: Class definition loaded and exported to window.BattleBridge');

// Create an immediate self-check function that logs whether the class is properly exposed
(function checkBattleBridgeExport() {
    // Delay check slightly to allow for script processing
    setTimeout(function() {
        if (typeof window.BattleBridge === 'function') {
            console.log('BattleBridge.js: Successfully verified global class export');
        } else {
            console.error('BattleBridge.js: Class export failed! window.BattleBridge is not a function');
        }
    }, 0);
})();

===== FILE: BattleBridgeInit.js =====
/**
 * BattleBridgeInit.js
 * Creates and initializes the BattleBridge instance
 * 
 * This script ensures there's a global instance of BattleBridge available
 * for the Battle Scene to use (separate from the BattleBridge class itself).
 * 
 * Version 0.5.1.2d - 2025-05-04
 */

(function() {
    // Create a fallback BattleBridge class if the real one isn't loaded
    function createFallbackBattleBridge() {
        console.warn('BattleBridgeInit: Creating a fallback BattleBridge class because the real one was not found');
        
        // Define a minimal BattleBridge implementation
        class FallbackBattleBridge {
            constructor() {
                this.battleManager = null;
                this.battleScene = null;
                this.eventListeners = {};
                
                // Define all event types to match the real implementation
                this.eventTypes = {
                    BATTLE_INITIALIZED: 'battle_initialized',
                    BATTLE_STARTED: 'battle_started',
                    BATTLE_ENDED: 'battle_ended',
                    TURN_STARTED: 'turn_started',
                    TURN_ENDED: 'turn_ended',
                    CHARACTER_ACTION: 'character_action',
                    CHARACTER_DAMAGED: 'character_damaged',
                    CHARACTER_HEALED: 'character_healed',
                    CHARACTER_DEFEATED: 'character_defeated',
                    STATUS_EFFECT_APPLIED: 'status_effect_applied',
                    STATUS_EFFECT_REMOVED: 'status_effect_removed',
                    ABILITY_USED: 'ability_used',
                    PASSIVE_TRIGGERED: 'passive_triggered',
                    BATTLE_UI_INTERACTION: 'battle_ui_interaction',
                    BATTLE_LOG: 'battle_log'
                };
                
                console.warn('FallbackBattleBridge: Created stub implementation with basic functionality');
            }
            
            initialize(battleManager, battleScene) {
                console.warn('FallbackBattleBridge: initialize called (stub implementation)');
                this.battleManager = battleManager;
                this.battleScene = battleScene;
                this.setupEventListeners();
                return this;
            }
            
            setupEventListeners() {
                Object.values(this.eventTypes).forEach(type => {
                    this.eventListeners[type] = [];
                });
                console.log('FallbackBattleBridge: Event listeners initialized');
            }
            
            addEventListener(eventType, callback) {
                if (!this.eventListeners[eventType]) {
                    this.eventListeners[eventType] = [];
                }
                this.eventListeners[eventType].push(callback);
                return this;
            }
            
            removeEventListener(eventType, callback) {
                if (!this.eventListeners[eventType]) return this;
                
                const index = this.eventListeners[eventType].indexOf(callback);
                if (index !== -1) {
                    this.eventListeners[eventType].splice(index, 1);
                }
                return this;
            }
            
            dispatchEvent(eventType, data) {
                console.log(`FallbackBattleBridge: Dispatching event ${eventType}`, data);
                
                if (!this.eventListeners[eventType]) {
                    return;
                }
                
                const eventData = {
                    ...data,
                    type: eventType,
                    timestamp: Date.now()
                };
                
                try {
                    this.eventListeners[eventType].forEach(callback => {
                        try {
                            callback(eventData);
                        } catch (error) {
                            console.error(`FallbackBattleBridge: Error in event listener for "${eventType}":`, error);
                        }
                    });
                } catch (error) {
                    console.error(`FallbackBattleBridge: Error dispatching event "${eventType}":`, error);
                }
            }
            
            patchBattleManager() {
                console.warn('FallbackBattleBridge: patchBattleManager called (stub implementation)');
                return this;
            }
            
            getPlayerTeam() {
                return this.battleManager ? this.battleManager.playerTeam : [];
            }
            
            getEnemyTeam() {
                return this.battleManager ? this.battleManager.enemyTeam : [];
            }
            
            startBattle(playerTeam, enemyTeam) {
                console.warn('FallbackBattleBridge: startBattle called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.startBattle(playerTeam, enemyTeam);
                }
            }
            
            requestCharacterAction(character) {
                console.warn('FallbackBattleBridge: requestCharacterAction called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.processCharacterTurn(character);
                }
            }
            
            requestPause() {
                console.warn('FallbackBattleBridge: requestPause called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.pauseBattle();
                }
            }
            
            requestResume() {
                console.warn('FallbackBattleBridge: requestResume called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.resumeBattle();
                }
            }
            
            setBattleSpeed(speed) {
                console.warn('FallbackBattleBridge: setBattleSpeed called (stub implementation)');
                if (this.battleManager && this.battleManager.setSpeed) {
                    this.battleManager.setSpeed(speed);
                    return true;
                }
                return false;
            }
            
            requestSpeedChange(speed) {
                console.warn('FallbackBattleBridge: requestSpeedChange called (stub implementation)');
                const success = this.setBattleSpeed(speed);
                this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { 
                    action: 'speed_change', 
                    speed,
                    success
                });
            }
        }
        
        // Register the fallback class globally
        window.BattleBridge = FallbackBattleBridge;
        return FallbackBattleBridge;
    }

    // Create the global accessor function
    window.getBattleBridge = function() {
        // Create instance if it doesn't exist
        if (typeof window.battleBridge === 'undefined' || window.battleBridge === null) {
            initBattleBridge();
        }
        return window.battleBridge;
    };

    // Initialize the battle bridge
    function initBattleBridge() {
        console.log('BattleBridgeInit: Checking for BattleBridge class...');
        
        // Check if the BattleBridge class is available
        let BattleBridgeClass = window.BattleBridge;
        
        // If not, create a fallback implementation
        if (typeof BattleBridgeClass !== 'function') {
            console.warn('BattleBridgeInit: BattleBridge class not found! Creating fallback implementation');
            
            // Try to load the script dynamically if possible
            const scriptElement = document.createElement('script');
            scriptElement.src = 'js/phaser/bridge/BattleBridge.js';
            scriptElement.async = false;
            document.head.appendChild(scriptElement);
            
            // Even if we're loading it, we need a fallback right now
            BattleBridgeClass = createFallbackBattleBridge();
        }
        
        try {
            // Create instance of BattleBridge class
            const battleBridge = new BattleBridgeClass();
            
            // Make it globally available with lowercase 'b' (instance)
            // The class is still available at window.BattleBridge (uppercase 'B')
            window.battleBridge = battleBridge;
            
            // Don't initialize immediately - we'll do this when both BattleManager and BattleScene are available
            // Define function for delayed initialization from BattleScene
            window.initializeBattleBridge = function(battleManager, battleScene) {
                console.log('BattleBridgeInit: Delayed initialization with BattleManager and BattleScene');
            if (typeof window.battleBridge.initialize === 'function') {
                window.battleBridge.initialize(battleManager, battleScene);
                return true;
            }
            return false;
        };
            
            console.log('BattleBridgeInit: BattleBridge instance created and assigned to window.battleBridge');
            
            // Return the instance
            return battleBridge;
        } catch (error) {
            console.error('BattleBridgeInit: Error creating BattleBridge instance:', error);
            
            // Try again with fallback as last resort
            try {
                const fallbackClass = createFallbackBattleBridge();
                const fallbackInstance = new fallbackClass();
                window.battleBridge = fallbackInstance;
                console.warn('BattleBridgeInit: Created fallback instance as emergency recovery');
                return fallbackInstance;
            } catch (fallbackError) {
                console.error('BattleBridgeInit: Even fallback creation failed:', fallbackError);
                return null;
            }
        }
    }

    // Run initialization immediately
    initBattleBridge();
    
    // Create a backup of our key battle bridge globals to prevent overwriting
    // Uses Object.defineProperty to protect our getBattleBridge function
    (function protectBattleBridgeGlobals() {
        // Store backup references
        const battleBridgeClass = window.BattleBridge;
        const battleBridgeInstance = window.battleBridge;
        const battleBridgeAccessor = window.getBattleBridge;
        
        // Make getBattleBridge write-protected
        try {
            Object.defineProperty(window, 'getBattleBridge', {
                enumerable: true,
                configurable: false,  // Cannot be deleted or redefined
                get: function() { return battleBridgeAccessor; }
            });
            console.log('BattleBridgeInit: Protected getBattleBridge function from overwriting');
        } catch(e) {
            console.error('BattleBridgeInit: Could not protect getBattleBridge:', e);
        }
        
        // Create restoration function that can be called later if needed
        window._restoreBattleBridge = function() {
            console.log('BattleBridgeInit: Restoring original BattleBridge components');
            window.BattleBridge = battleBridgeClass;
            window.battleBridge = battleBridgeInstance;
            return true;
        };
    })();
    
    // Also initialize on DOMContentLoaded, as a fallback
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof window.battleBridge === 'undefined' || window.battleBridge === null) {
            console.log('BattleBridgeInit: No bridge found at DOMContentLoaded, initializing now...');
            initBattleBridge();
        }
    });
    
    // Check script loading status and dependencies
    function checkScriptLoadStatus() {
        console.log('BattleBridgeInit: Checking script load status...');
        const scripts = document.querySelectorAll('script');
        const loadedScripts = [];
        
        scripts.forEach(script => {
            if (script.src) {
                const scriptName = script.src.split('/').pop();
                loadedScripts.push(`${scriptName} (${script.async ? 'async' : 'sync'})`);
            }
        });
        
        console.log('Loaded scripts:', loadedScripts.join(', '));
        console.log('BattleBridge class available:', typeof window.BattleBridge === 'function');
        console.log('battleBridge instance available:', typeof window.battleBridge !== 'undefined');
    }
    
    // Run status check after a delay to allow other scripts to load
    setTimeout(checkScriptLoadStatus, 1000);
    
    console.log('BattleBridgeInit: Setup complete. Use window.getBattleBridge() to access the bridge instance.');
})();

===== FILE: BattleLogTester.js =====
/**
 * BattleLogTester.js
 * Utility for testing the Battle Log functionality
 */

// Create a global testing utility
window.testBattleLog = function(message, type = 'info') {
    console.log(`Sending test message to battle log: ${message}`);
    
    if (window.battleBridge) {
        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG, {
            message: message,
            type: type
        });
        return true;
    } else {
        console.error('BattleBridge not available for testing');
        return false;
    }
};

// Create a function to test direct message addition
window.addDirectBattleLogMessage = function(message, type = 'info') {
    console.log(`Adding message directly to battle log: ${message}`);
    
    if (window.battleLogPanel) {
        window.battleLogPanel.addMessage(message, type);
        return true;
    } else {
        console.error('Battle log panel not available for direct message');
        return false;
    }
};

// Create a function to test multiple message types
window.testAllMessageTypes = function() {
    const types = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy'];
    
    types.forEach(type => {
        window.testBattleLog(`Test message with type: ${type}`, type);
    });
    
    return 'All message types tested';
};

console.log('Battle Log testing utilities loaded.');
console.log('Use window.testBattleLog("message", "type") to test via BattleBridge');
console.log('Use window.addDirectBattleLogMessage("message", "type") to test direct addition');
console.log('Use window.testAllMessageTypes() to test all message types');


===== FILE: ActionIndicator.js =====
/**
 * ActionIndicator.js
 * A component for displaying floating action text above characters during battle.
 * Shows what action a character is currently performing (auto attack, abilities, etc.)
 */
class ActionIndicator {
    /**
     * Create a new ActionIndicator
     * @param {Phaser.Scene} scene - The scene this indicator belongs to
     * @param {CharacterSprite} parent - The character sprite this indicator is attached to
     */
    constructor(scene, parent) {
        this.scene = scene;
        this.parent = parent;
        this.text = null;
        this.timeline = null;
        this.isAnimating = false;
        
        this.initialize();
    }
    
    /**
     * Initialize the text object with default styling
     */
    initialize() {
        // Create text with shadow for better readability
        this.text = this.scene.add.text(0, 0, '', {
            fontFamily: 'Arial',
            fontSize: '14px',
            color: '#ffffff',
            align: 'center',
            stroke: '#000000',
            strokeThickness: 3,
            shadow: {
                offsetX: 2,
                offsetY: 2,
                color: '#000000',
                blur: 2,
                stroke: true,
                fill: true
            }
        });
        
        // Set origin to center of text for better positioning
        this.text.setOrigin(0.5, 0.5);
        
        // Start invisible
        this.text.setAlpha(0);
        
        // Add to the parent's container if it exists, otherwise directly to scene
        if (this.parent.container) {
            this.parent.container.add(this.text);
        } else {
            // Position relative to parent manually
            this.updatePosition();
        }
    }
    
    /**
     * Update the indicator position relative to parent
     */
    updatePosition() {
        if (!this.parent || !this.text) return;
        
        // Position above the character's head
        const xPos = this.parent.container ? 0 : this.parent.x;
        const yPos = this.parent.container ? -60 : (this.parent.y - 60);
        
        this.text.setPosition(xPos, yPos);
    }
    
    /**
     * Show action text with animation
     * @param {string} actionText - The text to display
     * @param {object} options - Optional configuration for the animation
     */
    showAction(actionText, options = {}) {
        // Default options
        const config = {
            color: '#ffffff', // default white
            duration: 1500,   // how long to display
            rise: 20,         // how far it rises during animation
            ...options        // override with any provided options
        };
        
        // Cancel any existing animation
        if (this.timeline) {
            this.timeline.stop();
            this.timeline.destroy();
        }
        
        // Update text and color
        this.text.setText(actionText);
        this.text.setColor(config.color);
        
        // Update position before animation
        this.updatePosition();
        
        // Store original y position
        const startY = this.text.y;
        
        // Create animation timeline
        this.timeline = this.scene.tweens.createTimeline();
        
        // Add fade in while rising
        this.timeline.add({
            targets: this.text,
            alpha: 1,
            y: startY - (config.rise / 2),
            duration: 300,
            ease: 'Power1'
        });
        
        // Add hold phase
        this.timeline.add({
            targets: this.text,
            alpha: 1,
            duration: config.duration - 600, // Subtract fade in/out time
            hold: config.duration - 600,
            onStart: () => {
                this.isAnimating = true;
            }
        });
        
        // Add fade out while continuing to rise
        this.timeline.add({
            targets: this.text,
            alpha: 0,
            y: startY - config.rise,
            duration: 300,
            ease: 'Power1',
            onComplete: () => {
                this.isAnimating = false;
            }
        });
        
        // Start the animation
        this.timeline.play();
    }
    
    /**
     * Show auto attack action
     */
    showAutoAttack() {
        this.showAction('Auto Attack', {
            color: '#f0f0f0' // Light grey color
        });
    }
    
    /**
     * Show ability action
     * @param {string} abilityName - The name of the ability
     */
    showAbility(abilityName) {
        this.showAction(`Ability: ${abilityName}`, {
            color: '#42f5a7' // Light green color for abilities
        });
    }
    
    /**
     * Show status effect action (like applying a buff/debuff)
     * @param {string} statusName - The name of the status effect
     */
    showStatusEffect(statusName) {
        this.showAction(`Status: ${statusName}`, {
            color: '#f5d142' // Gold color for status effects
        });
    }
    
    /**
     * Hide the action indicator immediately
     */
    hide() {
        if (this.timeline) {
            this.timeline.stop();
            this.timeline.destroy();
            this.timeline = null;
        }
        this.text.setAlpha(0);
        this.isAnimating = false;
    }
    
    /**
     * Cleanup resources
     */
    destroy() {
        this.hide();
        if (this.text) {
            this.text.destroy();
            this.text = null;
        }
        this.parent = null;
        this.scene = null;
    }
}

// Make the class available globally
window.ActionIndicator = ActionIndicator;


===== FILE: BattleControlPanel.js =====
/**
 * BattleControlPanel.js
 * UI component for controlling battle flow in the Phaser Battle Scene
 * 
 * @version 0.5.0.9
 */

class BattleControlPanel extends Phaser.GameObjects.Container {
    constructor(scene, x, y) {
        super(scene, x, y);
        
        // Track panel state
        this.state = {
            battleStarted: false,
            battlePaused: false,
            currentSpeed: 1
        };
        
        // Create panel components
        this.createPanel();
        
        // Add to scene and make interactive
        scene.add.existing(this);
    }
    
    /**
     * Create the panel background and controls
     */
    createPanel() {
        try {
            // Calculate panel size based on scene dimensions
            const width = this.scene.cameras.main.width * 0.8;
            const height = 80;
            
            // Create background
            this.background = this.scene.add.rectangle(0, 0, width, height, 0x222233, 0.85);
            this.background.setStrokeStyle(2, 0x3333aa);
            this.add(this.background);
            
            // Create Start Battle button
            this.startBattleButton = this.createButton(
                -width/4, 0, 
                'Start Battle', 
                0x225588,
                () => this.onStartBattleClicked()
            );
            
            // Create Speed buttons
            const speedButtonWidth = 60;
            const speedButtonSpacing = 10;
            const speedButtonY = 0;
            
            this.speedButtons = [];
            const speeds = [1, 2, 3]; // Speed multipliers
            
            speeds.forEach((speed, index) => {
                const x = speedButtonWidth * index + (speedButtonSpacing * index);
                const button = this.createButton(
                    x, speedButtonY,
                    `${speed}x`, 
                    0x445566,
                    () => this.onSpeedButtonClicked(speed)
                );
                button.setScale(0.8);
                
                // Store reference for later use
                this.speedButtons.push(button);
                
                // Highlight 1x speed by default
                if (speed === 1) {
                    this.highlightSpeedButton(button);
                }
            });
            
            // Group speed buttons together and position on the right
            const speedButtonsGroup = this.scene.add.container(width/4, 0);
            this.speedButtons.forEach(button => {
                // Reparent the buttons to the group
                button.parentContainer.remove(button);
                speedButtonsGroup.add(button);
            });
            this.add(speedButtonsGroup);
            
            // Create Pause button
            this.pauseButton = this.createButton(
                0, 0, 
                'Pause', 
                0x664455,
                () => this.onPauseButtonClicked()
            );
            this.pauseButton.setPosition(width/4 - 120, 0);
            this.pauseButton.setScale(0.8);
            this.pauseButton.setVisible(false); // Hide until battle starts
            
            // Add panel title
            this.titleText = this.scene.add.text(
                0, -height/2 + 10, 
                'Battle Controls', 
                { 
                    fontFamily: 'Arial', 
                    fontSize: '18px', 
                    color: '#FFFFFF',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5, 0.5);
            this.add(this.titleText);
            
        } catch (error) {
            console.error('Error creating battle control panel:', error);
            // Create a minimal functional panel in case of error
            this.createFallbackPanel();
        }
    }
    
    /**
     * Create a minimal fallback panel in case of error
     */
    createFallbackPanel() {
        // Simple background
        this.background = this.scene.add.rectangle(0, 0, 400, 60, 0x222233, 0.8);
        this.add(this.background);
        
        // Simple start button
        this.startBattleButton = this.scene.add.text(
            0, 0, 
            'Start Battle', 
            { 
                fontFamily: 'Arial', 
                fontSize: '20px', 
                color: '#FFFFFF', 
                backgroundColor: '#225588',
                padding: { x: 10, y: 5 }
            }
        ).setOrigin(0.5, 0.5)
         .setInteractive({ useHandCursor: true })
         .on('pointerdown', () => this.onStartBattleClicked());
        
        this.add(this.startBattleButton);
    }
    
    /**
     * Create a styled button
     * @param {number} x - X position relative to container
     * @param {number} y - Y position relative to container
     * @param {string} text - Button text
     * @param {number} color - Button background color
     * @param {Function} callback - Button click handler
     * @returns {Phaser.GameObjects.Container} - The button container
     */
    createButton(x, y, text, color, callback) {
        // Create a container for the button
        const buttonContainer = this.scene.add.container(x, y);
        
        // Create button background
        const buttonWidth = text.length * 12 + 20; // Adjust width based on text length
        const buttonHeight = 40;
        const buttonBackground = this.scene.add.rectangle(0, 0, buttonWidth, buttonHeight, color, 1);
        buttonBackground.setStrokeStyle(2, 0xFFFFFF, 0.5);
        
        // Create button text
        const buttonText = this.scene.add.text(
            0, 0, 
            text, 
            { 
                fontFamily: 'Arial', 
                fontSize: '16px', 
                color: '#FFFFFF' 
            }
        ).setOrigin(0.5, 0.5);
        
        // Add components to container
        buttonContainer.add([buttonBackground, buttonText]);
        
        // Make button interactive
        buttonBackground.setInteractive({ useHandCursor: true })
            .on('pointerover', () => {
                buttonBackground.setFillStyle(color, 1.2);
                buttonBackground.setScale(1.05);
                buttonText.setScale(1.05);
            })
            .on('pointerout', () => {
                buttonBackground.setFillStyle(color, 1);
                buttonBackground.setScale(1);
                buttonText.setScale(1);
            })
            .on('pointerdown', () => {
                buttonBackground.setFillStyle(color, 0.8);
                buttonBackground.setScale(0.95);
                buttonText.setScale(0.95);
                
                // Play button sound if available
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            })
            .on('pointerup', () => {
                buttonBackground.setFillStyle(color, 1.2);
                buttonBackground.setScale(1.05);
                buttonText.setScale(1.05);
                callback();
            });
        
        // Add the button container to the panel
        this.add(buttonContainer);
        
        // Store background reference for highlight toggling
        buttonContainer.background = buttonBackground;
        buttonContainer.text = buttonText;
        
        return buttonContainer;
    }
    
    /**
     * Handle Start Battle button click
     */
    onStartBattleClicked() {
        try {
            // Use global accessor function to get bridge instance
            const battleBridge = window.getBattleBridge();
            
            // Dispatch appropriate event to bridge
            if (battleBridge) {
                console.log('BattleControlPanel: Start Battle clicked');
                
                // Get the team data from the scene
                const playerTeam = this.scene.playerTeam || [];
                const enemyTeam = this.scene.enemyTeam || [];
                
                console.log(`BattleControlPanel: Using team data from scene - Player: ${playerTeam.length} heroes, Enemy: ${enemyTeam.length} heroes`);
                
                // Add test event listeners to monitor all events for debugging
                const eventTypes = Object.values(battleBridge.eventTypes);
                eventTypes.forEach(type => {
                    battleBridge.addEventListener(type, (data) => {
                        console.log(`BATTLE EVENT MONITOR: ${type} event received`, data);
                    });
                });
                
                // Send a test message to the battle log to verify working
                battleBridge.dispatchEvent(battleBridge.eventTypes.BATTLE_LOG, {
                    message: "Battle starting - debug event from control panel",
                    type: "action"
                });
                
                battleBridge.dispatchEvent(battleBridge.eventTypes.BATTLE_UI_INTERACTION, {
                    action: 'start_battle',
                    source: 'ui_control',
                    playerTeamSize: playerTeam.length,
                    enemyTeamSize: enemyTeam.length
                });
                
                // Call start battle method on bridge if it exists, passing team data
                if (typeof battleBridge.startBattle === 'function') {
                    // Make deep copies of the team data
                    const playerTeamCopy = JSON.parse(JSON.stringify(playerTeam));
                    const enemyTeamCopy = JSON.parse(JSON.stringify(enemyTeam));
                    
                    battleBridge.startBattle(playerTeamCopy, enemyTeamCopy);
                    
                    // Set up periodic test events to confirm battle log is working
                    setTimeout(() => {
                        battleBridge.dispatchEvent(battleBridge.eventTypes.BATTLE_LOG, {
                            message: "Test damage event - verifying battle events",
                            type: "error"
                        });
                    }, 2000);
                    
                    setTimeout(() => {
                        battleBridge.dispatchEvent(battleBridge.eventTypes.BATTLE_LOG, {
                            message: "Test healing event - verifying battle events",
                            type: "success"
                        });
                    }, 3500);
                } else {
                    // Alternative: call directly on BattleManager
                    if (this.scene.battleConfig && this.scene.battleConfig.battleManager) {
                        // Make deep copies of the team data
                        const playerTeamCopy = JSON.parse(JSON.stringify(playerTeam));
                        const enemyTeamCopy = JSON.parse(JSON.stringify(enemyTeam));
                        
                        this.scene.battleConfig.battleManager.startBattle(playerTeamCopy, enemyTeamCopy);
                    }
                }
                
                // Update button states
                this.state.battleStarted = true;
                this.startBattleButton.setVisible(false);
                this.pauseButton.setVisible(true);
                
                // Show success message
                this.showFloatingMessage('Battle Started!');
            } else {
                console.error('BattleControlPanel: No battle bridge found');
                this.showFloatingMessage('Error: Battle system not ready', 0xff0000);
            }
        } catch (error) {
            console.error('Error starting battle:', error);
            this.showFloatingMessage('Error starting battle', 0xff0000);
        }
    }
    
    /**
     * Handle Speed button click
     * @param {number} speed - The speed multiplier
     */
    onSpeedButtonClicked(speed) {
        try {
            // Only proceed if battle has started
            if (!this.state.battleStarted) {
                this.showFloatingMessage('Start the battle first!', 0xffff00);
                return;
            }
            
            console.log(`BattleControlPanel: Speed ${speed}x clicked`);
            
            // Update speed state
            this.state.currentSpeed = speed;
            
            // Highlight the selected speed button
            this.speedButtons.forEach(button => {
                if (button.text.text === `${speed}x`) {
                    this.highlightSpeedButton(button);
                } else {
                    this.unhighlightSpeedButton(button);
                }
            });
            
            // Call speed change method on bridge if it exists
            const battleBridge = window.getBattleBridge();
            if (battleBridge) {
                battleBridge.requestSpeedChange(speed);
            }
            
            // Show success message
            this.showFloatingMessage(`Speed: ${speed}x`);
        } catch (error) {
            console.error('Error changing battle speed:', error);
            this.showFloatingMessage('Error changing speed', 0xff0000);
        }
    }
    
    /**
     * Handle Pause button click
     */
    onPauseButtonClicked() {
        try {
            // Only proceed if battle has started
            if (!this.state.battleStarted) {
                return;
            }
            
            // Toggle paused state
            this.state.battlePaused = !this.state.battlePaused;
            
            // Update button text
            this.pauseButton.text.setText(this.state.battlePaused ? 'Resume' : 'Pause');
            
            // Call appropriate method on bridge
            const battleBridge = window.getBattleBridge();
            if (battleBridge) {
                if (this.state.battlePaused) {
                    // Use requestPause method which will call battleManager.pauseBattle()
                    battleBridge.requestPause();
                    this.showFloatingMessage('Battle Paused');
                } else {
                    // Use requestResume method which will call battleManager.resumeBattle()
                    battleBridge.requestResume();
                    this.showFloatingMessage('Battle Resumed');
                }
            } else if (window.battleManager) {
                // Direct fallback to battleManager if bridge not available
                if (this.state.battlePaused) {
                    window.battleManager.pauseBattle();
                    this.showFloatingMessage('Battle Paused');
                } else {
                    window.battleManager.resumeBattle();
                    this.showFloatingMessage('Battle Resumed');
                }
            } else {
                console.warn('No bridge or battleManager available for pause control');
                this.showFloatingMessage('Pause control unavailable', 0xffaa00);
            }
        } catch (error) {
            console.error('Error toggling battle pause state:', error);
            this.showFloatingMessage('Error toggling pause', 0xff0000);
        }
    }
    
    /**
     * Highlight a speed button to show it's active
     * @param {Phaser.GameObjects.Container} button - The button to highlight
     */
    highlightSpeedButton(button) {
        button.background.setStrokeStyle(3, 0x00ff00, 1);
        button.background.setFillStyle(button.background.fillColor, 1.2);
    }
    
    /**
     * Remove highlight from a speed button
     * @param {Phaser.GameObjects.Container} button - The button to unhighlight
     */
    unhighlightSpeedButton(button) {
        button.background.setStrokeStyle(2, 0xFFFFFF, 0.5);
        button.background.setFillStyle(button.background.fillColor, 1);
    }
    
    /**
     * Show a floating message above the panel
     * @param {string} message - The message to display
     * @param {number} color - Text color (hex)
     */
    showFloatingMessage(message, color = 0xffffff) {
        const text = this.scene.add.text(
            0, -60, 
            message, 
            { 
                fontFamily: 'Arial', 
                fontSize: '20px', 
                color: `#${color.toString(16).padStart(6, '0')}`,
                stroke: '#000000',
                strokeThickness: 3
            }
        ).setOrigin(0.5, 0.5);
        
        this.add(text);
        
        // Animate the message
        this.scene.tweens.add({
            targets: text,
            y: -100,
            alpha: 0,
            duration: 1500,
            ease: 'Power2',
            onComplete: () => {
                text.destroy();
            }
        });
    }
    
    /**
     * Update the panel state based on battle events
     * @param {object} data - Event data
     */
    onBattleEvent(data) {
        if (!data || !data.type) return;
        
        switch (data.type) {
            case 'battle_started':
                this.state.battleStarted = true;
                this.startBattleButton.setVisible(false);
                this.pauseButton.setVisible(true);
                break;
                
            case 'battle_ended':
                this.state.battleStarted = false;
                this.state.battlePaused = false;
                this.startBattleButton.setVisible(true);
                this.pauseButton.setVisible(false);
                this.pauseButton.text.setText('Pause');
                break;
        }
    }
}


===== FILE: BattleLogPanel.js =====
/**
 * BattleLogPanel.js
 * DEPRECATED: This complex panel has been replaced by DirectBattleLog.js
 * @version 0.5.0.10ce
 * @deprecated Use DirectBattleLog instead
 */

// NOTE: This entire file is marked for deletion. It has been replaced by a simpler
// DirectBattleLog implementation that doesn't use the complex panel UI.
// The code is kept for reference but will be removed in a future update.

class BattleLogPanel {
    /**
     * Create a new battle log panel
     * @param {Phaser.Scene} scene - The scene to add this panel to
     * @param {number} x - The x position of the panel
     * @param {number} y - The y position of the panel
     * @param {number} width - The width of the panel
     * @param {number} height - The height of the panel
     * @param {Object} options - Additional options for the panel
     */
    constructor(scene, x, y, width, height, options = {}) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        
        // Default options
        this.options = {
            backgroundColor: 0x222233,
            backgroundAlpha: 0.95, // Further increased opacity
            textColor: '#ffffff',
            fontSize: 16, // Further increased font size
            padding: 12, // Increased padding
            maxMessages: 30, // More messages
            autoScroll: true,
            fontFamily: 'Arial',
            ...options // Override defaults with provided options
        };
        
        // Log options for debugging
        console.log('BattleLogPanel: Initialized with options:', JSON.stringify(this.options));
        
        // Initialize properties
        this.messages = [];
        this.scrollPosition = 0;
        this.isScrolling = false;
        this.isVisible = true;
        this.container = null;
        this.textObjects = [];
        this.messageTypes = {
            default: { color: '#ffffff' },   // White
            info: { color: '#4dabff' },      // Brighter blue
            success: { color: '#5aff5a' },   // Brighter green
            action: { color: '#ffee55' },    // Even brighter yellow
            error: { color: '#ff7777' },     // Even brighter red
            player: { color: '#66bbff' },    // Brighter blue for player
            enemy: { color: '#ff7777' }      // Brighter red for enemy
        };
        
        // Log message types for debugging
        console.log('BattleLogPanel: Message type colors:', JSON.stringify(this.messageTypes));
        
        // Create the UI
        this.create();
        
        // Debug - log panel position and dimensions
        console.log('BattleLogPanel: Created at position:', this.x, this.y, 'with size:', this.width, this.height);
        
        // Set up a connection to BattleBridge if possible
        this.connectToBattleBridge();
    }
    
    /**
     * Create the battle log panel UI
     */
    create() {
        // Create container
        this.container = this.scene.add.container(this.x, this.y);
        
        // Background
        this.background = this.scene.add.rectangle(
            0,
            0,
            this.width,
            this.height,
            this.options.backgroundColor,
            this.options.backgroundAlpha
        ).setOrigin(0.5);
        
        // Add border with more contrast
        this.border = this.scene.add.graphics();
        this.border.lineStyle(3, 0x4488ff, 1); // Thicker, blue border
        this.border.strokeRect(
            -this.width/2,
            -this.height/2,
            this.width, 
            this.height
        );
        
        // Create panel title
        this.titleBar = this.scene.add.rectangle(
            0,
            -this.height/2 + 15,
            this.width - 20,
            30,
            0x3366aa, // Brighter blue
            0.95 // More opaque
        ).setOrigin(0.5);
        
        this.titleText = this.scene.add.text(
            0,
            -this.height/2 + 15,
            'Battle Log',
            {
                fontFamily: this.options.fontFamily,
                fontSize: this.options.fontSize + 3, // Slightly larger
                color: '#ffffff',
                align: 'center',
                fontStyle: 'bold', // Bold text
                stroke: '#000000', // Black stroke
                strokeThickness: 2 // Thicker stroke
            }
        ).setOrigin(0.5);
        
        // Create scroll buttons
        this.createScrollButtons();
        
        // Add mask for text clipping
        const maskGraphics = this.scene.add.graphics();
        maskGraphics.fillStyle(0xffffff);
        maskGraphics.fillRect(
            this.x - this.width/2 + this.options.padding, 
            this.y - this.height/2 + 40, // Below title
            this.width - this.options.padding * 2,
            this.height - 50 // Leave space for title and controls
        );
        
        this.textMask = maskGraphics.createGeometryMask();
        
        // Create text container
        this.textContainer = this.scene.add.container(0, 0);
        this.textContainer.setMask(this.textMask);
        
        // Debug - Add visual marker for the text container origin
        const originMarker = this.scene.add.rectangle(0, 0, 10, 10, 0xff0000);
        this.textContainer.add(originMarker);
        
        // Debug - Log text container info
        console.log('BattleLogPanel: Text container created at:', this.textContainer.x, this.textContainer.y);
        // Safely log mask info without trying to access geometryMask.getBounds
        console.log('BattleLogPanel: Text mask created with parent coordinates:', 
            this.x - this.width/2 + this.options.padding, 
            this.y - this.height/2 + 40);
        
        // Debug - Add border around text area
        const textAreaBorder = this.scene.add.graphics();
        textAreaBorder.lineStyle(3, 0x00ff00, 1); // Bright green border
        textAreaBorder.strokeRect(
            -this.width/2 + this.options.padding,
            -this.height/2 + 40,
            this.width - this.options.padding * 2,
            this.height - 50
        );
        
        // Add all components to main container
        this.container.add([
            this.background,
            this.border,
            this.titleBar,
            this.titleText,
            this.textContainer,
            textAreaBorder, // Add debug border
            this.upButton,
            this.downButton,
            this.scrollTextBackground,
            this.scrollText,
            this.clearButton
        ]);
        
        // Initial state
        this.updateButtonStates();
        this.addMessage('Battle log initialized successfully', 'success');
    }
    
    /**
     * Create scroll buttons and controls
     */
    createScrollButtons() {
        const buttonStyle = {
            fontFamily: this.options.fontFamily,
            fontSize: this.options.fontSize + 4,
            color: '#ffffff',
            backgroundColor: '#444466',
            padding: { x: 10, y: 5 }
        };
        
        // Up button (at the top right)
        this.upButton = this.scene.add.text(
            this.width/2 - 30,
            -this.height/2 + 15,
            'â–²',
            buttonStyle
        ).setOrigin(0.5)
        .setInteractive({ useHandCursor: true })
        .on('pointerdown', () => this.scrollUp())
        .on('pointerover', () => this.upButton.setStyle({ backgroundColor: '#666688' }))
        .on('pointerout', () => this.upButton.setStyle({ backgroundColor: '#444466' }));
        
        // Down button (next to up button)
        this.downButton = this.scene.add.text(
            this.width/2 - 10,
            -this.height/2 + 15,
            'â–¼',
            buttonStyle
        ).setOrigin(0.5)
        .setInteractive({ useHandCursor: true })
        .on('pointerdown', () => this.scrollDown())
        .on('pointerover', () => this.downButton.setStyle({ backgroundColor: '#666688' }))
        .on('pointerout', () => this.downButton.setStyle({ backgroundColor: '#444466' }));
        
        // Scroll status text
        this.scrollTextBackground = this.scene.add.rectangle(
            -this.width/2 + 60,
            -this.height/2 + 15,
            100,
            24,
            0x333344,
            0.7
        ).setOrigin(0.5);
        
        this.scrollText = this.scene.add.text(
            -this.width/2 + 60,
            -this.height/2 + 15,
            'Auto-scroll: On',
            {
                fontFamily: this.options.fontFamily,
                fontSize: this.options.fontSize - 2,
                color: '#ffffff',
                align: 'center'
            }
        ).setOrigin(0.5);
        
        // Clear log button
        this.clearButton = this.scene.add.text(
            -this.width/2 + 140,
            -this.height/2 + 15,
            'Clear',
            buttonStyle
        ).setOrigin(0.5)
        .setInteractive({ useHandCursor: true })
        .on('pointerdown', () => this.clearLog())
        .on('pointerover', () => this.clearButton.setStyle({ backgroundColor: '#666688' }))
        .on('pointerout', () => this.clearButton.setStyle({ backgroundColor: '#444466' }));
    }
    
    /**
     * Connect to BattleBridge to receive events
     */
    connectToBattleBridge() {
        // Check if BattleBridge exists
        if (this.scene.battleBridge) {
            console.log('BattleLogPanel: Connecting to BattleBridge');
            
            // Set up event listeners for battle events
            const bridge = this.scene.battleBridge;
            
            // Listen for turn started
            bridge.addEventListener(bridge.eventTypes.TURN_STARTED, (data) => {
                try {
                    console.log('BattleLogPanel: TURN_STARTED event received', data);
                    this.addMessage(`Turn ${data.turnNumber}: ${data.currentCharacter.name}'s turn`, 'info');
                } catch (error) {
                    console.error('Error handling TURN_STARTED event:', error);
                }
            });
            
            // Listen for abilities
            bridge.addEventListener(bridge.eventTypes.ABILITY_USED, (data) => {
                try {
                    console.log('BattleLogPanel: ABILITY_USED event received', data);
                    const team = data.source.team === 'player' ? 'player' : 'enemy';
                    this.addMessage(`${data.source.name} uses ${data.ability.name}`, team);
                } catch (error) {
                    console.error('Error handling ABILITY_USED event:', error);
                }
            });
            
            // Listen for damage
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DAMAGED, (data) => {
                try {
                    console.log('BattleLogPanel: CHARACTER_DAMAGED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    this.addMessage(`${data.target.name} takes ${data.amount} damage (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                } catch (error) {
                    console.error('Error handling CHARACTER_DAMAGED event:', error);
                }
            });
            
            // Listen for healing
            bridge.addEventListener(bridge.eventTypes.CHARACTER_HEALED, (data) => {
                try {
                    console.log('BattleLogPanel: CHARACTER_HEALED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    this.addMessage(`${data.target.name} is healed for ${data.amount} HP (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                } catch (error) {
                    console.error('Error handling CHARACTER_HEALED event:', error);
                }
            });
            
            // Listen for status effects
            bridge.addEventListener(bridge.eventTypes.STATUS_EFFECT_APPLIED, (data) => {
                try {
                    // Defensive check for data structure
                    if (!data || !data.target) {
                        console.warn('Invalid data for STATUS_EFFECT_APPLIED event', data);
                        return;
                    }
                    
                    // Get team for coloring
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Get effect information - need defensive access
                    let effectName = 'status effect';
                    
                    // Try to get the status effect name from various possible properties
                    if (data.statusEffect && data.statusEffect.name) {
                        effectName = data.statusEffect.name;
                    } else if (data.effect && data.effect.name) {
                        effectName = data.effect.name;
                    } else if (data.effect && data.effect.definitionId) {
                        effectName = data.effect.definitionId;
                    } else if (data.effectId) {
                        effectName = data.effectId;
                    }
                    
                    // Make effect name more readable by removing prefix and capitalizing
                    if (effectName.startsWith('status_')) {
                        effectName = effectName.replace('status_', '');
                    }
                    effectName = effectName.charAt(0).toUpperCase() + effectName.slice(1);
                    
                    this.addMessage(`${data.target.name} is affected by ${effectName}`, team);
                } catch (error) {
                    console.warn('Error handling STATUS_EFFECT_APPLIED event:', error);
                    // Try a more basic message as fallback
                    if (data && data.target) {
                        this.addMessage(`${data.target.name} gained a status effect`, 'info');
                    }
                }
            });
            
            // Listen for defeats
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DEFEATED, (data) => {
                const team = data.character.team === 'player' ? 'player' : 'enemy';
                this.addMessage(`${data.character.name} is defeated!`, team === 'player' ? 'error' : 'success');
            });
            
            // Listen for battle end
            bridge.addEventListener(bridge.eventTypes.BATTLE_ENDED, (data) => {
                let message = '';
                let type = 'info';
                
                switch (data.winner) {
                    case 'player':
                        message = 'Victory! Your team has won the battle!';
                        type = 'success';
                        break;
                    case 'enemy':
                        message = 'Defeat! Your team has lost the battle.';
                        type = 'error';
                        break;
                    default:
                        message = 'The battle ended in a draw.';
                        type = 'info';
                }
                
                this.addMessage(message, type);
            });
            
            // Listen for the battle log events directly from BattleManager
            bridge.addEventListener(bridge.eventTypes.BATTLE_LOG, (data) => {
                try {
                    console.log('BattleLogPanel received BATTLE_LOG event:', data);
                    if (!data || !data.message) {
                        console.warn('BattleLogPanel: BATTLE_LOG event missing message data', data);
                        return;
                    }
                    this.addMessage(data.message, data.type || 'default');
                    console.log('BattleLogPanel: Added message to log:', data.message);
                } catch (error) {
                    console.warn('Error handling BATTLE_LOG event:', error);
                }
            });
            
            // Add a test message to verify panel is working properly
            this.addMessage('Battle log panel connected to battle events', 'success');
            this.addMessage('Ready for battle control input', 'info');
            this.addMessage('Test message from BattleScene via BattleBridge', 'info');
            
            console.log('BattleLogPanel: Connected to BattleBridge successfully');
        } else {
            console.warn('BattleLogPanel: BattleBridge not found, will not receive battle events');
        }
    }
    
    /**
     * Add a message to the battle log
     * @param {string} message - The message to add
     * @param {string} type - The type of message (default, info, success, error, action)
     */
    addMessage(message, type = 'default') {
        // Create timestamp
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Add message to array
        this.messages.push({
            text: message,
            type: type,
            timestamp: timestamp
        });
        
        // Limit message count
        if (this.messages.length > this.options.maxMessages) {
            this.messages.shift(); // Remove oldest message
        }
        
        // Render messages
        this.renderMessages();
        
        // Auto-scroll if enabled
        if (this.options.autoScroll) {
            this.scrollToBottom();
        }
    }
    
    /**
     * Render messages in the panel
     * @version 0.5.0.11 - Fixed text boundary containment
     */
    renderMessages() {
        // Clear existing text objects
        this.textObjects.forEach(obj => obj.destroy());
        this.textObjects = [];
        
        // Clear text container contents
        this.textContainer.removeAll(true);
        
        // Calculate visible range based on scroll position
        const startIndex = Math.max(0, this.messages.length - this.options.maxMessages - this.scrollPosition);
        const visibleMessages = this.messages.slice(startIndex, startIndex + this.options.maxMessages);
        
        // Calculate available width for text (accounting for padding)
        const availableWidth = this.width - (this.options.padding * 2) - 10;
        
        console.log(`Text container available width: ${availableWidth}px`);
        
        // Create text objects for each visible message
        visibleMessages.forEach((message, index) => {
            // Get color for message type
            const color = this.messageTypes[message.type]?.color || this.messageTypes.default.color;
            
            // Calculate relative Y position within container
            const yPos = index * (this.options.fontSize + 6);
            
            const textStyle = {
                fontFamily: this.options.fontFamily,
                fontSize: this.options.fontSize,
                color: color,
                wordWrap: { 
                    width: availableWidth,
                    useAdvancedWrap: true  // More accurate wrapping
                },
                stroke: '#000000',
                strokeThickness: 2,
                shadow: {
                    offsetX: 2,
                    offsetY: 2,
                    color: '#000000',
                    blur: 2,
                    stroke: true,
                    fill: true
                }
            };
            
            // Log text creation for debugging
            console.log(`Creating message ${index} at container position (${this.options.padding}, ${yPos})`);
            
            // Create message text - using CONTAINER-RELATIVE positioning
            const text = this.scene.add.text(
                this.options.padding,  // Relative X position within container
                yPos,                  // Relative Y position within container
                `[${message.timestamp}] ${message.text}`,
                textStyle
            );
            
            // Ensure text uses top-left origin
            text.setOrigin(0, 0);
            
            // Add bold for important messages
            if (message.type === 'action' || message.type === 'error' || message.type === 'success') {
                text.setFontStyle('bold');
                text.setStroke('#000000', 3);
            }
            
            // Add to text container
            this.textContainer.add(text);
            
            // Also track in our array for clean-up
            this.textObjects.push(text);
            
            console.log(`Message ${index} added to container, width=${text.width}px`);
        });
        
        // Position the textContainer appropriately within the panel
        this.textContainer.setPosition(-this.width/2 + this.options.padding, -this.height/2 + 40);
        
        // Update button states
        this.updateButtonStates();
    }
    
    /**
     * Scroll the log up
     */
    scrollUp() {
        if (this.scrollPosition < this.messages.length - this.options.maxMessages) {
            this.scrollPosition++;
            this.options.autoScroll = false; // Disable auto-scroll when manually scrolling
            this.updateScrollText();
            this.renderMessages();
        }
    }
    
    /**
     * Scroll the log down
     */
    scrollDown() {
        if (this.scrollPosition > 0) {
            this.scrollPosition--;
            this.renderMessages();
        } else {
            // If already at bottom, enable auto-scroll
            this.options.autoScroll = true;
            this.updateScrollText();
        }
    }
    
    /**
     * Scroll to the bottom of the log
     */
    scrollToBottom() {
        this.scrollPosition = 0;
        this.renderMessages();
    }
    
    /**
     * Toggle auto-scrolling
     */
    toggleAutoScroll() {
        this.options.autoScroll = !this.options.autoScroll;
        
        if (this.options.autoScroll) {
            this.scrollToBottom();
        }
        
        this.updateScrollText();
    }
    
    /**
     * Update the scroll text
     */
    updateScrollText() {
        this.scrollText.setText(`Auto-scroll: ${this.options.autoScroll ? 'On' : 'Off'}`);
    }
    
    /**
     * Clear the log
     */
    clearLog() {
        this.messages = [{
            text: 'Log cleared',
            type: 'info',
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        }];
        
        this.scrollPosition = 0;
        this.renderMessages();
    }
    
    /**
     * Update button states based on scroll position
     */
    updateButtonStates() {
        // Disable up button when at top
        this.upButton.setAlpha(this.scrollPosition < this.messages.length - this.options.maxMessages ? 1 : 0.5);
        
        // Disable down button when at bottom
        this.downButton.setAlpha(this.scrollPosition > 0 ? 1 : 0.5);
    }
    
    /**
     * Set the visibility of the panel
     * @param {boolean} visible - Whether the panel should be visible
     */
    setVisible(visible) {
        this.isVisible = visible;
        this.container.setVisible(visible);
    }
    
    /**
     * Toggle the visibility of the panel
     * @returns {boolean} The new visibility state
     */
    toggle() {
        this.isVisible = !this.isVisible;
        this.container.setVisible(this.isVisible);
        return this.isVisible;
    }
    
    /**
     * Resize the panel
     * @param {number} width - The new width
     * @param {number} height - The new height
     */
    resize(width, height) {
        this.width = width;
        this.height = height;
        
        // Update background
        this.background.width = width;
        this.background.height = height;
        
        // Update border
        this.border.clear();
        this.border.lineStyle(2, 0x444466, 1);
        this.border.strokeRect(
            -width/2,
            -height/2,
            width,
            height
        );
        
        // Update title bar
        this.titleBar.width = width - 20;
        this.titleBar.setPosition(0, -height/2 + 15);
        this.titleText.setPosition(0, -height/2 + 15);
        
        // Update buttons
        this.upButton.setPosition(width/2 - 30, -height/2 + 15);
        this.downButton.setPosition(width/2 - 10, -height/2 + 15);
        this.scrollTextBackground.setPosition(-width/2 + 60, -height/2 + 15);
        this.scrollText.setPosition(-width/2 + 60, -height/2 + 15);
        this.clearButton.setPosition(-width/2 + 140, -height/2 + 15);
        
        // Update mask
        const maskGraphics = this.scene.add.graphics();
        maskGraphics.fillStyle(0xffffff);
        maskGraphics.fillRect(
            this.x - width/2 + this.options.padding,
            this.y - height/2 + 40,
            width - this.options.padding * 2,
            height - 50
        );
        
        this.textMask.destroy();
        this.textMask = maskGraphics.createGeometryMask();
        this.textContainer.setMask(this.textMask);
        
        // Re-render messages
        this.renderMessages();
    }
    
    /**
     * Update method for animation or dynamic content
     * @param {number} time - The current time
     * @param {number} delta - The time since the last update
     */
    update(time, delta) {
        // Intentionally left empty for now
    }
    
    /**
     * Clean up resources used by this component
     */
    /**
     * Utility method to debug text rendering
     * Creates test text with unmissable styling
     */
    createDebugText() {
        try {
            console.log('Creating debug test text...');
            
            // Create a test text directly in the panel
            const testStyle = { 
                font: '24px Arial', 
                fill: '#FF0000',      // Bright red text
                backgroundColor: '#FFFF00',  // Yellow background
                padding: { x: 5, y: 5 }
            };
            
            // Create central test text
            const testX = this.x;
            const testY = this.y;
            const testText = this.scene.add.text(testX, testY, 'TEST TEXT RENDERING', testStyle);
            testText.setOrigin(0.5); // Center it
            testText.setDepth(100);
            
            console.log('Debug test text created at scene coords:', testX, testY);
            
            // Also create text at top-left of white area
            const cornerText = this.scene.add.text(
                this.x - this.width/2 + 20, // Left edge of panel + padding
                this.y - this.height/2 + 40, // Top of content area
                'CORNER TEXT',
                {
                    font: '20px Arial',
                    fill: '#0000FF',      // Blue text
                    backgroundColor: '#00FF00', // Green background
                    padding: { x: 5, y: 5 }
                }
            );
            cornerText.setOrigin(0, 0);
            cornerText.setDepth(100);
            
            console.log('Corner text created at absolute position:', 
                this.x - this.width/2 + 20, 
                this.y - this.height/2 + 40);
                
            return [testText, cornerText];
        } catch(e) {
            console.error("Error creating debug text:", e);
            return null;
        }
    }
    
    destroy() {
        // Remove any event listeners
        if (this.scene.battleBridge) {
            // Optionally remove specific event listeners if needed
        }
        
        // Destroy text objects directly
        this.textObjects.forEach(obj => obj.destroy());
        
        // Destroy mask if it exists
        if (this.textMask) this.textMask.destroy();
        
        // Destroy container and all children
        if (this.container) this.container.destroy();
    }
}

// Make globally accessible
window.BattleLogPanel = BattleLogPanel;


===== FILE: CharacterSprite.js =====
/**
 * CharacterSprite.js
 * Renders a character in the battle scene with appropriate visual elements
 * (Added try...catch blocks for debugging)
 */
class CharacterSprite {
    /**
     * Update the character's health and refresh the health bar
     * @param {number} newHealth - The character's new health value
     * @param {number} maxHealth - The character's maximum health (usually character.stats.hp)
     */
    updateHealth(newHealth, maxHealth) {
        console.log(`CharacterSprite.updateHealth: ${this.character?.name} health to ${newHealth}/${maxHealth}`);
        
        try {
            // Update the internal health tracking
            this.currentHealth = newHealth;
            
            // Update the character data's health tracking
            if (this.character) {
                this.character.currentHp = newHealth;
            }
            
            // Show a health change animation
            const healthChange = (this.previousHealth || newHealth) - newHealth;
            const isHealing = healthChange < 0;
            
            // Store current health for future reference
            this.previousHealth = newHealth;
            
            // Show floating text for significant health changes
            if (Math.abs(healthChange) > 0) {
                const textColor = isHealing ? '#00ff00' : '#ff0000';
                const prefix = isHealing ? '+' : '-';
                const text = `${prefix}${Math.abs(healthChange)}`;
                this.showFloatingText(text, { color: textColor, fontSize: 20 });
            }
            
            // Update the visual health bar
            this.updateHealthBar(newHealth, maxHealth);
            
            // Play a flash effect for damage on the character image instead of the circle
            if (healthChange > 0 && this.characterImage) {
                this.scene.tweens.add({
                    targets: this.characterImage,
                    alpha: { from: 1.0, to: 0.3 },
                    yoyo: true,
                    duration: 100,
                    repeat: 1,
                    ease: 'Sine.easeOut'
                });
            }
            
            // Play a healing glow effect on the character image
            if (healthChange < 0 && this.characterImage) {
                // Create a temporary glow effect
                const healGlow = this.scene.add.circle(0, 0, 42, 0x00ff00, 0.3);
                this.container.add(healGlow);
                this.container.sendToBack(healGlow);
                
                // Animate and remove the glow
                this.scene.tweens.add({
                    targets: healGlow,
                    alpha: { from: 0.3, to: 0 },
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 400,
                    ease: 'Sine.easeOut',
                    onComplete: () => {
                        healGlow.destroy();
                    }
                });
            }
        } catch (error) {
            console.error(`CharacterSprite.updateHealth: Error updating ${this.character?.name}'s health:`, error);
        }
    }
    
    /**
     * Update the health bar to reflect the current health
     * @param {number} currentHealth - Current health value
     * @param {number} maxHealth - Maximum health value
     */
    updateHealthBar(currentHealth, maxHealth) {
        console.log(`CharacterSprite.updateHealthBar: ${this.character?.name} health ${currentHealth}/${maxHealth}`);
        
        try {
            // Skip if health bar components don't exist
            if (!this.healthBar || !this.healthBarBg || !this.hpText) {
                console.warn(`updateHealthBar: Health bar components missing for ${this.character?.name}`);
                return;
            }
            
            // Ensure valid values
            const safeCurrentHealth = Math.max(0, currentHealth || 0);
            const safeMaxHealth = Math.max(1, maxHealth || 1); // Avoid division by zero
            
            // Calculate health percentage (0-1)
            const healthPercent = Math.min(1, safeCurrentHealth / safeMaxHealth);
            
            // Update health bar width
            const healthBarWidth = 80; // Original width
            
            // Use tweens for smooth transition if available
            if (this.scene?.tweens) {
                // Stop any existing health bar tweens to prevent conflicts
                this.scene.tweens.killTweensOf(this.healthBar);
                
                // Create a new tween for smooth transition
                this.scene.tweens.add({
                    targets: this.healthBar,
                    width: healthBarWidth * healthPercent,
                    duration: 300,
                    ease: 'Sine.easeOut',
                    onUpdate: () => {
                        // Update color during tween for smooth color transition
                        const currentWidth = this.healthBar.width;
                        const currentPercent = currentWidth / healthBarWidth;
                        this.healthBar.fillColor = this.getHealthBarColor(currentPercent);
                    }
                });
                
                // Animate health text (shake slightly when taking damage)
                if (this.previousHealthValue && this.previousHealthValue > safeCurrentHealth) {
                    // Character took damage - shake the text
                    this.scene.tweens.add({
                        targets: this.hpText,
                        x: { from: -2, to: 0 },
                        duration: 100,
                        repeat: 1,
                        yoyo: true,
                        ease: 'Sine.easeInOut'
                    });
                } else if (this.previousHealthValue && this.previousHealthValue < safeCurrentHealth) {
                    // Character was healed - subtle bounce
                    this.scene.tweens.add({
                        targets: this.hpText,
                        y: { from: -2, to: 0 },
                        duration: 150,
                        repeat: 0,
                        yoyo: true,
                        ease: 'Bounce'
                    });
                }
            } else {
                // Direct update if tweens not available
                this.healthBar.width = healthBarWidth * healthPercent;
                this.healthBar.fillColor = this.getHealthBarColor(healthPercent);
            }
            
            // Update health text
            this.hpText.setText(`${Math.round(safeCurrentHealth)}/${safeMaxHealth}`);
            
            // Store current health for next comparison
            this.previousHealthValue = safeCurrentHealth;
            
            // Ensure health bar is visible
            if (this.healthBarContainer) {
                this.healthBarContainer.setVisible(true);
            }
            
            console.log(`Health bar updated for ${this.character?.name}: ${healthPercent * 100}% (${safeCurrentHealth}/${safeMaxHealth})`);
        } catch (error) {
            console.error(`Error updating health bar for ${this.character?.name}:`, error);
        }
    }

    /**
     * Create a new character sprite
     * @param {Phaser.Scene} scene - The scene this sprite belongs to
     * @param {Object} character - The character data object
     * @param {Object} config - Configuration options
     */
    constructor(scene, character, config = {}) {
        this.scene = scene;
        this.character = character;
        this.config = Object.assign({
            x: 0,
            y: 0,
            scale: 1,
            showName: true,
            showHealth: true
        }, config);

         // --- Validate Character Data ---
         if (!character) {
              console.error("CharacterSprite Constructor: Invalid character data provided (null or undefined). Cannot create sprite.");
              throw new Error("Invalid character data for CharacterSprite."); // Stop execution here
         }
         if (!character.stats) {
             console.warn(`CharacterSprite Constructor: Character ${character.name || 'Unknown'} missing stats! Using defaults.`);
             character.stats = { hp: 1, // Provide minimal defaults
                                  currentHp: 1 };
         }
         if (typeof character.currentHp === 'undefined') {
            character.currentHp = character.stats.hp;
         }
         if (!character.name) {
             console.warn("CharacterSprite Constructor: Character missing name! Using ID or 'Unknown'.");
             character.name = character.id || 'UnknownCharacter';
         }
         if (!character.type) {
             console.warn(`CharacterSprite Constructor: Character ${character.name} missing type! Using 'neutral'.`);
             character.type = 'neutral';
         }
         // --- End Validation ---

        // Create container for character elements
         try {
             this.container = scene.add.container(this.config.x, this.config.y);
         } catch (error) {
             console.error(`CharacterSprite Constructor (${character.name}): Error creating main container:`, error);
             throw error; // Re-throw critical error
         }


        // --- Create character visual elements with try...catch ---
        try {
             console.log(`CharacterSprite (${character.name}): Creating character image...`);
            this.createCharacterImage();
             console.log(`CharacterSprite (${character.name}): Character image created.`);
        } catch(error) {
            console.error(`CharacterSprite Constructor (${character.name}): Error in createCharacterImage:`, error);
            // Optionally create a fallback visual here if image fails
        }

        if (this.config.showName) {
            try {
                 console.log(`CharacterSprite (${character.name}): Creating name text...`);
                this.createNameText();
                 console.log(`CharacterSprite (${character.name}): Name text created.`);
            } catch(error) {
                console.error(`CharacterSprite Constructor (${character.name}): Error in createNameText:`, error);
            }
        }

        if (this.config.showHealth) {
            try {
                 console.log(`CharacterSprite (${character.name}): Creating health bar...`);
                this.createHealthBar();
                 console.log(`CharacterSprite (${character.name}): Health bar created.`);
            } catch(error) {
                console.error(`CharacterSprite Constructor (${character.name}): Error in createHealthBar:`, error);
            }
        }
        // --- End character elements ---

        // Create action indicator
        try {
            console.log(`CharacterSprite (${character.name}): Creating action indicator...`);
            this.actionIndicator = new ActionIndicator(scene, this);
            console.log(`CharacterSprite (${character.name}): Action indicator created.`);
        } catch(error) {
            console.error(`CharacterSprite Constructor (${character.name}): Error creating action indicator:`, error);
        }

        // Make interactive if needed
        if (config.interactive) {
             try {
                 this.makeInteractive();
             } catch(error) {
                  console.error(`CharacterSprite Constructor (${character.name}): Error making sprite interactive:`, error);
             }
        }

        // Store reference for global access (for debugging)
        if (!window.characterSprites) window.characterSprites = {};
        window.characterSprites[character.name] = this; // Note: potential issue if multiple characters have same name
         console.log(`CharacterSprite Constructor (${character.name}): Initialization complete.`);
    }

    /**
     * Show action text above character
     * @param {string} actionText - The action being performed
     */
    showActionText(actionText) {
        try {
            if (!this.actionIndicator) {
                console.warn(`showActionText (${this.character?.name}): Action indicator not initialized.`);
                return;
            }
            
            if (actionText.toLowerCase().includes('auto attack')) {
                this.actionIndicator.showAutoAttack();
            } else if (actionText.toLowerCase().includes('ability:')) {
                // Extract ability name if in format "Ability: Name"
                const abilityName = actionText.split('Ability:')[1]?.trim() || actionText;
                this.actionIndicator.showAbility(abilityName);
            } else if (actionText.toLowerCase().includes('status:')) {
                // Extract status name if in format "Status: Name"
                const statusName = actionText.split('Status:')[1]?.trim() || actionText;
                this.actionIndicator.showStatusEffect(statusName);
            } else {
                // Generic action text
                this.actionIndicator.showAction(actionText);
            }
        } catch (error) {
            console.error(`showActionText (${this.character?.name}): Error showing action text:`, error);
        }
    }

    /**
     * Create the character image using the character art
     */
    createCharacterImage() {
        // Validate character name for path construction
        if (!this.character || !this.character.name) {
            console.error("createCharacterImage: Character name is missing.");
            return; // Cannot proceed without a name
        }

        // Create a type-colored circle as background
        const typeColor = this.getTypeColor(this.character.type);
        try {
            // Create the circle with opacity 0 (invisible) to remove visible background while maintaining functionality
            const circleRadius = 40;
            this.circle = this.scene.add.circle(0, 0, circleRadius, typeColor, 0);
            this.container.add(this.circle);
            // Log that we're using invisible circles per user request
            console.log(`createCharacterImage (${this.character.name}): Using invisible background circle`);
        } catch(error) {
            console.error(`createCharacterImage (${this.character.name}): Error creating background circle:`, error);
            return;
        }
        
        try {
            // Use the texture key that matches how we preloaded it in BattleScene
            const characterKey = `character_${this.character.name}`;
            
            // Check if texture exists (it should if properly preloaded)
            if (this.scene.textures.exists(characterKey)) {
                console.log(`createCharacterImage (${this.character.name}): Using preloaded texture ${characterKey}`);
                
                // Create the image with the proper texture
                this.characterImage = this.scene.add.image(0, 0, characterKey);
                this.container.add(this.characterImage);
                
                // Apply positioning from character data
                this.applyPositioning();
            } else {
                // Fallback if texture wasn't preloaded
                console.warn(`createCharacterImage (${this.character.name}): Texture ${characterKey} not found. Using fallback.`);
                this.createFallbackVisual();
            }
        } catch (error) {
            console.error(`createCharacterImage (${this.character.name}): Error creating image:`, error);
            this.createFallbackVisual();
        }
    }

    /** Helper function to apply positioning to the character image */
    applyPositioning() {
        try {
            if (!this.characterImage || !this.characterImage.scene) {
                console.error(`applyPositioning (${this.character.name}): characterImage or scene missing.`);
                return;
            }

            // Get original texture dimensions
            const textureWidth = this.characterImage.width;
            const textureHeight = this.characterImage.height;
            
            console.log(`applyPositioning (${this.character.name}): Texture dimensions: ${textureWidth}x${textureHeight}`);

            // Apply positioning from character data if available
            if (this.character && this.character.art) {
                const left = parseInt(this.character.art.left) || 0;
                const top = parseInt(this.character.art.top) || 0;
                
                // Apply positioning
                this.characterImage.setPosition(left, top);
                
                // Disable scaling completely for combat-optimized images
                // These are already pre-sized to the optimal dimensions
                console.log(`${this.character.name}: Using combat-optimized image - no scaling needed`);
                this.characterImage.setScale(1.0, 1.0);
                
                // Log final display size
                console.log(`${this.character.name}: Original size maintained at ${textureWidth}x${textureHeight}`);
            } else {
                console.log(`applyPositioning (${this.character.name}): Applying default art positioning.`);
                
                // Apply default positioning
                this.characterImage.setPosition(0, 0);
                
                // Disable scaling completely for combat-optimized images
                // These are already pre-sized to the optimal dimensions
                console.log(`${this.character.name}: Using combat-optimized image (default positioning) - no scaling needed`);
                this.characterImage.setScale(1.0, 1.0);
                
                // Adjust position to center the character art in the circle
                this.characterImage.setPosition(0, -10); // Default vertical offset to center in circle
            }
        } catch(error) {
            console.error(`applyPositioning (${this.character.name}): Error applying position:`, error);
            this.createFallbackVisual();
        }
    }

     /** Helper function to create fallback visual */
     createFallbackVisual() {
          try {
              if (this.characterImage && this.characterImage.active) this.characterImage.destroy(); // Remove potentially broken image
               console.warn(`Creating fallback visual for ${this.character?.name || 'Unknown Character'}`);
               const fallbackText = this.scene.add.text(0, 0, this.character?.name?.charAt(0) || '?', {
                   fontFamily: 'Arial',
                   fontSize: 32,
                   color: '#ffffff'
               }).setOrigin(0.5);
               if(this.container) {
                    this.container.add(fallbackText);
               } else {
                    console.error("Cannot add fallback text, main container missing.");
               }
          } catch (fallbackError) {
               console.error("Error creating fallback visual:", fallbackError);
          }
     }

    /**
     * Create text displaying the character's name
     */
    createNameText() {
         // Validate character data
         if (!this.character || !this.character.name || !this.character.team) {
             console.error("createNameText: Missing character name or team.");
             return;
         }
        // Add team identifier for clarity
        const teamIdentifier = this.character.team === 'player' ? ' (ally)' : ' (enemy)';
        const displayName = this.character.name + teamIdentifier;

         try {
             this.nameText = this.scene.add.text(0, 60, displayName, {
                 fontFamily: 'Arial',
                 fontSize: 14,
                 color: '#ffffff',
                 stroke: '#000000',
                 strokeThickness: 3,
                 align: 'center'
             }).setOrigin(0.5);
             this.container.add(this.nameText);
         } catch(error) {
             console.error(`createNameText (${this.character.name}): Error creating/adding name text:`, error);
         }
    }

    /**
     * Create health bar for the character
     */
    createHealthBar() {
         // Validate character data
         if (!this.character || !this.character.stats || typeof this.character.stats.hp === 'undefined' || typeof this.character.currentHp === 'undefined') {
             console.error(`createHealthBar (${this.character?.name}): Missing required stats (hp, currentHp).`);
             return;
         }
         try {
             // Create health bar container
             this.healthBarContainer = this.scene.add.container(0, 45);

             // Background rectangle
             const healthBarWidth = 80; // Original width
             this.healthBarBg = this.scene.add.rectangle(0, 0, healthBarWidth, 10, 0x000000, 0.7);
             this.healthBarBg.setOrigin(0.5, 0.5);

             // Health bar foreground
              // Ensure maxHP is not zero to avoid division by zero
              const maxHp = Math.max(1, this.character.stats.hp);
             const healthPercent = Math.max(0, Math.min(1, (this.character.currentHp || 0) / maxHp));
             const healthBarColor = this.getHealthBarColor(healthPercent);
             this.healthBar = this.scene.add.rectangle(
                  -healthBarWidth/2, // Start from left edge, adjusted for wider bar
                  0,
                  healthBarWidth * healthPercent,
                  10,
                  healthBarColor,
                  1
             );
              this.healthBar.setOrigin(0, 0.5); // Set origin to left-center for width scaling

             // Add HP text
             this.hpText = this.scene.add.text(0, 0, `${this.character.currentHp || 0}/${maxHp}`, {
                 fontFamily: 'Arial',
                 fontSize: 10,
                 color: '#ffffff',
                 stroke: '#000000',
                 strokeThickness: 2
             }).setOrigin(0.5);

             // Add elements to health bar container
             this.healthBarContainer.add([this.healthBarBg, this.healthBar, this.hpText]);

             // Add health bar container to main container
             this.container.add(this.healthBarContainer);
         } catch(error) {
              console.error(`createHealthBar (${this.character.name}): Error creating/adding health bar elements:`, error);
         }
    }

    /**
     * Make the character sprite interactive
     */
    makeInteractive() {
         // Ensure circle exists before making interactive
         if (!this.circle) {
             console.error(`makeInteractive (${this.character.name}): Background circle does not exist.`);
             return;
         }
         try {
             const hitArea = new Phaser.Geom.Circle(0, 0, 50);
             // Use setSize before setInteractive for non-Graphics objects if needed, but circle should be fine
             this.circle.setInteractive(hitArea, Phaser.Geom.Circle.Contains);

             // Add hover effects
             this.circle.on('pointerover', () => {
                  if (this.container) this.container.setScale(1.1);
                 document.body.style.cursor = 'pointer';
             });

             this.circle.on('pointerout', () => {
                  if (this.container) this.container.setScale(1);
                 document.body.style.cursor = 'default';
             });

             // Add click handler (can be customized later)
             this.circle.on('pointerdown', () => {
                 // Example: Emit a 'character_selected' event
                 this.scene.events.emit('character_selected', this.character);
             });
         } catch (error) {
              console.error(`makeInteractive (${this.character.name}): Error making sprite interactive:`, error);
         }
    }

    /**
     * Get the color for a character based on their type
     * @param {string} type - The character's type
     * @returns {number} - The color as a hex number
     */
    getTypeColor(type) {
        const typeColors = {
            fire: 0xFF4500, water: 0x1E90FF, nature: 0x32CD32,
            electric: 0xFFD700, ice: 0x87CEEB, rock: 0x8B4513,
            air: 0xF0F8FF, light: 0xFFFACD, dark: 0x483D8B,
            metal: 0xC0C0C0, psychic: 0xDA70D6, poison: 0x9370DB,
            physical: 0xBDB76B, arcane: 0x9932CC, mechanical: 0x708090,
            void: 0x191970, crystal: 0xB0E0E6, storm: 0x4682B4,
            ethereal: 0xE6E6FA, blood: 0x8B0000, plague: 0x556B2F,
            gravity: 0x2F4F4F, neutral: 0xAAAAAA // Added neutral for placeholder
        };
        // Fallback for undefined or null type
        const safeType = typeof type === 'string' ? type.toLowerCase() : 'neutral';
        return typeColors[safeType] || 0xCCCCCC; // Gray fallback
    }

    /**
     * Get appropriate color for health bar based on percentage
     * @param {number} percent - Health percentage (0-1)
     * @returns {number} - Color as hex
     */
    getHealthBarColor(percent) {
        if (percent < 0.3) return 0xFF0000; // Red (low health)
        if (percent < 0.6) return 0xFFAA00; // Orange (medium health)
        return 0x00FF00; // Green (high health)
    }

    /**
     * Update the character sprite's state
     */
    update() {
         try { // Added try..catch for safety
             if (this.character && this.character.stats) { // Added check for stats
                 // Update health bar if it exists
                 if (this.healthBar && this.healthBarContainer.visible) { // Check visibility too
                      // Ensure maxHP is valid and non-zero
                      const maxHp = Math.max(1, this.character.stats.hp);
                      // Ensure currentHp is a valid number, default to 0 if not
                      const currentHp = typeof this.character.currentHp === 'number' ? this.character.currentHp : 0;
                     const healthPercent = Math.max(0, Math.min(1, currentHp / maxHp));

                     // Update width smoothly using tweens if available, otherwise set directly
                      const healthBarWidth = 80; // Original width
                      if (this.scene?.tweens) {
                          this.scene.tweens.add({
                              targets: this.healthBar,
                              width: healthBarWidth * healthPercent,
                              duration: 150, // Faster update
                              ease: 'Linear'
                          });
                      } else {
                          this.healthBar.width = healthBarWidth * healthPercent;
                      }

                      // Update position (for left alignment)
                     this.healthBar.x = -healthBarWidth/2; // Adjusted from -40 to match wider bar

                     // Update color based on health percentage
                     this.healthBar.fillColor = this.getHealthBarColor(healthPercent);

                     // Update text
                     if (this.hpText) {
                         this.hpText.setText(`${Math.round(currentHp)}/${maxHp}`);
                     }
                 }
             }
         } catch(error) {
              console.error(`Error updating CharacterSprite (${this.character?.name}):`, error);
         }
    }


    /**
     * Show attack animation
     * @param {CharacterSprite} targetSprite - Target character sprite instance
     * @param {Function} onComplete - Callback when animation completes
     */
    showAttackAnimation(targetSprite, onComplete) {
         // Validate targetSprite
         if (!targetSprite || !targetSprite.container) {
             console.error(`showAttackAnimation (${this.character.name}): Invalid targetSprite provided.`);
             if (onComplete) onComplete();
             return;
         }
          // Validate own container and scene
          if (!this.container || !this.scene || !this.scene.tweens) {
               console.error(`showAttackAnimation (${this.character.name}): Missing container or scene/tweens manager.`);
               if (onComplete) onComplete();
               return;
          }

        try { // Added try...catch
            // Show auto attack action indicator
            this.showActionText('Auto Attack');
            
            // Store original position
            const originalX = this.container.x;
            const originalY = this.container.y;

            // Calculate target position (move 70% toward target)
             // Use targetSprite's container position directly
            const targetPos = {
                x: targetSprite.container.x,
                y: targetSprite.container.y
            };

            const moveToX = originalX + (targetPos.x - originalX) * 0.7;
            const moveToY = originalY + (targetPos.y - originalY) * 0.7;

            // Create animation timeline
            const timeline = this.scene.tweens.createTimeline();

            // Add move to target
            timeline.add({
                targets: this.container,
                x: moveToX,
                y: moveToY,
                duration: 300,
                ease: 'Power2'
            });

            // Add return to original position
            timeline.add({
                targets: this.container,
                x: originalX,
                y: originalY,
                duration: 300,
                ease: 'Power2'
            });

            // Play timeline
            timeline.play();

            // Call complete callback
            if (onComplete) {
                timeline.once('complete', onComplete);
            }
        } catch (error) {
             console.error(`showAttackAnimation (${this.character.name}): Error creating/playing tween:`, error);
             // Ensure callback is still called on error
             if (onComplete) {
                  try { onComplete(); } catch (cbError){ console.error("Error in onComplete callback:", cbError); }
             }
        }
    }


    /**
     * Show a floating text effect above the character
     * @param {string} text - Text to display
     * @param {Object} style - Text style options
     */
    showFloatingText(text, style = {}) {
          // Validate container and scene
          if (!this.container || !this.scene || !this.scene.tweens || !this.scene.add) {
               console.error(`showFloatingText (${this.character.name}): Missing container or scene functionality (tweens/add).`);
               return;
          }
         try { // Added try...catch
            const defaultStyle = {
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3
            };
            const mergedStyle = {...defaultStyle, ...style};

            // Create text
            const floatingText = this.scene.add.text(
                this.container.x,
                this.container.y - 50, // Initial position slightly higher
                text,
                mergedStyle
            ).setOrigin(0.5);

             // Ensure text is added to the correct display list / depth if necessary
             // floatingText.setDepth(100); // Example: Set depth if needed

            // Animate text
            this.scene.tweens.add({
                targets: floatingText,
                y: floatingText.y - 50, // Move further up
                alpha: { from: 1, to: 0 }, // Fade out
                duration: 1500,
                ease: 'Power2',
                onComplete: () => {
                     // Safely destroy text only if it hasn't been destroyed already
                     if (floatingText && floatingText.scene) {
                          floatingText.destroy();
                     }
                }
            });
        } catch (error) {
             console.error(`showFloatingText (${this.character.name}): Error creating/animating floating text:`, error);
        }
    }


    /**
     * Highlight this character as active
     */
    highlight() {
          if (!this.scene || !this.container) return; // Safety check
         try { // Added try...catch
            // Get the character sprite's height to position at the bottom
            let bottomOffset = 20; // Offset from center of container to bottom of character
            
            // Check if we have a character image to better determine position
            if (this.characterImage && this.characterImage.height) {
                // Position at the bottom of the character with a smaller offset (moved upward)
                bottomOffset = (this.characterImage.height / 2) -17; 
            }
            
            // Create highlight effect if it doesn't exist
            if (!this.highlightEffect || !this.highlightEffect.scene) { // Check if destroyed
                // Create a subtle 3D-like floor disc instead of a bright yellow circle
                
                // First, add a subtle shadow
                this.shadowEffect = this.scene.add.ellipse(0, bottomOffset, 90, 45, 0x000000, 0.4);
                this.container.add(this.shadowEffect);
                this.container.sendToBack(this.shadowEffect);
                
                // Then create the main floor indicator with gradient
                this.highlightEffect = this.scene.add.graphics();
                this.highlightEffect.setName(`highlight_${this.character?.name || 'unknown'}`);
                this.highlightEffect.setPosition(0, bottomOffset);
                
                // Determine color based on team
                const baseColor = this.character?.team === 'player' ? 0x4488ff : 0xff4444;
                
                // Create a gradient fill from center to edge
                const centerColor = baseColor;
                const edgeColor = Phaser.Display.Color.GetDarker(
                    Phaser.Display.Color.IntegerToColor(baseColor), 
                    30
                ).color;
                
                // Fill with gradient
                this.highlightEffect.fillGradientStyle(centerColor, centerColor, edgeColor, edgeColor, .1);
                this.highlightEffect.fillEllipse(0, 0, 80, 40);
                
                // Add glowing rim - color based on team
                const glowColor = this.character?.team === 'player' ? 0x00ffff : 0xff6666;
                this.highlightEffect.lineStyle(2, glowColor, 2);
                this.highlightEffect.strokeEllipse(0, 0, 80, 40);
                
                this.container.add(this.highlightEffect);
                this.container.sendToBack(this.highlightEffect);
                
                // Add subtle glow animation
                if (this.scene.tweens) {
                    // Stop any existing tween
                    if (this.glowTween) {
                        this.glowTween.stop();
                    }
                    
                    // Create a new tween for the stroke alpha
                    this.glowTween = this.scene.tweens.add({
                        targets: this.highlightEffect,
                        alpha: { from: 0.7, to: 1 },
                        duration: 1200,
                        ease: 'Sine.easeInOut',
                        yoyo: true,
                        repeat: -1
                    });
                }
            } else {
                 this.highlightEffect.setVisible(true);
                 if (this.shadowEffect) this.shadowEffect.setVisible(true);
                 
                 // Restart glow animation if it exists
                 if (this.glowTween && this.glowTween.isPaused()) {
                     this.glowTween.restart();
                 }
            }
         } catch (error) {
              console.error(`highlight (${this.character.name}): Error creating/showing highlight:`, error);
         }
    }


    /**
     * Remove highlight effect
     */
    unhighlight() {
        // Hide both highlight and shadow
        if (this.highlightEffect && this.highlightEffect.scene) {
             try { // Added try...catch
                 this.highlightEffect.setVisible(false);
                 
                 // Stop the glow animation if it exists
                 if (this.glowTween) {
                     this.glowTween.pause();
                 }
             } catch (error) {
                  console.error(`unhighlight (${this.character.name}): Error hiding highlight:`, error);
             }
        }
        
        if (this.shadowEffect && this.shadowEffect.scene) {
            try {
                this.shadowEffect.setVisible(false);
            } catch (error) {
                console.error(`unhighlight (${this.character.name}): Error hiding shadow:`, error);
            }
        }
    }

    /**
     * Clean up sprite resources
     */
    destroy() {
         console.log(`CharacterSprite destroy: Cleaning up sprite for ${this.character?.name || 'Unknown'}`);
        // Remove from global reference
        if (window.characterSprites && this.character && this.character.name) {
            // Only delete if it's the same instance (less critical now but good practice)
            if(window.characterSprites[this.character.name] === this) {
                 delete window.characterSprites[this.character.name];
            }
        }

        // Clean up action indicator
        if (this.actionIndicator) {
            try {
                this.actionIndicator.destroy();
                console.log(`CharacterSprite destroy: Action indicator destroyed for ${this.character?.name || 'Unknown'}`);
            } catch (error) {
                console.error(`CharacterSprite destroy: Error destroying action indicator for ${this.character?.name || 'Unknown'}:`, error);
            }
            this.actionIndicator = null;
        }
        
        // Stop any active tweens
        if (this.glowTween) {
            this.glowTween.stop();
            this.glowTween = null;
        }

        // Clean up and destroy container and its children
         if (this.container) {
             try {
                 this.container.destroy(true); // Pass true to destroy children
                 console.log(`CharacterSprite destroy: Container destroyed for ${this.character?.name || 'Unknown'}`);
             } catch (error) {
                  console.error(`CharacterSprite destroy: Error destroying container for ${this.character?.name || 'Unknown'}:`, error);
             }
             this.container = null; // Nullify reference
         }

         // Nullify other references
         this.scene = null;
         this.character = null;
         this.config = null;
         this.circle = null;
         this.characterImage = null;
         this.nameText = null;
         this.healthBarContainer = null;
         this.healthBar = null;
         this.healthBarBg = null;
         this.hpText = null;
         this.highlightEffect = null; // Ensure highlight is cleared too
         this.shadowEffect = null; // Clear shadow effect too
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CharacterSprite;
}

// Make available globally
window.CharacterSprite = CharacterSprite;

===== FILE: DirectBattleLog.js =====
/**
 * DirectBattleLog.js
 * A simplified battle log that displays text directly on screen
 * @version 0.5.0.14
 */
class DirectBattleLog {
    constructor(scene, x, y, width, options = {}) {
        try {
            this.scene = scene;
            this.x = x;
            this.y = y;
            this.width = width;
            this.maxHeight = options.maxHeight || scene.cameras.main.height * 0.5; // Default to half screen height
            
            // Default options
            this.options = {
                fontSize: 16,
                fontFamily: 'Arial',
                maxMessages: 30,
                lineSpacing: 2,
                backgroundColor: 0x000000,
                backgroundAlpha: 0.3,
                padding: 10,
                maxHeight: this.maxHeight, // Use the calculated max height
                ...options
            };
            
            // Store the max height
            this.maxHeight = this.options.maxHeight;
            
            // Message storage
            this.messages = [];
            
            // Add message queue properties
            this.messageQueue = [];
            this.isProcessingQueue = false;
            this.messageProcessingSpeed = 200; // Base speed in ms (reduced from 800ms for better responsiveness)
            this.messageProcessingPaused = false;
            
            // Create container for all text
            // Position container at the right edge at Y=350 (aligned with teams)
            this.container = this.scene.add.container(this.x, 350);
            
            // Text message colors
            this.messageTypes = {
                default: { color: '#ffffff' },
                info: { color: '#4dabff' },
                success: { color: '#5aff5a' },
                action: { color: '#ffee55' },
                error: { color: '#ff7777' },
                player: { color: '#66bbff' },
                enemy: { color: '#ff7777' },
                critical: { color: '#ff9900' },
                type: { color: '#66ffcc' }
            };
            
            // Create semi-transparent background
            if (this.options.backgroundColor) {
                this.background = this.scene.add.rectangle(
                    0, 0, 
                    this.width, 10, // Height will be dynamically set
                    this.options.backgroundColor,
                    this.options.backgroundAlpha
                ).setOrigin(0, 0);
                this.container.add(this.background);
            }
            
            // Add control button for pausing message flow
            this.addMessagePauseToggle();
            
            // Set up event connection
            this.connectToBattleBridge();
            
            console.log('DirectBattleLog: Initialized at', this.x, this.y);
        } catch (error) {
            console.error('Error initializing DirectBattleLog:', error);
            // Create a minimal fallback
            this.container = this.scene.add.container(x, y);
            this.messages = [];
            this.messageQueue = [];
            
            // Add simple text to indicate error
            const errorText = this.scene.add.text(
                0, 0, 
                'Battle Log Error - Check Console', 
                { fontSize: '14px', fill: '#ff0000' }
            );
            this.container.add(errorText);
        }
    }
    
    /**
     * Add toggle button for pausing/resuming message flow
     */
    addMessagePauseToggle() {
        try {
            // If we already have a toggle button, remove it first
            if (this.pauseToggle && this.pauseToggle.active) {
                this.pauseToggle.destroy();
            }
            
            // Important: Use local coordinates relative to container
            const toggleButton = this.scene.add.text(
                this.width - 30, 
                10,
                'â¸ï¸',  // Pause icon
                { 
                    fontSize: '18px', 
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    padding: { x: 5, y: 5 }
                }
            )
            .setInteractive({ useHandCursor: true })
            .on('pointerdown', () => {
                try {
                    this.messageProcessingPaused = !this.messageProcessingPaused;
                    toggleButton.setText(this.messageProcessingPaused ? 'â–¶ï¸' : 'â¸ï¸');
                    
                    if (!this.messageProcessingPaused && this.messageQueue.length > 0) {
                        this.processMessageQueue(); // Resume processing
                    }
                } catch (error) {
                    console.error('Error handling toggle button click:', error);
                }
            });
            
            // Store reference to the button object
            this.pauseToggle = toggleButton;
            
            // Add to container safely
            try {
                if (this.container && this.container.add) {
                    this.container.add(this.pauseToggle);
                }
            } catch (addError) {
                console.error('Error adding pause button to container:', addError);
            }
            
            return this.pauseToggle;
        } catch (error) {
            console.error('Error creating pause toggle button:', error);
            return null;
        }
    }
    
    /**
     * Connect to BattleBridge to receive events
     */
    connectToBattleBridge() {
        // Use the global accessor function to get the bridge instance
        this.battleBridge = window.getBattleBridge();
        
        if (this.battleBridge) {
            const bridge = this.battleBridge;
            
            // Add listener specifically for speed changes
            bridge.addEventListener(bridge.eventTypes.BATTLE_UI_INTERACTION, (data) => {
                if (data.action === 'speed_change' && data.speed) {
                    this.syncWithBattleSpeed(data.speed);
                }
            });
            
            // Connect to BATTLE_LOG events
            bridge.addEventListener(bridge.eventTypes.BATTLE_LOG, (data) => {
                try {
                    console.log('DirectBattleLog received BATTLE_LOG event:', data);
                    if (!data || !data.message) {
                        console.warn('DirectBattleLog: BATTLE_LOG event missing message data', data);
                        return;
                    }
                    this.addMessage(data.message, data.type || 'default');
                } catch (error) {
                    console.warn('Error handling BATTLE_LOG event:', error);
                }
            });
            
            // Listen for turn started
            bridge.addEventListener(bridge.eventTypes.TURN_STARTED, (data) => {
                try {
                    console.log('DirectBattleLog: TURN_STARTED event received', data);
                    this.addMessage(`Turn ${data.turnNumber}: ${data.currentCharacter.name}'s turn`, 'info');
                } catch (error) {
                    console.error('Error handling TURN_STARTED event:', error);
                }
            });
            
            // Listen for CHARACTER_ACTION events (newly added)
            bridge.addEventListener(bridge.eventTypes.CHARACTER_ACTION, (data) => {
                try {
                    console.log('DirectBattleLog: CHARACTER_ACTION event received', data);
                    
                    // Skip if missing critical data
                    if (!data.character || !data.action) return;
                    
                    const character = data.character;
                    const action = data.action;
                    const team = character.team === 'player' ? 'player' : 'enemy';
                    
                    // Different handling based on action type
                    if (action.type === 'attack') {
                        // Basic attack message
                        if (action.target) {
                            this.addMessage(`${character.name} attacks ${action.target.name}`, team);
                        }
                    } else if (action.name) {
                        // Ability usage
                        const targetText = action.target ? ` on ${action.target.name}` : '';
                        this.addMessage(`${character.name} uses ${action.name}${targetText}`, team);
                    }
                } catch (error) {
                    console.error('Error handling CHARACTER_ACTION event:', error);
                }
            });
            
            // Listen for abilities
            bridge.addEventListener(bridge.eventTypes.ABILITY_USED, (data) => {
                try {
                    console.log('DirectBattleLog: ABILITY_USED event received', data);
                    const team = data.source.team === 'player' ? 'player' : 'enemy';
                    
                    // Create more detailed message if targets are available
                    let targetText = '';
                    if (data.targets && data.targets.length > 0) {
                        if (data.targets.length === 1) {
                            targetText = ` on ${data.targets[0].name}`;
                        } else {
                            targetText = ` on multiple targets`;
                        }
                    }
                    
                    this.addMessage(`${data.source.name} uses ${data.ability.name}${targetText}`, team);
                } catch (error) {
                    console.error('Error handling ABILITY_USED event:', error);
                }
            });
            
            // Listen for damage
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DAMAGED, (data) => {
                try {
                    console.log('DirectBattleLog: CHARACTER_DAMAGED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Special handling for reflected damage
                    const isReflected = data.result?.damageType === 'reflected';
                    const damageSource = isReflected ? 'reflected damage from' : 'damage';
                    const sourceName = data.source ? ` from ${data.source.name}` : '';
                    
                    if (isReflected) {
                        this.addMessage(`${data.target.name} takes ${data.amount} ${damageSource} ${data.source.name} (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                    } else {
                        this.addMessage(`${data.target.name} takes ${data.amount} ${damageSource}${sourceName} (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                    }
                } catch (error) {
                    console.error('Error handling CHARACTER_DAMAGED event:', error);
                }
            });
            
            // Listen for healing
            bridge.addEventListener(bridge.eventTypes.CHARACTER_HEALED, (data) => {
                try {
                    console.log('DirectBattleLog: CHARACTER_HEALED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Include source if available
                    const sourceName = data.source ? ` by ${data.source.name}` : '';
                    this.addMessage(`${data.target.name} is healed for ${data.amount} HP${sourceName} (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                } catch (error) {
                    console.error('Error handling CHARACTER_HEALED event:', error);
                }
            });
            
            // Listen for passive triggers (newly added)
            bridge.addEventListener(bridge.eventTypes.PASSIVE_TRIGGERED, (data) => {
                try {
                    console.log('DirectBattleLog: PASSIVE_TRIGGERED event received', data);
                    
                    if (!data.character) return;
                    
                    const team = data.character.team === 'player' ? 'player' : 'enemy';
                    const passiveName = data.result?.message || 'passive ability triggered';
                    
                    this.addMessage(`${data.character.name}'s ${passiveName}`, team);
                } catch (error) {
                    console.error('Error handling PASSIVE_TRIGGERED event:', error);
                }
            });
            
            // Listen for status effects - already implemented
            bridge.addEventListener(bridge.eventTypes.STATUS_EFFECT_APPLIED, (data) => {
                try {
                    // Defensive check for data structure
                    if (!data || !data.target) {
                        console.warn('Invalid data for STATUS_EFFECT_APPLIED event', data);
                        return;
                    }
                    
                    // Get team for coloring
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Get effect information - need defensive access
                    let effectName = 'status effect';
                    
                    // Try to get the status effect name from various possible properties
                    if (data.statusEffect && data.statusEffect.name) {
                        effectName = data.statusEffect.name;
                    } else if (data.effect && data.effect.name) {
                        effectName = data.effect.name;
                    } else if (data.effect && data.effect.definitionId) {
                        effectName = data.effect.definitionId;
                    } else if (data.effectId) {
                        effectName = data.effectId;
                    }
                    
                    // Make effect name more readable by removing prefix and capitalizing
                    if (effectName.startsWith('status_')) {
                        effectName = effectName.replace('status_', '');
                    }
                    effectName = effectName.charAt(0).toUpperCase() + effectName.slice(1);
                    
                    this.addMessage(`${data.target.name} is affected by ${effectName}`, team);
                } catch (error) {
                    console.warn('Error handling STATUS_EFFECT_APPLIED event:', error);
                    // Try a more basic message as fallback
                    if (data && data.target) {
                        this.addMessage(`${data.target.name} gained a status effect`, 'info');
                    }
                }
            });
            
            // Listen for status effects removed (newly added)
            bridge.addEventListener(bridge.eventTypes.STATUS_EFFECT_REMOVED, (data) => {
                try {
                    if (!data || !data.target || !data.effectId) {
                        console.warn('Invalid data for STATUS_EFFECT_REMOVED event', data);
                        return;
                    }
                    
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    let effectName = data.effectId;
                    
                    // Format the effect name
                    if (effectName.startsWith('status_')) {
                        effectName = effectName.replace('status_', '');
                    }
                    effectName = effectName.charAt(0).toUpperCase() + effectName.slice(1);
                    
                    this.addMessage(`${data.target.name}'s ${effectName} effect expired`, team);
                } catch (error) {
                    console.error('Error handling STATUS_EFFECT_REMOVED event:', error);
                }
            });
            
            // Listen for defeats
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DEFEATED, (data) => {
                const team = data.character.team === 'player' ? 'player' : 'enemy';
                this.addMessage(`${data.character.name} is defeated!`, team === 'player' ? 'error' : 'success');
            });
            
            // Listen for battle end
            bridge.addEventListener(bridge.eventTypes.BATTLE_ENDED, (data) => {
                let message = '';
                let type = 'info';
                
                switch (data.winner) {
                    case 'player':
                        message = 'Victory! Your team has won the battle!';
                        type = 'success';
                        break;
                    case 'enemy':
                        message = 'Defeat! Your team has lost the battle.';
                        type = 'error';
                        break;
                    default:
                        message = 'The battle ended in a draw.';
                        type = 'info';
                }
                
                this.addMessage(message, type);
            });
            
            // Setup direct forward from BattleManager messages via battleBridge
            // This creates a "catch-all" for messages that don't have specific event handlers
            this.setupMessageForwarder();
            
            // Add initialization messages
            this.addMessage('Battle log initialized', 'success');
            this.addMessage('Ready for battle', 'info');
            
            console.log('DirectBattleLog: Connected to BattleBridge successfully');
        } else {
            console.warn('DirectBattleLog: BattleBridge not found, will not receive battle events');
        }
    }
    
    /**
     * Setup forwarding from BattleManager messages to the battle log
     */
    setupMessageForwarder() {
        // Create special method for BattleManager to use
        if (this.scene.battleBridge && this.scene.battleBridge.battleManager) {
            const battleManager = this.scene.battleBridge.battleManager;
            
            // Store original logMessage function
            const originalLogMessage = battleManager.logMessage;
            
            // Replace with a version that also sends events to this log
            battleManager.logMessage = (message, type = 'default') => {
                // Call the original function
                originalLogMessage.call(battleManager, message, type);
                
                // Forward the message to our battle log
                this.scene.battleBridge.dispatchEvent(this.scene.battleBridge.eventTypes.BATTLE_LOG, {
                    message: message,
                    type: type
                });
            };
            
            console.log('DirectBattleLog: Setup message forwarding from BattleManager');
        }
    }
    
    /**
     * Synchronize battle log speed with game speed
     * @param {number} speed - Battle speed multiplier
     */
    syncWithBattleSpeed(speed) {
        // Adjust message processing speed based on battle speed
        // Using a logarithmic scale to make higher speeds less extreme
        const scaleFactor = Math.log10(speed + 1) + 0.5;
        this.messageProcessingSpeed = Math.round(200 / scaleFactor); // Reduced base speed from 800ms to 200ms
        
        console.log(`Battle log speed adjusted: ${speed}x battle speed = ${this.messageProcessingSpeed}ms per message`);
        
        // Handle message backlog detection - more aggressive handling
        if (this.messageQueue.length > 3) { // Reduced threshold from 5 to 3
            const backlogFactor = Math.min(5, this.messageQueue.length / 2); // Increased max factor from 3 to 5, more aggressive scaling
            this.messageProcessingSpeed = Math.max(50, this.messageProcessingSpeed / backlogFactor); // Reduced minimum from 150ms to 50ms
            console.log(`Message backlog detected (${this.messageQueue.length}), adjusted to: ${this.messageProcessingSpeed}ms`);
        }
    }
    
    /**
     * Process message queue
     */
    processMessageQueue() {
        if (this.messageQueue.length === 0 || this.messageProcessingPaused) {
            this.isProcessingQueue = false;
            return;
        }
        
        this.isProcessingQueue = true;
        
        // Process one message
        const message = this.messageQueue.shift();
        this.messages.push(message);
        
        // Limit message count
        if (this.messages.length > this.options.maxMessages) {
            this.messages.shift();
        }
        
        // Update display with animation for the newest message
        this.renderMessages(true);
        
        // Schedule next message with current speed
        this.scene.time.delayedCall(
            this.messageProcessingSpeed, 
            this.processMessageQueue, 
            [], 
            this
        );
    }
    
    /**
     * Add a message to the battle log
     */
    addMessage(message, type = 'default') {
        // Add to message queue (timestamps removed as requested)
        this.messageQueue.push({
            text: message,
            type: type
        });
        
        // Start processing if not already running and not paused
        if (!this.isProcessingQueue && !this.messageProcessingPaused && this.messageQueue.length > 0) {
            this.processMessageQueue();
        }
    }
    
    /**
     * Render all messages
     * @param {boolean} animate - Whether to animate the newest message
     */
    renderMessages(animate = false) {
        // Initialize all variables at function scope level so they're available throughout the method
        // This prevents reference errors when variables are accessed outside their declaration blocks
        let totalHeight = this.options.padding;
        let messagesToShow = [];
        let messageHeights = [];
        let totalHeightNeeded = 0;
        
        try {
            // Store current pause button state and position
            const pauseToggleState = this.messageProcessingPaused;
            const hadPauseToggle = !!this.pauseToggle;
            
            // Clear everything except the pause toggle to avoid issues
            if (this.pauseToggle) {
                // Remove the pause toggle from the container temporarily
                this.container.remove(this.pauseToggle, false); // false = don't destroy
            }
            
            // Now safely clear the container
            this.container.removeAll(true);
            
            // Recreate background if needed
            if (this.options.backgroundColor) {
                this.background = this.scene.add.rectangle(
                    0, 0, 
                    this.width, Math.min(this.maxHeight, 10), // Placeholder height, updated below and limited by maxHeight
                    this.options.backgroundColor,
                    this.options.backgroundAlpha
                ).setOrigin(0, 0);
                this.container.add(this.background);
            }
            
            // Readd the pause toggle if it existed, or create a new one
            if (hadPauseToggle && this.pauseToggle && !this.pauseToggle.destroyed) {
                // Re-add the existing toggle
                this.container.add(this.pauseToggle);
                // Ensure correct state is displayed
                this.pauseToggle.setText(pauseToggleState ? '\u25b6\ufe0f' : '\u23f8\ufe0f');
            } else {
                // Create a new toggle if needed
                this.addMessagePauseToggle();
                if (this.pauseToggle && pauseToggleState) {
                    // Restore previous pause state
                    this.messageProcessingPaused = pauseToggleState;
                    this.pauseToggle.setText('\u25b6\ufe0f');
                }
            }
        } catch (error) {
            console.error('Error in renderMessages preparations:', error);
            // If we encounter an error, try to recover by recreating the toggle
            if (!this.pauseToggle || this.pauseToggle.destroyed) {
                this.addMessagePauseToggle();
            }
        }
        
        try {
            // Track total height for background sizing
            totalHeight = this.options.padding;
            
            // Calculate available height for messages (subtracting top and bottom padding)
            const availableHeight = this.maxHeight - (this.options.padding * 2);
            
            // Reset arrays and counters
            messagesToShow = [];
            messageHeights = [];
            totalHeightNeeded = 0;
            
            // Measure all messages (starting from newest/last)
            for (let i = this.messages.length - 1; i >= 0; i--) {
                const message = this.messages[i];
                
                // Create temporary text to measure height (with proper wrapping)
                const tempText = this.scene.add.text(
                    0, 0,
                    `${message.text}`,
                    {
                        fontFamily: this.options.fontFamily,
                        fontSize: this.options.fontSize,
                        wordWrap: {
                            width: this.width - (this.options.padding * 2),
                            useAdvancedWrap: true
                        }
                    }
                );
                
                // Store the height measurement
                const messageHeight = tempText.height + this.options.lineSpacing;
                tempText.destroy(); // Remove temporary text
                
                // Check if adding this message would exceed available height
                if (totalHeightNeeded + messageHeight <= availableHeight) {
                    messagesToShow.unshift(message); // Add to beginning of array
                    messageHeights.unshift(messageHeight);
                    totalHeightNeeded += messageHeight;
                } else {
                    // No more space for messages
                    break;
                }
            }
        } catch (error) {
            console.error('Error measuring messages:', error);
            // Create empty arrays in case of error
            messagesToShow = [];
            messageHeights = [];
            totalHeightNeeded = 0;
        }
        
        try {
            // Defensive check to ensure messagesToShow is defined
            if (!messagesToShow) messagesToShow = [];
            
            // Reset total height for message positioning
            totalHeight = this.options.padding;
            
            // Now create actual text objects for messages that fit
            messagesToShow.forEach((message, index) => {
                try {
                    // Get color for this message type
                    const color = this.messageTypes[message.type]?.color || this.messageTypes.default.color;
                    
                    // Calculate position
                    const yPos = totalHeight;
                    
                    // Create text style
                    const textStyle = {
                        fontFamily: this.options.fontFamily,
                        fontSize: this.options.fontSize,
                        color: color,
                        wordWrap: {
                            width: this.width - (this.options.padding * 2),
                            useAdvancedWrap: true
                        },
                        stroke: '#000000',
                        strokeThickness: 1
                    };
                    
                    // Create text with timestamp
                    const text = this.scene.add.text(
                        this.options.padding,
                        yPos,
                        `${message.text}`,
                        textStyle
                    );
                    
                    // Add bold for important messages
                    if (message.type === 'action' || message.type === 'error' || message.type === 'success' || message.type === 'critical') {
                        text.setFontStyle('bold');
                    }
                    
                    // Add to container
                    this.container.add(text);
                    
                    // Update total height for next message
                    totalHeight += text.height + this.options.lineSpacing;
                } catch (textError) {
                    console.error('Error creating message text:', textError);
                }
            });
            
            // Update background height - capped at maxHeight
            if (this.background) {
                this.background.height = Math.min(totalHeight + this.options.padding, this.maxHeight);
            }
            
            // Add animation for the most recent message if requested
            if (animate && messagesToShow.length > 0 && this.container) {
                try {
                    // Find the most recent text object (it might not be the last one due to pause button)
                    let lastMessageText = null;
                    for (let i = this.container.length - 1; i >= 0; i--) {
                        const obj = this.container.getAt(i);
                        if (obj && obj.type === 'Text' && obj !== this.pauseToggle) {
                            lastMessageText = obj;
                            break;
                        }
                    }
                    
                    if (lastMessageText) {
                        // Start with larger scale and fade in
                        lastMessageText.setAlpha(0.7).setScale(1.05);
                        
                        // Create animation
                        this.scene.tweens.add({
                            targets: lastMessageText,
                            alpha: 1,
                            scale: 1,
                            duration: 300,
                            ease: 'Sine.easeOut'
                        });
                    }
                } catch (animError) {
                    console.error('Error animating latest message:', animError);
                }
            }
            
            // Make sure pause toggle is at the front
            if (this.pauseToggle && this.container) {
                try {
                    this.container.bringToTop(this.pauseToggle);
                } catch (error) {
                    console.error('Error bringing pause toggle to top:', error);
                }
            }
        } catch (renderError) {
            console.error('Error rendering messages:', renderError);
        }
    }
    
    /**
     * Clear all messages
     */
    clear() {
        this.messages = [];
        this.renderMessages();
    }
    
    /**
     * Destroy this battle log
     */
    destroy() {
        if (this.container) {
            this.container.destroy();
        }
    }
}

// Make globally accessible 
window.DirectBattleLog = DirectBattleLog;

===== FILE: TeamContainer.js =====
/**
 * TeamContainer.js
 * Manages a team of character sprites with proper positioning
 * (Added try...catch blocks for debugging)
 */
class TeamContainer {
    /**
     * Update a character's health in this team
     * @param {string|number} characterId - The character ID or name to update
     * @param {number} newHealth - The new health value
     * @param {number} maxHealth - The maximum health value
     * @returns {boolean} - True if a character was found and updated
     */
    updateCharacterHealth(characterId, newHealth, maxHealth) {
        console.log(`TeamContainer.updateCharacterHealth: Updating ${characterId} to health ${newHealth}/${maxHealth}`);
        
        // Check if characterSprites is valid
        if (!Array.isArray(this.characterSprites) || this.characterSprites.length === 0) {
            console.warn('TeamContainer.updateCharacterHealth: No character sprites available');
            return false;
        }
        
        // Log available characters for debugging
        console.log('Available characters in team:');
        this.characterSprites.forEach(sprite => {
            if (sprite && sprite.character) {
                console.log(`- ${sprite.character.name} (id: ${sprite.character.id}, uniqueId: ${sprite.character.uniqueId})`);
            }
        });
        
        // Try to find the character sprite that matches this character
        const sprite = this.characterSprites.find(sprite => {
            // Check for nulls/undefined first
            if (!sprite || !sprite.character) return false;
            
            // Try each identifier
            const matchesId = sprite.character.id !== undefined && sprite.character.id === characterId;
            const matchesName = sprite.character.name === characterId;
            const matchesUniqueId = sprite.character.uniqueId === characterId;
            
            // Log match attempts for debugging
            if (matchesId || matchesName || matchesUniqueId) {
                console.log(`Found match for ${characterId}: ${sprite.character.name}`);
            }
            
            return matchesId || matchesName || matchesUniqueId;
        });
        
        if (sprite) {
            console.log(`TeamContainer: Updating ${sprite.character.name}'s health to ${newHealth}/${maxHealth}`);
            sprite.updateHealth(newHealth, maxHealth);
            return true;
        }
        
        console.warn(`Could not find character sprite for ID/name: ${characterId}`);
        return false;
    }

    /**
     * Create a new team container
     * @param {Phaser.Scene} scene - The scene this container belongs to
     * @param {Array} team - Array of character objects
     * @param {boolean} isPlayerTeam - Whether this is the player's team
     * @param {Object} config - Configuration options
     */
    constructor(scene, team, isPlayerTeam, config = {}) {
        this.scene = scene;
        this.team = team;
        this.isPlayerTeam = isPlayerTeam;

        // Set up default config
        this.config = Object.assign({
            x: isPlayerTeam ? 300 : 900,
            y: 350,
            spacing: 180, // Original spacing
            characterScale: 1,
            interactive: true
        }, config);

        // The character sprites in this team
        this.characterSprites = [];

        // Create container
        try { // Added try for container creation
            this.container = scene.add.container(this.config.x, this.config.y);
        } catch (error) {
             console.error(`TeamContainer Constructor: Error creating Phaser container for team ${isPlayerTeam ? 'Player' : 'Enemy'} at (${this.config.x}, ${this.config.y}):`, error);
             // Attempt to recover or just log and potentially fail later
             // For now, let's try creating a default container
             if (!this.container) {
                  try { this.container = scene.add.container(0,0); } catch(e){ console.error("Failed fallback container creation too!"); }
             }
             // Propagate the error up if needed, or handle it here
             // throw error; // Optional: re-throw if it's critical
        }


        // Initialize character sprites - Wrapped call
        try {
            console.log(`TeamContainer: Initializing characters for team ${isPlayerTeam ? 'Player' : 'Enemy'}. Team size: ${this.team?.length || 0}`);
            this.initializeCharacters();
             console.log(`TeamContainer: Finished initializing characters for team ${isPlayerTeam ? 'Player' : 'Enemy'}. Sprites created: ${this.characterSprites.length}`);
        } catch (error) {
            console.error(`TeamContainer Constructor: Error calling initializeCharacters for team ${isPlayerTeam ? 'Player' : 'Enemy'}:`, error);
             // Depending on how critical this is, you might want to stop or show an error message
             // For now, we log the error. The team might be partially rendered or empty.
        }

        // Make available globally for debugging
        if (!window.teamContainers) window.teamContainers = {player: null, enemy: null};
        window.teamContainers[isPlayerTeam ? 'player' : 'enemy'] = this;
    }

    /**
     * Initialize characters within the team
     */
    initializeCharacters() {
        // Ensure team is an array
        if (!Array.isArray(this.team)) {
            console.error('TeamContainer initializeCharacters: this.team is not an array!', this.team);
            this.team = []; // Attempt recovery
        }

        // Calculate positions for each character
        const positions = this.calculatePositions(this.team.length);
        console.log(`TeamContainer initializeCharacters: Calculated ${positions.length} positions.`);


        // Create character sprites
        this.team.forEach((character, index) => {
            // Add team property to character if not set
             if (!character) {
                 console.error(`TeamContainer initializeCharacters: Found null/undefined character at index ${index}. Skipping.`);
                 return; // Skip this iteration
             }

             if (!character.team) {
                character.team = this.isPlayerTeam ? 'player' : 'enemy';
            }

            // Set initial HP if not set
             if (!character.stats) {
                 console.error(`TeamContainer initializeCharacters: Character ${character.name || 'Unknown'} has no stats! Assigning default HP.`);
                 character.stats = { hp: 1 }; // Minimal default stats
             }
            if (typeof character.currentHp === 'undefined') {
                character.currentHp = character.stats.hp;
            }

            // --- Added try...catch around CharacterSprite instantiation ---
            try {
                 console.log(`TeamContainer initializeCharacters: Creating CharacterSprite for ${character.name || 'Unknown ID ' + character.id} at index ${index}.`);
                const sprite = new CharacterSprite(this.scene, character, {
                    x: positions[index].x,
                    y: positions[index].y,
                    scale: this.config.characterScale,
                    interactive: this.config.interactive
                });
                 console.log(`TeamContainer initializeCharacters: Successfully created sprite for ${character.name || 'Unknown ID ' + character.id}.`);

                // Add to our array ONLY if creation succeeded
                this.characterSprites.push(sprite);
                 // IMPORTANT: Add sprite's container to the TeamContainer's container
                 if (this.container && sprite.container) {
                      this.container.add(sprite.container);
                 } else {
                      console.error(`TeamContainer initializeCharacters: Cannot add sprite container for ${character.name}. Main container or sprite container is missing.`);
                 }

            } catch (error) {
                console.error(`TeamContainer initializeCharacters: Error creating CharacterSprite for character: ${character.name || 'Unknown ID ' + character.id} at index ${index}.`, error);
                 // Continue to next character instead of stopping the whole loop
            }
            // --- End of added try...catch ---
        });
         console.log(`TeamContainer initializeCharacters: Finished loop. Total sprites in array: ${this.characterSprites.length}. Sprites added to Phaser container: ${this.container?.list.length || 0}`);
    }

    /**
     * Calculate positions for characters based on team size
     * @param {number} teamSize - Number of characters in the team
     * @returns {Array} - Array of {x,y} positions
     */
    calculatePositions(teamSize) {
         if (typeof teamSize !== 'number' || teamSize < 0) {
             console.warn(`TeamContainer calculatePositions: Invalid teamSize (${teamSize}). Defaulting to 0.`);
             teamSize = 0;
         }
        const positions = [];
        const spacing = this.config.spacing;

        // Vertical positioning with team centered
        const startY = -(spacing * (teamSize - 1)) / 2;

        for (let i = 0; i < teamSize; i++) {
            positions.push({
                x: 0,
                y: startY + (i * spacing)
            });
        }

        return positions;
    }

    /**
     * Get a character sprite by name
     * @param {string} name - Character name
     * @returns {CharacterSprite|null} - The character sprite or null
     */
    getCharacterSpriteByName(name) {
         // Add safety check
         if (!Array.isArray(this.characterSprites)) return null;
        return this.characterSprites.find(sprite => sprite && sprite.character && sprite.character.name === name);
    }

    /**
     * Get a character sprite by index
     * @param {number} index - Index in the team
     * @returns {CharacterSprite|null} - The character sprite or null
     */
    getCharacterSpriteByIndex(index) {
         // Add safety check
         if (!Array.isArray(this.characterSprites)) return null;
        return index >= 0 && index < this.characterSprites.length
            ? this.characterSprites[index]
            : null;
    }

    /**
     * Update all character sprites in the team
     */
    update() {
         // Add safety check
         if (!Array.isArray(this.characterSprites)) return;
        this.characterSprites.forEach(sprite => {
             // Check if sprite exists and has an update method
             if (sprite && typeof sprite.update === 'function') {
                  sprite.update();
             }
        });
    }

    /**
     * Show turn indicator for a specific character
     * @param {string|number} identifier - Character name or index
     */
    showTurnIndicator(identifier) {
        let sprite;

        if (typeof identifier === 'number') {
            sprite = this.getCharacterSpriteByIndex(identifier);
        } else {
            sprite = this.getCharacterSpriteByName(identifier);
        }

        if (sprite) {
            // Unhighlight all others first
             if (Array.isArray(this.characterSprites)){
                 this.characterSprites.forEach(s => {
                      if(s && typeof s.unhighlight === 'function') s.unhighlight()
                 });
            }
            // Highlight the selected character
            if (typeof sprite.highlight === 'function') sprite.highlight();
        }
    }

    /**
     * Clear turn indicators from all characters in the team
     */
    clearTurnIndicators() {
        // Add safety check
        if (!Array.isArray(this.characterSprites)) return;
        
        // Unhighlight all characters in this team
        this.characterSprites.forEach(sprite => {
            if (sprite && typeof sprite.unhighlight === 'function') {
                sprite.unhighlight();
            }
        });
        
        console.log(`TeamContainer clearTurnIndicators: Cleared turn indicators for all characters in team ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
    }

    /**
     * Clean up resources
     */
    destroy() {
        console.log(`TeamContainer destroy: Cleaning up team ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
        // Remove from global reference
        if (window.teamContainers) {
            window.teamContainers[this.isPlayerTeam ? 'player' : 'enemy'] = null;
        }

        // Destroy all character sprites
         if (Array.isArray(this.characterSprites)) {
             this.characterSprites.forEach(sprite => {
                  if (sprite && typeof sprite.destroy === 'function') sprite.destroy()
             });
             this.characterSprites = []; // Clear the array
         }

        // Destroy container
        if (this.container) {
             try {
                 this.container.destroy();
                 console.log(`TeamContainer destroy: Container destroyed for team ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
             } catch(error) {
                  console.error(`TeamContainer destroy: Error destroying container for team ${this.isPlayerTeam ? 'Player' : 'Enemy'}:`, error);
             }
             this.container = null; // Nullify reference
        }
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TeamContainer;
}

// Make available globally
window.TeamContainer = TeamContainer;

===== FILE: TurnIndicator.js =====
/**
 * TurnIndicator.js
 * A floor marker component that highlights the active character's position during battle
 * 
 * @version 0.5.1.4
 */

export default class TurnIndicator extends Phaser.GameObjects.Graphics {
    /**
     * Constructor for TurnIndicator
     * @param {Phaser.Scene} scene - The scene this indicator belongs to
     */
    constructor(scene) {
        super(scene);
        scene.add.existing(this);
        this.setAlpha(0);
        this.scene = scene;
        this.fadeTween = null;
    }

    /**
     * Show the indicator at specified position with given color
     * @param {number} x - X position for the indicator
     * @param {number} y - Y position for the indicator
     * @param {number} color - Color of the indicator (hexadecimal)
     * @param {number} duration - Duration of fade-in animation in milliseconds
     */
    showAt(x, y, color, duration) {
        if (this.fadeTween) {
            this.fadeTween.stop();
            this.fadeTween = null;
        }

        this.clear();
        this.setPosition(x, y);
        
        // Create a 3D-like circle with gradient and shadow
        const radius = 32;
        
        // Draw shadow slightly offset
        this.fillStyle(0x000000, 0.3);
        this.fillEllipse(2, 4, radius + 2, radius * 0.5 + 2);
        
        // Draw flattened ellipse for 3D effect
        const gradientColor = Phaser.Display.Color.IntegerToColor(color);
        const darkerColor = Phaser.Display.Color.GetDarker(gradientColor, 40).color;
        
        // Fill with gradient from center to edge
        this.fillGradientStyle(color, color, darkerColor, darkerColor, 1);
        this.fillEllipse(0, 0, radius, radius * 0.5);
        
        // Add a subtle rim light
        this.lineStyle(1, 0xffffff, 0.4);
        this.strokeEllipse(0, 0, radius, radius * 0.5);

        this.fadeTween = this.scene.tweens.add({
            targets: this,
            alpha: 0.7,
            duration: duration,
            ease: 'Linear'
        });
    }

    /**
     * Hide the indicator with a fade out animation
     * @param {number} duration - Duration of fade-out animation in milliseconds
     */
    hide(duration) {
        if (this.fadeTween) {
            this.fadeTween.stop();
            this.fadeTween = null;
        }

        this.fadeTween = this.scene.tweens.add({
            targets: this,
            alpha: 0,
            duration: duration,
            ease: 'Linear'
        });
    }

    /**
     * Clean up the indicator resources
     * @param {boolean} fromScene - Whether this is being destroyed by a scene
     */
    destroy(fromScene) {
        if (this.fadeTween) {
            this.fadeTween.stop();
            this.fadeTween = null;
        }
        super.destroy(fromScene);
    }
}

===== FILE: Button.js =====
/**
 * Button Component
 * A reusable button component for Phaser UI
 */
class Button extends Phaser.GameObjects.Container {
    /**
     * Create a new button
     * @param {Phaser.Scene} scene - The scene this button belongs to
     * @param {number} x - The x position
     * @param {number} y - The y position
     * @param {string} text - The button text
     * @param {Object} style - The button style
     * @param {Function} callback - The callback function
     */
    constructor(scene, x, y, text, style = {}, callback = null) {
        super(scene, x, y);
        
        // Default style
        this.style = {
            width: style.width || 200,
            height: style.height || 50,
            color: style.color || 0x3742fa,
            hoverColor: style.hoverColor || 0x2536e0,
            disabledColor: style.disabledColor || 0x596275,
            textColor: style.textColor || '#ffffff',
            fontSize: style.fontSize || '18px',
            fontFamily: style.fontFamily || 'Arial',
            cornerRadius: style.cornerRadius || 8,
            ...style
        };
        
        // Create background
        this.background = scene.add.rectangle(0, 0, this.style.width, this.style.height, this.style.color)
            .setOrigin(0.5)
            .setInteractive({ useHandCursor: true });
        
        // Round corners if specified
        if (this.style.cornerRadius > 0) {
            this.background.setRoundedRectangle(
                this.style.width,
                this.style.height,
                this.style.cornerRadius
            );
        }
        
        // Create text
        this.text = scene.add.text(0, 0, text, {
            fontFamily: this.style.fontFamily,
            fontSize: this.style.fontSize,
            fill: this.style.textColor,
            align: 'center'
        }).setOrigin(0.5);
        
        // Add to container
        this.add([this.background, this.text]);
        
        // Add to scene
        scene.add.existing(this);
        
        // Set up events
        this.setupEvents(callback);
        
        // Set initial state
        this.setEnabled(true);
    }
    
    /**
     * Set up button events
     * @param {Function} callback - The callback function
     */
    setupEvents(callback) {
        // Hover effects
        this.background.on('pointerover', () => {
            if (this.enabled) {
                this.background.fillColor = this.style.hoverColor;
                
                // Scale effect
                this.scene.tweens.add({
                    targets: this,
                    scaleX: 1.05,
                    scaleY: 1.05,
                    duration: 100,
                    ease: 'Power1'
                });
            }
        });
        
        this.background.on('pointerout', () => {
            if (this.enabled) {
                this.background.fillColor = this.style.color;
                
                // Reset scale
                this.scene.tweens.add({
                    targets: this,
                    scaleX: 1,
                    scaleY: 1,
                    duration: 100,
                    ease: 'Power1'
                });
            }
        });
        
        // Click effect
        this.background.on('pointerdown', () => {
            if (this.enabled) {
                // Play sound if available
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
                
                // Scale down effect
                this.scene.tweens.add({
                    targets: this,
                    scaleX: 0.95,
                    scaleY: 0.95,
                    duration: 50,
                    ease: 'Power1',
                    yoyo: true,
                    onComplete: () => {
                        // Execute callback
                        if (callback) {
                            callback();
                        }
                    }
                });
            }
        });
    }
    
    /**
     * Set the button text
     * @param {string} text - The new button text
     */
    setText(text) {
        this.text.setText(text);
        return this;
    }
    
    /**
     * Enable or disable the button
     * @param {boolean} enabled - Whether the button should be enabled
     */
    setEnabled(enabled) {
        this.enabled = enabled;
        
        if (enabled) {
            this.background.fillColor = this.style.color;
            this.text.setAlpha(1);
            this.background.input.cursor = 'pointer';
        } else {
            this.background.fillColor = this.style.disabledColor;
            this.text.setAlpha(0.6);
            this.background.input.cursor = 'default';
        }
        
        return this;
    }
}


===== FILE: Panel.js =====
/**
 * Panel Component
 * A reusable panel/container component for Phaser UI
 */
class Panel extends Phaser.GameObjects.Container {
    /**
     * Create a new panel
     * @param {Phaser.Scene} scene - The scene this panel belongs to
     * @param {number} x - The x position
     * @param {number} y - The y position
     * @param {number} width - The panel width
     * @param {number} height - The panel height
     * @param {Object} style - The panel style
     */
    constructor(scene, x, y, width, height, style = {}) {
        super(scene, x, y);
        
        this.width = width;
        this.height = height;
        
        // Default style
        this.style = {
            backgroundColor: style.backgroundColor || 0x232a40,
            borderColor: style.borderColor || 0x596275,
            borderWidth: style.borderWidth || 0,
            alpha: style.alpha !== undefined ? style.alpha : 1,
            cornerRadius: style.cornerRadius || 8,
            shadow: style.shadow !== undefined ? style.shadow : true,
            shadowColor: style.shadowColor || 0x000000,
            shadowAlpha: style.shadowAlpha || 0.5,
            shadowBlur: style.shadowBlur || 10,
            shadowOffsetX: style.shadowOffsetX || 0,
            shadowOffsetY: style.shadowOffsetY || 5,
            ...style
        };
        
        // Create the panel background
        this.createBackground();
        
        // Add to scene
        scene.add.existing(this);
    }
    
    /**
     * Create the panel background
     */
    createBackground() {
        // Add shadow first if enabled
        if (this.style.shadow) {
            this.shadow = this.scene.add.rectangle(
                this.style.shadowOffsetX,
                this.style.shadowOffsetY,
                this.width,
                this.height,
                this.style.shadowColor,
                this.style.shadowAlpha
            ).setOrigin(0.5);
            
            // Apply corner radius to shadow if needed
            if (this.style.cornerRadius > 0) {
                this.shadow.setRoundedRectangle(
                    this.width,
                    this.height,
                    this.style.cornerRadius
                );
            }
            
            // Add blur effect if supported
            if (this.shadow.postFX) {
                this.shadow.postFX.addBlur(0, 0, this.style.shadowBlur, this.style.shadowBlur, 0x000000, 1);
            }
            
            this.add(this.shadow);
        }
        
        // Create the main background
        this.background = this.scene.add.rectangle(
            0,
            0,
            this.width,
            this.height,
            this.style.backgroundColor,
            this.style.alpha
        ).setOrigin(0.5);
        
        // Apply corner radius if needed
        if (this.style.cornerRadius > 0) {
            this.background.setRoundedRectangle(
                this.width,
                this.height,
                this.style.cornerRadius
            );
        }
        
        this.add(this.background);
        
        // Add border if needed
        if (this.style.borderWidth > 0) {
            this.border = this.scene.add.rectangle(
                0,
                0,
                this.width,
                this.height,
                this.style.borderColor
            ).setOrigin(0.5)
            .setStrokeStyle(this.style.borderWidth, this.style.borderColor);
            
            // Apply corner radius to border
            if (this.style.cornerRadius > 0) {
                this.border.setRoundedRectangle(
                    this.width,
                    this.height,
                    this.style.cornerRadius
                );
            }
            
            this.add(this.border);
        }
    }
    
    /**
     * Add a title to the panel
     * @param {string} text - The title text
     * @param {Object} style - Text style options
     * @returns {Phaser.GameObjects.Text} The created text object
     */
    addTitle(text, style = {}) {
        // Default title style
        const titleStyle = {
            fontFamily: style.fontFamily || 'Arial',
            fontSize: style.fontSize || '24px',
            fill: style.fill || '#ffffff',
            align: style.align || 'center',
            ...style
        };
        
        // Create title text
        this.title = this.scene.add.text(
            0,
            -this.height / 2 + 20,
            text,
            titleStyle
        ).setOrigin(0.5, 0);
        
        this.add(this.title);
        return this.title;
    }
    
    /**
     * Set the background color
     * @param {number} color - The color value
     * @param {number} alpha - The alpha value
     */
    setBackgroundColor(color, alpha = 1) {
        this.background.fillColor = color;
        this.background.fillAlpha = alpha;
        return this;
    }
    
    /**
     * Make the panel interactive
     * @param {Function} callback - Callback function when clicked
     */
    setInteractive(callback = null) {
        this.background.setInteractive({ useHandCursor: true });
        
        if (callback) {
            this.background.on('pointerdown', callback);
        }
        
        return this;
    }
    
    /**
     * Add a fade-in animation to the panel
     * @param {number} duration - The animation duration in milliseconds
     */
    fadeIn(duration = 300) {
        this.alpha = 0;
        this.scene.tweens.add({
            targets: this,
            alpha: 1,
            duration: duration,
            ease: 'Power2'
        });
        return this;
    }
    
    /**
     * Add a slide-in animation to the panel
     * @param {string} direction - The direction to slide from ('up', 'down', 'left', 'right')
     * @param {number} distance - The slide distance in pixels
     * @param {number} duration - The animation duration in milliseconds
     */
    slideIn(direction = 'down', distance = 100, duration = 300) {
        const initialPosition = { x: this.x, y: this.y };
        
        switch (direction) {
            case 'up':
                this.y = initialPosition.y + distance;
                break;
            case 'down':
                this.y = initialPosition.y - distance;
                break;
            case 'left':
                this.x = initialPosition.x + distance;
                break;
            case 'right':
                this.x = initialPosition.x - distance;
                break;
        }
        
        this.scene.tweens.add({
            targets: this,
            x: initialPosition.x,
            y: initialPosition.y,
            duration: duration,
            ease: 'Power2'
        });
        
        return this;
    }
}


===== FILE: CoordinateDisplay.js =====
/**
 * CoordinateDisplay.js
 * Provides a coordinate grid overlay and mouse position tracking for debugging
 */

class CoordinateDisplay {
    /**
     * @param {Phaser.Scene} scene - The scene to attach to
     * @param {Object} config - Configuration options
     */
    constructor(scene, config = {}) {
        this.scene = scene;
        
        // Configuration with defaults
        this.config = {
            gridSpacing: config.gridSpacing || 50,
            showGrid: config.showGrid !== undefined ? config.showGrid : true,
            showCoordinates: config.showCoordinates !== undefined ? config.showCoordinates : true,
            gridColor: config.gridColor || 0x00ff00,
            gridAlpha: config.gridAlpha || 0.3,
            textColor: config.textColor || '#00ff00',
            fontSize: config.fontSize || 12,
            fontFamily: config.fontFamily || 'Arial',
            backgroundColor: config.backgroundColor || '#000000',
            backgroundAlpha: config.backgroundAlpha || 0.7,
            enabled: config.enabled !== undefined ? config.enabled : true
        };
        
        // Graphics objects
        this.gridContainer = null;
        this.grid = null;
        this.coordinateText = null;
        
        // State tracking
        this.enabled = this.config.enabled;
        
        // Create the display elements
        this.create();
        
        // Make available globally for debugging
        window.CoordinateDisplay = this;
    }
    
    /**
     * Create the grid and coordinate display
     */
    create() {
        // Create a container to hold grid graphics and text labels
        this.gridContainer = this.scene.add.container();
        this.gridContainer.setDepth(1000); // Ensure it's above other elements
        
        // Create the grid graphics object
        this.grid = this.scene.add.graphics();
        this.gridContainer.add(this.grid); // Add graphics to container
        
        // Create coordinate text
        this.coordinateText = this.scene.add.text(10, 10, 'X: 0 Y: 0', {
            fontFamily: this.config.fontFamily,
            fontSize: this.config.fontSize,
            color: this.config.textColor,
            backgroundColor: this.config.backgroundColor + Math.floor(this.config.backgroundAlpha * 255).toString(16).padStart(2, '0'),
            padding: { x: 5, y: 2 }
        });
        this.coordinateText.setDepth(1001); // Above grid
        this.coordinateText.setScrollFactor(0); // Fixed to camera
        
        // Set initial visibility
        this.gridContainer.visible = this.config.showGrid && this.enabled;
        this.coordinateText.visible = this.config.showCoordinates && this.enabled;
        
        // Draw the initial grid
        this.drawGrid();
        
        // Add mouse move listener for coordinate tracking
        this.scene.input.on('pointermove', this.updateCoordinates, this);
        
        // Add keyboard shortcut for toggling (Ctrl+G)
        this.scene.input.keyboard.on('keydown-G', (event) => {
            if (this.scene.input.keyboard.checkModifierKey(event, 'ctrl')) {
                this.toggle();
            }
        });
        
        console.log('CoordinateDisplay: Created');
    }
    
    /**
     * Draw the coordinate grid
     */
    drawGrid() {
        // Clear any existing grid
        this.grid.clear();
        
        if (!this.config.showGrid || !this.enabled) return;
        
        // Set line style
        this.grid.lineStyle(1, this.config.gridColor, this.config.gridAlpha);
        
        // Get scene dimensions
        const width = this.scene.cameras.main.width;
        const height = this.scene.cameras.main.height;
        
        // Draw vertical lines
        for (let x = 0; x < width; x += this.config.gridSpacing) {
            this.grid.beginPath();
            this.grid.moveTo(x, 0);
            this.grid.lineTo(x, height);
            this.grid.strokePath();
            
            // Add coordinate label for x
            if (x > 0) {
                const text = this.scene.add.text(x, 0, x.toString(), {
                    fontFamily: this.config.fontFamily,
                    fontSize: 10,
                    color: this.config.textColor
                });
                text.setDepth(1000);
                text.setOrigin(0.5, 0);
                this.gridContainer.add(text); // Add to container so it gets destroyed with grid
            }
        }
        
        // Draw horizontal lines
        for (let y = 0; y < height; y += this.config.gridSpacing) {
            this.grid.beginPath();
            this.grid.moveTo(0, y);
            this.grid.lineTo(width, y);
            this.grid.strokePath();
            
            // Add coordinate label for y
            if (y > 0) {
                const text = this.scene.add.text(0, y, y.toString(), {
                    fontFamily: this.config.fontFamily,
                    fontSize: 10,
                    color: this.config.textColor
                });
                text.setDepth(1000);
                text.setOrigin(0, 0.5);
                this.gridContainer.add(text); // Add to container so it gets destroyed with grid
            }
        }
    }
    
    /**
     * Update the coordinate display based on mouse position
     * @param {Phaser.Input.Pointer} pointer - The mouse/touch pointer
     */
    updateCoordinates(pointer) {
        if (!this.config.showCoordinates || !this.enabled) return;
        
        // Get pointer world position (taking into account camera scroll)
        const x = Math.floor(pointer.worldX);
        const y = Math.floor(pointer.worldY);
        
        // Update the text display
        this.coordinateText.setText(`X: ${x} Y: ${y}`);
    }
    
    /**
     * Toggle the coordinate display on/off
     */
    toggle() {
        this.enabled = !this.enabled;
        
        // Update visibility
        this.gridContainer.visible = this.config.showGrid && this.enabled;
        this.coordinateText.visible = this.config.showCoordinates && this.enabled;
        
        // Redraw grid if turning on
        if (this.enabled && this.config.showGrid) {
            this.drawGrid();
        }
        
        console.log(`CoordinateDisplay: ${this.enabled ? 'Enabled' : 'Disabled'}`);
    }
    
    /**
     * Set grid spacing
     * @param {number} spacing - Grid line spacing in pixels
     */
    setGridSpacing(spacing) {
        this.config.gridSpacing = spacing;
        this.drawGrid();
    }
    
    /**
     * Toggle grid visibility
     * @param {boolean} visible - Whether the grid should be visible
     */
    setGridVisible(visible) {
        this.config.showGrid = visible;
        this.gridContainer.visible = visible && this.enabled;
        if (visible && this.enabled) {
            this.drawGrid();
        }
    }
    
    /**
     * Toggle coordinate display visibility
     * @param {boolean} visible - Whether coordinates should be visible
     */
    setCoordinatesVisible(visible) {
        this.config.showCoordinates = visible;
        this.coordinateText.visible = visible && this.enabled;
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        // Remove event listeners
        this.scene.input.off('pointermove', this.updateCoordinates, this);
        
        // Destroy graphics objects
        if (this.gridContainer) this.gridContainer.destroy();
        if (this.coordinateText) this.coordinateText.destroy();
        
        console.log('CoordinateDisplay: Destroyed');
    }
}

// Make the class globally available
window.CoordinateDisplay = CoordinateDisplay;

===== FILE: DebugManager.js =====
/**
 * DebugManager.js
 * Central manager for debug tools and configuration
 */

class DebugManager {
    /**
     * @param {Phaser.Scene} scene - The scene to attach to
     * @param {Object} config - Configuration options
     */
    constructor(scene, config = {}) {
        this.scene = scene;
        
        // Default configuration with sensible presets
        this.config = {
            enabled: config.enabled !== undefined ? config.enabled : true,
            persistSettings: config.persistSettings !== undefined ? config.persistSettings : true,
            storageKey: config.storageKey || 'autobattler_debug_settings',
            showPanel: config.showPanel !== undefined ? config.showPanel : true,
            position: config.position || { x: 10, y: 10 },
            tools: config.tools ||

===== FILE: ObjectIdentifier.js =====
/**
 * ObjectIdentifier.js
 * Provides object identification and inspection for debugging
 */

class ObjectIdentifier {
    /**
     * @param {Phaser.Scene} scene - The scene to attach to
     * @param {Object} config - Configuration options
     */
    constructor(scene, config = {}) {
        this.scene = scene;
        
        // Configuration with defaults
        this.config = {
            enabled: config.enabled !== undefined ? config.enabled : true,
            showBounds: config.showBounds !== undefined ? config.showBounds : true,
            highlightColor: config.highlightColor || 0xffff00,
            highlightAlpha: config.highlightAlpha || 0.5,
            textColor: config.textColor || '#ffffff',
            backgroundColor: config.backgroundColor || '#000000',
            backgroundAlpha: config.backgroundAlpha || 0.7,
            fontSize: config.fontSize || 12,
            fontFamily: config.fontFamily || 'Arial',
            margin: config.margin || 5,
            padding: config.padding || { x: 5, y: 3 },
            showDepth: config.showDepth !== undefined ? config.showDepth : true,
            showPosition: config.showPosition !== undefined ? config.showPosition : true,
            showSize: config.showSize !== undefined ? config.showSize : true,
            showType: config.showType !== undefined ? config.showType : true,
            showName: config.showName !== undefined ? config.showName : true,
            onlyInteractive: config.onlyInteractive !== undefined ? config.onlyInteractive : false
        };
        
        // State tracking
        this.enabled = this.config.enabled;
        this.highlight = null;
        this.infoPanel = null;
        this.pinnedObjects = [];
        this.pinnedPanels = [];
        
        // Create the display elements
        this.create();
        
        // Make available globally for debugging
        window.ObjectIdentifier = this;
    }
    
    /**
     * Create the identifier components
     */
    create() {
        // Create a graphics object for highlighting objects
        this.highlight = this.scene.add.graphics();
        this.highlight.setDepth(999); // Ensure it's above most elements
        
        // Create info panel container for hover info
        this.infoPanel = this.scene.add.container(0, 0);
        this.infoPanel.setDepth(1000); // Above highlight
        
        // Background for the panel
        const infoBg = this.scene.add.graphics();
        this.infoPanel.add(infoBg);
        
        // Text for the panel
        const infoText = this.scene.add.text(
            this.config.padding.x,
            this.config.padding.y,
            'Hover over an object',
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize,
                color: this.config.textColor,
                wordWrap: { width: 300 }
            }
        );
        this.infoPanel.add(infoText);
        
        // Set panel properties
        this.infoPanel.bg = infoBg;
        this.infoPanel.text = infoText;
        this.infoPanel.visible = false;
        
        // Add keyboard shortcut for toggling (Ctrl+I)
        this.scene.input.keyboard.on('keydown-I', (event) => {
            if (this.scene.input.keyboard.checkModifierKey(event, 'ctrl')) {
                this.toggle();
            }
        });
        
        // Add mouse events for object identification
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        
        console.log('ObjectIdentifier: Created');
    }
    
    /**
     * Handle pointer movement
     * @param {Phaser.Input.Pointer} pointer - The pointer device
     */
    onPointerMove(pointer) {
        if (!this.enabled) return;
        
        // Hide highlight and info panel initially
        this.highlight.clear();
        this.infoPanel.visible = false;
        
        // Get objects under the pointer
        const objects = this.getObjectsUnderPointer(pointer);
        if (objects.length === 0) return;
        
        // Get the top object
        const object = objects[0];
        
        // Highlight the object
        this.highlightObject(object);
        
        // Show object information
        this.showObjectInfo(object, pointer.x, pointer.y);
    }
    
    /**
     * Handle pointer down (click)
     * @param {Phaser.Input.Pointer} pointer - The pointer device
     */
    onPointerDown(pointer) {
        if (!this.enabled || pointer.button !== 0) return;
        
        // Get objects under the pointer
        const objects = this.getObjectsUnderPointer(pointer);
        if (objects.length === 0) return;
        
        // Get the top object
        const object = objects[0];
        
        // Pin or unpin the object
        const existingIndex = this.pinnedObjects.indexOf(object);
        if (existingIndex !== -1) {
            // Object already pinned, remove it
            this.unpinObject(existingIndex);
        } else {
            // Pin the object
            this.pinObject(object);
        }
    }
    
    /**
     * Get objects under the pointer
     * @param {Phaser.Input.Pointer} pointer - The pointer device
     * @returns {Array} Array of game objects
     */
    getObjectsUnderPointer(pointer) {
        // Get all input-enabled objects under the pointer
        let objects = this.scene.input.hitTestPointer(pointer);
        
        // If we only want interactive objects or no objects were found with hitTest
        if (this.config.onlyInteractive || objects.length === 0) {
            return objects;
        }
        
        // For non-interactive objects, we need to do a custom check
        // Get all game objects in the scene
        const allObjects = this.scene.children.list;
        
        // Filter objects that intersect with the pointer position
        const nonInteractiveObjects = allObjects.filter(obj => {
            // Skip if it's not a game object or already in our list
            if (!obj.getBounds || objects.includes(obj)) return false;
            
            // Get object bounds
            const bounds = obj.getBounds();
            
            // Check if pointer is within bounds
            return bounds.contains(pointer.x, pointer.y);
        });
        
        // Merge and sort by depth (highest depth first)
        objects = [...objects, ...nonInteractiveObjects]
            .sort((a, b) => b.depth - a.depth);
        
        return objects;
    }
    
    /**
     * Highlight a game object
     * @param {Phaser.GameObjects.GameObject} object - The object to highlight
     */
    highlightObject(object) {
        if (!this.config.showBounds || !object.getBounds) return;
        
        // Get object bounds
        const bounds = object.getBounds();
        
        // Draw highlight rectangle
        this.highlight.lineStyle(2, this.config.highlightColor, 1);
        this.highlight.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
        
        // Fill with semi-transparent color
        this.highlight.fillStyle(this.config.highlightColor, this.config.highlightAlpha);
        this.highlight.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
    
    /**
     * Show information about a game object
     * @param {Phaser.GameObjects.GameObject} object - The object to show info for
     * @param {number} x - X position of the pointer
     * @param {number} y - Y position of the pointer
     */
    showObjectInfo(object, x, y) {
        // Build info text
        const infoLines = [];
        
        // Check if pinned
        const isPinned = this.pinnedObjects.includes(object);
        
        // Type
        if (this.config.showType) {
            const type = object.type || object.constructor.name;
            infoLines.push(`Type: ${type}`);
        }
        
        // Name
        if (this.config.showName && object.name) {
            infoLines.push(`Name: ${object.name}`);
        }
        
        // Position
        if (this.config.showPosition) {
            infoLines.push(`Position: (${Math.round(object.x)}, ${Math.round(object.y)})`);
        }
        
        // Size (if available)
        if (this.config.showSize && (object.width !== undefined && object.height !== undefined)) {
            infoLines.push(`Size: ${Math.round(object.width)} Ã— ${Math.round(object.height)}`);
        }
        
        // Depth (z-order)
        if (this.config.showDepth && object.depth !== undefined) {
            infoLines.push(`Depth: ${object.depth}`);
        }
        
        // Alpha (transparency)
        if (object.alpha !== undefined) {
            infoLines.push(`Alpha: ${object.alpha.toFixed(2)}`);
        }
        
        // Origin
        if (object.originX !== undefined && object.originY !== undefined) {
            infoLines.push(`Origin: (${object.originX.toFixed(2)}, ${object.originY.toFixed(2)})`);
        }
        
        // Visibility
        infoLines.push(`Visible: ${object.visible}`);
        
        // Interactive
        infoLines.push(`Interactive: ${object.input ? 'Yes' : 'No'}`);
        
        // Pin status
        infoLines.push(`Status: ${isPinned ? 'ðŸ“Œ Pinned' : 'Click to pin'}`);
        
        // Set info text
        const infoText = infoLines.join('\n');
        this.infoPanel.text.setText(infoText);
        
        // Resize background
        const bounds = this.infoPanel.text.getBounds();
        this.infoPanel.bg.clear();
        this.infoPanel.bg.fillStyle(
            parseInt(this.config.backgroundColor.replace('#', '0x')),
            this.config.backgroundAlpha
        );
        this.infoPanel.bg.fillRect(
            0,
            0,
            bounds.width + (this.config.padding.x * 2),
            bounds.height + (this.config.padding.y * 2)
        );
        
        // Position panel near pointer, but ensure it stays on screen
        let panelX = x + this.config.margin;
        let panelY = y + this.config.margin;
        
        // Adjust if panel would go off right edge
        if (panelX + bounds.width + (this.config.padding.x * 2) > this.scene.cameras.main.width) {
            panelX = x - this.config.margin - bounds.width - (this.config.padding.x * 2);
        }
        
        // Adjust if panel would go off bottom edge
        if (panelY + bounds.height + (this.config.padding.y * 2) > this.scene.cameras.main.height) {
            panelY = y - this.config.margin - bounds.height - (this.config.padding.y * 2);
        }
        
        // Position the panel
        this.infoPanel.setPosition(panelX, panelY);
        this.infoPanel.visible = true;
    }
    
    /**
     * Pin an object for continued display
     * @param {Phaser.GameObjects.GameObject} object - The object to pin
     */
    pinObject(object) {
        // Add to pinned objects
        this.pinnedObjects.push(object);
        
        // Create pinned panel
        const panel = this.scene.add.container(10, 10 + (this.pinnedPanels.length * 150));
        panel.setDepth(1001); // Above other interface elements
        
        // Background for the panel
        const bg = this.scene.add.graphics();
        panel.add(bg);
        
        // Title for the panel
        const title = this.scene.add.text(
            this.config.padding.x,
            this.config.padding.y,
            `ðŸ“Œ ${object.name || object.type || object.constructor.name}`,
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize + 2,
                color: this.config.textColor,
                fontStyle: 'bold'
            }
        );
        panel.add(title);
        
        // Object properties
        const propsText = this.scene.add.text(
            this.config.padding.x,
            title.height + (this.config.padding.y * 2),
            'Loading properties...',
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize,
                color: this.config.textColor,
                wordWrap: { width: 250 }
            }
        );
        panel.add(propsText);
        
        // Close button
        const closeBtn = this.scene.add.text(
            240,
            this.config.padding.y,
            'âœ–',
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize + 2,
                color: '#ff6666'
            }
        );
        closeBtn.setInteractive({ useHandCursor: true });
        closeBtn.on('pointerdown', () => {
            const index = this.pinnedObjects.indexOf(object);
            if (index !== -1) {
                this.unpinObject(index);
            }
        });
        panel.add(closeBtn);
        
        // Store references
        panel.bg = bg;
        panel.title = title;
        panel.propsText = propsText;
        panel.closeBtn = closeBtn;
        panel.object = object;
        
        // Update the panel content
        this.updatePinnedPanel(panel);
        
        // Add to pinned panels
        this.pinnedPanels.push(panel);
        
        // Rearrange panels
        this.arrangePinnedPanels();
    }
    
    /**
     * Unpin an object
     * @param {number} index - The index of the object to unpin
     */
    unpinObject(index) {
        // Remove object and panel
        this.pinnedObjects.splice(index, 1);
        const panel = this.pinnedPanels.splice(index, 1)[0];
        
        // Destroy the panel
        panel.destroy();
        
        // Rearrange remaining panels
        this.arrangePinnedPanels();
    }
    
    /**
     * Update a pinned panel's content
     * @param {Phaser.GameObjects.Container} panel - The panel to update
     */
    updatePinnedPanel(panel) {
        const object = panel.object;
        
        // Build properties text
        let propsLines = [];
        
        try {
            // Extract key properties
            const props = {
                // Position and dimensions
                x: Math.round(object.x),
                y: Math.round(object.y),
                width: object.width !== undefined ? Math.round(object.width) : 'N/A',
                height: object.height !== undefined ? Math.round(object.height) : 'N/A',
                
                // Visual properties
                visible: object.visible,
                alpha: object.alpha !== undefined ? object.alpha.toFixed(2) : 'N/A',
                depth: object.depth,
                
                // Transform
                scaleX: object.scaleX !== undefined ? object.scaleX.toFixed(2) : 'N/A',
                scaleY: object.scaleY !== undefined ? object.scaleY.toFixed(2) : 'N/A',
                rotation: object.rotation !== undefined ? (object.rotation * (180/Math.PI)).toFixed(1) + 'Â°' : 'N/A'
            };
            
            // Format properties
            Object.entries(props).forEach(([key, value]) => {
                propsLines.push(`${key}: ${value}`);
            });
            
            // For text objects, also show text content
            if (object.text !== undefined) {
                propsLines.push('');
                propsLines.push('Text: ' + (object.text.length > 30 ? object.text.substring(0, 30) + '...' : object.text));
            }
            
            // Panel content
            panel.propsText.setText(propsLines.join('\n'));
            
            // Resize background
            const titleBounds = panel.title.getBounds();
            const propsBounds = panel.propsText.getBounds();
            const width = Math.max(titleBounds.width, propsBounds.width) + (this.config.padding.x * 3) + panel.closeBtn.width;
            const height = titleBounds.height + propsBounds.height + (this.config.padding.y * 3);
            
            panel.bg.clear();
            panel.bg.fillStyle(parseInt(this.config.backgroundColor.replace('#', '0x')), this.config.backgroundAlpha);
            panel.bg.lineStyle(1, 0xffffff, 0.5);
            panel.bg.fillRoundedRect(0, 0, width, height, 5);
            panel.bg.strokeRoundedRect(0, 0, width, height, 5);
            
            // Update close button position
            panel.closeBtn.setPosition(width - this.config.padding.x - panel.closeBtn.width, this.config.padding.y);
        } catch (error) {
            console.error('Error updating pinned panel:', error);
            panel.propsText.setText('Error getting properties');
        }
    }
    
    /**
     * Arrange pinned panels vertically
     */
    arrangePinnedPanels() {
        this.pinnedPanels.forEach((panel, index) => {
            panel.setPosition(10, 10 + (index * 160));
        });
    }
    
    /**
     * Update pinned panels with current object properties
     */
    update() {
        if (!this.enabled) return;
        
        this.pinnedPanels.forEach(panel => {
            this.updatePinnedPanel(panel);
        });
    }
    
    /**
     * Toggle the object identifier on/off
     */
    toggle() {
        this.enabled = !this.enabled;
        
        // Update visibility
        this.highlight.visible = this.enabled;
        this.infoPanel.visible = false;
        
        // Update pinned panels
        this.pinnedPanels.forEach(panel => {
            panel.visible = this.enabled;
        });
        
        console.log(`ObjectIdentifier: ${this.enabled ? 'Enabled' : 'Disabled'}`);
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        // Remove event listeners
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.input.off('pointerdown', this.onPointerDown, this);
        
        // Destroy graphics objects
        if (this.highlight) this.highlight.destroy();
        if (this.infoPanel) this.infoPanel.destroy();
        
        // Destroy pinned panels
        this.pinnedPanels.forEach(panel => panel.destroy());
        this.pinnedPanels = [];
        this.pinnedObjects = [];
        
        console.log('ObjectIdentifier: Destroyed');
    }
}

// Make the class globally available
window.ObjectIdentifier = ObjectIdentifier;

===== FILE: BattleScene - Copy.js =====
/**
 * BattleScene.js
 * Main scene for battle visualization in Phaser
 * 
 * This scene displays the battle between player and enemy teams.
 * It provides the visual representation layer that connects to
 * the BattleManager for game logic processing.
 * 
 * @version 0.5.0.4
 */

class BattleScene extends Phaser.Scene {
    constructor() {
        super({
            key: 'BattleScene'
        });
        
        // Track initialization
        this.isInitialized = false;
        
        // Debug settings
        this.debug = {
            enabled: true,
            showCoordinates: false,
            showObjectInfo: false
        };
        
        // References to battle components
        this.components = {};
        
        // Make available globally for debugging
        window.BattleScene = this;
    }
    
    /**
     * Initialize the scene with battle configuration
     * @param {Object} data - Battle configuration data from TeamBuilder
     */
    init(data) {
        console.log('BattleScene init with data:', data);
        this.battleConfig = data || {};
        
        // Store references to teams
        this.playerTeam = this.battleConfig.playerTeam || [];
        this.enemyTeam = this.battleConfig.enemyTeam || [];
        
        // Track debug mode from URL parameter if present
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('debug')) {
            this.debug.enabled = urlParams.get('debug') !== 'false';
        }
    }
    
    /**
     * Preload any assets needed for the battle scene
     */
    preload() {
        console.log('BattleScene preload');
        
        // Load basic placeholder assets for testing
        try {
            // Try to load character circle image, but don't fail if not found
            this.load.image('character-circle', 'assets/images/icons/character-circle.png');
        } catch (error) {
            console.warn('Could not load character-circle image:', error);
        }
    }
    
    /**
     * Create the battle scene display
     * Sets up the basic scene elements and initializes the debug tools
     */
    create() {
        console.log('BattleScene create');
        
        try {
            // Create plain background for now
            this.createBackground();
            
            // Add scene title for testing
            this.createSceneTitle();
            
            // Add return button (temporary)
            this.createReturnButton();
            
            // Add test pattern to confirm rendering
            this.createTestPattern();
            
            // Add welcome message to confirm battle data
            this.createWelcomeMessage();
            
            // Initialize debug tools if available
            this.initializeDebugTools();
            
            // Initialize battle bridge if BattleManager is available
            this.initializeBattleBridge();
            
            // Create character teams for visualization
            this.createCharacterTeams();
            
            // Add debug controls panel
            this.createDebugPanel();
            
            // Mark as initialized
            this.isInitialized = true;
            
            console.log('BattleScene created successfully');
        } catch (error) {
            console.error('Error in BattleScene create:', error);
            this.showErrorMessage('Failed to initialize battle scene: ' + error.message);
        }
    }
    
    /**
     * Create character teams for visualization
     * Sets up player and enemy teams with CharacterSprite components
     */
    createCharacterTeams() {
        try {
            console.log('Creating character teams...');
            
            // Make sure team data is available
            if (!this.playerTeam || !this.enemyTeam) {
                console.warn('Team data not available, using sample data');
                
                // Create sample teams if needed
                this.playerTeam = this.playerTeam || [
                    { name: 'Aqualia', type: 'water', team: 'player', stats: { hp: 100 } }
                ];
                
                this.enemyTeam = this.enemyTeam || [
                    { name: 'Vaelgor', type: 'dark', team: 'enemy', stats: { hp: 100 } }
                ];
            }
            
            // Initialize character sprites for player team
            this.playerTeamContainer = new TeamContainer(
                this, 
                this.playerTeam, 
                true, // isPlayerTeam
                { x: 300, y: 350 }
            );
            
            // Initialize character sprites for enemy team if there are any enemies
            if (this.enemyTeam && this.enemyTeam.length > 0) {
                this.enemyTeamContainer = new TeamContainer(
                    this, 
                    this.enemyTeam, 
                    false, // isPlayerTeam
                    { x: 900, y: 350 }
                );
            }
            
            console.log('Character teams created');
            
            // Hide test pattern now that we have actual character sprites
            if (this.testPattern) {
                this.testPattern.setVisible(false);
            }
        } catch (error) {
            console.error('Error creating character teams:', error);
            this.showErrorMessage('Failed to create character teams: ' + error.message);
        }
    }
    
    /**
     * Clean up character teams
     */
    cleanupCharacterTeams() {
        try {
            if (this.playerTeamContainer) {
                this.playerTeamContainer.destroy();
                this.playerTeamContainer = null;
            }
            
            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.destroy();
                this.enemyTeamContainer = null;
            }
            
            console.log('Character teams cleaned up');
        } catch (error) {
            console.error('Error cleaning up character teams:', error);
        }
    }
    
    /**
     * Highlight the active character in the battle
     * @param {Object} character - The character to highlight
     */
    highlightActiveCharacter(character) {
        try {
            if (!character) return;
            
            const teamContainer = character.team === 'player' 
                ? this.playerTeamContainer 
                : this.enemyTeamContainer;
            
            if (!teamContainer) return;
            
            teamContainer.highlightCharacter(character.name);
        } catch (error) {
            console.error('Error highlighting active character:', error);
        }
    }
    
    /**
     * Show attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Function} onComplete - Callback when animation completes
     */
    showAttackAnimation(attacker, target, onComplete) {
        try {
            if (!attacker || !target) {
                if (onComplete) onComplete();
                return;
            }
            
            // Find sprites
            const attackerTeamContainer = attacker.team === 'player' 
                ? this.playerTeamContainer 
                : this.enemyTeamContainer;
                
            const targetTeamContainer = target.team === 'player' 
                ? this.playerTeamContainer 
                : this.enemyTeamContainer;
            
            if (!attackerTeamContainer || !targetTeamContainer) {
                if (onComplete) onComplete();
                return;
            }
            
            const attackerSprite = attackerTeamContainer.getCharacterSpriteByName(attacker.name);
            const targetSprite = targetTeamContainer.getCharacterSpriteByName(target.name);
            
            if (!attackerSprite || !targetSprite) {
                if (onComplete) onComplete();
                return;
            }
            
            attackerSprite.showAttackAnimation(targetSprite, onComplete);
        } catch (error) {
            console.error('Error showing attack animation:', error);
            if (onComplete) onComplete();
        }
    }
    
    /**
     * Show floating text above a character
     * @param {Object} character - Character to show text above
     * @param {string} text - Text to display
     * @param {Object} style - Text style options
     */
    showFloatingText(character, text, style = {}) {
        try {
            if (!character) return;
            
            const teamContainer = character.team === 'player' 
                ? this.playerTeamContainer 
                : this.enemyTeamContainer;
            
            if (!teamContainer) return;
            
            const sprite = teamContainer.getCharacterSpriteByName(character.name);
            
            if (!sprite) return;
            
            sprite.showFloatingText(text, style);
        } catch (error) {
            console.error('Error showing floating text:', error);
        }
    }
    
    /**
     * Create a test pattern to verify the scene is rendering correctly
     * This is a temporary visual element to confirm Phaser is working
     */
    createTestPattern() {
        try {
            // Create a container for test elements
            const testContainer = this.add.container(
                this.cameras.main.width / 2,
                this.cameras.main.height / 2
            );
            
            // Add colorful circles in different positions
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            const radius = 30;
            
            for (let i = 0; i < colors.length; i++) {
                const angle = (i / colors.length) * Math.PI * 2;
                const x = Math.cos(angle) * 100;
                const y = Math.sin(angle) * 100;
                
                const circle = this.add.circle(x, y, radius, colors[i], 0.8);
                testContainer.add(circle);
                
                // Add pulsing animation
                this.tweens.add({
                    targets: circle,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    duration: 500 + (i * 100),
                    yoyo: true,
                    repeat: -1
                });
            }
            
            // Add version text
            const versionText = this.add.text(0, 0, 'Battle Scene v0.5.0.4', {
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#ffffff',
                align: 'center'
            }).setOrigin(0.5);
            
            testContainer.add(versionText);
            
            // Store reference
            this.testPattern = testContainer;
            
            console.log('Test pattern created successfully');
        } catch (error) {
            console.error('Error creating test pattern:', error);
        }
    }
    
    /**
     * Create a welcome message showing battle data
     * Displays player team and enemy team information
     */
    createWelcomeMessage() {
        try {
            // Create player team summary
            const playerTeamNames = this.playerTeam.map(character => character.name).join(', ');
            const playerTeamText = `Player Team (${this.playerTeam.length}): ${playerTeamNames || 'None'}`;
            
            // Create enemy team summary
            const enemyTeamNames = this.enemyTeam.map(character => character.name).join(', ');
            const enemyTeamText = `Enemy Team (${this.enemyTeam.length}): ${enemyTeamNames || 'None'}`;
            
            // Create battle mode text
            const battleModeText = `Battle Mode: ${this.battleConfig.battleMode || 'Unknown'}`;
            
            // Create welcome message
            const welcomeText = this.add.text(
                this.cameras.main.width / 2,
                120,
                `Battle Scene Initialized!\n${playerTeamText}\n${enemyTeamText}\n${battleModeText}`,
                {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 2
                }
            ).setOrigin(0.5);
            
            // Add to scene
            this.welcomeMessage = welcomeText;
            
            console.log('Welcome message created successfully');
        } catch (error) {
            console.error('Error creating welcome message:', error);
        }
    }
    
    /**
     * Create the background for the battle scene
     */
    createBackground() {
        try {
            // Create a gradient background
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            
            // Create background rectangle
            this.add.rectangle(
                width / 2,
                height / 2,
                width,
                height,
                0x333344
            );
            
            // Add some visual interest with diagonal lines
            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0xffffff, 0.1);
            
            // Draw grid lines
            const spacing = 80;
            for (let i = 0; i < width + height; i += spacing) {
                graphics.moveTo(0, i);
                graphics.lineTo(i, 0);
            }
            
            graphics.strokePath();
            
            console.log('Background created successfully');
        } catch (error) {
            console.error('Error creating background:', error);
        }
    }
    
    /**
     * Create the scene title
     */
    createSceneTitle() {
        try {
            this.sceneTitle = this.add.text(
                this.cameras.main.width / 2,
                50,
                'Battle Scene',
                {
                    fontFamily: 'Arial',
                    fontSize: 36,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }
            ).setOrigin(0.5);
            
            // Add simple animation
            this.tweens.add({
                targets: this.sceneTitle,
                y: 40,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            console.log('Scene title created successfully');
        } catch (error) {
            console.error('Error creating scene title:', error);
        }
    }
    
    /**
     * Create the return button to go back to the TeamBuilder
     */
    
    /**
     * Update loop for the battle scene
     * Called by Phaser on every frame to update game state
     * 
     * @param {number} time - Current time in ms since game start
     * @param {number} delta - Time in ms since last update
     */
    update(time, delta) {
        try {
            // Update debug tools if enabled
            if (this.debug.enabled) {
                // Update object identifier if it exists
                if (this.objectIdentifier && typeof this.objectIdentifier.update === 'function') {
                    this.objectIdentifier.update();
                }
                
                // Update coordinate display if it exists
                if (this.coordinateDisplay && typeof this.coordinateDisplay.update === 'function') {
                    this.coordinateDisplay.update();
                }
            }
            
            // Update character teams if present
            if (this.playerTeamContainer) {
                this.playerTeamContainer.update();
            }
            
            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.update();
            }
        } catch (error) {
            console.error('Error in update loop:', error);
            // Don't show error messages here to avoid spamming the user
            // since this method is called many times per second
        }
    }
    
    /**
     * Scene shutdown handler
     * Clean up resources and listeners when the scene is stopped
     */
    shutdown() {
        console.log('BattleScene: Shutting down');
        
        try {
            // Clean up debug tools
            this.cleanupDebugTools();
            
            // Clean up battle bridge
            this.cleanupBattleBridge();
            
            // Clean up character teams
            this.cleanupCharacterTeams();
            
            // Clean up keyboard listeners
            if (this.input && this.input.keyboard) {
                this.input.keyboard.off('keydown-D', this.handleDebugKeypress, this);
            }
            
            // Clean up tweens
            this.tweens.killAll();
            
            // Clean up local references
            this.battleConfig = null;
            this.playerTeam = null;
            this.enemyTeam = null;
            this.components = {};
            
            console.log('BattleScene: Shut down successfully');
        } catch (error) {
            console.error('Error during scene shutdown:', error);
        }
    }
}
            
            // Update character teams if present
            if (this.playerTeamContainer) {
                this.playerTeamContainer.update();
            }
            
            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.update();
            }
        } catch (error) {
            console.error('Error in update loop:', error);
            // Don't show error messages here to avoid spamming the user
            // since this method is called many times per second
        }
    }
    
    /**
     * Scene shutdown handler
     * Clean up resources and listeners when the scene is stopped
     */
    shutdown() {
        console.log('BattleScene: Shutting down');
        
        try {
            // Clean up debug tools
            this.cleanupDebugTools();
            
            // Clean up battle bridge
            this.cleanupBattleBridge();
            
            // Clean up character teams
            this.cleanupCharacterTeams();
            
            // Clean up keyboard listeners
            if (this.input && this.input.keyboard) {
                this.input.keyboard.off('keydown-D', this.handleDebugKeypress, this);
            }
            
            // Clean up tweens
            this.tweens.killAll();
            
            // Clean up local references
            this.battleConfig = null;
            this.playerTeam = null;
            this.enemyTeam = null;
            this.components = {};
            
            console.log('BattleScene: Shut down successfully');
        } catch (error) {
            console.error('Error during scene shutdown:', error);
        }
    }
    
    /**
     * Update loop for the battle scene
     * Called by Phaser on every frame to update game state
     * 
     * @param {number} time - Current time in ms since game start
     * @param {number} delta - Time in ms since last update
     */
    update(time, delta) {
        try {
            // Update debug tools if enabled
            if (this.debug.enabled) {
                // Update object identifier if it exists
                if (this.objectIdentifier && typeof this.objectIdentifier.update === 'function') {
                    this.objectIdentifier.update();
                }
                
                // Update coordinate display if it exists
                if (this.coordinateDisplay && typeof this.coordinateDisplay.update === 'function') {
                    this.coordinateDisplay.update();
                }
            }
            
            // Update character teams if present
            if (this.playerTeamContainer) {
                this.playerTeamContainer.update();
            }
            
            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.update();
            }
        } catch (error) {
            console.error('Error in update loop:', error);
            // Don't show error messages here to avoid spamming the user
            // since this method is called many times per second
        }
    }
    
    /**
     * Scene shutdown handler
     * Clean up resources and listeners when the scene is stopped
     */
    shutdown() {
        console.log('BattleScene: Shutting down');
        
        try {
            // Clean up debug tools
            this.cleanupDebugTools();
            
            // Clean up battle bridge
            this.cleanupBattleBridge();
            
            // Clean up character teams
            this.cleanupCharacterTeams();
            
            // Clean up keyboard listeners
            if (this.input && this.input.keyboard) {
                this.input.keyboard.off('keydown-D', this.handleDebugKeypress, this);
            }
            
            // Clean up tweens
            this.tweens.killAll();
            
            // Clean up local references
            this.battleConfig = null;
            this.playerTeam = null;
            this.enemyTeam = null;
            this.components = {};
            
            console.log('BattleScene: Shut down successfully');
        } catch (error) {
            console.error('Error during scene shutdown:', error);
        }
    }

===== FILE: BattleScene.js =====
/**
 * BattleScene.js
 * Main scene for battle visualization in Phaser
 * * This scene displays the battle between player and enemy teams.
 * It provides the visual representation layer that connects to
 * the BattleManager for game logic processing.
 * * @version 0.5.1.4 (with Turn Indicator feature)
 */

import TurnIndicator from '../components/battle/TurnIndicator.js';

// Define the BattleScene class
export default class BattleScene extends Phaser.Scene {
    /**
     * Set up core event listeners for battle events
     */
    setupCoreEventListeners() {
        if (!this.battleBridge) {
            console.error('BattleScene: Cannot set up core event listeners - BattleBridge not connected');
            return;
        }
        
        // Listen for turn started events
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.TURN_STARTED, this.handleTurnStarted.bind(this));

        // Listen for character damaged events for floating text
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.CHARACTER_DAMAGED, (data) => {
            console.log(`Bridge Event: ${data.target?.name} damaged by ${data.source?.name || 'effect'} for ${data.amount}`);
            this.showFloatingText(data.target, `-${data.amount}`, { color: '#ff0000' }); // Red for damage
        });

        // Listen for character healed events for floating text
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.CHARACTER_HEALED, (data) => {
            console.log(`Bridge Event: ${data.target?.name} healed by ${data.source?.name || 'effect'} for ${data.amount}`);
            this.showFloatingText(data.target, `+${data.amount}`, { color: '#00ff00' }); // Green for healing
        });

        // Listen for battle ended events
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.BATTLE_ENDED, (data) => {
            console.log(`Bridge Event: Battle ended. Result: ${data.winner}`);
            // Show battle outcome screen
            this.showBattleOutcome(data.winner);
        });
        
        console.log('BattleScene: Core event listeners registered');
    }
    /**
     * Set up event listeners for character health updates
     */
    setupHealthUpdateListeners() {
        if (!this.battleBridge) {
            console.error('BattleScene: Cannot set up health update listeners - BattleBridge not connected');
            return;
        }
        
        // Listen for CHARACTER_DAMAGED events - use event type constants directly
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.CHARACTER_DAMAGED, this.onCharacterDamaged.bind(this));
        
        // Listen for CHARACTER_HEALED events - use event type constants directly
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.CHARACTER_HEALED, this.onCharacterHealed.bind(this));
        
        console.log('BattleScene: Health update listeners registered with event types:', {
            'damaged': this.battleBridge.eventTypes.CHARACTER_DAMAGED,
            'healed': this.battleBridge.eventTypes.CHARACTER_HEALED
        });
    }
    
    /**
     * Handle character damaged event
     * @param {Object} data - Event data including character and health info
     */
    onCharacterDamaged(data) {
        // Debug log the full data received
        console.log(`BattleScene: onCharacterDamaged called with data:`, data);
        
        // Extract data safely with defaults
        const character = data.character || data.target;
        const newHealth = data.newHealth !== undefined ? data.newHealth : character.currentHp;
        const maxHealth = character?.stats?.hp || 100;
        
        console.log(`BattleScene: Character damaged - ${character?.name} health now ${newHealth}/${maxHealth}`);
        
        // Determine which team the character belongs to
        const teamContainer = character?.team === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
        
        // Update the character's health bar
        if (teamContainer) {
            // Try multiple identifiers to find the character
            let idToUse = null;
            // Log all available identifiers for debugging
            console.log(`Available identifiers for ${character?.name}:`, {
                id: character.id,
                uniqueId: character.uniqueId,
                name: character.name
            });
            
            // Try each identifier in priority order
            if (character.uniqueId) {
                // Try uniqueId first as it's most specific
                const result = teamContainer.updateCharacterHealth(character.uniqueId, newHealth, maxHealth);
                if (result) {
                    console.log(`Found character using uniqueId: ${character.uniqueId}`);
                    return;
                }
            }
            
            if (character.id) {
                // Try id next
                const result = teamContainer.updateCharacterHealth(character.id, newHealth, maxHealth);
                if (result) {
                    console.log(`Found character using id: ${character.id}`);
                    return;
                }
            }
            
            // Fall back to name as last resort
            const updateResult = teamContainer.updateCharacterHealth(character.name, newHealth, maxHealth);
            console.log(`Health bar update for ${character?.name} result: ${updateResult ? 'success' : 'failed'} using name`);
        } else {
            console.warn(`BattleScene: Could not find team container for ${character?.name}`);
        }
    }
    
    /**
     * Handle character healed event
     * @param {Object} data - Event data including character and health info
     */
    onCharacterHealed(data) {
        // Debug log the full data received
        console.log(`BattleScene: onCharacterHealed called with data:`, data);
        
        // Extract data safely with defaults
        const character = data.character || data.target;
        const newHealth = data.newHealth !== undefined ? data.newHealth : character.currentHp;
        const maxHealth = character?.stats?.hp || 100;
        
        console.log(`BattleScene: Character healed - ${character?.name} health now ${newHealth}/${maxHealth}`);
        
        // Determine which team the character belongs to
        const teamContainer = character?.team === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
        
        // Update the character's health bar
        if (teamContainer) {
            // Try multiple identifiers to find the character
            let idToUse = null;
            // Log all available identifiers for debugging
            console.log(`Available identifiers for ${character?.name}:`, {
                id: character.id,
                uniqueId: character.uniqueId,
                name: character.name
            });
            
            // Try each identifier in priority order
            if (character.uniqueId) {
                // Try uniqueId first as it's most specific
                const result = teamContainer.updateCharacterHealth(character.uniqueId, newHealth, maxHealth);
                if (result) {
                    console.log(`Found character using uniqueId: ${character.uniqueId}`);
                    return;
                }
            }
            
            if (character.id) {
                // Try id next
                const result = teamContainer.updateCharacterHealth(character.id, newHealth, maxHealth);
                if (result) {
                    console.log(`Found character using id: ${character.id}`);
                    return;
                }
            }
            
            // Fall back to name as last resort
            const updateResult = teamContainer.updateCharacterHealth(character.name, newHealth, maxHealth);
            console.log(`Health bar update for ${character?.name} result: ${updateResult ? 'success' : 'failed'} using name`);
        } else {
            console.warn(`BattleScene: Could not find team container for ${character?.name}`);
        }
    }
    constructor() {
        super({
            key: 'BattleScene'
        });

        // Track initialization
        this.isInitialized = false;

        // Battle state
        this.battleState = {
            isStarted: false,
            isPaused: false,
            currentSpeed: 1,
            currentTurn: 0,
            activeCharacter: null
        };
        
        // Track active character data
        this.activeCharacter = null;

        // Debug settings
        this.debug = {
            enabled: true,
            showCoordinates: true,
            showObjectInfo: false
        };

        // References to battle components
        this.components = {};
        this.playerTeamContainer = null; // Initialize to null
        this.enemyTeamContainer = null; // Initialize to null
        this.testPattern = null; // Initialize to null

        // Make available globally for debugging
        window.BattleScene = this;
    }

    /**
     * Initialize the scene with battle configuration
     * @param {Object} data - Battle configuration data from TeamBuilder
     */
    init(data) {
        console.log('BattleScene init with data:', data);
        this.battleConfig = data || {};

        // Store references to teams (with deep copying to prevent reference issues)
        if (this.battleConfig.playerTeam) {
            this.playerTeam = JSON.parse(JSON.stringify(this.battleConfig.playerTeam));
            console.log(`BattleScene: Stored player team with ${this.playerTeam.length} heroes (deep copy)`);
        } else {
            this.playerTeam = [];
            console.warn('BattleScene: No player team provided');
        }
        
        if (this.battleConfig.enemyTeam) {
            this.enemyTeam = JSON.parse(JSON.stringify(this.battleConfig.enemyTeam));
            console.log(`BattleScene: Stored enemy team with ${this.enemyTeam.length} heroes (deep copy)`);
        } else {
            this.enemyTeam = [];
            console.warn('BattleScene: No enemy team provided');
        }

        // Track debug mode from URL parameter if present
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('debug')) {
            this.debug.enabled = urlParams.get('debug') !== 'false';
        }
        console.log(`BattleScene Initializing with Player Team Count: ${this.playerTeam.length}, Enemy Team Count: ${this.enemyTeam.length}`);
    }

    /**
     * Preload any assets needed for the battle scene
     */
    preload() {
        console.log('BattleScene preload starting...');

        // Try to set texture filtering to LINEAR (with error handling)
        // Note: Texture filtering is now handled in PhaserConfig.js via render settings instead
        // of trying to use textures.setFilter which isn't available in this version of Phaser
        console.log('BattleScene: Using config-level texture filtering instead of direct method');

        // Preload all character images in a centralized location
        try {
            // Basic placeholder asset
            this.load.image('character-circle', 'assets/images/icons/character-circle.png');
            
            // Preload all combat-optimized character art - this is the proper place to load assets
            const characterArt = [
                'Aqualia', 'Drakarion', 'Zephyr', 'Lumina', 
                'Sylvanna', 'Vaelgor', 'Seraphina' 
            ];
            
            // Special case for Caste due to parentheses in filename
            const casteKey = 'character_Caste';
            const castePath = 'assets/images/Character Art/Combat_Version/Caste.png';
            this.load.image(casteKey, castePath);
            console.log(`BattleScene: Preloading combat-optimized character image ${casteKey} from ${castePath}`);
            
            characterArt.forEach(name => {
                const key = `character_${name}`;
                // Use the combat-optimized versions of character art
                const path = `assets/images/Character Art/Combat_Version/${name}.png`;
                this.load.image(key, path);
                console.log(`BattleScene: Preloading combat-optimized character image ${key} from ${path}`);
            });
            
            console.log('BattleScene: Character art preload complete');
        } catch (error) {
            console.warn('BattleScene: Could not preload character art:', error);
        }
        
        console.log('BattleScene preload finished.');
    }

    /**
     * Create the battle scene display
     * Sets up the basic scene elements and initializes the debug tools
     */
    create() {
        console.log('BattleScene create starting...');
        
        // Create turn indicator (using static import from top of file)
        try {
            this.turnIndicator = new TurnIndicator(this);
            this.turnIndicator.setDepth(1); // Set depth to render below sprites but above background
            console.log('Turn indicator created successfully');
        } catch (err) {
            console.error('Error creating TurnIndicator:', err);
            // Fallback: create a simple Graphics object if instantiation fails
            this.turnIndicator = this.add.graphics();
            this.turnIndicator.setAlpha(0);
        }

        // Force Canvas smoothing specifically for this scene
        try {
            if (this.sys.game.renderer.type === Phaser.CANVAS) {
                // For Canvas renderer, we need to explicitly enable image smoothing
                const canvasContext = this.sys.canvas.getContext('2d');
                canvasContext.imageSmoothingEnabled = true;
                canvasContext.imageSmoothingQuality = 'high';
                console.log('BattleScene: Canvas imageSmoothingEnabled set to true');
            }
        } catch (e) {
            console.warn('Could not configure Canvas smoothing', e);
        }

        try {
            console.log('BattleScene create: Creating background...');
            // Create plain background for now
            this.createBackground();
            console.log('BattleScene create: Background created.');

            console.log('BattleScene create: Creating scene title...');
            // Add scene title for testing
            this.createSceneTitle();
            console.log('BattleScene create: Scene title created.');

            console.log('BattleScene create: Creating return button...');
            // Add return button (temporary)
            this.createReturnButton();
            console.log('BattleScene create: Return button created.');

            console.log('BattleScene create: Creating test pattern...');
            // Add test pattern to confirm rendering
            this.createTestPattern();
            console.log('BattleScene create: Test pattern created.');

            console.log('BattleScene create: Creating welcome message...');
            // Add welcome message to confirm battle data
            this.createWelcomeMessage();
            console.log('BattleScene create: Welcome message created.');

            console.log('BattleScene create: Initializing debug tools...');
            // Initialize debug tools if available
            this.initializeDebugTools();
            console.log('BattleScene create: Debug tools initialized.');

            console.log('BattleScene create: Initializing battle bridge...');
            // Initialize battle bridge if BattleManager is available
            this.initializeBattleBridge();
            console.log('BattleScene create: Battle bridge initialized.');

            console.log('BattleScene create: Creating character teams...');
            // Create character teams for visualization
            this.createCharacterTeams(); // This now has internal try-catch blocks
            console.log('BattleScene create: Character teams creation attempted.');

            console.log('BattleScene create: Creating debug panel...');
            // Add debug controls panel
            this.createDebugPanel();
            console.log('BattleScene create: Debug panel created.');
            
            console.log('BattleScene create: Creating battle controls...');
            // Add battle control panel
            this.createBattleControls();
            console.log('BattleScene create: Battle controls created.');
            
            console.log('BattleScene create: Creating battle log panel...');
            // Add battle log panel
            this.createBattleLogPanel();
            console.log('BattleScene create: Battle log panel created.');

            // Mark as initialized
            this.isInitialized = true;
            
            // Make test functions available globally for debugging
            window.testHealthUpdate = this.testHealthUpdate.bind(this);
            window.testActionIndicator = this.testActionIndicator.bind(this);

            console.log('BattleScene created successfully');
        } catch (error) {
            // This outer catch handles errors in the main create flow
            console.error('FATAL Error in BattleScene create method:', error);
            this.showErrorMessage('FATAL: Failed to initialize battle scene: ' + error.message);
        }
    }

    /**
     * Create character teams for visualization
     * Sets up player and enemy teams with CharacterSprite components
     */
    createCharacterTeams() {
        console.log('Attempting to create character teams...'); // Log start

        // --- Player Team Creation ---
        try {
            console.log(`Creating player team container with ${this.playerTeam?.length || 0} characters.`);
            if (!this.playerTeam || this.playerTeam.length === 0) {
                 console.warn('Player team data is empty or missing!');
                 // Optionally create a placeholder if needed for testing, or just proceed
                 this.playerTeam = []; // Ensure it's an array
            }
            this.playerTeamContainer = new TeamContainer(
                this,
                this.playerTeam,
                true, // isPlayerTeam
                { x: 800, y: 600 }  // Changed from 400 to 600
            );
            console.log('Player team container created successfully.');
        } catch (error) {
            console.error('ERROR creating PLAYER TeamContainer:', error);
            this.showErrorMessage('Failed to create player team container: ' + error.message);
            // Optionally set playerTeamContainer to null or handle fallback
            this.playerTeamContainer = null;
        }

        // --- Enemy Team Creation ---
        try {
             console.log(`Checking enemy team with ${this.enemyTeam?.length || 0} characters.`);
            if (this.enemyTeam && this.enemyTeam.length > 0) {
                console.log('Creating enemy team container from provided data.');
                this.enemyTeamContainer = new TeamContainer(
                this,
                this.enemyTeam,
                false, // isPlayerTeam
                { x: 1200, y: 600 }  // Changed from 400 to 600
                );
                console.log('Enemy team container created successfully from data.');
            } else {
                console.warn('No enemy team provided or team is empty. Creating placeholder enemy.');
                const placeholderEnemyTeam = [
                    { name: 'Placeholder Enemy', type: 'neutral', team: 'enemy', stats: { hp: 50 }, id: 'placeholder_0' } // Added an ID
                ];
                this.enemyTeamContainer = new TeamContainer(
                    this,
                    placeholderEnemyTeam,
                    false, // isPlayerTeam
                    { x: 1200, y: 400 }
                );
                console.log('Placeholder enemy team container created successfully.');
                // Optionally update this.enemyTeam if needed elsewhere
                // this.enemyTeam = placeholderEnemyTeam;
            }
        } catch (error) {
            console.error('ERROR creating ENEMY TeamContainer (or placeholder):', error);
            this.showErrorMessage('Failed to create enemy team container: ' + error.message);
            // Optionally set enemyTeamContainer to null or handle fallback
            this.enemyTeamContainer = null;
        }

        console.log('Character teams creation process finished.');

        // Hide test pattern *only if* at least one container was successfully created
        if (this.testPattern && (this.playerTeamContainer || this.enemyTeamContainer)) {
             console.log('Hiding test pattern as character containers seem to exist.');
            this.testPattern.setVisible(false);
        } else if (this.testPattern) {
             console.warn('Not hiding test pattern because character container creation might have failed.');
        }
    }


    /**
     * Handle turn started event
     * @param {Object} eventData - Event data for turn start
     */
    handleTurnStarted(eventData) {
        console.log('[BattleScene] handleTurnStarted CALLED. Data:', eventData);
        console.log('Event: TURN_STARTED', eventData);
        
        // Get the new active character
        const newActiveCharacter = eventData.character || eventData.currentCharacter;
        if (!newActiveCharacter) {
            console.warn('Missing character data in TURN_STARTED event');
            return;
        }
        
        // Store the active character reference
        this.activeCharacter = newActiveCharacter;
        
        // Determine the correct TeamContainer based on the character's team
        const teamContainer = newActiveCharacter.team === 'player' 
            ? this.playerTeamContainer 
            : this.enemyTeamContainer;
            
        if (!teamContainer) {
            console.warn(`Could not find team container for team: ${newActiveCharacter.team}`);
            return;
        }
        
        // Find the corresponding character sprite
        const activeSprite = teamContainer.getCharacterSpriteByName(newActiveCharacter.name);
        
        if (activeSprite) {
            // Clear any previous turn indicators
            if (this.playerTeamContainer) this.playerTeamContainer.clearTurnIndicators();
            if (this.enemyTeamContainer) this.enemyTeamContainer.clearTurnIndicators();
            
            // Show turn indicator for the active character
            teamContainer.showTurnIndicator(newActiveCharacter.name);
            
            // Determine marker color based on team (blue for player, red for enemy)
            const markerColor = newActiveCharacter.team === 'player' ? 0x4488ff : 0xff4444;
            
            // Calculate position (under the character)
            const targetX = activeSprite.container.x;
            const targetY = activeSprite.container.y + 40; // Adjust this offset for best visual placement
            
            // Get battle speed multiplier
            const speedMultiplier = this.battleManager?.speedMultiplier || 1;
            
            // Define base animation duration and adjust for battle speed
            const baseFadeDuration = 250;
            const fadeDuration = baseFadeDuration / speedMultiplier;
            
            // Show the indicator at the calculated position
            if (this.turnIndicator) {
                this.turnIndicator.showAt(targetX, targetY, markerColor, fadeDuration);
            }
            
            console.log(`Turn indicator set for ${newActiveCharacter.name} at position: ${targetX},${targetY}`);
        } else {
            console.warn('Could not find active character sprite for:', newActiveCharacter?.name);
            
            // Hide the indicator if we can't find the character
            if (this.turnIndicator) {
                const baseFadeDuration = 250;
                const speedMultiplier = this.battleManager?.speedMultiplier || 1;
                const fadeDuration = baseFadeDuration / speedMultiplier;
                this.turnIndicator.hide(fadeDuration);
            }
        }
    }
    
    /**
     * Clean up character teams
     */
    cleanupCharacterTeams() {
        try {
            if (this.playerTeamContainer) {
                this.playerTeamContainer.destroy();
                this.playerTeamContainer = null;
            }

            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.destroy();
                this.enemyTeamContainer = null;
            }

            console.log('Character teams cleaned up');
        } catch (error) {
            console.error('Error cleaning up character teams:', error);
        }
    }

    /**
     * Show turn indicator for the active character in the battle
     * @param {Object} character - The character to highlight
     */
    highlightActiveCharacter(character) {
        try {
            if (!character) return;

            const teamContainer = character.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!teamContainer) return;

            teamContainer.showTurnIndicator(character.name);
        } catch (error) {
            console.error('Error showing turn indicator for active character:', error);
        }
    }

    /**
     * Show attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Function} onComplete - Callback when animation completes
     */
    showAttackAnimation(attacker, target, onComplete) {
        try {
            if (!attacker || !target) {
                if (onComplete) onComplete();
                return;
            }

            // Find sprites
            const attackerTeamContainer = attacker.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            const targetTeamContainer = target.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!attackerTeamContainer || !targetTeamContainer) {
                if (onComplete) onComplete();
                return;
            }

            const attackerSprite = attackerTeamContainer.getCharacterSpriteByName(attacker.name);
            const targetSprite = targetTeamContainer.getCharacterSpriteByName(target.name);

            if (!attackerSprite || !targetSprite) {
                if (onComplete) onComplete();
                return;
            }

            attackerSprite.showAttackAnimation(targetSprite, onComplete);
        } catch (error) {
            console.error('Error showing attack animation:', error);
            if (onComplete) onComplete();
        }
    }

    /**
     * Show floating text above a character
     * @param {Object} character - Character to show text above
     * @param {string} text - Text to display
     * @param {Object} style - Text style options
     */
    showFloatingText(character, text, style = {}) {
        try {
            if (!character) return;

            const teamContainer = character.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!teamContainer) return;

            const sprite = teamContainer.getCharacterSpriteByName(character.name);

            if (!sprite) return;

            sprite.showFloatingText(text, style);
        } catch (error) {
            console.error('Error showing floating text:', error);
        }
    }

    /**
     * Create a test pattern to verify the scene is rendering correctly
     * This is a temporary visual element to confirm Phaser is working
     */
    createTestPattern() {
        try {
            // Create a container for test elements
            const testContainer = this.add.container(
                this.cameras.main.width / 2,
                this.cameras.main.height / 2
            );

            // Add colorful circles in different positions
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            const radius = 30;

            for (let i = 0; i < colors.length; i++) {
                const angle = (i / colors.length) * Math.PI * 2;
                const x = Math.cos(angle) * 100;
                const y = Math.sin(angle) * 100;

                const circle = this.add.circle(x, y, radius, colors[i], 0.8);
                testContainer.add(circle);

                // Add pulsing animation
                this.tweens.add({
                    targets: circle,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    duration: 500 + (i * 100),
                    yoyo: true,
                    repeat: -1
                });
            }

            // Add version text
            const versionText = this.add.text(0, 0, 'Battle Scene v0.5.0.4b', { // *** UPDATED VERSION ***
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#ffffff',
                align: 'center'
            }).setOrigin(0.5);

            testContainer.add(versionText);

            // Store reference
            this.testPattern = testContainer;

            console.log('Test pattern created successfully');
        } catch (error) {
            console.error('Error creating test pattern:', error);
        }
    }

    /**
     * Create a welcome message showing battle data
     * Displays player team and enemy team information
     */
    createWelcomeMessage() {
        try {
            // Create player team summary
            const playerTeamNames = this.playerTeam.map(character => character.name).join(', ');
            const playerTeamText = `Player Team (${this.playerTeam.length}): ${playerTeamNames || 'None'}`;

            // Create enemy team summary
            // Ensure enemyTeam is an array before mapping
            const safeEnemyTeam = Array.isArray(this.enemyTeam) ? this.enemyTeam : [];
            const enemyTeamNames = safeEnemyTeam.map(character => character.name).join(', ');
            const enemyTeamText = `Enemy Team (${safeEnemyTeam.length}): ${enemyTeamNames || 'None'}`;

            // Create battle mode text
            const battleModeText = `Battle Mode: ${this.battleConfig.battleMode || 'Unknown'}`;

            // Create welcome message
            const welcomeText = this.add.text(
                this.cameras.main.width / 2,
                120,
                `Battle Scene Initialized!\n${playerTeamText}\n${enemyTeamText}\n${battleModeText}`,
                {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 2
                }
            ).setOrigin(0.5);

            // Add to scene
            this.welcomeMessage = welcomeText;

            console.log('Welcome message created successfully');
        } catch (error) {
            console.error('Error creating welcome message:', error);
        }
    }

    /**
     * Create the background for the battle scene
     */
    createBackground() {
        try {
            // Create a gradient background
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;

            // Create background rectangle
            this.add.rectangle(
                width / 2,
                height / 2,
                width,
                height,
                0x333344 // Navy blue color
            );

            // Add some visual interest with diagonal lines
            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0xffffff, 0.1);

            // Draw grid lines
            const spacing = 80;
            for (let i = 0; i < width + height; i += spacing) {
                graphics.moveTo(0, i);
                graphics.lineTo(i, 0);
            }

            graphics.strokePath();

            console.log('Background created successfully');
        } catch (error) {
            console.error('Error creating background:', error);
        }
    }

    /**
     * Create the scene title
     */
    createSceneTitle() {
        try {
            this.sceneTitle = this.add.text(
                this.cameras.main.width / 2,
                50,
                'Battle Scene',
                {
                    fontFamily: 'Arial',
                    fontSize: 36,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }
            ).setOrigin(0.5);

            // Add simple animation
            this.tweens.add({
                targets: this.sceneTitle,
                y: 40,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            console.log('Scene title created successfully');
        } catch (error) {
            console.error('Error creating scene title:', error);
        }
    }

    /**
     * Create the return button to go back to the TeamBuilder
     */
     createReturnButton() {
         // ** Implementation Added for v0.5.0.4b Fix **
         try {
             const button = this.add.text(
                 this.cameras.main.width - 100,
                 50,
                 'Return',
                 {
                     fontFamily: 'Arial',
                     fontSize: '20px',
                     color: '#ffffff',
                     backgroundColor: '#555555',
                     padding: { x: 15, y: 8 }
                 }
             ).setOrigin(0.5).setInteractive({ useHandCursor: true });

             button.on('pointerdown', () => {
                 console.log('Return button clicked');
                 this.returnToTeamBuilder();
             });

             button.on('pointerover', () => {
                 button.setBackgroundColor('#777777');
             });

             button.on('pointerout', () => {
                 button.setBackgroundColor('#555555');
             });

             this.returnButton = button;
             console.log('Return button created successfully');
         } catch (error) {
             console.error('Error creating return button:', error);
             this.showErrorMessage('Failed to create return button');
         }
     }

     /**
     * Handle returning to the TeamBuilder scene/UI
     */
     returnToTeamBuilder() {
         try {
             console.log('Returning to Team Builder...');

             // Stop the current scene properly
             this.scene.stop();

             // Hide Phaser container and show DOM UI
             const phaserContainer = document.getElementById('game-container');
             if (phaserContainer) {
                 phaserContainer.style.display = 'none';
             }
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if (teamBuilderContainer) {
                 teamBuilderContainer.style.display = 'block'; // Or 'flex' depending on your CSS
             }

             // Optionally, notify TeamBuilderUI if it exists
             if (window.teamBuilderUI && typeof window.teamBuilderUI.onReturnFromPhaserBattle === 'function') {
                 window.teamBuilderUI.onReturnFromPhaserBattle();
             } else {
                 console.warn('TeamBuilderUI or onReturnFromPhaserBattle not found.');
             }

         } catch (error) {
             console.error('Error returning to Team Builder:', error);
             // Add fallback in case of error during transition
             alert('Error returning to Team Builder. Please refresh if needed.');
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
         }
     }

    /**
     * Initialize debug tools like coordinate display and object identifier
     */
     initializeDebugTools() {
        // ** Implementation Added for v0.5.0.4b Fix **
         if (!this.debug.enabled) return;

         try {
             if (typeof CoordinateDisplay !== 'undefined' && this.debug.showCoordinates) {
                 this.coordinateDisplay = new CoordinateDisplay(this);
                 console.log('CoordinateDisplay initialized');
             } else if (this.debug.showCoordinates) {
                 console.warn('CoordinateDisplay class not found.');
             }

             if (typeof ObjectIdentifier !== 'undefined' && this.debug.showObjectInfo) {
                 this.objectIdentifier = new ObjectIdentifier(this);
                 console.log('ObjectIdentifier initialized');
             } else if (this.debug.showObjectInfo) {
                 console.warn('ObjectIdentifier class not found.');
             }
         } catch (error) {
             console.error('Error initializing debug tools:', error);
             this.showErrorMessage('Failed to load debug tools');
         }
     }

     /**
      * Cleanup debug tools
      */
      cleanupDebugTools() {
         // ** Implementation Added for v0.5.0.4b Fix **
         try {
             if (this.coordinateDisplay && typeof this.coordinateDisplay.destroy === 'function') {
                 this.coordinateDisplay.destroy();
                 this.coordinateDisplay = null;
                 console.log('CoordinateDisplay destroyed.');
             }
             if (this.objectIdentifier && typeof this.objectIdentifier.destroy === 'function') {
                 this.objectIdentifier.destroy();
                 this.objectIdentifier = null;
                 console.log('ObjectIdentifier destroyed.');
             }
         } catch(error) {
              console.error('Error cleaning up debug tools:', error);
         }
     }

     /**
      * Initialize the bridge connection to BattleManager
      */
      initializeBattleBridge() {
         // ** Implementation Added for v0.5.0.4b Fix **
          try {
              // Ensure turn indicator exists
              if (!this.turnIndicator) {
                  try {
                      this.turnIndicator = new TurnIndicator(this);
                      this.turnIndicator.setDepth(1);
                  } catch (err) {
                      console.error('Error creating TurnIndicator during bridge init:', err);
                  }
              }
              // Primary approach: Call the dedicated initialization function
              if (typeof window.initializeBattleBridge === 'function' && window.battleManager) {
                  console.log('BattleScene: Calling initializeBattleBridge with BattleManager and BattleScene');
                  const success = window.initializeBattleBridge(window.battleManager, this);
                  if (success) {
                      console.log('BattleScene: Successfully initialized battle bridge');
                      // Get the bridge instance after initialization
                      this.battleBridge = window.getBattleBridge ? window.getBattleBridge() : window.battleBridge;
                      
                      // Set up event listeners after successful initialization
                      this.setupHealthUpdateListeners();
                      this.setupActionIndicatorListeners();
                      
                      // Setup other core event listeners
                      this.setupCoreEventListeners();
                  } else {
                      console.warn('BattleScene: initializeBattleBridge reported failure');
                  }
              }
              // Fallback #1: Use getBattleBridge accessor if available
              else if (typeof window.getBattleBridge === 'function') {
                  console.log('BattleScene: Getting battleBridge through getBattleBridge()');
                  this.battleBridge = window.getBattleBridge();
                  
                  // Initialize manually if needed
                  if (this.battleBridge && window.battleManager && typeof this.battleBridge.initialize === 'function') {
                      console.log('BattleScene: Initializing battleBridge manually');
                      this.battleBridge.initialize(window.battleManager, this);
                      
                      // Set up event listeners after manual initialization
                      this.setupHealthUpdateListeners();
                      this.setupActionIndicatorListeners();
                      
                      // Setup other core event listeners
                      this.setupCoreEventListeners();
                  }
              }
              // Fallback #2: Direct access as last resort
              else if (window.battleBridge && window.battleManager) {
                  console.log('BattleScene: Using legacy direct access to battleBridge');
                  this.battleBridge = window.battleBridge; // Use existing global INSTANCE
                  this.battleBridge.initialize(window.battleManager, this); // Pass references
                  
                  // Set up health update listeners
                  this.setupHealthUpdateListeners();
                  
                  // Set up action indicator listeners
                  this.setupActionIndicatorListeners();
                  
                  // Set up core event listeners
                  this.setupCoreEventListeners();
                  
                  // Add listener specifically for TURN_STARTED events
                  this.battleBridge.addEventListener(this.battleBridge.eventTypes.TURN_STARTED, this.handleTurnStarted.bind(this));

                  console.log('BattleBridge initialized and listeners set up.');
              } else {
                  console.warn('battleBridge instance or BattleManager not found. Bridge not initialized.');
                  // Add fallback to create instance if only the class exists
                  if (window.BattleBridge && typeof window.BattleBridge === 'function' && window.battleManager) {
                      try {
                          console.log('Attempting to create battleBridge instance on-demand...');
                          this.battleBridge = new window.BattleBridge();
                          window.battleBridge = this.battleBridge; // Also make globally available
                          this.battleBridge.initialize(window.battleManager, this);
                          // Set up all event listeners
                          this.setupHealthUpdateListeners();
                          this.setupActionIndicatorListeners();
                          this.setupCoreEventListeners();
                          console.log('Created battleBridge instance on-demand successfully');
                      } catch (instanceError) {
                          console.error('Failed to create battleBridge instance on-demand:', instanceError);
                      }
                  }
              }
          } catch(error) {
              console.error('Error initializing BattleBridge:', error);
              this.showErrorMessage('Failed to connect to battle logic.');
          }
      }


     /**
      * Cleanup the bridge connection
      */
      cleanupBattleBridge() {
         // ** Implementation Added for v0.5.0.4b Fix **
          try {
              if (this.battleBridge) {
                  // Remove specific listeners
                  this.battleBridge.removeEventListener(this.battleBridge.eventTypes.TURN_STARTED, this.handleTurnStarted.bind(this));
                  console.log('BattleBridge listeners should be cleaned up if necessary.');
                  // Resetting the reference, assuming BattleBridge handles its own internal cleanup if needed
                  // this.battleBridge = null;
              }
          } catch(error) {
               console.error('Error cleaning up BattleBridge:', error);
          }
      }

     /**
      * Create the debug controls panel
      */
      createDebugPanel() {
          // Debug panel disabled to avoid UI clutter
          return; // Skip creating debug panel entirely
      }


     /**
     * Create the battle log for displaying battle events
     */
     createBattleLogPanel() {
        try {
            // Check if DirectBattleLog class exists
            if (typeof DirectBattleLog === 'function') {
                // Calculate half screen height for max height constraint
                const halfScreenHeight = this.cameras.main.height * 0.5;
                
                // Create the direct battle log in the right side of the screen
                this.battleLog = new DirectBattleLog(
                    this, 
                    this.cameras.main.width - 350, // X position (right side)
                    50,                            // Y position (top)
                    300,                           // Width
                    {
                        backgroundColor: 0x000000,
                        backgroundAlpha: 0.5,
                        fontSize: 16,
                        maxMessages: 30,
                        padding: 10,
                        maxHeight: halfScreenHeight // Limit height to half the screen
                    }
                );
                
                // For testing only - send a test message through BattleBridge if available
                if (this.battleBridge) {
                    console.log('BattleScene: Sending test message through BattleBridge');
                    this.battleBridge.dispatchEvent(this.battleBridge.eventTypes.BATTLE_LOG, {
                        message: 'Test message from BattleScene via BattleBridge',
                        type: 'info'
                    });
                } else {
                    console.warn('BattleScene: BattleBridge not available for test message');
                }
                
                // Add direct access for testing in console
                window.battleLog = this.battleLog;
                
                console.log('Battle log created successfully');
            } else {
                console.error('DirectBattleLog class not found');
                this.showErrorMessage('Battle log not available');
            }
        } catch (error) {
            console.error('Error creating battle log:', error);
            this.showErrorMessage('Failed to create battle log');
        }
    }
    
    /**
     * Create the battle control panel
     * Adds UI controls for starting battle, changing speed, pausing/resuming
     */
     /**
     * Test health bar updates manually (for debugging)
     * @param {string} teamType - 'player' or 'enemy'
     * @param {number} characterIndex - Index of the character in the team
     * @param {number} newHealth - New health value to set
     */
    testHealthUpdate(teamType = 'player', characterIndex = 0, newHealth = 50) {
        try {
            // Get the appropriate team container
            const teamContainer = teamType === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            if (!teamContainer) {
                console.error(`testHealthUpdate: ${teamType} team container not found`);
                return;
            }
            
            // Get the character array for reference values
            const characterArray = teamType === 'player' ? this.playerTeam : this.enemyTeam;
            if (!characterArray || characterArray.length === 0) {
                console.error(`testHealthUpdate: ${teamType} team array is empty`);
                return;
            }
            
            // Validate characterIndex
            if (characterIndex < 0 || characterIndex >= characterArray.length) {
                console.error(`testHealthUpdate: Invalid character index ${characterIndex} for ${teamType} team`);
                return;
            }
            
            // Get character data
            const character = characterArray[characterIndex];
            const maxHealth = character.stats.hp || 100;
            
            // Update character's health in data structure
            character.currentHp = newHealth;
            
            // Create mock event data
            const mockEventData = {
                character: character,
                newHealth: newHealth,
                amount: character.currentHp - newHealth // Simulated damage/healing amount
            };
            
            // Call the appropriate event handler
            if (newHealth < character.currentHp) {
                console.log(`Testing damage event for ${character.name} (${teamType} team) to ${newHealth}/${maxHealth}`);
                this.onCharacterDamaged(mockEventData);
            } else {
                console.log(`Testing healing event for ${character.name} (${teamType} team) to ${newHealth}/${maxHealth}`);
                this.onCharacterHealed(mockEventData);
            }
            
            console.log(`testHealthUpdate: Updated ${character.name}'s health to ${newHealth}/${maxHealth}`);
            
            // Make function available in window for console testing
            window.testHealthUpdate = this.testHealthUpdate.bind(this);
        } catch (error) {
            console.error(`testHealthUpdate: Error:`, error);
        }
    }

    /**
     * Set up event listeners for character actions
     */
    setupActionIndicatorListeners() {
        if (!this.battleBridge) {
            console.error('BattleScene: Cannot set up action listeners - BattleBridge not connected');
            return;
        }
        
        // Listen for CHARACTER_ACTION events
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.CHARACTER_ACTION, this.onCharacterAction.bind(this));
        
        // Listen for ABILITY_USED events
        this.battleBridge.addEventListener(this.battleBridge.eventTypes.ABILITY_USED, this.onAbilityUsed.bind(this));
        
        console.log('BattleScene: Action indicator listeners registered');
    }
    
    /**
     * Handle character action event
     * @param {Object} data - Event data including character and action info
     */
    onCharacterAction(data) {
        console.log(`BattleScene: onCharacterAction called with data:`, data);
        
        try {
            // Extract data safely with defaults
            const character = data.character;
            
            // Extract action info from the action object
            const action = data.action || {};
            const actionType = action.type || 'autoAttack';
            const actionName = action.name || (actionType === 'ability' ? action.abilityName : actionType);
            
            if (!character) {
                console.warn('BattleScene: Character action event missing character data');
                return;
            }
            
            console.log(`BattleScene: Character action - ${character.name} performing ${actionType}: ${actionName}`);
            
            // Determine which team the character belongs to
            const teamContainer = character.team === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            
            if (!teamContainer) {
                console.warn(`BattleScene: Could not find team container for ${character.name}`);
                return;
            }
            
            // Get the character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(character.name);
            
            if (!characterSprite) {
                console.warn(`BattleScene: Could not find character sprite for ${character.name}`);
                return;
            }
            
            // Format the action text based on the action type
            let actionText = '';
            
            if (actionType === 'autoAttack') {
                actionText = 'Auto Attack';
            } else if (actionType === 'ability') {
                actionText = `Ability: ${actionName}`;
            } else if (actionType === 'status') {
                actionText = `Status: ${actionName}`;
            } else {
                actionText = actionName;
            }
            
            // Show the action text above the character
            characterSprite.showActionText(actionText);
            
        } catch (error) {
            console.error('BattleScene: Error handling character action:', error);
        }
    }
    
    /**
     * Handle ability used event
     * @param {Object} data - Event data including character and ability info
     */
    onAbilityUsed(data) {
        console.log(`BattleScene: onAbilityUsed called with data:`, data);
        
        try {
            // Extract data safely with defaults
            const character = data.character || data.source;
            const ability = data.ability || {};
            const abilityName = ability.name || 'Unknown Ability';
            
            if (!character) {
                console.warn('BattleScene: Ability used event missing character data');
                return;
            }
            
            console.log(`BattleScene: Ability used - ${character.name} using ${abilityName}`);
            
            // Determine which team the character belongs to
            const teamContainer = character.team === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            
            if (!teamContainer) {
                console.warn(`BattleScene: Could not find team container for ${character.name}`);
                return;
            }
            
            // Get the character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(character.name);
            
            if (!characterSprite) {
                console.warn(`BattleScene: Could not find character sprite for ${character.name}`);
                return;
            }
            
            // Show the ability text above the character
            characterSprite.showActionText(`Ability: ${abilityName}`);
            
        } catch (error) {
            console.error('BattleScene: Error handling ability used:', error);
        }
    }
    
    /**
     * Test action indicator manually (for debugging)
     * @param {string} teamType - 'player' or 'enemy'
     * @param {number} characterIndex - Index of the character in the team
     * @param {string} actionText - Action text to display
     */
    testActionIndicator(teamType = 'player', characterIndex = 0, actionText = 'Test Action') {
        try {
            // Get the appropriate team container
            const teamContainer = teamType === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            if (!teamContainer) {
                console.error(`testActionIndicator: ${teamType} team container not found`);
                return;
            }
            
            // Get the character array for reference
            const characterArray = teamType === 'player' ? this.playerTeam : this.enemyTeam;
            if (!characterArray || characterArray.length === 0) {
                console.error(`testActionIndicator: ${teamType} team array is empty`);
                return;
            }
            
            // Validate characterIndex
            if (characterIndex < 0 || characterIndex >= characterArray.length) {
                console.error(`testActionIndicator: Invalid character index ${characterIndex} for ${teamType} team`);
                return;
            }
            
            // Get character data
            const character = characterArray[characterIndex];
            
            // Get character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(character.name);
            if (!characterSprite) {
                console.error(`testActionIndicator: Could not find sprite for ${character.name}`);
                return;
            }
            
            // Show action text
            characterSprite.showActionText(actionText);
            
            console.log(`testActionIndicator: Showed '${actionText}' for ${character.name} (${teamType} team)`);
        } catch (error) {
            console.error(`testActionIndicator: Error:`, error);
        }
    }
    
     createBattleControls() {
     try {
     // Create debug test buttons (only in development mode)
     if (this.debug.enabled) {
          // Create button for testing action indicators
          const actionTestButton = this.add.text(
              100, 90, 'Test Action', {
                  fontFamily: 'Arial',
                  fontSize: '16px',
                  color: '#ffffff',
                  backgroundColor: '#333333',
                  padding: { x: 10, y: 5 }
              }
          ).setInteractive({ useHandCursor: true });
          
          actionTestButton.on('pointerdown', () => {
              // Test showing action indicator for player team character at index 0
              if (this.playerTeam && this.playerTeam.length > 0) {
                  this.testActionIndicator('player', 0, 'Ability: Fireball');
              }
          });
          
          actionTestButton.on('pointerover', () => actionTestButton.setBackgroundColor('#555555'));
          actionTestButton.on('pointerout', () => actionTestButton.setBackgroundColor('#333333'));
          
          // Create button for testing health bar updates
                  const testButton = this.add.text(
                      100, 50, 'Test Health', {
                          fontFamily: 'Arial',
                          fontSize: '16px',
                          color: '#ffffff',
                          backgroundColor: '#333333',
                          padding: { x: 10, y: 5 }
                      }
                  ).setInteractive({ useHandCursor: true });
                  
                  testButton.on('pointerdown', () => {
                      // Test player team character at index 0 with 50% health
                      if (this.playerTeam && this.playerTeam.length > 0) {
                          const character = this.playerTeam[0];
                          const maxHealth = character.stats.hp;
                          const newHealth = Math.floor(maxHealth * 0.5); // 50% health
                          this.testHealthUpdate('player', 0, newHealth);
                      }
                  });
                  
                  testButton.on('pointerover', () => testButton.setBackgroundColor('#555555'));
                  testButton.on('pointerout', () => testButton.setBackgroundColor('#333333'));
              }
              
              // Create the battle control panel at the bottom of the screen
              if (typeof BattleControlPanel === 'function') {
                 this.battleControlPanel = new BattleControlPanel(
                     this,
                     this.cameras.main.width / 2, // center horizontally
                     this.cameras.main.height - 50 // position near bottom
                 );
                 
                 // Set up event listeners for battle events
                 if (this.battleBridge) {
                     // Listen for battle events to update control panel
                     this.battleBridge.addEventListener(this.battleBridge.eventTypes.BATTLE_STARTED, 
                         (data) => this.battleControlPanel.onBattleEvent(data));
                     this.battleBridge.addEventListener(this.battleBridge.eventTypes.BATTLE_ENDED, 
                         (data) => this.battleControlPanel.onBattleEvent(data));
                     this.battleBridge.addEventListener(this.battleBridge.eventTypes.TURN_STARTED, 
                         (data) => this.onTurnStarted(data));
                 }
                 
                 console.log('Battle control panel created successfully');
             } else {
                 console.error('BattleControlPanel class not found');
                 this.showErrorMessage('Battle controls not available');
             }
         } catch (error) {
             console.error('Error creating battle control panel:', error);
             this.showErrorMessage('Failed to create battle controls');
         }
     }
     
     /**
      * Handle turn started event from BattleManager
      * @param {object} data - Turn data including currentCharacter
      */
     onTurnStarted(data) {
         try {
             console.log(`Turn ${data.turnNumber} started. Character: ${data.currentCharacter?.name}`);
             
             // Update battle state
             this.battleState.currentTurn = data.turnNumber;
             this.battleState.activeCharacter = data.currentCharacter;
             
             // Highlight the active character
             this.highlightActiveCharacter(data.currentCharacter);
             
             // Show turn indicator
             this.showTurnIndicator(data.currentCharacter, data.turnNumber);
         } catch (error) {
             console.error('Error handling turn started event:', error);
         }
     }
     
     /**
      * Show a turn indicator above the active character
      * @param {object} character - The active character
      * @param {number} turnNumber - The current turn number
      */
     showTurnIndicator(character, turnNumber) {
         try {
             if (!character) return;
             
             // Find the character's team container
             const teamContainer = character.team === 'player'
                 ? this.playerTeamContainer
                 : this.enemyTeamContainer;
                 
             if (!teamContainer) return;
             
             // Find the character sprite
             const characterSprite = teamContainer.getCharacterSpriteByName(character.name);
             if (!characterSprite) return;
             
             // Create the turn indicator text
             const text = `TURN ${turnNumber}: ${character.name}'s Action`;
             const indicatorStyle = {
                 fontFamily: 'Arial',
                 fontSize: '18px',
                 color: '#ffffff',
                 stroke: '#000000',
                 strokeThickness: 3,
                 backgroundColor: character.team === 'player' ? '#225588' : '#882255',
                 padding: { x: 10, y: 5 }
             };
             
             // Position at the top of the screen
             const indicator = this.add.text(
                 this.cameras.main.width / 2,
                 80,
                 text,
                 indicatorStyle
             ).setOrigin(0.5, 0.5);
             
             // Store reference for cleanup
             if (this.turnIndicator) this.turnIndicator.destroy();
             this.turnIndicator = indicator;
             
             // Add animation effect
             this.tweens.add({
                 targets: indicator,
                 scale: { from: 0.8, to: 1 },
                 duration: 300,
                 ease: 'Back.easeOut',
                 onComplete: () => {
                     // Slight bounce effect when complete
                     this.tweens.add({
                         targets: indicator,
                         y: { from: 80, to: 85 },
                         duration: 1500,
                         yoyo: true,
                         repeat: -1,
                         ease: 'Sine.easeInOut'
                     });
                 }
             });
         } catch (error) {
             console.error('Error showing turn indicator:', error);
         }
     }

     /**
     * Handle debug keypress events
     */
     handleDebugKeypress(event) {
        // Removed to clean up UI
        return;
     }
     
    /**
     * Get team data from scene
     * Returns copies of team data to prevent reference issues
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} - Deep copy of requested team data
     */
    getTeamData(teamType) {
        try {
            if (teamType === 'player' && this.playerTeam) {
                console.log(`BattleScene: Providing player team data with ${this.playerTeam.length} heroes`);
                return JSON.parse(JSON.stringify(this.playerTeam));
            } else if (teamType === 'enemy' && this.enemyTeam) {
                console.log(`BattleScene: Providing enemy team data with ${this.enemyTeam.length} heroes`);
                return JSON.parse(JSON.stringify(this.enemyTeam));
            } else {
                console.warn(`BattleScene: Unable to provide ${teamType} team data`);
                return [];
            }
        } catch (error) {
            console.error(`BattleScene: Error getting ${teamType} team data:`, error);
            return [];
        }
    }
    
    /**
     * Display battle outcome screen
     * @param {string} winner - 'player', 'enemy', or 'draw'
     */
    showBattleOutcome(winner) {
        try {
            console.log(`BattleScene: Showing battle outcome - Winner: ${winner}`);
            
            // Create container for outcome elements
            const container = this.add.container(this.cameras.main.width / 2, this.cameras.main.height / 2);
            container.setDepth(1000); // Ensure it appears above everything else
            
            // Add semi-transparent background
            const background = this.add.rectangle(
                0, 0, 
                this.cameras.main.width, 
                this.cameras.main.height, 
                0x000000, 0.7
            );
            container.add(background);
            
            // Create outcome message
            let message = '';
            let color = 0xffffff;
            
            if (winner === 'player') {
                message = 'VICTORY!';
                color = 0x00ff00; // Green
            } else if (winner === 'enemy') {
                message = 'DEFEAT';
                color = 0xff0000; // Red
            } else {
                message = 'DRAW';
                color = 0xffff00; // Yellow
            }
            
            // Add outcome text
            const outcomeText = this.add.text(
                0, -50,
                message,
                {
                    fontFamily: 'Arial',
                    fontSize: '64px',
                    color: `#${color.toString(16).padStart(6, '0')}`,
                    stroke: '#000000',
                    strokeThickness: 6,
                    align: 'center',
                    shadow: { color: '#000000', fill: true, offsetX: 2, offsetY: 2, blur: 8 }
                }
            ).setOrigin(0.5);
            container.add(outcomeText);
            
            // Add return button
            const returnButton = this.add.text(
                0, 50,
                'Return to Team Builder',
                {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    color: '#ffffff',
                    backgroundColor: '#555555',
                    padding: { x: 20, y: 10 }
                }
            ).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            returnButton.on('pointerover', () => returnButton.setBackgroundColor('#777777'));
            returnButton.on('pointerout', () => returnButton.setBackgroundColor('#555555'));
            returnButton.on('pointerdown', () => {
                console.log('Return to Team Builder requested by user after battle');
                this.returnToTeamBuilder();
            });
            
            container.add(returnButton);
            
            // Add animation
            this.tweens.add({
                targets: container,
                scale: { from: 0.5, to: 1 },
                alpha: { from: 0, to: 1 },
                duration: 500,
                ease: 'Back.easeOut'
            });
            
            // Store reference to cleanup later
            this.outcomeContainer = container;
            
        } catch (error) {
            console.error('Error showing battle outcome:', error);
        }
    }

     /**
      * Display error messages in the UI
      * @param {string} message - The error message to show
      */
      showErrorMessage(message) {
          console.error('UI Error Message:', message); // Log to console

          // Create or update an error text object on the screen
          if (this.errorText) {
              this.errorText.setText(`ERROR: ${message}`);
          } else {
              this.errorText = this.add.text(
                  this.cameras.main.centerX,
                  30, // Position near top-center
                  `ERROR: ${message}`,
                  {
                      fontFamily: 'Arial',
                      fontSize: '16px',
                      color: '#ff0000', // Red color for errors
                      backgroundColor: 'rgba(0,0,0,0.7)',
                      padding: { x: 10, y: 5 },
                      wordWrap: { width: this.cameras.main.width - 40 }
                  }
              ).setOrigin(0.5, 0).setDepth(1001); // Ensure it's visible
          }
          // Optionally fade out the error after some time
           this.time.delayedCall(5000, () => {
               if (this.errorText) {
                   this.errorText.destroy();
                   this.errorText = null;
               }
           }, [], this);
      }

    /**
     * Update loop for the battle scene
     * Called by Phaser on every frame to update game state
     * * @param {number} time - Current time in ms since game start
     * @param {number} delta - Time in ms since last update
     */
    update(time, delta) {
        // Ensure proper try...catch block structure
        try {

            // Update debug tools if enabled
            if (this.debug.enabled) {
                // Update object identifier if it exists and has an update method
                if (this.objectIdentifier && typeof this.objectIdentifier.update === 'function') {
                    this.objectIdentifier.update();
                } // Closing brace for objectIdentifier check

                // Update coordinate display if it exists and has an update method
                // No separate update needed for CoordinateDisplay as it uses pointer events

            } // Closing brace for debug.enabled check

            // Update character teams if present
            if (this.playerTeamContainer) {
                this.playerTeamContainer.update();
            } // Closing brace for playerTeamContainer check

            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.update();
            } // Closing brace for enemyTeamContainer check

        } catch (error) { // Closing brace for try block, starting catch block
            console.error('Error in update loop:', error);
            // Don't show error messages here to avoid spamming the user
            // since this method is called many times per second
        } // Closing brace for catch block
    } // Closing brace for update method

    /**
     * Scene shutdown handler
     * Clean up resources and listeners when the scene is stopped
     */
    shutdown() {
        console.log('BattleScene: Shutting down');

        try {
            // Clean up debug tools
            this.cleanupDebugTools();

            // Clean up battle bridge
            this.cleanupBattleBridge();

            // Clean up character teams
            this.cleanupCharacterTeams();

            // Clean up keyboard listeners
            if (this.input && this.input.keyboard) {
                this.input.keyboard.off('keydown-D', this.handleDebugKeypress, this);
                // Remove other specific key listeners if they were added (e.g., for Ctrl+G, Ctrl+I)
                // This requires knowing exactly which keys were registered
            }

            // Clean up tweens
            this.tweens.killAll();

            // Clean up local references
            this.battleConfig = null;
            this.playerTeam = null;
            this.enemyTeam = null;
            this.components = {};
            
            // Clean up battle control panel if it exists
            if(this.battleControlPanel) { this.battleControlPanel.destroy(); this.battleControlPanel = null; }
            if(this.battleLog) { this.battleLog.destroy(); this.battleLog = null; }

            // Clean up potential UI elements added
            if(this.errorText) { this.errorText.destroy(); this.errorText = null; }
            if(this.sceneTitle) { this.sceneTitle.destroy(); this.sceneTitle = null; }
            if(this.returnButton) { this.returnButton.destroy(); this.returnButton = null; }
            if(this.testPattern) { this.testPattern.destroy(); this.testPattern = null; }
            if(this.welcomeMessage) { this.welcomeMessage.destroy(); this.welcomeMessage = null; }
            if(this.debugPanel) { this.debugPanel.destroy(); this.debugPanel = null; }
            // Clean up turn indicator
            if(this.turnIndicator) { 
                this.turnIndicator.destroy(); 
                this.turnIndicator = null; 
            }
            if(this.outcomeContainer) { this.outcomeContainer.destroy(); this.outcomeContainer = null; }


            console.log('BattleScene: Shut down successfully');
        } catch (error) {
            console.error('Error during scene shutdown:', error);
        }
    } // Closing brace for shutdown method

} // Closing brace for the BattleScene class

window.BattleScene = BattleScene;

===== FILE: BootScene.js =====
/**
 * Boot Scene
 * The initial scene that loads critical assets and setups the game
 */
class BootScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BootScene' });
    }
    
    /**
     * Preload essential assets for the game
     */
    preload() {
        // Display loading text
        this.add.text(
            this.cameras.main.width / 2,
            this.cameras.main.height / 2, 
            'Loading...', 
            { 
                font: '32px Arial',
                fill: '#ffffff'
            }
        ).setOrigin(0.5);
        
        // Create loading bar
        this.createLoadingBar();
        
        // Load essential UI assets
        this.load.image('button', 'assets/images/ui/button.png');
        this.load.image('panel', 'assets/images/ui/panel.png');
        
        // We'll add more assets here as needed
        
        // Show progress
        this.load.on('progress', (value) => {
            this.updateLoadingBar(value);
        });
        
        // When all assets are loaded
        this.load.on('complete', () => {
            // Clean up loading bar
            if (this.loadingBar) {
                this.loadingBar.destroy();
                this.loadingBarBg.destroy();
            }
        });
    }
    
    /**
     * Create game objects and setup the scene
     */
    create() {
        console.log('BootScene: Starting game initialization');
        
        // Initialize game settings
        this.initializeSettings();
        
        // Start the MainMenuScene (or TeamBuilderScene if we want to go directly there)
        this.scene.start('TeamBuilderScene');
    }
    
    /**
     * Create a visual loading bar
     */
    createLoadingBar() {
        const width = 400;
        const height = 30;
        const x = (this.cameras.main.width - width) / 2;
        const y = (this.cameras.main.height + 100) / 2;
        
        // Background of the loading bar
        this.loadingBarBg = this.add.rectangle(
            x + width / 2,
            y + height / 2,
            width,
            height,
            0x333333
        );
        
        // The actual loading bar that will be scaled
        this.loadingBar = this.add.rectangle(
            x + 2 + (width - 4) / 2, // Account for border
            y + 2 + (height - 4) / 2,
            width - 4, // Account for border
            height - 4,
            0x3742fa
        );
        
        // Start at 0 width
        this.loadingBar.scaleX = 0;
    }
    
    /**
     * Update the loading bar based on progress
     * @param {number} value - Progress value between 0 and 1
     */
    updateLoadingBar(value) {
        if (this.loadingBar) {
            this.loadingBar.scaleX = value;
        }
    }
    
    /**
     * Initialize game settings
     */
    initializeSettings() {
        // Set up any global game settings here
        console.log('BootScene: Game settings initialized');
    }
}


===== FILE: TeamBuilderScene.js =====
/**
 * Team Builder Scene
 * Allows players to select and customize their team
 */
class TeamBuilderScene extends Phaser.Scene {
    constructor() {
        super({ key: 'TeamBuilderScene' });
        
        this.teamManager = null;
        this.selectedHeroes = [null, null, null];
        this.selectedHeroDetails = null;
    }
    
    /**
     * Load assets needed for the team builder
     */
    preload() {
        // Load character images
        // We'll use existing character art initially
        
        // Load UI elements
        this.load.image('grid-bg', 'assets/images/ui/grid-bg.png');
        this.load.image('slot-bg', 'assets/images/ui/slot-bg.png');
        
        // You can add more specific assets later
    }
    
    /**
     * Create the team builder interface
     */
    create() {
        console.log('TeamBuilderScene: Creating Phaser team builder UI');
        
        // Get reference to the existing TeamManager
        this.teamManager = window.teamManager;
        
        // Add "Toggle UI" button that switches between DOM and Phaser
        this.createToggleButton();
        
        // Currently, we'll start with a simple placeholder UI
        // that shows a working Phaser scene with some text
        this.createPlaceholderUI();
        
        // Create events to communicate with DOM UI
        this.setupEvents();
    }
    
    /**
     * Update loop for the scene
     */
    update() {
        // Will be used for animations and interactions
    }
    
    /**
     * Create a button to toggle between DOM and Phaser UI
     */
    createToggleButton() {
        const button = this.add.rectangle(100, 50, 180, 40, 0x3742fa)
            .setInteractive();
        
        const text = this.add.text(100, 50, 'Toggle to DOM UI', { 
            fontSize: '16px',
            fill: '#ffffff' 
        }).setOrigin(0.5);
        
        button.on('pointerdown', () => {
            console.log('Switching to DOM UI');
            // Signal to switch back to DOM UI
            this.toggleToDomUI();
        });
        
        button.on('pointerover', () => {
            button.fillColor = 0x2536e0;
        });
        
        button.on('pointerout', () => {
            button.fillColor = 0x3742fa;
        });
    }
    
    /**
     * Create placeholder UI elements
     */
    createPlaceholderUI() {
        // Add background
        this.add.rectangle(
            this.cameras.main.width / 2,
            this.cameras.main.height / 2,
            this.cameras.main.width,
            this.cameras.main.height,
            0x232a40,
            0.8
        );
        
        // Add title
        this.add.text(
            this.cameras.main.width / 2,
            100,
            'Team Builder (Phaser UI)',
            {
                fontSize: '42px',
                fontFamily: 'Bebas Neue',
                fill: '#ffffff'
            }
        ).setOrigin(0.5);
        
        // Add subtitle
        this.add.text(
            this.cameras.main.width / 2,
            160,
            'This is a placeholder for the Phaser-based team builder',
            {
                fontSize: '18px',
                fontFamily: 'Open Sans',
                fill: '#a4b0be'
            }
        ).setOrigin(0.5);
        
        // Add information
        this.add.text(
            this.cameras.main.width / 2,
            this.cameras.main.height / 2,
            'Phaser UI integration in progress...\nClick "Toggle to DOM UI" to return to the original interface',
            {
                fontSize: '24px',
                fontFamily: 'Arial',
                fill: '#ffffff',
                align: 'center'
            }
        ).setOrigin(0.5);
    }
    
    /**
     * Setup event listeners to communicate with DOM UI
     */
    setupEvents() {
        // Create custom events for communication
        // Will be expanded as we implement more features
    }
    
    /**
     * Toggle back to DOM UI
     */
    toggleToDomUI() {
        // Signal to UIManager to show the DOM UI
        if (window.uiManager) {
            window.uiManager.showDomUI();
        } else {
            // Fallback if uiManager isn't initialized yet
            const phaserContainer = document.getElementById('phaser-container');
            if (phaserContainer) {
                phaserContainer.style.display = 'none';
            }
            
            // Show the team builder container
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) {
                teamBuilderContainer.classList.add('active');
            }
            
            // Hide the game container
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.classList.remove('active');
            }
        }
    }
}


===== FILE: assets.js =====
/**
 * Assets Manager
 * Handles loading and organizing game assets
 */
class AssetsManager {
    constructor() {
        // Will store information about assets
        this.assets = {
            // Character assets
            characters: {},
            
            // UI assets
            ui: {},
            
            // Effect assets
            effects: {},
            
            // Arena backgrounds
            arenas: {}
        };
    }
    
    /**
     * Initialize the assets manager
     */
    initialize() {
        // Catalog arena backgrounds
        this.catalogArenaBackgrounds();
        
        // Catalog UI assets
        this.catalogUIAssets();
        
        // Catalog character assets
        this.catalogCharacterAssets();
        
        console.log('AssetsManager: Initialized');
    }
    
    /**
     * Catalog available arena backgrounds
     */
    catalogArenaBackgrounds() {
        // Get arena backgrounds from existing game
        this.assets.arenas = {
            'default': 'assets/images/Arena Art/default.png',
            'grassyfield': 'assets/images/Arena Art/Grassy Field.png'
            // More will be added as they become available
        };
    }
    
    /**
     * Catalog UI assets
     */
    catalogUIAssets() {
        // Basic UI assets
        this.assets.ui = {
            // Buttons
            'button': 'assets/images/ui/button.png',
            'button-hover': 'assets/images/ui/button-hover.png',
            
            // Panels
            'panel': 'assets/images/ui/panel.png',
            'slot': 'assets/images/ui/slot.png',
            
            // Icons
            'health-icon': 'assets/images/icons/health.png',
            'attack-icon': 'assets/images/icons/attack.png',
            'defense-icon': 'assets/images/icons/defense.png',
            'speed-icon': 'assets/images/icons/speed.png'
            
            // More will be added as needed
        };
    }
    
    /**
     * Catalog character assets
     */
    catalogCharacterAssets() {
        // Use the existing TeamBuilderImageLoader to get character images
        if (window.TeamBuilderImageLoader) {
            const loader = new window.TeamBuilderImageLoader();
            this.assets.characters = loader.characterImages || {};
        } else {
            // Fallback to hard-coded paths
            this.assets.characters = {
                'Aqualia': 'assets/images/Character Art/Aqualia.png',
                'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
                'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
                'Lumina': 'assets/images/Character Art/Lumina.png'
                // More can be added as they become available
            };
        }
    }
    
    /**
     * Get the path to a character image
     * @param {string} characterName - The name of the character
     * @returns {string} The path to the character image
     */
    getCharacterImagePath(characterName) {
        return this.assets.characters[characterName] || '';
    }
    
    /**
     * Get the path to an arena background
     * @param {string} arenaKey - The key of the arena
     * @returns {string} The path to the arena background
     */
    getArenaBackgroundPath(arenaKey) {
        return this.assets.arenas[arenaKey] || this.assets.arenas['default'];
    }
    
    /**
     * Get the path to a UI asset
     * @param {string} assetKey - The key of the UI asset
     * @returns {string} The path to the UI asset
     */
    getUIAssetPath(assetKey) {
        return this.assets.ui[assetKey] || '';
    }
    
    /**
     * Preload assets into a Phaser scene
     * @param {Phaser.Scene} scene - The scene to preload assets into
     * @param {string} type - The type of assets to preload ('characters', 'ui', 'arenas', 'all')
     */
    preloadAssets(scene, type = 'all') {
        if (!scene || !scene.load) {
            console.error('AssetsManager: Invalid scene provided for preloading');
            return;
        }
        
        // Preload character assets
        if (type === 'all' || type === 'characters') {
            for (const [name, path] of Object.entries(this.assets.characters)) {
                if (path) {
                    scene.load.image(`character-${name.toLowerCase()}`, path);
                }
            }
        }
        
        // Preload UI assets
        if (type === 'all' || type === 'ui') {
            for (const [key, path] of Object.entries(this.assets.ui)) {
                if (path) {
                    scene.load.image(`ui-${key}`, path);
                }
            }
        }
        
        // Preload arena backgrounds
        if (type === 'all' || type === 'arenas') {
            for (const [key, path] of Object.entries(this.assets.arenas)) {
                if (path) {
                    scene.load.image(`arena-${key}`, path);
                }
            }
        }
    }
}


===== FILE: bridge.js =====
/**
 * Game Bridge (LEGACY SYSTEM)
 * Provides communication between existing game logic and Phaser UI
 * 
 * NOTE: This is a legacy bridge that is being replaced by BattleBridge.
 * It is kept for compatibility but should not be used for new development.
 */
class GameBridge {
    constructor() {
        // References to key game components
        this.teamManager = null;
        this.battleManager = null;
        
        // Event listeners for game events
        this.eventListeners = {};
        
        // IMPORTANT: Do not overwrite the global BattleBridge class or instance
        console.log('GameBridge: Created legacy bridge - this system is deprecated');
        console.log('GameBridge: Preserving existing BattleBridge if it exists');
    }
    
    /**
     * Initialize the bridge with game managers
     * @param {Object} teamManager - The team manager instance
     * @param {Object} battleManager - The battle manager instance
     */
    initialize(teamManager, battleManager) {
        this.teamManager = teamManager;
        this.battleManager = battleManager;
        
        // Set up event system
        this.setupEvents();
        
        console.log('GameBridge: Initialized');
    }
    
    /**
     * Set up event system for communication
     */
    setupEvents() {
        // Create a custom event system for game events
        this.eventTypes = {
            TEAM_UPDATED: 'team_updated',
            BATTLE_STARTED: 'battle_started',
            BATTLE_ENDED: 'battle_ended',
            CHARACTER_ACTION: 'character_action',
            CHARACTER_DAMAGED: 'character_damaged',
            CHARACTER_HEALED: 'character_healed',
            CHARACTER_DEFEATED: 'character_defeated',
            STATUS_EFFECT_APPLIED: 'status_effect_applied',
            ABILITY_USED: 'ability_used'
        };
        
        // Initialize event listeners
        Object.values(this.eventTypes).forEach(type => {
            this.eventListeners[type] = [];
        });
        
        console.log('GameBridge: Event system set up');
    }
    
    /**
     * Add an event listener for a game event
     * @param {string} eventType - The type of event to listen for
     * @param {Function} callback - The callback function to execute
     */
    addEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) {
            this.eventListeners[eventType] = [];
        }
        
        this.eventListeners[eventType].push(callback);
    }
    
    /**
     * Remove an event listener
     * @param {string} eventType - The type of event
     * @param {Function} callback - The callback function to remove
     */
    removeEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) return;
        
        const index = this.eventListeners[eventType].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[eventType].splice(index, 1);
        }
    }
    
    /**
     * Dispatch a game event
     * @param {string} eventType - The type of event to dispatch
     * @param {Object} data - The data to pass to event listeners
     */
    dispatchEvent(eventType, data) {
        if (!this.eventListeners[eventType]) return;
        
        this.eventListeners[eventType].forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`GameBridge: Error in event listener for ${eventType}`, error);
            }
        });
    }
    
    /**
     * Patch into BattleManager to receive battle events
     */
    patchBattleManager() {
        if (!this.battleManager) {
            console.error('GameBridge: BattleManager not available for patching');
            return;
        }
        
        // Store original functions
        const originalApplyDamage = this.battleManager.applyDamage;
        const originalApplyHealing = this.battleManager.applyHealing;
        const originalProcessAbility = this.battleManager.processAbility;
        const originalAddStatusEffect = this.battleManager.addStatusEffect;
        const originalStartBattle = this.battleManager.startBattle;
        const originalEndBattle = this.battleManager.endBattle;
        
        // Patch functions to add event dispatching
        const self = this;
        
        // Patch damage function
        this.battleManager.applyDamage = function(target, amount, source) {
            const result = originalApplyDamage.call(this, target, amount, source);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.CHARACTER_DAMAGED, {
                target,
                amount,
                source,
                result
            });
            
            // Check for defeat
            if (target.stats.hp <= 0) {
                self.dispatchEvent(self.eventTypes.CHARACTER_DEFEATED, {
                    character: target,
                    source
                });
            }
            
            return result;
        };
        
        // Patch healing function
        this.battleManager.applyHealing = function(target, amount, source) {
            const result = originalApplyHealing.call(this, target, amount, source);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.CHARACTER_HEALED, {
                target,
                amount,
                source,
                result
            });
            
            return result;
        };
        
        // Patch ability processing
        this.battleManager.processAbility = function(character, ability, targets) {
            const result = originalProcessAbility.call(this, character, ability, targets);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.ABILITY_USED, {
                character,
                ability,
                targets,
                result
            });
            
            return result;
        };
        
        // Patch status effect application
        this.battleManager.addStatusEffect = function(target, effect, source) {
            const result = originalAddStatusEffect.call(this, target, effect, source);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.STATUS_EFFECT_APPLIED, {
                target,
                effect,
                source,
                result
            });
            
            return result;
        };
        
        // Patch battle start
        this.battleManager.startBattle = function(playerTeam, enemyTeam) {
            const result = originalStartBattle.call(this, playerTeam, enemyTeam);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.BATTLE_STARTED, {
                playerTeam,
                enemyTeam
            });
            
            return result;
        };
        
        // Patch battle end
        this.battleManager.endBattle = function(winner) {
            const result = originalEndBattle.call(this, winner);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.BATTLE_ENDED, {
                winner,
                playerTeam: this.playerTeam,
                enemyTeam: this.enemyTeam
            });
            
            return result;
        };
        
        console.log('GameBridge: BattleManager patched for event dispatching');
    }
    
    /**
     * Patch into TeamManager to receive team events
     */
    patchTeamManager() {
        if (!this.teamManager) {
            console.error('GameBridge: TeamManager not available for patching');
            return;
        }
        
        // Store original functions
        const originalSetPlayerTeam = this.teamManager.setPlayerTeam;
        const originalSetCustomEnemyTeam = this.teamManager.setCustomEnemyTeam;
        
        // Patch functions to add event dispatching
        const self = this;
        
        // Patch player team setting
        this.teamManager.setPlayerTeam = function(team) {
            const result = originalSetPlayerTeam.call(this, team);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.TEAM_UPDATED, {
                team: 'player',
                characters: team
            });
            
            return result;
        };
        
        // Patch enemy team setting
        this.teamManager.setCustomEnemyTeam = function(team) {
            const result = originalSetCustomEnemyTeam.call(this, team);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.TEAM_UPDATED, {
                team: 'enemy',
                characters: team
            });
            
            return result;
        };
        
        console.log('GameBridge: TeamManager patched for event dispatching');
    }
    
    /**
     * Get player team from TeamManager
     * @returns {Array} The player team
     */
    getPlayerTeam() {
        return this.teamManager ? this.teamManager.playerTeam : [];
    }
    
    /**
     * Get enemy team from TeamManager
     * @returns {Array} The enemy team
     */
    getEnemyTeam() {
        return this.teamManager ? this.teamManager.enemyTeam : [];
    }
    
    /**
     * Start a battle with the current teams
     */
    startBattle() {
        if (!this.battleManager) {
            console.error('GameBridge: BattleManager not available for battle');
            return;
        }
        
        // Start the battle with current teams
        const playerTeam = this.getPlayerTeam();
        const enemyTeam = this.getEnemyTeam();
        
        this.battleManager.startBattle(playerTeam, enemyTeam);
    }
}


===== FILE: config.js =====
/**
 * Phaser Game Configuration
 * This file contains the configuration for the Phaser game instance
 */

class PhaserConfig {
    /**
     * Create a Phaser game configuration
     * @param {Object} gameConfig - The game configuration settings
     * @returns {Object} Phaser game configuration object
     */
    static create(gameConfig) {
        // Default settings if not provided
        const width = gameConfig?.width || 1920;
        const height = gameConfig?.height || 1080;
        
        return {
            type: Phaser.AUTO,
            width: width,
            height: height,
            parent: 'phaser-container',
            backgroundColor: '#141e2e',
            transparent: true,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            // We'll add scenes dynamically after they're loaded
            scene: []
        };
    }
    
    /**
     * Initialize the Phaser container in the DOM
     * @param {string} parentId - The ID of the parent container
     * @returns {HTMLElement} The created Phaser container
     */
    static initContainer(parentId = 'game-container') {
        const gameContainer = document.getElementById(parentId);
        
        // Check if container already exists
        let phaserContainer = document.getElementById('phaser-container');
        if (phaserContainer) {
            return phaserContainer;
        }
        
        // Create container if it doesn't exist
        phaserContainer = document.createElement('div');
        phaserContainer.id = 'phaser-container';
        phaserContainer.style.position = 'absolute';
        phaserContainer.style.top = '0';
        phaserContainer.style.left = '0';
        phaserContainer.style.width = '100%';
        phaserContainer.style.height = '100%';
        phaserContainer.style.zIndex = '0';
        gameContainer.appendChild(phaserContainer);
        
        return phaserContainer;
    }
}


===== FILE: PhaserConfig.js =====
/**
 * PhaserConfig.js
 * Configuration utilities for Phaser game initialization
 * 
 * @version 0.5.0.3
 */

// Create a self-executing function to avoid global namespace pollution
(function() {
    // Create the PhaserConfig object
    const PhaserConfig = {
        /**
         * Initialize and get the container for Phaser game
         * @param {string} containerId - The ID for the container element
         * @returns {HTMLElement} - The container element
         */
        initContainer: function(containerId) {
            try {
                // Check if container exists
                let container = document.getElementById(containerId);
                
                // Create container if it doesn't exist
                if (!container) {
                    console.log(`Creating Phaser container with ID: ${containerId}`);
                    container = document.createElement('div');
                    container.id = containerId;
                    document.body.appendChild(container);
                }
                
                // Make sure it has proper styling
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.position = 'absolute';
                container.style.top = '0';
                container.style.left = '0';
                container.style.zIndex = '1000';  // Make sure it's above the TeamBuilder UI
                
                // Hide initially
                container.style.display = 'none';
                
                return container;
            } catch (error) {
                console.error('Error initializing Phaser container:', error);
                // Create emergency fallback container
                const fallbackContainer = document.createElement('div');
                fallbackContainer.id = containerId + '-fallback';
                document.body.appendChild(fallbackContainer);
                return fallbackContainer;
            }
        },
        
        /**
         * Create the Phaser game configuration
         * @param {Object} gameConfig - Game configuration from game.js
         * @returns {Object} - Phaser game configuration object
         */
        create: function(gameConfig) {
            return {
                type: Phaser.AUTO,
                width: gameConfig.width || 1280,
                height: gameConfig.height || 720,
                parent: 'game-container',
                backgroundColor: '#333344',
                scene: [], // Scenes will be added after initialization
                render: {
                    pixelArt: false,
                    antialias: true,
                    roundPixels: false, // Need false for smoother scaling
                    powerPreference: 'high-performance',
                    crisp: false, // Don't use crisp pixelated rendering
                    batchSize: 8192, // Increased batch size for performance
                    // Note: setFilter was removed as it's not available in this Phaser version
                    // Instead, we use these render settings for the same effect
                },
                scale: {
                    mode: Phaser.Scale.FIT,
                    autoCenter: Phaser.Scale.CENTER_BOTH
                },
                physics: {
                    default: false  // No physics needed for this game
                }
            };
        },
        
        /**
         * Check if Phaser is properly initialized
         * @returns {boolean} - Whether Phaser is ready
         */
        isPhaserReady: function() {
            return (
                typeof Phaser !== 'undefined' && 
                window.game && 
                window.game.scene
            );
        }
    };
    
    // Make PhaserConfig available globally
    window.PhaserConfig = PhaserConfig;
    
    console.log('PhaserConfig initialized successfully');
})();


===== FILE: uiManager.js =====
/**
 * UI Manager
 * Handles switching between DOM and Phaser UIs
 */
class UIManager {
    constructor() {
        this.currentUI = 'dom'; // 'dom' or 'phaser'
        this.game = null; // Will hold the Phaser game instance
        this.scenes = {}; // Will hold references to scenes
    }
    
    /**
     * Initialize the UI Manager
     * @param {Object} game - Phaser game instance
     */
    initialize(game) {
        this.game = game;
        
        // Store references to DOM elements
        this.domElements = {
            teamBuilder: document.getElementById('team-builder-container'),
            gameContainer: document.getElementById('game-container'),
            phaserContainer: document.getElementById('phaser-container')
        };
        
        // Add UI toggle buttons to DOM
        this.addDomToggleButtons();
        
        console.log('UIManager: Initialized');
    }
    
    /**
     * Add toggle buttons to the DOM UI
     */
    addDomToggleButtons() {
        // Create toggle button for team builder
        const teamBuilderContainer = this.domElements.teamBuilder;
        if (teamBuilderContainer) {
            const toggleButton = document.createElement('button');
            toggleButton.textContent = 'Try Phaser UI';
            toggleButton.className = 'phaser-toggle-btn';
            toggleButton.style.position = 'absolute';
            toggleButton.style.top = '20px';
            toggleButton.style.right = '20px';
            toggleButton.style.zIndex = '1000';
            toggleButton.style.backgroundColor = '#3742fa';
            toggleButton.style.color = 'white';
            toggleButton.style.border = 'none';
            toggleButton.style.padding = '8px 16px';
            toggleButton.style.borderRadius = '4px';
            toggleButton.style.cursor = 'pointer';
            
            toggleButton.addEventListener('click', () => {
                this.showPhaserUI('TeamBuilderScene');
            });
            
            teamBuilderContainer.appendChild(toggleButton);
        }
        
        // The battle UI toggle button will be added when battle starts
    }
    
    /**
     * Register a scene with the UI Manager
     * @param {string} key - The scene key
     * @param {Phaser.Scene} scene - The scene instance
     */
    registerScene(key, scene) {
        this.scenes[key] = scene;
    }
    
    /**
     * Show the DOM UI
     */
    showDomUI() {
        // Hide Phaser container
        if (this.domElements.phaserContainer) {
            this.domElements.phaserContainer.style.display = 'none';
        }
        
        // Show appropriate DOM container based on current context
        if (this.currentUI === 'battle') {
            // Show game container for battle
            if (this.domElements.gameContainer) {
                this.domElements.gameContainer.classList.add('active');
            }
            
            // Hide team builder
            if (this.domElements.teamBuilder) {
                this.domElements.teamBuilder.classList.remove('active');
            }
        } else {
            // Show team builder for team selection
            if (this.domElements.teamBuilder) {
                this.domElements.teamBuilder.classList.add('active');
            }
            
            // Hide game container
            if (this.domElements.gameContainer) {
                this.domElements.gameContainer.classList.remove('active');
            }
        }
        
        this.currentUI = 'dom';
        console.log('UIManager: Switched to DOM UI');
    }
    
    /**
     * Show the Phaser UI with the specified scene
     * @param {string} sceneKey - The scene to show
     */
    showPhaserUI(sceneKey) {
        // Make sure the game is initialized
        if (!this.game) {
            console.error('UIManager: Phaser game not initialized');
            return;
        }
        
        // Show Phaser container
        if (this.domElements.phaserContainer) {
            this.domElements.phaserContainer.style.display = 'block';
        }
        
        // Hide DOM UI containers
        if (this.domElements.teamBuilder) {
            this.domElements.teamBuilder.classList.remove('active');
        }
        
        if (this.domElements.gameContainer) {
            this.domElements.gameContainer.classList.remove('active');
        }
        
        // Start the appropriate scene
        try {
            // Stop all active scenes
            const activeScenes = this.game.scene.getScenes(true);
            activeScenes.forEach(scene => {
                if (scene.scene.key !== sceneKey) {
                    scene.scene.stop();
                }
            });
            
            // Start or resume the requested scene
            if (!this.game.scene.isActive(sceneKey)) {
                this.game.scene.start(sceneKey);
            } else {
                this.game.scene.resume(sceneKey);
            }
            
            // Update current UI state
            this.currentUI = sceneKey === 'BattleScene' ? 'battle' : 'phaser';
            console.log(`UIManager: Switched to Phaser UI (${sceneKey})`);
        } catch (error) {
            console.error(`UIManager: Error starting scene ${sceneKey}`, error);
        }
    }
    
    /**
     * Start a battle with the specified teams in Phaser
     * @param {Array} playerTeam - The player's team
     * @param {Array} enemyTeam - The enemy team
     */
    startBattleInPhaser(playerTeam, enemyTeam) {
        // Show Phaser UI with BattleScene
        this.showPhaserUI('BattleScene');
        
        // Get reference to BattleScene
        const battleScene = this.game.scene.getScene('BattleScene');
        if (battleScene) {
            // Start the battle
            battleScene.startBattle(playerTeam, enemyTeam);
        }
    }
}


===== FILE: BattleUI.js =====
/**
 * Battle UI
 * Manages the user interface during battle
 * Implements a Tailwind CSS-based design
 */

class BattleUI {
    /**
     * Verify that background images are available
     * @param {Array} backgroundKeys - Keys for backgrounds to check
     */
    verifyBackgroundImages(backgroundKeys) {
        console.log('Verifying background images availability...');
        
        backgroundKeys.forEach(key => {
            if (key === 'default') {
                console.log('Default grid pattern background is always available');
                return;
            }
            
            const imageUrl = key === 'grassyfield' ? 
                'assets/images/Arena Art/Grassy Field.png' : 
                `assets/images/Arena Art/${key}.jpg`;
            
            // Create a test image to check if it loads
            const img = new Image();
            img.onload = () => {
                console.log(`âœ… Background image verified: ${imageUrl}`);
            };
            img.onerror = () => {
                console.error(`âŒ Background image not found: ${imageUrl}`);
                // Try an alternative path without leading slash
                const altUrl = key === 'grassyfield' ? 
                    'assets/images/Arena Art/Grassy Field.png' : 
                    `assets/images/Arena Art/${key}.jpg`;
                
                console.log(`Trying alternative path: ${altUrl}`);
                
                const altImg = new Image();
                altImg.onload = () => {
                    console.log(`âœ… Alternative path works: ${altUrl}`);
                    // Update the CSS with the working path
                    this.updateBackgroundImagePath(key, altUrl);
                };
                altImg.onerror = () => {
                    console.error(`âŒ Alternative path also failed: ${altUrl}`);
                    console.log('Checking if directory exists...');
                };
                altImg.src = altUrl;
            };
            img.src = imageUrl;
        });
    }
    
    /**
     * Update background image path in CSS
     * @param {string} key - Background key
     * @param {string} url - Working URL
     */
    updateBackgroundImagePath(key, url) {
        // Find the style element
        const styleEl = document.getElementById('battle-ui-styles');
        if (!styleEl) return;
        
        // Get the current styles
        let css = styleEl.textContent;
        
        // Replace the URL in the CSS
        const regex = new RegExp(`\.arena-${key}\s*{[^}]*background-image:\s*url\(['"]?([^'"\)]+)['"]?\)`, 'g');
        const newCss = css.replace(regex, (match, oldUrl) => {
            return match.replace(oldUrl, url);
        });
        
        // Update the style element
        styleEl.textContent = newCss;
        
        console.log(`Updated CSS with working path for ${key}`);
    }
    /**
     * Create a new Battle UI
     * @param {Phaser.Scene} scene - The Phaser scene for the battle
     * @param {BattleManager} battleManager - Reference to the battle manager
     */
    constructor(scene, battleManager) {
        this.scene = scene;
        this.battleManager = battleManager;
        this.elements = {};
        this.isSetup = false;
        this.playerTeam = [];
        this.enemyTeam = [];
        this.currentTurn = 0;
        this.logMessages = [];
        this.activeCharacter = null;
        this.floatingTexts = [];
        this.typeColors = {
            fire: '#ff4757',
            water: '#1e90ff',
            nature: '#2ed573',
            dark: '#9900cc',
            light: '#ffd700',
            air: '#70a1ff'
        };
        this.arenaBackground = 'grassyfield'; // Use Grassy Field as default background
    }

    /**
     * Initialize the battle UI
     */
    initialize() {
        // Check if already initialized
        if (this.isSetup) {
            console.log('BattleUI: Already initialized, skipping');
            // Even if already initialized, make sure tooltips are cleaned up
            this.cleanupTooltips();
            return;
        }
        
        // Check if battle UI already exists in DOM and remove it if it does
        const existingUI = document.getElementById('battle-ui');
        if (existingUI) {
            console.log('BattleUI: Found existing UI, removing it');
            // Clean up tooltips before removing the UI
            this.cleanupTooltips();
            existingUI.remove();
        }
        
        console.log('BattleUI: Initializing...');
        
        // Clear anything in the game container
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.innerHTML = '';
        } else {
            console.error('Game container not found! Make sure game-container element exists.');
        }
        
        // Add Tailwind CSS if not already present
        this.ensureTailwindCSSIsLoaded();
        
        // Add custom CSS
        this.addCustomStyles();
        
        // Initialize tooltip manager
        this.initializeTooltipManager();
        
        // Create the UI container
        const battleUI = document.createElement('div');
        battleUI.id = 'battle-ui';
        battleUI.className = 'min-h-screen flex flex-col p-4 font-inter';
        battleUI.style.backgroundColor = '#141e2e';
        battleUI.style.color = '#e0e0e0';
        battleUI.style.fontFamily = "'Inter', sans-serif";
        
        // Create header with controls
        const header = this.createHeader();
        battleUI.appendChild(header);
        
        // Create main battle area
        const main = document.createElement('main');
        main.className = 'flex-grow flex gap-4 md:gap-8 items-start justify-center pt-8 relative';
        main.id = 'battle-arena';
        
        // Add arena background
        this.setArenaBackground(main, this.arenaBackground);
        
        // Create player team section
        const playerSection = this.createTeamSection('Your Team', 'text-blue-300');
        
        // Create VS divider
        const vsDiv = document.createElement('div');
        vsDiv.className = 'flex items-center justify-center flex-grow-0 pt-24';
        const vsSpan = document.createElement('span');
        vsSpan.className = 'text-4xl font-bold text-gray-500';
        vsSpan.textContent = 'VS';
        vsDiv.appendChild(vsSpan);
        
        // Create enemy team section
        const enemySection = this.createTeamSection('Enemy Team', 'text-red-300');
        
        // Add team sections to main
        main.appendChild(playerSection);
        main.appendChild(vsDiv);
        main.appendChild(enemySection);
        
        battleUI.appendChild(main);
        
        // Create battle log and add it to the main battle area
        const battleLog = this.createBattleLog();
        main.appendChild(battleLog);
        
        // Add to DOM
        document.body.appendChild(battleUI);
        
        // Store references to key elements
        this.elements = {
            playerTeamContainer: playerSection,
            enemyTeamContainer: enemySection,
            turnDisplay: document.getElementById('turn-display'),
            logContent: document.getElementById('battle-log-content'),
            speedButtons: {
                '1x': document.getElementById('speed-1x'),
                '2x': document.getElementById('speed-2x'),
                '4x': document.getElementById('speed-4x')
            },
            pauseButton: document.getElementById('pause-button'),
            nextTurnButton: document.getElementById('next-turn-button'),
            battleArena: main
        };
        
        this.isSetup = true;
        console.log('BattleUI: Initialized');
        
        // Check available backgrounds
        this.verifyBackgroundImages(['default', 'grassyfield']);
        
        // Check if Tailwind is working correctly and apply fallback styles if needed
        setTimeout(() => {
            if (BattleUIDebug) {
                const snapshot = BattleUIDebug.createSnapshot(this);
                if (!snapshot.tailwindStatus.tailwindWorking) {
                    console.log('BattleUI: Tailwind not working, applying fallback styles');
                    BattleUIDebug.injectFallbackStyles();
                    BattleUIDebug.fixCommonIssues(this);
                }
            }
        }, 500);
    }
    
    /**
     * Ensure Tailwind CSS is loaded
     */
    ensureTailwindCSSIsLoaded() {
        if (!document.getElementById('tailwind-css')) {
            console.log('BattleUI: Adding Tailwind CSS script tag');
            const tailwindScript = document.createElement('script');
            tailwindScript.id = 'tailwind-css';
            tailwindScript.src = 'https://cdn.tailwindcss.com';
            document.head.appendChild(tailwindScript);
            
            // Also add Inter font
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap';
            document.head.appendChild(fontLink);
        }
    }
    
    /**
     * Add custom styles for the battle UI
     */
    addCustomStyles() {
        if (!document.getElementById('battle-ui-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'battle-ui-styles';
            styleEl.textContent = `
                .panel-bg {
                    background-color: #232a40; /* Darker panel color */
                }
                /* Type colors for backgrounds */
                .bg-fire { background-color: #ff4757; }
                .bg-water { background-color: #1e90ff; }
                .bg-nature { background-color: #2ed573; }
                .bg-dark { background-color: #9900cc; }
                .bg-light { background-color: #ffd700; }
                .bg-air { background-color: #70a1ff; }
                
                /* Character Art Styles */
                .character-art-container {
                    background-color: transparent !important;
                    border: none !important;
                    overflow: visible;
                    width: 64px !important;
                    height: 64px !important;
                }
                
                .character-art-wrapper {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 5;
                    pointer-events: none;
                }
                
                .character-art {
                    width: 80px;
                    height: 120px;
                    object-fit: contain;
                    position: absolute;
                    top: -52px;
                    left: -2px; /* Moved more to the right */
                    pointer-events: none;
                    z-index: 10;
                }
                
                /* Special styling for characters with art during active/animation states */
                .active-character .character-art-container {
                    box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.3) !important;
                }
                
                .art-loaded.character-moving img {
                    filter: drop-shadow(0 0 5px rgba(30, 144, 255, 0.8));
                }

                /* Character Circle */
                .character-circle {
                    width: 64px; /* Adjust size as needed */
                    height: 64px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.5rem; /* Size for initial letter */
                    font-weight: bold;
                    margin-bottom: 8px; /* Space between circle and HP bar */
                    border: 2px solid rgba(255, 255, 255, 0.3); /* Subtle border */
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    position: relative; /* Needed for floating text positioning */
                    transition: transform 0.3s ease-in-out;
                }
                /* Character Movement Animations */
                .character-moving {
                    z-index: 100; /* Ensure moving character appears above others */
                }
                /* Text color for light backgrounds */
                .text-dark-on-light { color: #141e2e; }

                /* Simple HP bar style */
                .hp-bar-container {
                    width: 80px; /* Match width roughly to circle */
                    margin: 0 auto; /* Center the bar */
                }
                .hp-bar-background {
                    background-color: #4a5568; /* Gray background for the bar */
                    height: 8px;
                    border-radius: 4px;
                    overflow: hidden;
                    border: 1px solid #2d3748;
                }
                .hp-bar-current {
                    background-color: #48bb78; /* Green for current HP */
                    height: 100%;
                    transition: width 0.3s ease-in-out;
                    border-radius: 4px 0 0 4px; /* Keep left radius */
                }

                /* Highlight for active character */
                .active-character .character-circle { /* Apply glow to the circle */
                    box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6); /* Gold glow */
                    border-color: rgba(255, 215, 0, 0.8);
                }
                .active-character { /* Add scaling to the container */
                     transform: scale(1.05);
                }

                /* Status icons */
                .status-icons-container {
                    margin-top: 4px;
                    display: flex;
                    justify-content: center; /* Center icons below HP bar */
                    gap: 4px; /* Space between icons */
                    min-height: 16px; /* Reserve space even if no icons */
                }
                .status-icon {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    text-align: center;
                    line-height: 16px;
                    font-weight: bold;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
                    cursor: help; /* Show help cursor on hover */
                    transition: transform 0.2s, box-shadow 0.2s;
                    background-color: rgba(0, 0, 0, 0.3); /* Default background color */
                    border: 1px solid rgba(255, 255, 255, 0.3); /* Light border */
                    position: relative;
                    overflow: hidden; /* Make sure icon doesn't overflow the circle */
                    background-size: cover; /* For icon images */
                    background-position: center;
                    background-repeat: no-repeat;
                }
                
                .status-icon:hover {
                    transform: scale(1.3); /* Scale up on hover */
                    box-shadow: 0 0 6px rgba(255, 255, 255, 0.8); /* Glow effect */
                    z-index: 10; /* Ensure it appears above other icons */
                }

                /* Basic button styling */
                .control-button {
                    background-color: #4a5568;
                    padding: 6px 12px;
                    border-radius: 6px;
                    margin-left: 8px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                    font-size: 14px;
                }
                .control-button:hover {
                    background-color: #718096;
                }
                .control-button.active {
                    background-color: #a0aec0;
                    color: #141e2e;
                }

                /* Battle Log Styling */
                .battle-log {
                    height: 180px; /* Increased height */
                    overflow-y: auto;
                    transition: height 0.3s ease-in-out;
                    max-height: 250px;
                    background-color: rgba(28, 33, 48, 0.95) !important; /* More opaque, darker background */
                    /* Hide default scrollbar in different browsers */
                    scrollbar-width: none; /* Firefox */
                    -ms-overflow-style: none; /* IE and Edge */
                }
                
                /* Hide scrollbar for Chrome, Safari and Opera */
                .battle-log::-webkit-scrollbar {
                    display: none;
                }

                /* Simple floating text placeholder */
                .floating-text {
                    position: absolute;
                    top: -25px; /* Position above the circle */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 2px 6px;
                    border-radius: 4px;
                    font-size: 16px;
                    font-weight: bold;
                    white-space: nowrap;
                    z-index: 10; /* Ensure it's above the circle */
                    animation: float-up-fade-out 1.2s forwards;
                }
                
                @keyframes float-up-fade-out {
                    0% {
                        opacity: 0;
                        transform: translate(-50%, 0);
                    }
                    10% {
                        opacity: 1;
                    }
                    80% {
                        opacity: 1;
                    }
                    100% {
                        opacity: 0;
                        transform: translate(-50%, -30px);
                    }
                }
                
                /* Arena backgrounds */
                .arena-default {
                    background-color: #1a1a2e;
                    background-image: linear-gradient(rgba(0,0,0,0.3) 1px, transparent 1px),
                                      linear-gradient(90deg, rgba(0,0,0,0.3) 1px, transparent 1px);
                    background-size: 20px 20px;
                }
                .arena-grassyfield {
                    background-image: url('assets/images/Arena Art/Grassy Field.png');
                    background-size: cover;
                    background-position: center;
                }
                
                /* Victory overlay */
                .victory-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: calc(100% - 200px); /* Leave space for battle log */
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    background-color: rgba(0, 0, 0, 0.7);
                    z-index: 20;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out;
                }
                .victory-text {
                    font-size: 48px;
                    font-weight: bold;
                    margin-bottom: 24px;
                    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
                }
                .victory-button {
                    padding: 12px 24px;
                    background-color: #3742fa;
                    color: white;
                    border-radius: 8px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }
                .victory-button:hover {
                    background-color: #2536e0;
                }
                
                /* Animation for when a character takes damage */
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-5px); }
                    50% { transform: translateX(5px); }
                    75% { transform: translateX(-5px); }
                }
                
                /* Bonk attack animation */
                @keyframes bonk-animation {
                    0% { transform: translateX(-50%) scale(0); opacity: 0; }
                    50% { transform: translateX(-50%) scale(1.5); opacity: 1; }
                    100% { transform: translateX(-50%) scale(1); opacity: 0; }
                }
                
                .attack-bonk {
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 24px;
                    z-index: 110;
                    pointer-events: none;
                }
                
                .animate-bonk {
                    animation: bonk-animation 500ms ease-out forwards;
                }
                
                /* Action Text Animation */
                @keyframes action-text-animation {
                    0% { 
                        opacity: 0;
                        transform: translate(-50%, 10px) scale(0.8);
                    }
                    15% { 
                        opacity: 1;
                        transform: translate(-50%, -5px) scale(1.1);
                    }
                    80% { 
                        opacity: 1;
                        transform: translate(-50%, -5px) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translate(-50%, -15px) scale(0.9);
                    }
                }

                .action-text {
                    position: absolute;
                    top: 10px; /* Adjusted to appear above character container */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.6);
                    color: white;
                    padding: 3px 8px;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: bold;
                    white-space: nowrap;
                    z-index: 50;
                    animation: action-text-animation 1.8s forwards;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                    pointer-events: none;
                }

                /* Action text colors */
                .action-text-attack {
                    color: #f56565; /* Red for attacks */
                }

                .action-text-ability {
                    color: #4299e1; /* Blue for abilities */
                }

                .action-text-heal {
                    color: #48bb78; /* Green for healing */
                }
                
                /* Make sure battle UI properly fills the screen */
                #battle-ui {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    background-color: #141e2e;
                    color: white;
                    overflow: hidden;
                }
            `;
            document.head.appendChild(styleEl);
        }
    }
    
    /**
     * Create the header with turn indicator and controls
     * @returns {HTMLElement} Header element
     */
    createHeader() {
        const header = document.createElement('header');
        header.className = 'panel-bg rounded-lg p-3 mb-4 flex justify-between items-center shadow-md';
        
        // Turn display
        const turnDiv = document.createElement('div');
        const turnSpan = document.createElement('span');
        turnSpan.id = 'turn-display';
        turnSpan.className = 'text-lg font-semibold';
        turnSpan.textContent = 'Turn: 0';
        turnDiv.appendChild(turnSpan);
        
        // Controls
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'flex items-center';
        
        const speedLabel = document.createElement('span');
        speedLabel.className = 'mr-2 text-sm';
        speedLabel.textContent = 'Speed:';
        controlsDiv.appendChild(speedLabel);
        
        // Speed buttons
        const speedButtons = [
            { id: 'speed-1x', text: '1x', active: true, speed: 1 },
            { id: 'speed-2x', text: '2x', active: false, speed: 2 },
            { id: 'speed-4x', text: '4x', active: false, speed: 4 }
        ];
        
        speedButtons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = `control-button ${btn.active ? 'active' : ''}`;
            button.textContent = btn.text;
            button.addEventListener('click', () => this.setSpeed(btn.speed));
            controlsDiv.appendChild(button);
        });
        
        // Pause button
        const pauseButton = document.createElement('button');
        pauseButton.id = 'pause-button';
        pauseButton.className = 'control-button ml-4';
        pauseButton.innerHTML = '&#10074;&#10074;'; // Pause symbol
        pauseButton.addEventListener('click', () => this.togglePause());
        controlsDiv.appendChild(pauseButton);
        
        // Next turn button
        const nextTurnButton = document.createElement('button');
        nextTurnButton.id = 'next-turn-button';
        nextTurnButton.className = 'control-button ml-4';
        nextTurnButton.innerHTML = '&#9654;&#9654;'; // Fast forward symbol
        nextTurnButton.addEventListener('click', () => this.nextTurn());
        controlsDiv.appendChild(nextTurnButton);
        
        // Settings button
        const settingsButton = document.createElement('button');
        settingsButton.id = 'settings-button';
        settingsButton.className = 'control-button ml-1';
        settingsButton.innerHTML = '&#9881;'; // Gear symbol
        settingsButton.addEventListener('click', () => this.showSettings());
        controlsDiv.appendChild(settingsButton);
        
        // Back button
        const backButton = document.createElement('button');
        backButton.id = 'back-button';
        backButton.className = 'control-button ml-4';
        backButton.textContent = 'Back';
        backButton.addEventListener('click', () => this.exitBattle());
        controlsDiv.appendChild(backButton);
        
        header.appendChild(turnDiv);
        header.appendChild(controlsDiv);
        
        return header;
    }
    
    /**
     * Create a team section (either player or enemy)
     * @param {string} title - Section title
     * @param {string} titleColor - Color class for the title
     * @returns {HTMLElement} Team section element
     */
    createTeamSection(title, titleColor) {
        const section = document.createElement('section');
        section.className = 'flex flex-col items-center gap-6 w-1/3 md:w-1/4';
        
        const heading = document.createElement('h2');
        heading.className = `text-xl font-semibold mb-2 ${titleColor}`;
        heading.textContent = title;
        
        section.appendChild(heading);
        
        return section;
    }
    
    /**
     * Create the battle log
     * @returns {HTMLElement} Battle log element
     */
    createBattleLog() {
        const logContainer = document.createElement('div');
        logContainer.className = 'absolute bottom-4 left-4';
        logContainer.style.width = '400px'; // Increased width from 300px to 400px
        logContainer.style.zIndex = '30'; // Higher than victory overlay (which is 20)
        
        const logDiv = document.createElement('div');
        logDiv.className = 'rounded-lg p-4 shadow-md battle-log';
        logDiv.style.backgroundColor = 'rgba(28, 33, 48, 0.95)'; // More opaque, darker background // Increased padding from p-3 to p-4
        
        const logHeading = document.createElement('div');
        logHeading.className = 'flex justify-between items-center text-sm font-semibold mb-2 border-b border-gray-600 pb-1';
        
        const logTitle = document.createElement('h3');
        logTitle.textContent = 'Battle Log';
        
        const copyButton = document.createElement('button');
        copyButton.className = 'text-xs py-0 px-2 bg-blue-600 rounded hover:bg-blue-500';
        copyButton.textContent = 'Copy';
        copyButton.addEventListener('click', () => this.copyBattleLog());
        
        logHeading.appendChild(logTitle);
        logHeading.appendChild(copyButton);
        
        const logContent = document.createElement('div');
        logContent.id = 'battle-log-content';
        logContent.className = 'text-xs space-y-2'; // Increased space between entries from space-y-1 to space-y-2
        
        logDiv.appendChild(logHeading);
        logDiv.appendChild(logContent);
        logContainer.appendChild(logDiv);
        
        return logContainer;
    }
    
    /**
     * Set the arena background
     * @param {HTMLElement} arenaElement - Arena element to apply background to
     * @param {string} backgroundKey - Key for the background to apply ('default', 'forest', etc)
     */
    setArenaBackground(arenaElement, backgroundKey) {
        // Only accept 'default' or 'grassyfield' for now
        if (backgroundKey !== 'default' && backgroundKey !== 'grassyfield') {
            console.log(`Background '${backgroundKey}' not implemented yet, using 'grassyfield' instead`);
            backgroundKey = 'grassyfield';
        }
        
        // Remove any existing arena classes
        arenaElement.classList.remove('arena-default', 'arena-grassyfield');
        
        // Add the requested arena class
        arenaElement.classList.add(`arena-${backgroundKey}`);
        
        // Check if the background is an image and verify it exists
        if (backgroundKey === 'grassyfield') {
            const imageUrl = 'assets/images/Arena Art/Grassy Field.png';
            
            // Apply a custom inline style to be absolutely sure it's applied
            arenaElement.style.backgroundImage = `url("${imageUrl}")`;
            arenaElement.style.backgroundSize = 'cover';
            arenaElement.style.backgroundPosition = 'center';
            
            // Attempt to preload the image to verify it exists
            const img = new Image();
            img.onerror = () => {
                console.error(`Failed to load background image: ${imageUrl}`);
                // Fallback to default background if image fails to load
                arenaElement.classList.remove(`arena-${backgroundKey}`);
                arenaElement.classList.add('arena-default');
                arenaElement.style.backgroundImage = '';
                this.arenaBackground = 'default';
            };
            img.src = imageUrl;
        } else {
            // Remove inline style if using default
            arenaElement.style.backgroundImage = '';
        }
        
        this.arenaBackground = backgroundKey;
    }
    
    /**
     * Render characters in the battle UI
     * @param {Array} playerTeam - Player team characters
     * @param {Array} enemyTeam - Enemy team characters
     */
    renderCharacters(playerTeam, enemyTeam) {
        this.playerTeam = playerTeam;
        this.enemyTeam = enemyTeam;
        
        console.log('BattleUI: Rendering characters', playerTeam, enemyTeam);
        
        // Clear existing characters
        const playerSection = this.elements.playerTeamContainer;
        const enemySection = this.elements.enemyTeamContainer;
        
        // Keep the heading, remove other children
        while (playerSection.childNodes.length > 1) {
            playerSection.removeChild(playerSection.lastChild);
        }
        
        while (enemySection.childNodes.length > 1) {
            enemySection.removeChild(enemySection.lastChild);
        }
        
        // Render player team
        playerTeam.forEach(character => {
            const characterElement = this.createCharacterElement(character, 'player');
            playerSection.appendChild(characterElement);
        });
        
        // Render enemy team
        enemyTeam.forEach(character => {
            const characterElement = this.createCharacterElement(character, 'enemy');
            enemySection.appendChild(characterElement);
        });
        
        // Set the first character as active
        if (playerTeam.length > 0) {
            this.setActiveCharacter(playerTeam[0]);
        }
    }
    
    /**
     * Create a character element
     * @param {Object} character - Character data
     * @param {string} team - 'player' or 'enemy'
     * @returns {HTMLElement} Character element
     */
    createCharacterElement(character, team) {
        const container = document.createElement('div');
        container.className = 'flex flex-col items-center text-center';
        
        // Create a unique ID for this character that includes team information
        // This ensures we correctly identify characters even if they have the same name
        character.uniqueId = `${team}_${character.id}`;
        
        container.id = `character-container-${character.uniqueId}`;
        container.dataset.team = team; // Store team info for attack animations
        
        // Character representation (circle or image)
        const circle = document.createElement('div');
        
        // Check if this is a character with art (Aqualia or any character with art property)
        if (character.name === "Aqualia" || (character.art && character.art.enabled !== false)) {
            // Add a class to identify this as a character with art
            circle.className = 'character-circle character-art-container';
            circle.id = `character-${character.uniqueId}`;
            circle.style.position = 'relative'; // Ensure relative positioning for the movement
            circle.dataset.hasArt = 'true'; // Mark this character as having art
            
            // Log that we're creating a character with art
            console.log(`Creating ${character.name} character with art`);
            
            // Use a direct path to the image based on the web server root
            const artPath = `assets/images/Character Art/${character.name}.png`;
            
            // Create a wrapper div to contain the image and properly position it
            const imageWrapper = document.createElement('div');
            imageWrapper.className = 'character-art-wrapper';
            imageWrapper.style.position = 'absolute';
            imageWrapper.style.top = '0';
            imageWrapper.style.left = '0';
            imageWrapper.style.width = '100%';
            imageWrapper.style.height = '100%';
            imageWrapper.style.zIndex = '5';
            
            // Create and add the image element
            const imgElement = new Image();
            imgElement.className = 'character-art';
            imgElement.alt = character.name;
            
            // Apply character-specific art settings if available
            if (character.art) {
                if (character.art.left) {
                    imgElement.style.left = character.art.left;
                    // Store original left value to maintain position during animations
                    imgElement.dataset.originalLeft = character.art.left;
                }
                if (character.art.top) {
                    imgElement.style.top = character.art.top;
                    // Store original top value to maintain position during animations
                    imgElement.dataset.originalTop = character.art.top;
                }
                if (character.art.width) imgElement.style.width = character.art.width;
                if (character.art.height) imgElement.style.height = character.art.height;
            }
            
            // Log to diagnose image loading issues
            imgElement.onload = function() {
                console.log(`SUCCESS: ${character.name} image loaded successfully`);
                // Remove the background completely once the image loads
                circle.style.backgroundColor = 'transparent';
                circle.style.borderColor = 'transparent';
            };
            
            imgElement.onerror = function(e) {
                console.error(`FAILED: Error loading ${character.name} image:`, e);
                console.log('Image path tried:', imgElement.src);
                // Keep the fallback color/letter if image fails to load
            };
            
            // Set a transparent background by default
            circle.style.backgroundColor = 'transparent';
            circle.style.border = 'none';
            
            // Set the src AFTER setting up event handlers
            imgElement.src = artPath;
            
            // Add the image to the wrapper, then wrapper to circle
            imageWrapper.appendChild(imgElement);
            circle.appendChild(imageWrapper);
        } else {
            // Standard circle for other characters
            circle.className = `character-circle bg-${character.type}`;
            if (character.type === 'light') {
                circle.classList.add('text-dark-on-light');
            }
            circle.id = `character-${character.uniqueId}`;
            circle.textContent = character.name.charAt(0).toUpperCase();
            circle.style.position = 'relative'; // Ensure relative positioning for the movement
        }
        
        // HP bar container
        const hpBarContainer = document.createElement('div');
        hpBarContainer.className = 'hp-bar-container';
        
        const hpBarBackground = document.createElement('div');
        hpBarBackground.className = 'hp-bar-background';
        
        const currentHp = character.currentHp !== undefined ? character.currentHp : character.stats.hp;
        const maxHp = character.stats.hp;
        const healthPercentage = (currentHp / maxHp) * 100;
        
        const hpBarCurrent = document.createElement('div');
        hpBarCurrent.className = 'hp-bar-current';
        hpBarCurrent.style.width = `${healthPercentage}%`;
        hpBarCurrent.id = `hp-bar-${character.uniqueId}`;
        
        hpBarBackground.appendChild(hpBarCurrent);
        hpBarContainer.appendChild(hpBarBackground);
        
        // Character name
        const nameDiv = document.createElement('div');
        nameDiv.className = 'text-sm font-semibold mt-1';
        nameDiv.textContent = character.name;
        
        // HP text
        const hpText = document.createElement('div');
        hpText.className = 'text-xs';
        hpText.textContent = `HP: ${currentHp} / ${maxHp}`;
        hpText.id = `hp-text-${character.uniqueId}`;
        
        // Status icons container
        const statusContainer = document.createElement('div');
        statusContainer.className = 'status-icons-container';
        statusContainer.id = `status-icons-${character.uniqueId}`;
        
        // Add elements to container
        container.appendChild(circle);
        container.appendChild(hpBarContainer);
        container.appendChild(nameDiv);
        container.appendChild(hpText);
        container.appendChild(statusContainer);
        
        return container;
    }
    
    /**
     * Set a character as the active character
     * @param {Object} character - Character data
     */
    setActiveCharacter(character) {
        // Remove active class from all character containers
        document.querySelectorAll('.active-character').forEach(el => {
            el.classList.remove('active-character');
            
            // Restore original position values for any character art if they exist
            const characterId = el.id.replace('character-container-', '');
            const artContainer = document.getElementById(`character-${characterId}`);
            if (artContainer && artContainer.dataset.hasArt === 'true') {
                const img = artContainer.querySelector('.character-art');
                if (img) {
                    // Restore original position values if available
                    if (img.dataset.originalLeft) {
                        img.style.left = img.dataset.originalLeft;
                    }
                    if (img.dataset.originalTop) {
                        img.style.top = img.dataset.originalTop;
                    }
                }
            }
        });
        
        this.activeCharacter = character;
        
        // Add active class to the character container
        // We need the uniqueId which includes team information
        const uniqueId = character.uniqueId || (character.team === 'player' ? `player_${character.id}` : `enemy_${character.id}`);
        const characterContainer = document.getElementById(`character-container-${uniqueId}`);
        if (characterContainer) {
            characterContainer.classList.add('active-character');
            
            // Make sure character art maintains its position when active
            const artContainer = document.getElementById(`character-${uniqueId}`);
            if (artContainer && artContainer.dataset.hasArt === 'true') {
                // If character has art, ensure position is maintained
                const img = artContainer.querySelector('.character-art');
                if (img && img.dataset.originalLeft && img.dataset.originalTop) {
                    // Re-apply the original position values
                    img.style.left = img.dataset.originalLeft;
                    img.style.top = img.dataset.originalTop;
                }
            }
        }
    }
    
    /**
     * Show an attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Object} ability - Ability used
     */
    showAttackAnimation(attacker, target, ability) {
        // DEBUG MESSAGE FOR DEPRECATED DOM ANIMATIONS
        console.warn('âš ï¸ USING DEPRECATED DOM BATTLE ANIMATIONS: Please use Phaser-based battle scene for improved performance');

        // Disable DirectImageLoader during this animation to prevent art switching
        if (typeof window.disableDirectImageLoaderDuringAnimation === 'function') {
            window.disableDirectImageLoaderDuringAnimation();
        } else {
            // Fallback if function doesn't exist
            window.disableDirectImageLoader = true;
            setTimeout(() => { window.disableDirectImageLoader = false; }, 2000);
        }
        
        // Logging for debugging purposes
        console.log(`Animation: ${attacker.name} (${attacker.uniqueId}) attacking ${target.name} (${target.uniqueId})`);
        
        // Get the character elements using uniqueId
        const attackerContainer = document.getElementById(`character-container-${attacker.uniqueId}`);
        const targetContainer = document.getElementById(`character-container-${target.uniqueId}`);
        const attackerCircle = document.getElementById(`character-${attacker.uniqueId}`);
        const targetCircle = document.getElementById(`character-${target.uniqueId}`);
        
        // Add Action Text display above character head (to the container, not the circle)
        const actionType = ability ? (ability.isHealing ? 'heal' : 'ability') : 'attack';
        const actionText = ability ? ability.name : 'Auto-Attack';
        // Use the container instead of circle so text stays in place
        this.showActionText(attackerContainer, actionText, actionType);
        
        if (!attackerCircle || !targetCircle) {
            console.error('Could not find character elements for animation:', 
                        { attacker: attacker.name, target: target.name, 
                          attackerId: attacker.uniqueId, targetId: target.uniqueId });
            return;
        }
        
        // SIMPLIFIED ANIMATION: Just show the action text and update health
        // Store damage info
        const damage = ability ? ability.damage : attacker.stats.attack;
        const isHealing = ability && ability.isHealing;
        
        // Show simplified effect
        this.showBonkEffect(targetCircle, isHealing);
        
        // Show damage numbers
        this.showFloatingText(
            target.id,
            isHealing ? `+${damage}` : `-${damage}`,
            isHealing ? 'text-green-500' : 'text-red-500'
        );
        
        // Update target's health
        this.updateCharacterHealth(target, damage, isHealing);
        
        // Re-enable DirectImageLoader after animation is completely finished
        setTimeout(() => {
            window.disableDirectImageLoader = false;
            console.log('Animation complete, DirectImageLoader re-enabled');
        }, 500);
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Check if this character has artwork
        const hasArt = attackerCircle.dataset.hasArt === 'true';
        
        // Store attacker info in data attribute for secure identification
        // This helps prevent character art mix-ups during animations
        const attackerUniqueId = attacker.uniqueId;
        const attackerName = attacker.name;
        
        // Create a fresh clone of the attacker circle for the animation
        const animatedClone = attackerCircle.cloneNode(false); // Shallow clone first
        animatedClone.id = `clone-${attackerUniqueId}`;
        animatedClone.setAttribute('data-character-id', attacker.id);
        animatedClone.setAttribute('data-character-name', attackerName);
        animatedClone.setAttribute('data-character-unique-id', attackerUniqueId);
        animatedClone.style.position = 'fixed'; // Use fixed positioning for accurate placement
        animatedClone.style.zIndex = '200';
        animatedClone.style.margin = '0'; // Remove any margin
        animatedClone.style.opacity = '1'; 
        animatedClone.style.transition = 'none'; // Disable transitions initially
        animatedClone.classList.add('character-moving');
        
        // Special handling for characters with art
        if (hasArt) {
            // Make sure the container has correct styling
            animatedClone.style.backgroundColor = 'transparent';
            animatedClone.style.border = 'none';
            
            // Create a fresh wrapper instead of cloning to avoid potential reference issues
            const artWrapper = document.createElement('div');
            artWrapper.className = 'character-art-wrapper';
            animatedClone.appendChild(artWrapper);
            
            // Create a fresh image element
            const img = new Image();
            img.className = 'character-art';
            img.alt = attackerName;
            
            // IMPORTANT: Set character-specific data attributes to prevent misidentification
            img.dataset.characterName = attackerName;
            img.dataset.characterId = attacker.id;
            img.dataset.characterUniqueId = attackerUniqueId;
            
            // Ensure the image is set to a working path based on attacker name
            const imagePath = `assets/images/Character Art/${attackerName}.png`;
            img.src = imagePath;
            
            // Use a secure global reference if available
            if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[attackerName]) {
                console.log(`Using cached image for ${attackerName} during animation`);
                // Copy the src from the cache to ensure consistency
                const cachedSrc = window.CHARACTER_IMAGE_CACHE[attackerName].src;
                if (cachedSrc) img.src = cachedSrc;
            }
            
            // Copy over the custom positioning from original image
            const originalImg = attackerCircle.querySelector('.character-art');
            if (originalImg) {
                // Copy exact positioning from original image
                if (originalImg.dataset.originalLeft) {
                    img.style.left = originalImg.dataset.originalLeft;
                    img.dataset.originalLeft = originalImg.dataset.originalLeft;
                }
                if (originalImg.dataset.originalTop) {
                    img.style.top = originalImg.dataset.originalTop;
                    img.dataset.originalTop = originalImg.dataset.originalTop;
                }
                // Copy width/height from original if available
                if (originalImg.style.width) img.style.width = originalImg.style.width;
                if (originalImg.style.height) img.style.height = originalImg.style.height;
            }
            
            // Add the image to the wrapper
            artWrapper.appendChild(img);
            
            // Add a loaded class to the clone
            animatedClone.classList.add('art-loaded');
            
            // Log animation for debugging purposes
            console.log(`Created animation clone for ${attackerName} (${attackerUniqueId})`);
        }
        
        // Hide the original circle during animation
        attackerCircle.style.visibility = 'hidden';
        
        // Clean up any lingering clones before adding a new one
        // This helps prevent potential art mix-ups from earlier animations
        const existingClones = document.querySelectorAll('[id^="clone-"]');
        existingClones.forEach(clone => {
            if (clone.parentNode) {
                clone.parentNode.removeChild(clone);
                console.log('Removed lingering animation clone');
            }
        });
        
        // Add the clone to the battle area
        const battleArena = document.getElementById('battle-arena');
        battleArena.appendChild(animatedClone);
        
        // Calculate positions
        const attackerRect = attackerCircle.getBoundingClientRect();
        const targetRect = targetCircle.getBoundingClientRect();
        
        // Position the clone at the attacker's position
        animatedClone.style.left = `${attackerRect.left}px`;
        animatedClone.style.top = `${attackerRect.top}px`;
        animatedClone.style.width = `${attackerRect.width}px`;
        animatedClone.style.height = `${attackerRect.height}px`;
        
        // Calculate animation timing based on speed
        const speedMultiplier = this.battleManager ? this.battleManager.speedMultiplier || 1 : 1;
        const moveDuration = 400 / speedMultiplier;
        const returnDuration = 300 / speedMultiplier;
        
        // 1. Initial slight scale down
        requestAnimationFrame(() => {
            // Start with a small scale
            animatedClone.style.transform = 'scale(0.9)';
            
            // 2. Move to target with a slight delay
            setTimeout(() => {
                // Apply transition for movement
                animatedClone.style.transition = `left ${moveDuration}ms ease-out, top ${moveDuration}ms ease-out, transform 200ms ease-out`;
                
                // Calculate the target position (stop just short of the target)
                // For player team attacking enemy team, move to the left of the target
                // For enemy team attacking player team, move to the right of the target
                const attackerTeam = attackerContainer.dataset.team;
                const targetTeam = targetContainer.dataset.team;
                
                let moveToX, moveToY;
                if (attackerTeam === 'player' && targetTeam === 'enemy') {
                    // Player attacking enemy - move to the left side of the target
                    moveToX = targetRect.left - (attackerRect.width / 2);
                } else if (attackerTeam === 'enemy' && targetTeam === 'player') {
                    // Enemy attacking player - move to the right side of the target
                    moveToX = targetRect.right - (attackerRect.width / 2);
                } else {
                    // Same team (healing) - go to the center
                    moveToX = targetRect.left + (targetRect.width - attackerRect.width) / 2;
                }
                
                // Vertically align with the target
                moveToY = targetRect.top + (targetRect.height - attackerRect.height) / 2;
                
                // Move toward the target
                animatedClone.style.transform = 'scale(1.1)';
                animatedClone.style.left = `${moveToX}px`;
                animatedClone.style.top = `${moveToY}px`;
                
                // 3. When near target, show impact effect
                setTimeout(() => {
                    // Show bonk effect and shake target
                    this.showBonkEffect(targetCircle, isHealing);
                    targetCircle.style.animation = 'shake 0.5s';
                    
                    // Show damage numbers
                    this.showFloatingText(
                        target.id,
                        isHealing ? `+${damage}` : `-${damage}`,
                        isHealing ? 'text-green-500' : 'text-red-500'
                    );
                    
                    // Update target's health
                    this.updateCharacterHealth(target, damage, isHealing);
                    
                    // 4. Move back to original position
                    setTimeout(() => {
                        animatedClone.style.transition = `left ${returnDuration}ms ease-in, top ${returnDuration}ms ease-in, opacity 200ms ease-out`;
                        animatedClone.style.left = `${attackerRect.left}px`;
                        animatedClone.style.top = `${attackerRect.top}px`;
                        animatedClone.style.transform = 'scale(0.9)';
                        
                        // 5. Fade out clone and remove
                        setTimeout(() => {
                            // Begin fade out
                            animatedClone.style.opacity = '0';
                            
                            setTimeout(() => {
                                // Verify clone is the correct one for this character (safety check)
                                if (animatedClone.dataset.characterUniqueId !== attackerUniqueId) {
                                    console.warn(`Animation clone mismatch detected: ${animatedClone.dataset.characterUniqueId} vs expected ${attackerUniqueId}`);
                                }
                                
                                // Ensure the clone is properly removed
                                if (animatedClone.parentNode) {
                                    console.log(`Removing animation clone for ${attackerName}`);
                                    animatedClone.parentNode.removeChild(animatedClone);
                                }
                                
                                // Double check for any other clones that might be lingering
                                const otherClones = document.querySelectorAll(`[id="clone-${attackerUniqueId}"]`);
                                otherClones.forEach(clone => {
                                    if (clone.parentNode) {
                                        console.warn('Found additional clone to remove');
                                        clone.parentNode.removeChild(clone);
                                    }
                                });
                                
                                // Reset target animation
                                targetCircle.style.animation = '';
                                
                                // Show original attacker circle again
                                attackerCircle.style.visibility = 'visible';
                                
                                // Re-enable DirectImageLoader after animation is completely finished
                                // This ensures no injection happens during the animation
                                window.disableDirectImageLoader = false;
                                console.log('Animation complete, DirectImageLoader re-enabled');
                            }, 200);
                        }, returnDuration - 50);
                    }, 400 / speedMultiplier);
                }, moveDuration);
            }, 50);
        });
        */
    }
    
    /**
     * Show a bonk effect on the target
     * @param {HTMLElement} targetElement - The target element
     * @param {boolean} isHealing - Whether this is a healing effect
     */
    showBonkEffect(targetElement, isHealing = false) {
        // Create bonk element
        const bonk = document.createElement('div');
        bonk.className = 'attack-bonk';
        
        // Use different icon based on whether it's healing or attack
        if (isHealing) {
            bonk.textContent = 'âœ¨'; // Sparkle for healing
            bonk.style.color = '#48bb78'; // Green color
        } else {
            bonk.textContent = 'ðŸ’¥'; // Impact for attack
            bonk.style.color = '#f56565'; // Red color
        }
        
        // Add to target
        targetElement.appendChild(bonk);
        
        // Add animation class
        bonk.classList.add('animate-bonk');
        
        // Remove after animation completes
        setTimeout(() => {
            if (bonk.parentNode === targetElement) {
                targetElement.removeChild(bonk);
            }
        }, 500);
    }
    
    /**
     * Show action text above a character
     * @param {HTMLElement} characterElement - The character element
     * @param {string} actionText - Text to display
     * @param {string} actionType - Type of action ('attack', 'ability', or 'heal')
     */
    showActionText(characterElement, actionText, actionType = 'attack') {
        // Create the action text element
        const actionTextElement = document.createElement('div');
        actionTextElement.className = `action-text action-text-${actionType}`;
        actionTextElement.textContent = actionText;
        
        // Add to character element
        characterElement.appendChild(actionTextElement);
        
        // Remove after animation completes
        const duration = 1800 / (this.battleManager ? this.battleManager.speedMultiplier || 1 : 1);
        setTimeout(() => {
            if (actionTextElement.parentNode === characterElement) {
                characterElement.removeChild(actionTextElement);
            }
        }, duration); // Match the animation duration with battle speed adjustment
    }
    
    /**
     * Show passive effect visual feedback
     * @param {Object} character - Character with the passive ability
     * @param {string} effectName - Name of the passive effect
     */
    showPassiveEffect(character, effectName) {
        // Get character's unique ID
        const uniqueId = character.uniqueId || (character.team === 'player' ? `player_${character.id}` : `enemy_${character.id}`);
        
        // Find the character element
        const characterElement = document.getElementById(`character-${uniqueId}`);
        
        if (!characterElement) {
            console.error(`Could not find character element for ${character.name} (${uniqueId})`);
            return;
        }
        
        // Create passive effect element
        const passiveEffect = document.createElement('div');
        passiveEffect.className = 'passive-effect';
        passiveEffect.textContent = 'âœ¨ ' + effectName;
        
        // Add some custom styling for passive effects
        passiveEffect.style.position = 'absolute';
        passiveEffect.style.top = '-30px';
        passiveEffect.style.left = '50%';
        passiveEffect.style.transform = 'translateX(-50%)';
        passiveEffect.style.backgroundColor = 'rgba(75, 0, 130, 0.8)'; // Purple for passives
        passiveEffect.style.color = 'white';
        passiveEffect.style.padding = '3px 8px';
        passiveEffect.style.borderRadius = '4px';
        passiveEffect.style.fontSize = '12px';
        passiveEffect.style.fontWeight = 'bold';
        passiveEffect.style.whiteSpace = 'nowrap';
        passiveEffect.style.zIndex = '100';
        passiveEffect.style.animation = 'float-up-fade-out 1.5s forwards';
        passiveEffect.style.border = '1px solid rgba(128, 0, 255, 0.5)';
        
        // Add to character element
        characterElement.appendChild(passiveEffect);
        
        // Remove after animation completes
        setTimeout(() => {
            if (passiveEffect.parentNode === characterElement) {
                characterElement.removeChild(passiveEffect);
            }
        }, 1500);
        
        // Also add a glowing effect to the character
        const glowEffect = document.createElement('div');
        glowEffect.className = 'passive-glow';
        glowEffect.style.position = 'absolute';
        glowEffect.style.top = '0';
        glowEffect.style.left = '0';
        glowEffect.style.width = '100%';
        glowEffect.style.height = '100%';
        glowEffect.style.borderRadius = '50%';
        glowEffect.style.boxShadow = '0 0 15px 5px rgba(128, 0, 255, 0.6)';
        glowEffect.style.animation = 'passive-glow 1s ease-out';
        glowEffect.style.zIndex = '5';
        glowEffect.style.pointerEvents = 'none';
        
        // Add glow animation style if it doesn't exist
        if (!document.getElementById('passive-effect-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'passive-effect-styles';
            styleEl.textContent = `
                @keyframes passive-glow {
                    0% { opacity: 0.8; transform: scale(0.9); }
                    50% { opacity: 1; transform: scale(1.1); }
                    100% { opacity: 0; transform: scale(1.2); }
                }
            `;
            document.head.appendChild(styleEl);
        }
        
        // Add the glow element behind other content
        characterElement.insertBefore(glowEffect, characterElement.firstChild);
        
        // Remove glow after animation
        setTimeout(() => {
            if (glowEffect.parentNode === characterElement) {
                characterElement.removeChild(glowEffect);
            }
        }, 1000);
    }
    
    /**
     * Show floating text above a character
     * @param {string} characterId - ID of the character
     * @param {string} text - Text to display
     * @param {string} textColor - Color class for the text
     */
    showFloatingText(characterId, text, textColor) {
        // In case we're passed a regular ID, let's try to find the uniqueId first
        let characterElement = null;
        
        // Try to find the element with uniqueId (player_id or enemy_id)
        const possibleIds = [`player_${characterId}`, `enemy_${characterId}`];
        for (const id of possibleIds) {
            const element = document.getElementById(`character-${id}`);
            if (element) {
                characterElement = element;
                break;
            }
        }
        
        // If not found with uniqueId, fall back to regular id
        if (!characterElement) {
            characterElement = document.getElementById(`character-${characterId}`);
        }
        
        if (!characterElement) {
            console.error(`Could not find character element for ID: ${characterId}`);
            return;
        }
        
        const floatingText = document.createElement('div');
        floatingText.className = `floating-text ${textColor}`;
        floatingText.textContent = text;
        
        characterElement.appendChild(floatingText);
        
        // Remove after animation completes
        setTimeout(() => {
            if (floatingText.parentNode === characterElement) {
                characterElement.removeChild(floatingText);
            }
        }, 1200);
    }
    
    /**
     * Update character health display
     * @param {Object} character - Character data
     * @param {number} amount - Amount to change (damage or healing)
     * @param {boolean} isHealing - Whether this is healing
     */
    updateCharacterHealth(character, amount, isHealing = false) {
        // Update character object
        const newHealth = isHealing 
            ? Math.min(character.currentHp + amount, character.stats.hp)
            : Math.max(0, character.currentHp - amount);
        
        character.currentHp = newHealth;
        
        // Use uniqueId if available
        const uniqueId = character.uniqueId || character.id;
        
        // Update HP bar
        const hpBar = document.getElementById(`hp-bar-${uniqueId}`);
        const hpText = document.getElementById(`hp-text-${uniqueId}`);
        
        if (hpBar && hpText) {
            // Calculate health percentage
            const healthPercentage = (character.currentHp / character.stats.hp) * 100;
            
            // Update HP bar width with animation
            hpBar.style.width = `${healthPercentage}%`;
            
            // Update HP text
            hpText.textContent = `HP: ${character.currentHp} / ${character.stats.hp}`;
            
            // Change color based on health percentage
            if (healthPercentage <= 25) {
                hpBar.style.backgroundColor = '#f56565'; // Red for low health
            } else if (healthPercentage <= 50) {
                hpBar.style.backgroundColor = '#ed8936'; // Orange for medium health
            } else {
                hpBar.style.backgroundColor = '#48bb78'; // Green for good health
            }
        }
    }
    
    /**
     * Update the UI with current state
     */
    update() {
        if (this.battleManager) {
            const turnDisplay = this.elements.turnDisplay;
            if (turnDisplay) {
                turnDisplay.textContent = `Turn: ${this.battleManager.currentTurn}`;
            }
        }
    }
    
    /**
     * Add message to battle log
     * @param {string} message - Message text
     * @param {string} type - Message type
     */
    addLogMessage(message, type = 'default') {
        // Add to our log array
        this.logMessages.push({ message, type });
        
        // No longer limiting to most recent messages so we can copy the entire battle log
        // Previously: if (this.logMessages.length > 30) { this.logMessages.shift(); }
        
        // Update log display
        const logContent = this.elements.logContent;
        if (logContent) {
            const messageElement = document.createElement('p');
            
            // Format the message with colored spans based on content
            let formattedMessage = message;
            
            // Override formatting based on message type
            switch (type) {
                case 'success':
                    messageElement.style.color = '#48bb78'; // Green
                    break;
                case 'error':
                    messageElement.style.color = '#f56565'; // Red
                    break;
                case 'info':
                    messageElement.style.color = '#4299e1'; // Blue
                    break;
                case 'action':
                    messageElement.style.color = '#ed8936'; // Orange
                    break;
            }
            
            messageElement.innerHTML = formattedMessage
                .replace(/\[(.*?)\]/g, '<span style="color: #a0aec0">[$1]</span>') // Abilities in brackets
                .replace(/\+(\d+) HP/g, '<span style="color: #48bb78">+$1 HP</span>') // Healing
                .replace(/Miss!/g, '<span style="color: #a0aec0">Miss!</span>'); // Misses
                
            logContent.appendChild(messageElement);
            
            // Scroll to bottom
            logContent.scrollTop = logContent.scrollHeight;
        }
    }
    
    /**
     * Toggle pause state
     */
    togglePause() {
        if (this.battleManager) {
            const isPaused = this.battleManager.togglePause();
            const pauseButton = this.elements.pauseButton;
            if (pauseButton) {
                pauseButton.innerHTML = isPaused ? '&#9658;' : '&#10074;&#10074;'; // Play or pause symbol
            }
        }
    }
    
    /**
     * Set battle speed
     * @param {number} speed - Speed multiplier
     */
    setSpeed(speed) {
        if (this.battleManager) {
            this.battleManager.setSpeed(speed);
            
            // Update button styles
            Object.entries(this.elements.speedButtons).forEach(([btnSpeed, button]) => {
                if (button) {
                    if (btnSpeed === `${speed}x`) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                }
            });
        }
    }
    
    /**
     * Go to next turn
     */
    nextTurn() {
        if (this.battleManager) {
            this.battleManager.startNextTurn();
        }
    }
    
    /**
     * Show settings dialog
     */
    showSettings() {
        // Only offer backgrounds that actually exist
        const bgOptions = ['default', 'grassyfield'];
        const selectedBg = prompt(`Select arena background (${bgOptions.join(', ')}):`, this.arenaBackground);
        
        if (selectedBg && bgOptions.includes(selectedBg)) {
            this.setArenaBackground(this.elements.battleArena, selectedBg);
            
            // Special handling for grassyfield background
            if (selectedBg === 'grassyfield') {
                // Call our utility method that tries multiple paths
                setTimeout(() => {
                    this.setGrassyFieldDirect();
                }, 100);
            }
            
            // Add a visual notification to confirm the change
            const notification = document.createElement('div');
            notification.textContent = `Background changed to ${selectedBg}`;
            notification.style.position = 'fixed';
            notification.style.top = '60px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            notification.style.color = 'white';
            notification.style.padding = '8px 16px';
            notification.style.borderRadius = '4px';
            notification.style.zIndex = '1000';
            document.body.appendChild(notification);
            
            // Remove notification after 2 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
            
            console.log(`Background changed to ${selectedBg}`);
        }
    }
    
    /**
     * Set Grassy Field as background using direct URL
     * This is a utility method the user can call directly from console
     */
    setGrassyFieldDirect() {
        if (!this.elements || !this.elements.battleArena) {
            console.error('Battle arena element not found');
            return;
        }
        
        const arenaElement = this.elements.battleArena;
        
        // Remove any existing arena classes
        arenaElement.classList.remove('arena-default', 'arena-forest', 'arena-volcano', 'arena-glacier', 'arena-grassyfield');
        
        // Add the grassyfield class
        arenaElement.classList.add('arena-grassyfield');
        
        // Try multiple paths to ensure one works
        const paths = [
            'assets/images/Arena Art/Grassy Field.png',
            './assets/images/Arena Art/Grassy Field.png',
            '../assets/images/Arena Art/Grassy Field.png',
            '../../assets/images/Arena Art/Grassy Field.png',
            '/assets/images/Arena Art/Grassy Field.png',
            'C:/Personal/AutoBattler/assets/images/Arena Art/Grassy Field.png',
            // Try base64 encoded small green rectangle as absolute fallback
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFeQI7Z6j1AwAAAABJRU5ErkJggg=='
        ];
        
        // Try each path
        let currentPath = 0;
        const tryNextPath = () => {
            if (currentPath >= paths.length) {
                console.error('All paths failed, using default background');
                arenaElement.classList.remove('arena-grassyfield');
                arenaElement.classList.add('arena-default');
                arenaElement.style.backgroundImage = '';
                return;
            }
            
            const path = paths[currentPath];
            console.log(`Trying path ${currentPath + 1}/${paths.length}: ${path}`);
            
            // Set the background image
            arenaElement.style.backgroundImage = `url("${path}")`;
            arenaElement.style.backgroundSize = 'cover';
            arenaElement.style.backgroundPosition = 'center';
            
            // If it's the base64 fallback, we're done
            if (path.startsWith('data:')) {
                console.log('Using base64 fallback');
                return;
            }
            
            // Otherwise check if the image loaded
            const img = new Image();
            img.onload = () => {
                console.log(`Success! Path ${currentPath + 1} worked: ${path}`);
            };
            img.onerror = () => {
                console.error(`Path ${currentPath + 1} failed: ${path}`);
                currentPath++;
                tryNextPath();
            };
            img.src = path;
        };
        
        // Start trying paths
        tryNextPath();
        
        // Update background setting
        this.arenaBackground = 'grassyfield';
        
        // Add a notification
        const notification = document.createElement('div');
        notification.textContent = 'Setting Grassy Field background...';
        notification.style.position = 'fixed';
        notification.style.top = '60px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        notification.style.color = 'white';
        notification.style.padding = '8px 16px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '1000';
        document.body.appendChild(notification);
        
        // Remove notification after 3 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
        
        return 'Attempting to set Grassy Field background...';
    }
    
    /**
     * Show victory/defeat screen
     * @param {string} result - 'victory', 'defeat', or 'draw'
     */
    showBattleResult(result) {
        // DEBUG MESSAGE FOR DEPRECATED DOM BATTLE UI
        console.warn('âš ï¸ USING DEPRECATED DOM BATTLE RESULT SCREEN: Please use Phaser-based battle scene for improved performance');

        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'victory-overlay';
        
        const resultText = document.createElement('h2');
        resultText.className = 'victory-text';
        
        switch (result) {
            case 'victory':
                resultText.textContent = 'VICTORY!';
                resultText.style.color = '#48bb78'; // Green
                break;
            case 'defeat':
                resultText.textContent = 'DEFEAT!';
                resultText.style.color = '#f56565'; // Red
                break;
            case 'draw':
                resultText.textContent = 'DRAW!';
                resultText.style.color = '#a0aec0'; // Gray
                break;
        }
        
        const returnButton = document.createElement('button');
        returnButton.className = 'victory-button mb-4';
        returnButton.textContent = 'Return to Team Builder';
        returnButton.addEventListener('click', () => this.exitBattle());
        
        const logNote = document.createElement('div');
        logNote.className = 'text-sm text-gray-300 mt-2';
        logNote.textContent = 'Battle log is still accessible in the bottom-left corner';
        
        overlay.appendChild(resultText);
        overlay.appendChild(returnButton);
        overlay.appendChild(logNote);
        
        // Add to battle UI
        document.getElementById('battle-ui').appendChild(overlay);
        
        // Enhance battle log visibility
        const battleLog = document.querySelector('.battle-log');
        if (battleLog) {
            battleLog.style.backgroundColor = 'rgba(28, 33, 48, 0.98)'; // More opaque
            battleLog.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)'; // Add glow
        }
        
        // Show immediately instead of using animation delay
        overlay.style.opacity = '1';
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Animate in with delay
        setTimeout(() => {
            overlay.style.opacity = '1';
        }, 100);
        */
    }
    
    /**
     * Handle round end events
     * @param {Object} data - Round end data
     */
    handleRoundEnd(data) {
        // DEBUG MESSAGE FOR DEPRECATED DOM ROUND INDICATOR
        console.warn('âš ï¸ USING DEPRECATED DOM ROUND INDICATOR: Please use Phaser-based battle scene for improved performance');

        // Create round end visual indicator
        const roundIndicator = document.createElement('div');
        roundIndicator.className = 'round-end-indicator';
        roundIndicator.textContent = `Round ${data.roundNumber} Complete`;
        
        // Style it directly to make it visible without custom CSS
        roundIndicator.style.position = 'absolute';
        roundIndicator.style.top = '50%';
        roundIndicator.style.left = '50%';
        roundIndicator.style.transform = 'translate(-50%, -50%)';
        roundIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        roundIndicator.style.color = 'white';
        roundIndicator.style.padding = '15px 30px';
        roundIndicator.style.borderRadius = '8px';
        roundIndicator.style.fontWeight = 'bold';
        roundIndicator.style.fontSize = '24px';
        roundIndicator.style.zIndex = '100';
        
        // Add to battle arena if available
        const battleArena = document.getElementById('battle-arena');
        if (battleArena) {
            battleArena.appendChild(roundIndicator);
        } else {
            document.body.appendChild(roundIndicator);
        }
        
        // Remove immediately to avoid delays
        setTimeout(() => {
            if (roundIndicator.parentNode) {
                roundIndicator.parentNode.removeChild(roundIndicator);
            }
        }, 100);
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Show for 2 seconds then fade out
        setTimeout(() => {
            roundIndicator.classList.add('fade-out');
            setTimeout(() => {
                roundIndicator.remove();
            }, 1000); // Fade out duration
        }, 2000); // Display duration
        */
    }

    /**
     * Exit battle
     */
    exitBattle() {
        // Remove our UI
        const battleUI = document.getElementById('battle-ui');
        if (battleUI) {
            document.body.removeChild(battleUI);
        }
        
        // Reset our setup flag
        this.isSetup = false;
        
        // Switch back to team builder
        document.getElementById('game-container').classList.remove('active');
        document.getElementById('team-builder-container').classList.add('active');
    }

    /**
     * Initialize tooltip manager for battle UI
     */
    initializeTooltipManager() {
        // Clean up any existing tooltips first
        this.cleanupTooltips();
        
        // If TooltipManager hasn't been initialized yet
        if (!window.tooltipManager) {
            console.log('BattleUI: Creating new TooltipManager instance');
            // Create a new instance
            window.tooltipManager = new TooltipManager();
        }
        
        // Add battle-specific CSS for tooltips
        this.addBattleTooltipStyles();
    }
    
    /**
     * Clean up all existing tooltips and event listeners
     */
    cleanupTooltips() {
        // Remove all existing tooltip event listeners
        const tooltipElements = document.querySelectorAll('.status-icon');
        tooltipElements.forEach(el => {
            // Clone element to remove all event listeners
            const newEl = el.cloneNode(true);
            if (el.parentNode) {
                el.parentNode.replaceChild(newEl, el);
            }
        });
        
        // Clear any existing tooltip containers
        const tooltipContainers = document.querySelectorAll('.battle-tooltip');
        tooltipContainers.forEach(container => {
            if (container.parentNode) {
                container.parentNode.removeChild(container);
            }
        });
        
        // Reset the battleTooltip property
        this.battleTooltip = null;
        
        console.log('BattleUI: Cleaned up existing tooltips');
    }

    /**
     * Add custom CSS for battle tooltips
     */
    addBattleTooltipStyles() {
        if (!document.getElementById('battle-tooltip-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'battle-tooltip-styles';
            styleEl.textContent = `
                /* Override the info icon for battle status icons */
                .status-icon.has-tooltip::after {
                    content: none; /* Remove the "i" icon */
                }
                
                /* Make status icons more interactive */
                .status-icon {
                    cursor: help;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                    position: relative;
                }
                
                .status-icon:hover {
                    transform: scale(1.2);
                    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
                    z-index: 50;
                }
                
                /* Custom styling for battle tooltips */
                .battle-tooltip {
                    position: fixed; /* Use fixed position */
                    background-color: rgba(20, 30, 46, 0.95); /* Darker blue */
                    color: #e2e8f0;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    max-width: 250px;
                    z-index: 9999; /* Very high z-index */
                    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 5px rgba(66, 153, 225, 0.5); /* Blue glow */
                    pointer-events: none;
                    border: 1px solid rgba(66, 153, 225, 0.3); /* Subtle blue border */
                    display: none; /* Hide initially */
                    transition: opacity 0.2s ease;
                    text-align: left;
                }
                
                .battle-tooltip.visible {
                    display: block;
                }
                
                .tooltip-title {
                    font-weight: bold;
                    margin-bottom: 4px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                    padding-bottom: 4px;
                    color: #90cdf4; /* Light blue for title */
                    font-size: 13px;
                }
                
                .tooltip-content {
                    font-size: 11px;
                    line-height: 1.4;
                }

                .tooltip-content div {
                    margin-bottom: 3px;
                }
            `;
            document.head.appendChild(styleEl);
        }
    }

    /**
     * Add a tooltip to a status icon
     * @param {HTMLElement} icon - The status icon element
     * @param {string} content - HTML content for the tooltip
     */
    addStatusTooltip(icon, content) {
        // Add custom class and cursor style
        icon.classList.add('battle-status-tooltip');
        icon.style.cursor = 'help';
        
        // Create the tooltip element if it doesn't exist
        if (!this.battleTooltip) {
            this.battleTooltip = document.createElement('div');
            this.battleTooltip.className = 'battle-tooltip';
            this.battleTooltip.style.position = 'fixed'; // Use fixed positioning
            this.battleTooltip.style.zIndex = '9999'; // Ensure high z-index
            document.body.appendChild(this.battleTooltip);
        }
        
        // Store content on the icon for easy access
        icon.dataset.tooltipContent = content;
        
        // Add event listeners for both hover and click
        icon.addEventListener('mouseenter', () => {
            this.showStatusTooltip(icon, content);
        });
        
        icon.addEventListener('mouseleave', () => {
            this.hideStatusTooltip();
        });
        
        // Also add click event as a fallback
        icon.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent battle UI click events
            this.showStatusTooltip(icon, content);
            
            // Hide tooltip when clicking elsewhere
            const hideOnOutsideClick = (event) => {
                if (!icon.contains(event.target)) {
                    this.hideStatusTooltip();
                    document.removeEventListener('click', hideOnOutsideClick);
                }
            };
            
            // Add a slight delay to avoid immediate trigger
            setTimeout(() => {
                document.addEventListener('click', hideOnOutsideClick);
            }, 10);
        });
    }

    /**
     * Show a status tooltip for an icon
     * @param {HTMLElement} icon - The status icon element
     * @param {string} content - HTML content for the tooltip
     */
    showStatusTooltip(icon, content) {
        // Get tooltip content from data attribute if not provided
        const tooltipContent = content || icon.dataset.tooltipContent; 
        if (!tooltipContent || !this.battleTooltip) return;

        // Set content first
        this.battleTooltip.innerHTML = tooltipContent;
        
        // Position the tooltip before making it visible
        const rect = icon.getBoundingClientRect();
        
        // First set it to a default position
        this.battleTooltip.style.left = `${rect.left + rect.width / 2 - 125}px`; // Center tooltip
        this.battleTooltip.style.top = `${rect.top - 10}px`; // Temporary position
        
        // Force layout recalculation to ensure offsetHeight is accurate
        this.battleTooltip.style.opacity = '0';
        this.battleTooltip.style.display = 'block';
        
        // Now use the correct height to position properly
        const tooltipHeight = this.battleTooltip.offsetHeight;
        this.battleTooltip.style.top = `${rect.top - tooltipHeight - 10}px`; // Position above icon
        
        // Check if tooltip would go offscreen and adjust if needed
        const tooltipRect = this.battleTooltip.getBoundingClientRect();
        if (tooltipRect.left < 10) {
            this.battleTooltip.style.left = '10px';
        }
        if (tooltipRect.right > window.innerWidth - 10) {
            this.battleTooltip.style.left = `${window.innerWidth - 250 - 10}px`;
        }
        if (tooltipRect.top < 10) {
            // If tooltip would go above the screen, position it below the icon instead
            this.battleTooltip.style.top = `${rect.bottom + 10}px`;
        }
        
        // Make visible
        this.battleTooltip.style.opacity = '1';
        this.battleTooltip.classList.add('visible');
    }
    
    /**
     * Hide the status tooltip
     */
    hideStatusTooltip() {
        if (this.battleTooltip) {
            this.battleTooltip.classList.remove('visible');
            this.battleTooltip.style.display = 'none';
        }
    }
    
    /**
     * Copy battle log to clipboard
     */
    copyBattleLog() {
        // Extract plain text from log messages
        const logText = this.logMessages.map(msg => msg.message).join('\n');
        
        // Copy to clipboard
        navigator.clipboard.writeText(logText)
            .then(() => {
                // Show feedback
                const copyButton = document.querySelector('.battle-log button');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#48bb78'; // Green
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                }, 2000);
            })
            .catch(err => {
                console.error('Failed to copy log:', err);
                alert('Failed to copy battle log to clipboard');
            });
    }
}

// Export for use in other modules
window.BattleUI = BattleUI;
// Also make available as a global variable
if (typeof BattleUI === 'undefined') {
    BattleUI = window.BattleUI;
}

console.log('BattleUI class loaded and available as window.BattleUI');

===== FILE: BattleUIDebug.js =====
/**
 * Battle UI Debug Helper
 * Provides debugging and troubleshooting for the BattleUI
 */

class BattleUIDebug {
    /**
     * Create a debug snapshot of the current state of the UI
     * @param {BattleUI} battleUI - The BattleUI instance to debug
     * @returns {Object} Debug information
     */
    static createSnapshot(battleUI) {
        const snapshot = {
            isSetup: battleUI.isSetup,
            playerTeamCount: battleUI.playerTeam.length,
            enemyTeamCount: battleUI.enemyTeam.length,
            domElements: {},
            tailwindStatus: {}
        };
        
        // Check if key elements exist in the DOM
        snapshot.domElements.battleUI = !!document.getElementById('battle-ui');
        snapshot.domElements.battleArena = !!document.getElementById('battle-arena');
        snapshot.domElements.turnDisplay = !!document.getElementById('turn-display');
        snapshot.domElements.logContent = !!document.getElementById('battle-log-content');
        
        // Check Tailwind CSS status
        snapshot.tailwindStatus.linkExists = !!document.getElementById('tailwind-css');
        snapshot.tailwindStatus.interFontExists = !!document.querySelector('link[href*="fonts.googleapis.com/css2?family=Inter"]');
        
        // Check for any CSS classes that are definitely from Tailwind
        const testElement = document.createElement('div');
        testElement.className = 'text-blue-500';
        document.body.appendChild(testElement);
        const computedStyle = window.getComputedStyle(testElement);
        snapshot.tailwindStatus.tailwindWorking = computedStyle.color !== 'rgb(0, 0, 0)'; // If not black, Tailwind might be working
        document.body.removeChild(testElement);
        
        // Create a log of all used colors
        snapshot.cssColors = {};
        document.querySelectorAll('.character-circle').forEach(el => {
            const style = window.getComputedStyle(el);
            const type = el.classList[1]?.replace('bg-', '') || 'unknown';
            snapshot.cssColors[type] = style.backgroundColor;
        });
        
        console.log('BattleUI Debug Snapshot:', snapshot);
        return snapshot;
    }
    
    /**
     * Fix common UI issues
     * @param {BattleUI} battleUI - The BattleUI instance to fix
     */
    static fixCommonIssues(battleUI) {
        console.log('BattleUIDebug: Attempting to fix common issues...');
        
        // Ensure Tailwind CSS is loaded directly
        if (!document.getElementById('tailwind-css')) {
            console.log('BattleUIDebug: Adding Tailwind CSS...');
            const tailwindScript = document.createElement('script');
            tailwindScript.id = 'tailwind-css';
            tailwindScript.src = 'https://cdn.tailwindcss.com';
            document.head.appendChild(tailwindScript);
            
            // Also add Inter font
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap';
            document.head.appendChild(fontLink);
        }
        
        // Force reinstall custom styles
        console.log('BattleUIDebug: Reinstalling custom styles...');
        const existingStyles = document.getElementById('battle-ui-styles');
        if (existingStyles) {
            document.head.removeChild(existingStyles);
        }
        battleUI.addCustomStyles();
        
        // Force update UI elements
        console.log('BattleUIDebug: Forcing UI update...');
        if (battleUI.isSetup && battleUI.playerTeam.length > 0) {
            battleUI.update();
            
            // Re-render characters
            battleUI.renderCharacters(battleUI.playerTeam, battleUI.enemyTeam);
            
            // Reset active character
            if (battleUI.playerTeam.length > 0) {
                battleUI.setActiveCharacter(battleUI.playerTeam[0]);
            }
        }
        
        console.log('BattleUIDebug: Fix attempts completed');
    }
    
    /**
     * Inject a simple fallback UI style if Tailwind CSS fails to load
     */
    static injectFallbackStyles() {
        console.log('BattleUIDebug: Injecting fallback styles...');
        
        const fallbackStyles = document.createElement('style');
        fallbackStyles.id = 'battle-ui-fallback-styles';
        fallbackStyles.textContent = `
            #battle-ui {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #141e2e;
                color: white;
                font-family: Arial, sans-serif;
                z-index: 9999;
                display: flex;
                flex-direction: column;
                padding: 20px;
            }
            
            header {
                background-color: #232a40;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            main {
                flex: 1;
                display: flex;
                gap: 20px;
                justify-content: center;
                align-items: flex-start;
                padding-top: 30px;
                background-color: #1a1a2e;
            }
            
            section {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 20px;
                width: 30%;
            }
            
            h2 {
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 10px;
            }
            
            footer {
                margin-top: 15px;
            }
            
            .character-circle {
                width: 64px;
                height: 64px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 10px;
                border: 2px solid rgba(255, 255, 255, 0.3);
            }
            
            .bg-fire { background-color: #ff4757; }
            .bg-water { background-color: #1e90ff; }
            .bg-nature { background-color: #2ed573; }
            .bg-dark { background-color: #9900cc; }
            .bg-light { background-color: #ffd700; }
            .bg-air { background-color: #70a1ff; }
            
            .hp-bar-container {
                width: 80px;
                margin: 0 auto;
            }
            
            .hp-bar-background {
                background-color: #4a5568;
                height: 8px;
                border-radius: 4px;
                overflow: hidden;
            }
            
            .hp-bar-current {
                background-color: #48bb78;
                height: 100%;
                border-radius: 4px 0 0 4px;
            }
            
            .battle-log {
                height: 150px;
                overflow-y: auto;
                background-color: #232a40;
                padding: 10px;
                border-radius: 8px;
            }
            
            .active-character .character-circle {
                box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6);
            }
            
            button {
                padding: 8px 15px;
                background-color: #3742fa;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                margin-right: 5px;
            }
            
            .control-button {
                background-color: #4a5568;
            }
            
            .control-button.active {
                background-color: #3742fa;
            }
            
            /* Simple floating text animation */
            .floating-text {
                position: absolute;
                top: -25px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 16px;
                font-weight: bold;
                white-space: nowrap;
                z-index: 10;
                animation: float-up-fade-out 1.2s forwards;
            }
            
            @keyframes float-up-fade-out {
                0% {
                    opacity: 0;
                    transform: translate(-50%, 0);
                }
                10% {
                    opacity: 1;
                }
                80% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                    transform: translate(-50%, -30px);
                }
            }
            
            /* Animation for when a character takes damage */
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-5px); }
            }
        `;
        
        document.head.appendChild(fallbackStyles);
        console.log('BattleUIDebug: Fallback styles injected');
    }
}

// Export for use in other modules
window.BattleUIDebug = BattleUIDebug;


===== FILE: SoundManager.js =====
/**
 * Sound Manager
 * Manages sound effects for the UI
 */

class SoundManager {
    /**
     * Create a new Sound Manager
     */
    constructor() {
        this.sounds = {};
        this.muted = false;
        this.volume = 0.5;
        this.audioContext = null;
        
        try {
            // Try to create audio context for generating sounds
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
            console.log('AudioContext initialized');
        } catch (e) {
            console.warn('Web Audio API not supported', e);
        }
        
        // Create DOM element for controlling sound
        this.createSoundControls();
        this.initialize();
    }

    /**
     * Initialize sound effects
     */
    initialize() {
        // Define sound effects - this will use the generated sounds
        // until actual sound files are available
        this.registerSound('click', 'assets/audio/click.mp3');
        this.registerSound('hover', 'assets/audio/hover.mp3');
        this.registerSound('select', 'assets/audio/select.mp3');
        this.registerSound('add', 'assets/audio/add.mp3');
        this.registerSound('remove', 'assets/audio/remove.mp3');
        this.registerSound('error', 'assets/audio/error.mp3');
        this.registerSound('battle_start', 'assets/audio/battle_start.mp3');
        
        console.log('Sound effects registered');
    }
    
    /**
     * Create sound control UI elements
     */
    createSoundControls() {
        // Create sound controls container
        const soundControls = document.createElement('div');
        soundControls.className = 'sound-controls';
        soundControls.style.position = 'fixed';
        soundControls.style.bottom = '20px';
        soundControls.style.right = '20px';
        soundControls.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        soundControls.style.padding = '10px';
        soundControls.style.borderRadius = '5px';
        soundControls.style.zIndex = '1000';
        
        // Create sound toggle button
        const soundToggle = document.createElement('button');
        soundToggle.textContent = 'ðŸ”Š';
        soundToggle.style.background = 'none';
        soundToggle.style.border = 'none';
        soundToggle.style.color = 'white';
        soundToggle.style.fontSize = '24px';
        soundToggle.style.cursor = 'pointer';
        soundToggle.title = 'Toggle Sound';
        
        // Add click event
        soundToggle.addEventListener('click', () => {
            this.toggleMute();
            soundToggle.textContent = this.muted ? 'ðŸ”‡' : 'ðŸ”Š';
        });
        
        // Add to container
        soundControls.appendChild(soundToggle);
        
        // Add volume slider
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.min = '0';
        volumeSlider.max = '100';
        volumeSlider.value = this.volume * 100;
        volumeSlider.style.width = '100px';
        volumeSlider.style.marginLeft = '10px';
        volumeSlider.title = 'Volume';
        
        // Add change event
        volumeSlider.addEventListener('input', (e) => {
            this.setVolume(e.target.value / 100);
        });
        
        // Add to container
        soundControls.appendChild(volumeSlider);
        
        // Add to document
        document.body.appendChild(soundControls);
    }

    /**
     * Register a sound with both file and generated fallback
     * @param {string} id - Sound identifier
     * @param {string} path - Path to sound file
     */
    registerSound(id, path) {
        this.sounds[id] = {
            path: path,
            loaded: false,
            audio: null
        };
        
        // Try to load the sound file
        this.loadSoundFile(id, path);
    }
    
    /**
     * Try to load an actual sound file
     * @param {string} id - Sound identifier
     * @param {string} path - Path to sound file
     */
    loadSoundFile(id, path) {
        // Create an audio element
        const audio = new Audio();
        
        // Set up event listeners
        audio.oncanplaythrough = () => {
            console.log(`Sound loaded: ${id}`);
            this.sounds[id].loaded = true;
            this.sounds[id].audio = audio;
        };
        
        audio.onerror = () => {
            console.log(`Could not load sound file: ${path}. Will use generated sound instead.`);
        };
        
        // Load the file
        try {
            audio.src = path;
            audio.load();
        } catch (e) {
            console.warn(`Error loading sound file ${path}:`, e);
        }
    }

    /**
     * Play a sound effect
     * @param {string} id - Sound identifier
     */
    play(id) {
        if (this.muted || !this.sounds[id]) return;
        
        try {
            // If the sound file is loaded, play it
            if (this.sounds[id].loaded && this.sounds[id].audio) {
                const soundInstance = this.sounds[id].audio.cloneNode();
                soundInstance.volume = this.volume;
                soundInstance.play();
            } else {
                // Otherwise, generate a sound
                this.generateSound(id);
            }
        } catch (e) {
            console.warn(`Error playing sound ${id}:`, e);
        }
    }
    
    /**
     * Generate a sound using Web Audio API
     * @param {string} id - Sound identifier
     */
    generateSound(id) {
        if (!this.audioContext) return;
        
        try {
            // Create oscillator
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            // Set volume
            gainNode.gain.value = this.volume * 0.3; // Lower volume for generated sounds
            
            // Configure sound based on type
            switch (id) {
                case 'click':
                    oscillator.type = 'square';
                    oscillator.frequency.value = 800;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                    break;
                    
                case 'hover':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 600;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.08);
                    break;
                    
                case 'select':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                    break;
                    
                case 'add':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'remove':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(300, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'error':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(180, this.audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'battle_start':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                    oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.3);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.7);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.7);
                    break;
                    
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            console.log(`Generated sound: ${id}`);
            
        } catch (e) {
            console.warn(`Error generating sound ${id}:`, e);
        }
    }

    /**
     * Set sound volume
     * @param {number} volume - Volume level (0-1)
     */
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        console.log(`Volume set to ${this.volume}`);
    }

    /**
     * Toggle mute state
     * @returns {boolean} - New mute state
     */
    toggleMute() {
        this.muted = !this.muted;
        console.log(`Sound ${this.muted ? 'muted' : 'unmuted'}`);
        return this.muted;
    }

    /**
     * Add hover sound to an element
     * @param {HTMLElement} element - Element to add sound to
     */
    addHoverSound(element) {
        // Hover sounds disabled - too distracting
        // Previously: element.addEventListener('mouseenter', () => this.play('hover'));
    }

    /**
     * Add click sound to an element
     * @param {HTMLElement} element - Element to add sound to
     */
    addClickSound(element) {
        element.addEventListener('click', () => {
            this.play('click');
        });
    }
    
    /**
     * Add sounds to common UI elements
     */
    addSoundsToUI() {
        // Add sounds to all buttons
        document.querySelectorAll('button').forEach(button => {
            this.addHoverSound(button);
            this.addClickSound(button);
        });
        
        // Add sounds to battle mode selectors
        document.querySelectorAll('.battle-mode').forEach(mode => {
            this.addHoverSound(mode);
            mode.addEventListener('click', () => {
                this.play('select');
            });
        });
        
        // Add sounds to hero cards
        document.querySelectorAll('.hero-card').forEach(card => {
            this.addHoverSound(card);
            card.addEventListener('click', () => {
                this.play('select');
            });
        });
        
        // Add sounds to team slots
        document.querySelectorAll('.slot-empty').forEach(slot => {
            this.addHoverSound(slot);
            slot.addEventListener('click', () => {
                this.play('add');
            });
        });
        
        // Add sounds to remove buttons
        document.querySelectorAll('.remove-hero').forEach(button => {
            this.addHoverSound(button);
            button.addEventListener('click', () => {
                this.play('remove');
            });
        });
        
        // Start battle button
        const startButton = document.getElementById('start-battle');
        if (startButton) {
            this.addHoverSound(startButton);
            startButton.addEventListener('click', () => {
                if (!startButton.disabled) {
                    this.play('battle_start');
                } else {
                    this.play('error');
                }
            });
        }
        
        console.log('Added sounds to UI elements');
    }
}

// Create a singleton instance
const soundManager = new SoundManager();

// Make it available globally
window.soundManager = soundManager;

// Add sound effects to UI elements once the page is fully loaded
window.addEventListener('load', () => {
    // Wait a moment for all UI elements to be created
    setTimeout(() => {
        window.soundManager.addSoundsToUI();
    }, 1000);
});


===== FILE: TeamBuilderUI.js =====
/**
 * Team Builder UI
 * Manages the user interface for team selection
 * Based on the React mockup concept
 */

class TeamBuilderUI {
    /**
     * Create a new Team Builder UI
     * @param {TeamManager} teamManager - Reference to the team manager
     */
    constructor(teamManager) {
        this.teamManager = teamManager || null;
        this.availableHeroes = [];
        this.selectedHeroes = [null, null, null];
        this.enemySelectedHeroes = [null, null, null];
        this.selectedHeroDetails = null;
        this.battleMode = 'random';
        this.activeFilters = {
            types: [],
            roles: []
        };
        this.isSelectingEnemyTeam = false; // Flag to track if we're selecting enemy team
        this.imageLoader = null; // Will hold the TeamBuilderImageLoader
        this.typeColors = {
            fire: '#ff4757',
            water: '#1e90ff',
            nature: '#2ed573',
            dark: '#9900cc',
            light: '#ffd700',
            air: '#70a1ff'
        };
        this.rarityColors = {
            Common: '#aaaaaa',
            Uncommon: '#2ed573',
            Rare: '#1e90ff',
            Epic: '#9900cc',
            Legendary: '#ffd700'
        };
    }

    /**
     * Initialize the team builder UI
     */
    async initialize() {
        console.log('TeamBuilderUI: Initializing...');
        // Fetch available heroes from data file
        try {
            // Try both relative and absolute paths
            let response;
            try {
                response = await fetch('data/characters.json');
            } catch (err) {
                console.log('Trying with alternate path...');
                response = await fetch('./data/characters.json');
            }
            const data = await response.json();
            this.availableHeroes = data.characters;
            console.log('TeamBuilderUI: Loaded', this.availableHeroes.length, 'heroes');
            
            // Initialize the image loader
            await this.initializeImageLoader();
            
            this.renderFilters();
            this.renderHeroGrid();
            this.renderTeamSlots();
            this.renderBattleModes();
            this.setupEventListeners();
        } catch (error) {
            console.error('Error loading characters data:', error);
            
            // Display error on the page for debugging
            const heroesGrid = document.getElementById('heroes-grid');
            if (heroesGrid) {
                heroesGrid.innerHTML = `<div style="color: red; padding: 20px;">Error loading heroes data: ${error.message}</div>`;
            }
        }
    }

    /**
     * Render filter options for types and roles
     */
    renderFilters() {
        const heroesSection = document.getElementById('available-heroes');
        
        // Check if filter section already exists
        let filterSection = document.getElementById('hero-filters');
        if (!filterSection) {
            filterSection = document.createElement('div');
            filterSection.id = 'hero-filters';
            
            // Insert filters before the heroes grid
            const heroesGrid = document.getElementById('heroes-grid');
            heroesSection.insertBefore(filterSection, heroesGrid);
        } else {
            filterSection.innerHTML = '';
        }

        // Create type filters
        const typeFilters = document.createElement('div');
        typeFilters.className = 'filter-group';
        
        const typeLabel = document.createElement('div');
        typeLabel.className = 'filter-label';
        typeLabel.textContent = 'Filter by Type:';
        typeFilters.appendChild(typeLabel);
        
        // Get unique types from heroes
        const types = [...new Set(this.availableHeroes.map(hero => hero.type))];
        
        const typeButtonsContainer = document.createElement('div');
        typeButtonsContainer.className = 'filter-buttons';
        
        types.forEach(type => {
            const typeButton = document.createElement('button');
            typeButton.className = `filter-button ${this.activeFilters.types.includes(type) ? 'active' : ''}`;
            typeButton.dataset.type = type;
            typeButton.style.backgroundColor = `${this.typeColors[type]}88`;
            typeButton.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            
            // Add event listener
            typeButton.addEventListener('click', () => {
                const index = this.activeFilters.types.indexOf(type);
                if (index === -1) {
                    // Add filter
                    this.activeFilters.types.push(type);
                    typeButton.classList.add('active');
                } else {
                    // Remove filter
                    this.activeFilters.types.splice(index, 1);
                    typeButton.classList.remove('active');
                }
                
                // Re-render heroes grid
                this.renderHeroGrid();
                
                // Play sound
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            });
            
            // Add hover sound
            if (window.soundManager) {
                window.soundManager.addHoverSound(typeButton);
            }
            
            typeButtonsContainer.appendChild(typeButton);
        });
        
        typeFilters.appendChild(typeButtonsContainer);
        filterSection.appendChild(typeFilters);
        
        // Create role filters
        const roleFilters = document.createElement('div');
        roleFilters.className = 'filter-group';
        
        const roleLabel = document.createElement('div');
        roleLabel.className = 'filter-label';
        roleLabel.textContent = 'Filter by Role:';
        roleFilters.appendChild(roleLabel);
        
        // Get unique roles from heroes
        const roles = [...new Set(this.availableHeroes.map(hero => hero.role))];
        
        const roleButtonsContainer = document.createElement('div');
        roleButtonsContainer.className = 'filter-buttons';
        
        roles.forEach(role => {
            const roleButton = document.createElement('button');
            roleButton.className = `filter-button ${this.activeFilters.roles.includes(role) ? 'active' : ''}`;
            roleButton.dataset.role = role;
            roleButton.textContent = role;
            
            // Add event listener
            roleButton.addEventListener('click', () => {
                const index = this.activeFilters.roles.indexOf(role);
                if (index === -1) {
                    // Add filter
                    this.activeFilters.roles.push(role);
                    roleButton.classList.add('active');
                } else {
                    // Remove filter
                    this.activeFilters.roles.splice(index, 1);
                    roleButton.classList.remove('active');
                }
                
                // Re-render heroes grid
                this.renderHeroGrid();
                
                // Play sound
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            });
            
            // Add hover sound
            if (window.soundManager) {
                window.soundManager.addHoverSound(roleButton);
            }
            
            roleButtonsContainer.appendChild(roleButton);
        });
        
        roleFilters.appendChild(roleButtonsContainer);
        filterSection.appendChild(roleFilters);
        
        // Add clear filters button
        const clearButton = document.createElement('button');
        clearButton.className = 'clear-filters-btn';
        clearButton.textContent = 'Clear Filters';
        clearButton.addEventListener('click', () => {
            this.activeFilters.types = [];
            this.activeFilters.roles = [];
            this.renderFilters();
            this.renderHeroGrid();
            
            // Play sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
        });
        
        // Add hover sound
        if (window.soundManager) {
            window.soundManager.addHoverSound(clearButton);
        }
        
        filterSection.appendChild(clearButton);
    }

    /**
     * Render the available heroes grid
     */
    renderHeroGrid() {
        const heroesGrid = document.getElementById('heroes-grid');
        heroesGrid.innerHTML = '';

        // Filter heroes based on active filters
        let filteredHeroes = [...this.availableHeroes];
        
        // Apply type filters
        if (this.activeFilters.types.length > 0) {
            filteredHeroes = filteredHeroes.filter(hero => 
                this.activeFilters.types.includes(hero.type)
            );
        }
        
        // Apply role filters
        if (this.activeFilters.roles.length > 0) {
            filteredHeroes = filteredHeroes.filter(hero => 
                this.activeFilters.roles.includes(hero.role)
            );
        }

        // Display message if no heroes match filters
        if (filteredHeroes.length === 0) {
            const noHeroes = document.createElement('div');
            noHeroes.className = 'no-heroes-message';
            noHeroes.textContent = 'No heroes match your filters';
            heroesGrid.appendChild(noHeroes);
            return;
        }

        filteredHeroes.forEach(hero => {
            const heroCard = document.createElement('div');
            heroCard.className = 'hero-card';
            heroCard.style.backgroundColor = `${this.typeColors[hero.type]}22`;
            heroCard.dataset.heroId = hero.id;

            if (this.selectedHeroDetails && this.selectedHeroDetails.id === hero.id) {
                heroCard.classList.add('selected');
            }

            const heroContent = document.createElement('div');
            heroContent.className = 'hero-card-content';

            // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
            const heroIconContainer = document.createElement('div');
            heroIconContainer.className = 'hero-avatar-container';
            heroIconContainer.dataset.characterId = hero.id;
            heroIconContainer.dataset.characterName = hero.name;
            heroIconContainer.dataset.artSynced = '0';
            // No background color set - will only be visible if character art exists
            
            // Create art wrapper for character images - this is all we need now
            const artWrapper = document.createElement('div');
            artWrapper.className = 'hero-art-wrapper';
            
            // Assemble the icon structure
            heroIconContainer.appendChild(artWrapper);

            const heroText = document.createElement('div');
            heroText.className = 'hero-card-text';

            const heroName = document.createElement('div');
            heroName.className = 'hero-name';
            heroName.textContent = hero.name;

            const heroType = document.createElement('div');
            heroType.className = 'hero-type';
            
            const typeText = document.createElement('span');
            typeText.style.color = this.typeColors[hero.type];
            typeText.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);
            
            const separator = document.createElement('span');
            separator.textContent = ' â€¢ ';
            
            const roleText = document.createElement('span');
            roleText.textContent = hero.role;

            heroType.appendChild(typeText);
            heroType.appendChild(separator);
            heroType.appendChild(roleText);

            heroText.appendChild(heroName);
            heroText.appendChild(heroType);

            heroContent.appendChild(heroIconContainer);
            heroContent.appendChild(heroText);

            heroCard.appendChild(heroContent);
            heroesGrid.appendChild(heroCard);

            // Add event listener
            heroCard.addEventListener('click', () => this.selectHeroDetails(hero));
        });
        
        // Force image loader to check for new images
        if (this.imageLoader) {
            this.imageLoader.forceCheck();
        }
    }

    /**
     * Render the team slots
     */
    renderTeamSlots() {
        const teamSlots = document.getElementById('team-slots');
        teamSlots.innerHTML = '';
        
        // Add team heading that shows which team we're building
        const teamHeading = document.createElement('div');
        teamHeading.className = 'team-heading team-heading-change';
        teamHeading.id = 'team-heading';
        teamHeading.textContent = this.isSelectingEnemyTeam ? 'Enemy Team' : 'Your Team';
        teamHeading.style.color = this.isSelectingEnemyTeam ? '#ff4757' : '#1e90ff';
        teamSlots.appendChild(teamHeading);
        
        // Add class to container if selecting enemy team
        if (this.isSelectingEnemyTeam) {
            teamSlots.classList.add('is-selecting-enemy');
        } else {
            teamSlots.classList.remove('is-selecting-enemy');
        }
        
        // Get the right array based on what we're selecting
        const currentTeam = this.isSelectingEnemyTeam ? this.enemySelectedHeroes : this.selectedHeroes;

        // Create 3 team slots
        for (let i = 0; i < 3; i++) {
            const slotElement = document.createElement('div');
            slotElement.className = 'team-slot';

            const slotLabel = document.createElement('div');
            slotLabel.className = 'slot-label';
            slotLabel.textContent = `${i + 1}${this.getOrdinalSuffix(i + 1)} Pick`;

            const slotContent = document.createElement('div');
            slotContent.className = 'slot-content';
            
            // Enemy team styling is handled by CSS via the is-selecting-enemy class

            if (currentTeam[i]) {
                // Slot is filled
                slotContent.classList.add('slot-filled');
                slotContent.style.backgroundColor = `${this.typeColors[currentTeam[i].type]}33`;

                const heroDetails = document.createElement('div');
                heroDetails.className = 'hero-details';
                
                // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
                const heroIconContainer = document.createElement('div');
                heroIconContainer.className = 'hero-avatar-container';
                heroIconContainer.dataset.characterId = currentTeam[i].id;
                heroIconContainer.dataset.characterName = currentTeam[i].name;
                heroIconContainer.dataset.artSynced = '0';
                // No background color set - will only be visible if character art exists
                
                // Create art wrapper for character images
                const artWrapper = document.createElement('div');
                artWrapper.className = 'hero-art-wrapper';
                
                // Assemble the icon structure
                heroIconContainer.appendChild(artWrapper);

                const heroInfo = document.createElement('div');
                heroInfo.className = 'hero-info';

                const heroName = document.createElement('div');
                heroName.className = 'hero-name';
                heroName.style.fontWeight = 'bold';
                heroName.textContent = currentTeam[i].name;

                const heroType = document.createElement('div');
                heroType.className = 'hero-type';
                heroType.style.fontSize = '12px';
                heroType.innerHTML = `<span style="color: ${this.typeColors[currentTeam[i].type]}">${currentTeam[i].type.charAt(0).toUpperCase() + currentTeam[i].type.slice(1)}</span> â€¢ ${currentTeam[i].role}`;

                // Basic stats
                const heroStats = document.createElement('div');
                heroStats.className = 'hero-stats';
                heroStats.style.fontSize = '12px';
                heroStats.style.color = '#a4b0be';
                heroStats.textContent = `HP: ${currentTeam[i].stats.hp} | ATK: ${currentTeam[i].stats.attack} | DEF: ${currentTeam[i].stats.defense}`;
                
                // Add advanced stats in condensed format
                const heroAdvStats = document.createElement('div');
                heroAdvStats.className = 'hero-adv-stats';
                heroAdvStats.style.fontSize = '11px';
                heroAdvStats.style.color = '#a4b0be';
                
                // Check if expanded stats exist before displaying them
                if (currentTeam[i].stats.strength && currentTeam[i].stats.intellect && currentTeam[i].stats.spirit) {
                    heroAdvStats.textContent = `STR: ${currentTeam[i].stats.strength} | INT: ${currentTeam[i].stats.intellect} | SPI: ${currentTeam[i].stats.spirit}`;
                    heroInfo.appendChild(heroAdvStats);
                }

                heroInfo.appendChild(heroName);
                heroInfo.appendChild(heroType);
                heroInfo.appendChild(heroStats);

                heroDetails.appendChild(heroIconContainer);
                heroDetails.appendChild(heroInfo);

                const removeButton = document.createElement('button');
                removeButton.className = 'remove-hero';
                removeButton.textContent = 'Ã—';
                removeButton.dataset.slotIndex = i;
                removeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeHeroFromTeam(i);
                });

                slotContent.appendChild(heroDetails);
                slotContent.appendChild(removeButton);
            } else {
                // Slot is empty
                slotContent.classList.add('slot-empty');

                const emptyText = document.createElement('span');
                if (this.selectedHeroDetails) {
                    emptyText.textContent = `Click to place ${this.selectedHeroDetails.name} here`;
                } else {
                    emptyText.textContent = 'Select a hero first';
                    emptyText.style.color = '#a4b0be';
                }

                slotContent.appendChild(emptyText);
                slotContent.dataset.slotIndex = i;
                slotContent.addEventListener('click', () => this.addHeroToTeam(i));
            }

            slotElement.appendChild(slotLabel);
            slotElement.appendChild(slotContent);
            teamSlots.appendChild(slotElement);
        }
        
        // If we're in enemy selection mode, add a Back button to return to player team
        if (this.isSelectingEnemyTeam) {
            const backButton = document.createElement('button');
            backButton.className = 'enemy-team-control-btn';
            backButton.textContent = 'Back to Your Team';
            backButton.addEventListener('click', () => {
                this.isSelectingEnemyTeam = false;
                this.renderTeamSlots();
                this.renderTeamSynergies();
                this.updateStartBattleButton();
            });
            teamSlots.appendChild(backButton);
        }

        // Update synergies - only show for player team
        if (!this.isSelectingEnemyTeam) {
            this.renderTeamSynergies();
        }
        
        // Update the start battle button
        this.updateStartBattleButton();
        
        // Force image loader to check for new images
        if (this.imageLoader) {
            this.imageLoader.forceCheck();
        }
    }

    /**
     * Render the team synergies
     */
    renderTeamSynergies() {
        const synergiesList = document.getElementById('synergies-list');
        synergiesList.innerHTML = '';

        const synergies = this.calculateSynergies();

        if (synergies.length > 0) {
            synergies.forEach(synergy => {
                const synergyItem = document.createElement('li');
                synergyItem.textContent = synergy;
                synergiesList.appendChild(synergyItem);
            });
        } else {
            const noSynergies = document.createElement('li');
            noSynergies.textContent = 'No active synergies yet';
            noSynergies.style.color = '#a4b0be';
            synergiesList.appendChild(noSynergies);
        }
    }

    /**
     * Render the hero details panel
     */
    renderHeroDetails() {
        const detailContent = document.getElementById('detail-content');
        
        // Keep track of previous hero name for intelligent comparison
        const previousHeroId = this.previousHeroId || null;
        this.previousHeroId = this.selectedHeroDetails ? this.selectedHeroDetails.id : null;
        
        // CRITICAL: Disable art observer during detail panel updates
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            // OPTIMIZATION: Instead of clearing all content, preserve the wrapper structure
            const existingDetail = detailContent.querySelector('.detail-hero');
            const existingWrapper = detailContent.querySelector('.hero-avatar-container.detail-icon-container');
            
            // Only clear content if either:
            // 1. No hero is selected (show empty state) OR
            // 2. No existing detail content exists
            if (!this.selectedHeroDetails) {
                // Just emptying content for "no hero selected" state
                detailContent.innerHTML = '';
                
                // No hero selected - show empty state and exit
                const detailEmpty = document.createElement('div');
                detailEmpty.className = 'detail-empty';
                detailEmpty.textContent = 'Select a hero to view details';
                detailContent.appendChild(detailEmpty);
                return;
            }
            
            // If details already exist with a wrapper, update the existing details
            // This preserves the image container for ALL heroes, not just Aqualia
            if (existingDetail && existingWrapper) {
                console.log(`Preserving art wrapper while updating details for ${this.selectedHeroDetails.name}`);
                this.updateExistingHeroDetails(existingDetail);
                return;
            }
        
        // Regular rendering for other heroes or first-time rendering
        const hero = this.selectedHeroDetails;
        const detailHero = document.createElement('div');
        detailHero.className = 'detail-hero';
        detailHero.style.backgroundColor = `${this.typeColors[hero.type]}22`;

        // Header section
        const detailHeader = document.createElement('div');
        detailHeader.className = 'detail-header';

        // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
        const detailIconContainer = document.createElement('div');
        detailIconContainer.className = 'hero-avatar-container detail-icon-container';
        detailIconContainer.dataset.characterId = hero.id;
        detailIconContainer.dataset.characterName = hero.name;
        // No background color set - will only be visible if character art exists
        
        // Create art wrapper for character images
        const artWrapper = document.createElement('div');
        artWrapper.className = 'hero-art-wrapper';
        
        // Assemble the icon structure
        detailIconContainer.appendChild(artWrapper);

        const detailNameType = document.createElement('div');
        detailNameType.className = 'detail-name-type';

        const heroName = document.createElement('h3');
        heroName.textContent = hero.name;

        const detailTags = document.createElement('div');
        detailTags.className = 'detail-tags';

        const typeTag = document.createElement('span');
        typeTag.className = 'detail-tag';
        typeTag.style.backgroundColor = this.typeColors[hero.type];
        typeTag.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);

        const roleTag = document.createElement('span');
        roleTag.className = 'detail-tag';
        roleTag.style.backgroundColor = '#2f3542';
        roleTag.textContent = hero.role;

        const rarityTag = document.createElement('span');
        rarityTag.className = 'detail-tag';
        rarityTag.style.backgroundColor = this.rarityColors[hero.rarity];
        rarityTag.textContent = hero.rarity;

        detailTags.appendChild(typeTag);
        detailTags.appendChild(roleTag);
        detailTags.appendChild(rarityTag);

        detailNameType.appendChild(heroName);
        detailNameType.appendChild(detailTags);

        detailHeader.appendChild(detailIconContainer);
        detailHeader.appendChild(detailNameType);

        // Stats section
        const detailStats = document.createElement('div');
        detailStats.className = 'detail-stats';

        // Add CSS to detail-stats to use flex-column
        detailStats.style.display = 'flex';
        detailStats.style.flexDirection = 'column';
        detailStats.style.gap = '8px';

        // First row of stats (existing)
        const statsRow1 = document.createElement('div');
        statsRow1.className = 'stats-row';
        statsRow1.style.display = 'flex';
        statsRow1.style.justifyContent = 'space-between';
        statsRow1.style.gap = '8px';

        const hpStat = this.createStatBox('HP', hero.stats.hp, 'Health Points - How much damage a character can take before being defeated');
        const atkStat = this.createStatBox('ATK', hero.stats.attack, 'Attack Power - Determines basic attack damage');
        const defStat = this.createStatBox('DEF', hero.stats.defense, 'Defense - Reduces damage taken from attacks');
        const spdStat = this.createStatBox('SPD', hero.stats.speed, 'Speed - Determines turn order in battle (higher goes first)');

        statsRow1.appendChild(hpStat);
        statsRow1.appendChild(atkStat);
        statsRow1.appendChild(defStat);
        statsRow1.appendChild(spdStat);

        // Only add second row if expanded stats exist
        if (hero.stats.strength && hero.stats.intellect && hero.stats.spirit) {
            // Second row of stats (new)
            const statsRow2 = document.createElement('div');
            statsRow2.className = 'stats-row';
            statsRow2.style.display = 'flex';
            statsRow2.style.justifyContent = 'space-between';
            statsRow2.style.gap = '8px';

            const strStat = this.createStatBox('STR', hero.stats.strength, 'Strength - Increases physical ability damage');
            const intStat = this.createStatBox('INT', hero.stats.intellect, 'Intellect - Increases spell ability damage');
            const spiStat = this.createStatBox('SPI', hero.stats.spirit, 'Spirit - Increases healing effectiveness');

            statsRow2.appendChild(strStat);
            statsRow2.appendChild(intStat);
            statsRow2.appendChild(spiStat);

            // Add both rows
            detailStats.appendChild(statsRow1);
            detailStats.appendChild(statsRow2);
        } else {
            // Just add the first row if no expanded stats
            detailStats.appendChild(statsRow1);
        }

        // Abilities section
        const detailAbilities = document.createElement('div');
        detailAbilities.className = 'detail-abilities';

        const abilitiesTitle = document.createElement('h4');
        abilitiesTitle.textContent = 'Abilities';

        detailAbilities.appendChild(abilitiesTitle);

        hero.abilities.forEach(ability => {
            const abilityBox = document.createElement('div');
            abilityBox.className = 'ability-box';

            const abilityName = document.createElement('div');
            abilityName.className = 'ability-name';
            abilityName.textContent = ability.name;

            const abilityDesc = document.createElement('div');
            abilityDesc.className = 'ability-desc';
            abilityDesc.textContent = ability.description;

            abilityBox.appendChild(abilityName);
            abilityBox.appendChild(abilityDesc);
            detailAbilities.appendChild(abilityBox);
            
            // Add tooltip with more detailed info
            if (window.tooltipManager) {
                const cooldownText = ability.cooldown > 0 ? `Cooldown: ${ability.cooldown} turns` : 'No cooldown';
                
                // Get detailed scaling information with formula
                const detailedScaling = this.getDetailedScalingText(ability, hero);
                
                const tooltipContent = `
                    <div class="tooltip-title">${ability.name}</div>
                    <div>${ability.description}</div>
                    <div class="tooltip-content">
                        ${detailedScaling.damageText}
                        <div>${cooldownText}</div>
                        <div>Type: ${ability.damageType || (ability.isHealing ? 'Healing' : 'Damage')}</div>
                        <div>${detailedScaling.scalingText}</div>
                    </div>
                `;
                
                window.tooltipManager.addTooltip(abilityBox, tooltipContent);
                abilityBox.classList.add('has-tooltip');
            }
        });

        // Advantages section
        const detailAdvantages = document.createElement('div');
        detailAdvantages.className = 'detail-advantages';

        const advantagesTitle = document.createElement('h4');
        advantagesTitle.textContent = 'Advantages';

        const advantagesList = document.createElement('div');
        advantagesList.className = 'advantage-list';
        
        let advantageHTML = '';
        let tooltipContent = `<div class="tooltip-title">Type Advantages</div><div class="tooltip-content">`;

        // Add type advantages based on hero type
        switch (hero.type) {
            case 'fire':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.nature}">Nature</span>`;
                tooltipContent += 'Fire does 50% more damage to Nature types.<br>Fire takes 50% more damage from Water types.';
                break;
            case 'water':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.fire}">Fire</span>`;
                tooltipContent += 'Water does 50% more damage to Fire types.<br>Water takes 50% more damage from Nature types.';
                break;
            case 'nature':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.water}">Water</span>`;
                tooltipContent += 'Nature does 50% more damage to Water types.<br>Nature takes 50% more damage from Fire types.';
                break;
            case 'light':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.dark}">Dark</span>`;
                tooltipContent += 'Light does 50% more damage to Dark types.<br>Light takes 50% more damage from Dark types.';
                break;
            case 'dark':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.light}">Light</span>`;
                tooltipContent += 'Dark does 50% more damage to Light types.<br>Dark takes 50% more damage from Light types.';
                break;
            case 'air':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.earth || '#8B4513'}">Earth</span>`;
                tooltipContent += 'Air does 50% more damage to Earth types.<br>Air takes 50% more damage from Electric types.';
                break;
        }
        
        tooltipContent += '</div>';
        advantagesList.innerHTML = advantageHTML;
        
        // Add tooltip to advantages section
        if (window.tooltipManager) {
            window.tooltipManager.addTooltip(advantagesList, tooltipContent);
            advantagesList.classList.add('has-tooltip');
        }

        detailAdvantages.appendChild(advantagesTitle);
        detailAdvantages.appendChild(advantagesList);

        // Add all sections to the detail content
        detailHero.appendChild(detailHeader);
        detailHero.appendChild(detailStats);
        detailHero.appendChild(detailAbilities);
        detailHero.appendChild(detailAdvantages);

        detailContent.appendChild(detailHero);
        
        // If this character has art, add it directly without relying on the observer
        if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[hero.name]) {
            this.addArtToDetailPanel(hero, detailIconContainer);
        }
        } finally {
            // Re-enable art observer after all detail panel updates are complete
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }
    
    /**
     * Get detailed scaling text with formula for ability tooltips
     * @param {Object} ability - The ability object
     * @param {Object} hero - The hero object for stat reference
     * @returns {Object} Object with damageText and scalingText
     */
    getDetailedScalingText(ability, hero) {
        let scalingText = '';
        let damageText = '';
        let statValue = 0;
        
        if (ability.isHealing || ability.damageType === 'healing') {
            // Healing ability scaling with Spirit
            statValue = hero.stats.spirit || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalHealing = ability.damage + scalingAmount;
            
            damageText = `<div>Healing: ${ability.damage} + (50% of Spirit) = ${totalHealing} HP</div>`;
            scalingText = `${ability.name} restores ${ability.damage} + (50% of Spirit) health`;
        } 
        else if (ability.damageType === 'physical') {
            // Physical ability scaling with Strength
            statValue = hero.stats.strength || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalDamage = ability.damage + scalingAmount;
            
            damageText = `<div>Damage: ${ability.damage} + (50% of Strength) = ${totalDamage} pre-defense</div>`;
            scalingText = `${ability.name} deals ${ability.damage} + (50% of Strength) damage`;
        } 
        else if (ability.damageType === 'spell') {
            // Spell ability scaling with Intellect
            statValue = hero.stats.intellect || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalDamage = ability.damage + scalingAmount;
            
            damageText = `<div>Damage: ${ability.damage} + (50% of Intellect) = ${totalDamage} pre-defense</div>`;
            scalingText = `${ability.name} deals ${ability.damage} + (50% of Intellect) damage`;
        }
        else if (ability.damageType === 'utility') {
            // Utility ability scaling with Spirit
            damageText = `<div>Effect scales with Spirit</div>`;
            scalingText = `${ability.name}'s effectiveness scales with Spirit`;
        }
        else {
            // Default case (no scaling)
            damageText = ability.isHealing ? 
                `<div>Healing: ${ability.damage} HP</div>` : 
                `<div>Damage: ${ability.damage} points</div>`;
            scalingText = "No scaling";
        }
        
        return { damageText, scalingText };
    }
    
    /**
     * Add character art directly to a detail panel without using the observer
     */
    addArtToDetailPanel(hero, detailIconContainer) {
        // Find art wrapper or create one
        let artWrapper = detailIconContainer.querySelector('.hero-art-wrapper');
        if (!artWrapper) {
            artWrapper = document.createElement('div');
            artWrapper.className = 'hero-art-wrapper';
            artWrapper.style.display = 'block';
            detailIconContainer.appendChild(artWrapper);
        }
        
        // Clear any existing art
        while (artWrapper.firstChild) {
            artWrapper.removeChild(artWrapper.firstChild);
        }
        
        // Clone image from cache
        const newImg = window.CHARACTER_IMAGE_CACHE[hero.name].cloneNode(true);
        
        // Set styling for detail view
        newImg.className = 'character-art team-builder-art';
        newImg.alt = hero.name;
        newImg.style.position = 'absolute';
        
        // Get character positioning data
        const character = this.availableHeroes.find(c => c.id == hero.id);
        const artSettings = character?.detailArt || character?.teamBuilderArt || character?.art || {};
        
        // Apply custom positioning for this character
        newImg.style.left = artSettings.left || '-30px';
        newImg.style.top = artSettings.top || '-45px';
        newImg.style.width = artSettings.width || '140px';
        newImg.style.height = artSettings.height || '140px';
        newImg.style.visibility = 'visible';
        newImg.style.display = 'block';
        newImg.style.zIndex = '100';
        
        // Add the image to the wrapper
        artWrapper.appendChild(newImg);
        
        // Add relevant classes
        detailIconContainer.classList.add('has-art');
        const detailHero = detailIconContainer.closest('.detail-hero');
        if (detailHero) detailHero.classList.add('has-art');
    }
    
    /**
     * Update an existing hero details panel without rebuilding the entire DOM structure
     * This applies to all heroes to preserve character art in the details panel
     */
    updateExistingHeroDetails(detailHero) {
        const hero = this.selectedHeroDetails;
        
        // Disable observer while updating
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            // Important: Update the data attributes on the wrapper to match the new hero
            const detailIconContainer = detailHero.querySelector('.hero-avatar-container.detail-icon-container');
            if (detailIconContainer) {
                // Update the container to reflect the new character
                detailIconContainer.dataset.characterId = hero.id;
                detailIconContainer.dataset.characterName = hero.name;
                
                // Add art directly if available, bypassing observer
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[hero.name]) {
                    this.addArtToDetailPanel(hero, detailIconContainer);
                }
            }
            
            // Update background color for the detail hero container
            if (detailHero) {
                detailHero.style.backgroundColor = `${this.typeColors[hero.type]}22`;
            }
        
            // Update the hero name and tags
            const heroNameEl = detailHero.querySelector('.detail-name-type h3');
            if (heroNameEl) heroNameEl.textContent = hero.name;
            
            // Update the type, role, and rarity tags
            const typeTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(1)');
            if (typeTag) {
                typeTag.style.backgroundColor = this.typeColors[hero.type];
                typeTag.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);
            }
            
            const roleTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(2)');
            if (roleTag) roleTag.textContent = hero.role;
            
            const rarityTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(3)');
            if (rarityTag) {
                rarityTag.style.backgroundColor = this.rarityColors[hero.rarity];
                rarityTag.textContent = hero.rarity;
            }
            
            // Get or create stats container
            const detailStats = detailHero.querySelector('.detail-stats');
            if (detailStats) {
                // Clear existing stat rows
                detailStats.innerHTML = '';

                // First row of stats (existing)
                const statsRow1 = document.createElement('div');
                statsRow1.className = 'stats-row';
                statsRow1.style.display = 'flex';
                statsRow1.style.justifyContent = 'space-between';
                statsRow1.style.gap = '8px';

                const hpStat = this.createStatBox('HP', hero.stats.hp, 'Health Points - How much damage a character can take before being defeated');
                const atkStat = this.createStatBox('ATK', hero.stats.attack, 'Attack Power - Determines basic attack damage');
                const defStat = this.createStatBox('DEF', hero.stats.defense, 'Defense - Reduces damage taken from attacks');
                const spdStat = this.createStatBox('SPD', hero.stats.speed, 'Speed - Determines turn order in battle (higher goes first)');
                
                statsRow1.appendChild(hpStat);
                statsRow1.appendChild(atkStat);
                statsRow1.appendChild(defStat);
                statsRow1.appendChild(spdStat);
                
                // Only add second row if expanded stats exist
                if (hero.stats.strength && hero.stats.intellect && hero.stats.spirit) {
                    // Second row of stats (new)
                    const statsRow2 = document.createElement('div');
                    statsRow2.className = 'stats-row';
                    statsRow2.style.display = 'flex';
                    statsRow2.style.justifyContent = 'space-between';
                    statsRow2.style.gap = '8px';

                    const strStat = this.createStatBox('STR', hero.stats.strength, 'Strength - Increases physical ability damage');
                    const intStat = this.createStatBox('INT', hero.stats.intellect, 'Intellect - Increases spell ability damage');
                    const spiStat = this.createStatBox('SPI', hero.stats.spirit, 'Spirit - Increases healing effectiveness');

                    statsRow2.appendChild(strStat);
                    statsRow2.appendChild(intStat);
                    statsRow2.appendChild(spiStat);

                    // Add rows to stats container
                    detailStats.appendChild(statsRow1);
                    detailStats.appendChild(statsRow2);
                } else {
                    // Just add the first row if no expanded stats
                    detailStats.appendChild(statsRow1);
                }
            }
            
            // Update abilities (a bit more complex - might need to rebuild this section)
            const abilitiesContainer = detailHero.querySelector('.detail-abilities');
            if (abilitiesContainer) {
                // Keep the title but replace all ability boxes
                const abilitiesTitle = abilitiesContainer.querySelector('h4');
                abilitiesContainer.innerHTML = '';
                abilitiesContainer.appendChild(abilitiesTitle);
                
                // Re-add all abilities
                hero.abilities.forEach(ability => {
                    const abilityBox = document.createElement('div');
                    abilityBox.className = 'ability-box';

                    const abilityName = document.createElement('div');
                    abilityName.className = 'ability-name';
                    abilityName.textContent = ability.name;

                    const abilityDesc = document.createElement('div');
                    abilityDesc.className = 'ability-desc';
                    abilityDesc.textContent = ability.description;

                    abilityBox.appendChild(abilityName);
                    abilityBox.appendChild(abilityDesc);
                    abilitiesContainer.appendChild(abilityBox);
                    
                    // Re-add tooltips
                    if (window.tooltipManager) {
                        const cooldownText = ability.cooldown > 0 ? `Cooldown: ${ability.cooldown} turns` : 'No cooldown';
                        
                        // Get detailed scaling information with formula
                        const detailedScaling = this.getDetailedScalingText(ability, hero);
                        
                        const tooltipContent = `
                            <div class="tooltip-title">${ability.name}</div>
                            <div>${ability.description}</div>
                            <div class="tooltip-content">
                                ${detailedScaling.damageText}
                                <div>${cooldownText}</div>
                                <div>Type: ${ability.damageType || (ability.isHealing ? 'Healing' : 'Damage')}</div>
                                <div>${detailedScaling.scalingText}</div>
                            </div>
                        `;
                        
                        window.tooltipManager.addTooltip(abilityBox, tooltipContent);
                        abilityBox.classList.add('has-tooltip');
                    }
                });
            }
            
            // Update advantages section
            const advantagesList = detailHero.querySelector('.advantage-list');
            if (advantagesList) {
                let advantageHTML = '';
                let tooltipContent = `<div class="tooltip-title">Type Advantages</div><div class="tooltip-content">`;

                // Update type advantages based on hero type
                switch (hero.type) {
                    case 'fire':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.nature}">Nature</span>`;
                        tooltipContent += 'Fire does 50% more damage to Nature types.<br>Fire takes 50% more damage from Water types.';
                        break;
                    case 'water':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.fire}">Fire</span>`;
                        tooltipContent += 'Water does 50% more damage to Fire types.<br>Water takes 50% more damage from Nature types.';
                        break;
                    case 'nature':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.water}">Water</span>`;
                        tooltipContent += 'Nature does 50% more damage to Water types.<br>Nature takes 50% more damage from Fire types.';
                        break;
                    case 'light':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.dark}">Dark</span>`;
                        tooltipContent += 'Light does 50% more damage to Dark types.<br>Light takes 50% more damage from Dark types.';
                        break;
                    case 'dark':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.light}">Light</span>`;
                        tooltipContent += 'Dark does 50% more damage to Light types.<br>Dark takes 50% more damage from Light types.';
                        break;
                    case 'air':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.earth || '#8B4513'}">Earth</span>`;
                        tooltipContent += 'Air does 50% more damage to Earth types.<br>Air takes 50% more damage from Electric types.';
                        break;
                }
                
                tooltipContent += '</div>';
                advantagesList.innerHTML = advantageHTML;
                
                // Update tooltip for advantages section
                if (window.tooltipManager) {
                    window.tooltipManager.addTooltip(advantagesList, tooltipContent);
                    if (!advantagesList.classList.contains('has-tooltip')) {
                        advantagesList.classList.add('has-tooltip');
                    }
                }
            }
        
        } finally {
            // Re-enable the observer when done
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }

    /**
     * Render battle mode options
     */
    renderBattleModes() {
        const battleModes = document.getElementById('battle-modes');
        battleModes.innerHTML = '';

        const modes = [
            {
                id: 'random',
                name: 'Random Opponent',
                description: 'Battle against a randomly generated team'
            },
            {
                id: 'custom',
                name: 'Custom Battle',
                description: 'Choose your opponent\'s team composition'
            },
            {
                id: 'campaign',
                name: 'Campaign Mode',
                description: 'Fight through increasingly difficult encounters'
            }
        ];

        modes.forEach(mode => {
            const modeElement = document.createElement('div');
            
            // Add special class for custom mode when selecting enemy team
            let selectedClass = mode.id === this.battleMode ? 'selected' : '';
            if (mode.id === 'custom' && this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                selectedClass = 'selected enemy-selection-active';
            }
            
            modeElement.className = `battle-mode ${selectedClass}`;
            modeElement.dataset.modeId = mode.id;

            const modeName = document.createElement('div');
            modeName.className = 'battle-mode-name';
            modeName.textContent = mode.name;
            
            // Add indicator for enemy team selection
            if (mode.id === 'custom' && this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                modeName.innerHTML = `${mode.name} <span style="color: #ff4757; font-size: 12px;">(Selecting Enemy)</span>`;
            }

            const modeDesc = document.createElement('div');
            modeDesc.className = 'battle-mode-desc';
            modeDesc.textContent = mode.description;

            modeElement.appendChild(modeName);
            modeElement.appendChild(modeDesc);
            battleModes.appendChild(modeElement);

            // Add event listener
            modeElement.addEventListener('click', () => {
                // Only allow changing battle mode if not in enemy selection mode
                if (!this.isSelectingEnemyTeam || mode.id === this.battleMode) {
                    this.battleMode = mode.id;
                    this.renderBattleModes();
                    
                    // Reset enemy selection when changing modes
                    if (this.isSelectingEnemyTeam && mode.id !== 'custom') {
                        this.isSelectingEnemyTeam = false;
                        this.renderTeamSlots();
                    }
                } else {
                    // If in enemy selection, show a message that they should complete or cancel enemy selection first
                    if (window.soundManager) {
                        window.soundManager.play('error');
                    }
                    alert('Please complete enemy team selection or click "Back to Your Team" before changing battle mode');
                }
            });
        });
    }

    /**
     * Update the start battle button state
     */
    updateStartBattleButton() {
        const startButton = document.getElementById('start-battle');
        const hasTeamMembers = this.selectedHeroes.some(hero => hero !== null);
        
        // For Custom Battle mode, we need to check if we're ready to select enemy team
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // If we have team members but haven't begun enemy team selection
            if (hasTeamMembers) {
                startButton.textContent = 'Choose Enemy Team';
                startButton.disabled = false;
            } else {
                startButton.textContent = 'Start Battle';
                startButton.disabled = true;
            }
        } else {
            // For Random and Campaign modes, or if we're already selecting enemy team
            startButton.textContent = 'Start Battle';
            
            if (this.isSelectingEnemyTeam) {
                // When selecting enemy team, we need at least one enemy
                startButton.disabled = !this.enemySelectedHeroes.some(hero => hero !== null);
            } else {
                // For Random or Campaign, just check player team
                startButton.disabled = !hasTeamMembers;
            }
        }
    }

    /**
     * Helper function to create a stat box
     * @param {string} label - Stat label
     * @param {number} value - Stat value
     * @param {string} tooltip - Tooltip text
     * @returns {HTMLElement} The stat box element
     */
    createStatBox(label, value, tooltip) {
        const statBox = document.createElement('div');
        statBox.className = 'stat-box';
        statBox.style.flex = '1';
        statBox.style.padding = '5px';
        statBox.style.backgroundColor = '#1e272e';
        statBox.style.borderRadius = '5px';
        statBox.style.textAlign = 'center';

        const statLabel = document.createElement('div');
        statLabel.className = 'stat-label';
        statLabel.textContent = label;

        const statValue = document.createElement('div');
        statValue.className = 'stat-value';
        statValue.textContent = value;

        statBox.appendChild(statLabel);
        statBox.appendChild(statValue);

        // Add tooltip if provided
        if (tooltip && window.tooltipManager) {
            window.tooltipManager.addTooltip(statBox, tooltip);
            statBox.classList.add('has-tooltip');
        }

        return statBox;
    }

    /**
     * Calculate team synergies
     * @returns {string[]} An array of synergy descriptions
     */
    calculateSynergies() {
        const heroes = this.selectedHeroes.filter(hero => hero !== null);
        if (heroes.length < 2) return [];

        const types = heroes.map(hero => hero.type);
        const roles = heroes.map(hero => hero.role);
        
        const typeCounts = {};
        types.forEach(type => {
            typeCounts[type] = (typeCounts[type] || 0) + 1;
        });
        
        const roleCounts = {};
        roles.forEach(role => {
            roleCounts[role] = (roleCounts[role] || 0) + 1;
        });
        
        const synergies = [];
        
        // Check for type synergies
        Object.entries(typeCounts).forEach(([type, count]) => {
            if (count >= 2) {
                synergies.push(`${type.charAt(0).toUpperCase() + type.slice(1)} Alliance (${count}): +${count * 10}% ${type} damage`);
            }
        });
        
        // Check for role synergies
        if (roleCounts['Warrior'] >= 2) synergies.push('Warrior (2): +20% defense');
        if (roleCounts['Mage'] >= 2) synergies.push('Mage (2): +20% ability power');
        if (roleCounts['Ranger'] >= 2) synergies.push('Ranger (2): +15% attack speed');
        if (roleCounts['Knight'] >= 2) synergies.push('Knight (2): +25% max health');
        if (roleCounts['Assassin'] >= 2) synergies.push('Assassin (2): +30% critical hit chance');
        if (roleCounts['Cleric'] >= 2) synergies.push('Cleric (2): +40% healing effectiveness');
        
        return synergies;
    }

    /**
     * Select a hero to view details
     * @param {Object} hero - The hero to select
     */
    selectHeroDetails(hero) {
        // Disable observer during hero selection to prevent excessive log messages
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            this.selectedHeroDetails = hero;
            this.renderHeroGrid();
            this.renderHeroDetails();
            this.renderTeamSlots();
            
            // Play select sound
            if (window.soundManager) {
                window.soundManager.play('select');
            }
        } finally {
            // Re-enable observer when done
            // Note: this is redundant with the one in renderHeroDetails, but ensures
            // it happens even if renderHeroDetails fails
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }

    /**
     * Add the selected hero to a team slot
     * @param {number} position - The slot position (0-2)
     */
    addHeroToTeam(position) {
        if (!this.selectedHeroDetails) return;
        
        // Determine which team we're modifying
        const targetTeam = this.isSelectingEnemyTeam ? this.enemySelectedHeroes : this.selectedHeroes;

        // Check if hero is already in team
        const existingIndex = targetTeam.findIndex(h => h && h.id === this.selectedHeroDetails.id);
        if (existingIndex !== -1) {
            targetTeam[existingIndex] = null;
        }

        // Update the correct team
        if (this.isSelectingEnemyTeam) {
            this.enemySelectedHeroes[position] = this.selectedHeroDetails;
        } else {
            this.selectedHeroes[position] = this.selectedHeroDetails;
        }
        
        this.renderTeamSlots();
        
        // Play add sound
        if (window.soundManager) {
            window.soundManager.play('add');
        }
    }

    /**
     * Remove a hero from a team slot
     * @param {number} position - The slot position (0-2)
     */
    removeHeroFromTeam(position) {
        // Remove from the appropriate team
        if (this.isSelectingEnemyTeam) {
            this.enemySelectedHeroes[position] = null;
        } else {
            this.selectedHeroes[position] = null;
        }
        
        this.renderTeamSlots();
        
        // Play remove sound
        if (window.soundManager) {
            window.soundManager.play('remove');
        }
    }

    /**
     * Initialize event listeners for the start battle button
     */
    setupEventListeners() {
        const startButton = document.getElementById('start-battle');
        startButton.addEventListener('click', () => {
            if (!startButton.disabled) {
                this.startBattle();
            }
        });
    }
    
    /**
     * Initialize the character art image loader
     */
    async initializeImageLoader() {
        try {
            // Check if window.TeamBuilderImageLoader is available (using window explicitly)
            if (typeof window.TeamBuilderImageLoader === 'undefined') {
                console.warn('TeamBuilderImageLoader not found, skipping image loading');
                return;
            }
            
            // Create the image loader
            this.imageLoader = new window.TeamBuilderImageLoader();
            
            // Initialize it
            await this.imageLoader.initialize();
            
            console.log('TeamBuilderUI: Image loader initialized');
        } catch (error) {
            console.error('Error initializing image loader:', error);
        }
    }

    /**
     * Start a battle with the selected team
     */
    startBattle() {
        // For Custom Battle mode, we need to switch to enemy team selection if not done yet
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // Filter out empty slots
            const team = this.selectedHeroes.filter(hero => hero !== null);
            
            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }
            
            // Switch to enemy team selection mode
            this.isSelectingEnemyTeam = true;
            this.renderTeamSlots();
            this.updateStartBattleButton();
            
            // Play selection sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
            
            return; // Exit without starting battle
        }
        
        // Filter out empty slots
        const team = this.selectedHeroes.filter(hero => hero !== null);
        
        if (team.length === 0) {
            alert('Please select at least one hero for your team!');
            // Play error sound
            if (window.soundManager) {
                window.soundManager.play('error');
            }
            return;
        }
        
        // Play battle start sound
        if (window.soundManager) {
            window.soundManager.play('battle_start');
        }

        console.log('Starting battle with team:', team);
        console.log('Battle mode:', this.battleMode);

        // Remove any existing battle UI elements
        const existingBattleUI = document.getElementById('battle-ui');
        if (existingBattleUI) {
            document.body.removeChild(existingBattleUI);
        }
        
        // Switch to battle scene
        document.getElementById('team-builder-container').classList.remove('active');
        
        // Clear the game container and make it active
        const gameContainer = document.getElementById('game-container');
        gameContainer.innerHTML = ''; // Clear any previous content
        gameContainer.classList.add('active');

        // Initialize the battle manager and start the battle
        if (this.teamManager) {
            this.teamManager.setPlayerTeam(team);
            
            // For Custom battle, use the selected enemy team
            if (this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                const enemyTeam = this.enemySelectedHeroes.filter(hero => hero !== null);
                if (enemyTeam.length > 0) {
                    this.teamManager.setCustomEnemyTeam(enemyTeam);
                } else {
                    // Fallback if somehow no enemies were selected
                    this.teamManager.generateEnemyTeam('random');
                }
            } else {
                // For other modes, generate enemy team as usual
                this.teamManager.generateEnemyTeam(this.battleMode);
            }
            
            // Start the battle with our teams
            if (window.battleManager) {
                // We need to ensure BattleUI is available before starting the battle
                if (typeof window.BattleUI === 'undefined') {
                    console.error('BattleUI class not found, attempting to load it');
                    
                    // Dynamically load the BattleUI script
                    const loadBattleUI = new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'js/ui/BattleUI.js';
                        script.onload = () => {
                            console.log('BattleUI script loaded successfully');
                            resolve();
                        };
                        script.onerror = () => {
                            console.error('Failed to load BattleUI script');
                            reject(new Error('Failed to load BattleUI script'));
                        };
                        document.head.appendChild(script);
                    });
                    
                    // Try to load the script before continuing
                    loadBattleUI.then(() => {
                        this.startBattleWithDelay();
                    }).catch(error => {
                        console.error('Error loading BattleUI:', error);
                        alert('Failed to load battle system. Please refresh and try again.');
                    });
                    
                    return; // Exit and wait for script to load
                }
                
                // BattleUI is available, proceed with starting the battle
                this.startBattleWithDelay();
            }
        }
    }

    /**
     * Get ordinal suffix for a number
     * @param {number} n - The number
     * @returns {string} The ordinal suffix (st, nd, rd, th)
     */
    getOrdinalSuffix(n) {
        const s = ['th', 'st', 'nd', 'rd'];
        const v = n % 100;
        return (s[(v - 20) % 10] || s[v] || s[0]);
    }
    
    /**
     * Start the battle with a delay to ensure scripts are loaded
     */
    startBattleWithDelay() {
        // Make sure the battleManager is initialized with BattleUI
        setTimeout(() => {
            try {
                // Initialize BattleUI first if needed
                if (!window.battleManager.battleUI) {
                    window.battleManager.initialize();
                }
                
                // Then start the battle
                window.battleManager.startBattle(
                    this.teamManager.playerTeam,
                    this.teamManager.enemyTeam
                );
            } catch (error) {
                console.error('Error starting battle:', error);
                alert('Error starting battle. See console for details.');
            }
        }, 500); // Increased delay to ensure script loading
    }
}


===== FILE: TeamBuilderUIUpdates.js =====
/**
 * TeamBuilderUIUpdates.js
 * Updates to the TeamBuilderUI class to support Phaser Battle Scene transition
 *
 * @version 0.5.0.3 (with added diagnostics)
 */

// Wait for DOM content to be loaded
document.addEventListener('DOMContentLoaded', function() {
    // Check if TeamBuilderUI exists
    if (typeof TeamBuilderUI !== 'function') {
        console.error('TeamBuilderUIUpdates: TeamBuilderUI class not found!');
        return;
    }

    /**
     * Start a battle with Phaser instead of DOM-based battle UI
     * @param {Array} team - The player's team
     * @param {string} battleMode - The battle mode (random, custom, campaign)
     */
    TeamBuilderUI.prototype.startBattleWithPhaser = async function(team, battleMode) {

        // --- BEGIN DIAGNOSTIC LOGS ---
        console.log(`[DEBUG] startBattleWithPhaser called at ${new Date().toLocaleTimeString()}`);
        console.log(`[DEBUG] window.game exists? `, !!window.game);
        if (window.game) {
            console.log(`[DEBUG] window.game.isRunning? `, window.game.isRunning); // Check if Phaser game loop is running
            console.log(`[DEBUG] window.game.scene exists? `, !!window.game.scene); // Check if scene manager exists
            if (window.game.scene) {
                 // Use Object.keys on the keys object provided by Phaser's scene manager
                 console.log(`[DEBUG] Scene keys known to Phaser: `, Object.keys(window.game.scene.keys));
                 // Check if the key 'BattleScene' exists within the keys object
                 console.log(`[DEBUG] BattleScene registered? `, window.game.scene.keys.hasOwnProperty('BattleScene'));
                 // Attempt to retrieve the scene instance; will be null if not added or inactive
                 console.log(`[DEBUG] Attempting to get BattleScene instance: `, window.game.scene.getScene('BattleScene'));
            } else {
                console.error("[DEBUG] window.game.scene is NOT defined!");
            }
        } else {
             console.error("[DEBUG] window.game is NOT defined when startBattleWithPhaser is called!");
        }
        // Log the data *before* preparing it, ensuring window.battleManager is checked
        console.log(`[DEBUG] Battle data prerequisites:`, { team, battleMode, battleManager: window.battleManager });
        // --- END DIAGNOSTIC LOGS ---


        try {
            // If no team is provided, use the selected heroes
            if (!team) {
                team = this.selectedHeroes.filter(hero => hero !== null);
            }

            // If no battle mode is provided, use the current mode
            if (!battleMode) {
                battleMode = this.battleMode;
            }

            console.log('Starting Phaser battle with team:', team);
            console.log('Battle mode:', battleMode);

            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }

            // Play battle start sound
            if (window.soundManager) {
                window.soundManager.play('battle_start');
            }

            // Initialize the team manager
            if (this.teamManager) {
                this.teamManager.setPlayerTeam(team);

                // For Custom battle, use the selected enemy team
                let teamGenerationPromise;
                if (battleMode === 'custom' && this.isSelectingEnemyTeam) {
                    const enemyTeam = this.enemySelectedHeroes.filter(hero => hero !== null);
                    if (enemyTeam.length > 0) {
                        this.teamManager.setCustomEnemyTeam(enemyTeam);
                        teamGenerationPromise = Promise.resolve(); // No async work needed
                    } else {
                        // Fallback if somehow no enemies were selected
                        teamGenerationPromise = this.teamManager.generateEnemyTeam('random');
                    }
                } else {
                    // For other modes, generate enemy team as usual
                    teamGenerationPromise = this.teamManager.generateEnemyTeam(battleMode);
                }
                
                // Wait for team generation to complete before proceeding
                console.log('Waiting for enemy team generation to complete...');
                try {
                    await teamGenerationPromise;
                    console.log('Enemy team generation complete, proceeding with battle');
                } catch (error) {
                    console.error('Error during enemy team generation:', error);
                    alert('Error generating enemy team. Please try again.');
                    return;
                }

                // Check if Phaser is properly initialized using the utility function
                if (!window.isPhaserReady || !window.isPhaserReady()) {
                    console.error('Phaser game or scene manager not ready, falling back to original battle UI');
                    // Fallback to old battle UI, but only if not already in a fallback loop
                    if (!this._fallingBack) {
                        this._fallingBack = true;
                        this.startBattleWithOriginalUI(team, battleMode);
                        setTimeout(() => { this._fallingBack = false; }, 500); // Reset fallback flag after a delay
                    }
                    return;
                }

                // Hide the team builder UI
                const teamBuilderContainer = document.getElementById('team-builder-container');
                if (teamBuilderContainer) {
                    teamBuilderContainer.style.display = 'none';
                }

                // Show Phaser container
                const gameContainer = document.getElementById('game-container');
                if (gameContainer) {
                    gameContainer.style.display = 'block';
                }

                // Get Phaser canvas and ensure it's visible
                const canvas = document.querySelector('#game-container canvas'); // More specific selector
                if (canvas) {
                    canvas.style.display = 'block';
                } else {
                    console.warn("Phaser canvas element not found inside #game-container.");
                }

                // --- Ensure BattleScene is Added Before Starting ---
                if (!window.game.scene.getScene('BattleScene')) {
                     if (window.BattleScene) {
                         try {
                             window.game.scene.add('BattleScene', window.BattleScene);
                             console.log('[startBattleWithPhaser] BattleScene added dynamically.');
                         } catch (sceneAddError) {
                              console.error("Error dynamically adding BattleScene:", sceneAddError);
                              alert("Failed to prepare BattleScene. Cannot start battle.");
                              // Attempt to revert UI state
                              if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                              if (gameContainer) gameContainer.style.display = 'none';
                              return;
                         }
                     } else {
                         console.error("BattleScene class not available when trying to start battle!");
                         alert("BattleScene is not loaded. Cannot start battle.");
                          // Attempt to revert UI state
                         if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                         if (gameContainer) gameContainer.style.display = 'none';
                         return;
                     }
                 }
                 // --- End Scene Add Check ---


                try {
                    // Prepare battle data for the scene
                    const battleData = {
                        playerTeam: this.teamManager.playerTeam,
                        enemyTeam: this.teamManager.enemyTeam,
                        battleMode: battleMode,
                        battleManager: window.battleManager // Ensure this uses the correct global instance
                    };

                    // Check battleManager just before starting scene
                    if(!battleData.battleManager) {
                        console.error("CRITICAL: battleManager is undefined just before starting BattleScene!");
                        alert("Battle logic manager is missing. Cannot start battle.");
                         // Attempt to revert UI state
                         if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                         if (gameContainer) gameContainer.style.display = 'none';
                        return;
                    }

                    // Implement polling mechanism to wait for scene to be fully registered
                    const checkSceneReadyAndStart = (sceneKey, data, maxAttempts = 20, attempt = 1) => {
                        const sceneInstance = window.game.scene.getScene(sceneKey);
                        // Also check if the key is known, as getScene might return null even if added but not fully ready
                        const sceneKeyExists = window.game.scene.keys.hasOwnProperty(sceneKey); 

                        if (sceneInstance && sceneKeyExists) {
                            console.log(`[DEBUG] BattleScene is ready on attempt ${attempt}. Starting scene...`);
                            try {
                                window.game.scene.start(sceneKey, data);
                                console.log('Phaser BattleScene started successfully via check.');
                            } catch (startError) {
                                console.error(`[DEBUG] Error during scene.start('${sceneKey}'):`, startError);
                                alert(`Failed to start BattleScene even after it seemed ready. Error: ${startError.message}`);
                                // Revert UI state
                                if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                                if (gameContainer) gameContainer.style.display = 'none';
                            }
                        } else if (attempt < maxAttempts) {
                            console.log(`[DEBUG] BattleScene not ready yet (Attempt ${attempt}/${maxAttempts}). Waiting 100ms...`);
                            setTimeout(() => checkSceneReadyAndStart(sceneKey, data, maxAttempts, attempt + 1), 100);
                        } else {
                            console.error(`[DEBUG] BattleScene failed to become ready after ${maxAttempts} attempts.`);
                            alert("Error: Battle scene did not become ready in time. Cannot start battle.");
                            // Revert UI state
                            if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                            if (gameContainer) gameContainer.style.display = 'none';
                        }
                    };

                    // Use the polling check instead of directly starting the scene
                    checkSceneReadyAndStart('BattleScene', battleData);
                    console.log('Initiated polling for BattleScene readiness');

                } catch (error) {
                    console.error('Error starting Phaser BattleScene:', error);
                    // Show error message to user
                    alert('There was an error starting the battle. Falling back to original battle UI.');

                    // Fallback to old battle UI
                    if (!this._fallingBack) {
                        this._fallingBack = true;
                        this.startBattleWithOriginalUI(team, battleMode);
                        setTimeout(() => { this._fallingBack = false; }, 500);
                    }
                }
            } else {
                 console.error("TeamManager not available in startBattleWithPhaser!");
                 alert("Team Manager error. Cannot start battle.");
            }
        } catch (error) {
            console.error('Error in startBattleWithPhaser:', error);
            // Attempt emergency fallback to original battle UI
            if (!this._fallingBack) {
                this._fallingBack = true;
                 // Ensure team is defined for fallback
                 const fallbackTeam = team || this.selectedHeroes.filter(hero => hero !== null);
                 const fallbackMode = battleMode || this.battleMode;
                this.startBattleWithOriginalUI(fallbackTeam, fallbackMode);
                setTimeout(() => { this._fallingBack = false; }, 500);
            }
        }
    };

    /**
     * Start a battle with the original DOM-based battle UI
     * This is used as a fallback when Phaser initialization fails
     * @param {Array} team - The player's team
     * @param {string} battleMode - The battle mode (random, custom, campaign)
     */
    TeamBuilderUI.prototype.startBattleWithOriginalUI = function(team, battleMode) {
        // Use the original startBattle method that was saved
        if (typeof this.startBattleOriginal === 'function') {
            console.log('Falling back to original battle UI');
            // Call the original function which handles its own logic
            this.startBattleOriginal();
        } else {
            console.error('Original startBattle method not found, cannot fallback');
            // Show error message to user
            alert('There was an error starting the battle. Please refresh the page and try again.');
        }
    };

    /**
     * Handle return from Phaser battle scene
     */
    TeamBuilderUI.prototype.onReturnFromPhaserBattle = function() {
        try {
            console.log('Returned from Phaser battle');

            // Show the team builder UI
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) {
                teamBuilderContainer.style.display = 'block'; // Or 'flex', check your CSS
            }

            // Hide Phaser container
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.style.display = 'none';
            }

            // Hide canvas specifically
            const canvas = document.querySelector('#game-container canvas');
            if (canvas) {
                canvas.style.display = 'none';
            }

            // Reset enemy team selection if needed
            if (this.isSelectingEnemyTeam) {
                this.isSelectingEnemyTeam = false;
                this.renderTeamSlots();
            }

            // Update battle modes display
            this.renderBattleModes();

            // Play UI sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
        } catch (error) {
            console.error('Error in onReturnFromPhaserBattle:', error);
            // Try showing the team builder UI anyway as a fallback
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if(teamBuilderContainer) teamBuilderContainer.style.display = 'block'; // Or 'flex'
        }
    };

    /**
     * Legacy method name for backward compatibility
     */
    TeamBuilderUI.prototype.onReturnFromBattle = TeamBuilderUI.prototype.onReturnFromPhaserBattle;

    /**
     * Override the original startBattle to use Phaser version
     * Original method will be kept as fallback
     */
    // Ensure startBattleOriginal actually exists before trying to assign it
    if (typeof TeamBuilderUI.prototype.startBattle === 'function') {
         TeamBuilderUI.prototype.startBattleOriginal = TeamBuilderUI.prototype.startBattle;
    } else {
         console.error("Original TeamBuilderUI.prototype.startBattle not found for backup!");
         // Define a dummy original if needed to prevent errors later, though this indicates a bigger problem
         TeamBuilderUI.prototype.startBattleOriginal = function() { console.error("startBattleOriginal fallback called - original missing!"); };
    }


    TeamBuilderUI.prototype.startBattle = async function() {
        // For Custom Battle mode, we need to switch to enemy team selection if not done yet
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // Filter out empty slots
            const team = this.selectedHeroes.filter(hero => hero !== null);

            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }

            // Switch to enemy team selection mode
            this.isSelectingEnemyTeam = true;
            this.renderTeamSlots();
            this.updateStartBattleButton();

            // Play selection sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }

            return; // Exit without starting battle
        }

        // Get the selected team
        const team = this.selectedHeroes.filter(hero => hero !== null);

        // Check if we should use Phaser battle scene or fallback to original
        const usePhaser = true; // Set to true to always use Phaser, false to use original

        if (usePhaser) {
            // Call the Phaser-specific method
            await this.startBattleWithPhaser(team, this.battleMode);
        } else {
            // Call the original DOM-based method (if it was correctly backed up)
             if (typeof this.startBattleOriginal === 'function') {
                 this.startBattleOriginal();
             } else {
                  console.error("Cannot call original startBattle - backup failed.");
                  alert("Error initiating battle.");
             }
        }
    };

    console.log('TeamBuilderUIUpdates: Successfully added methods and diagnostics to TeamBuilderUI prototype');
});

===== FILE: TooltipManager.js =====
/**
 * Tooltip Manager
 * Manages tooltip display for UI elements
 */

class TooltipManager {
    /**
     * Create a new Tooltip Manager
     */
    constructor() {
        this.tooltip = null;
        this.initialize();
    }

    /**
     * Initialize the tooltip element
     */
    initialize() {
        // Create tooltip element if it doesn't exist
        if (!this.tooltip) {
            this.tooltip = document.createElement('div');
            this.tooltip.className = 'tooltip';
            this.tooltip.style.display = 'none';
            document.body.appendChild(this.tooltip);

            // Add mousemove event to move tooltip with cursor
            document.addEventListener('mousemove', (e) => {
                if (this.tooltip.style.display === 'block') {
                    const offset = 15; // Distance from cursor
                    
                    // Position tooltip based on cursor position
                    this.tooltip.style.left = (e.pageX + offset) + 'px';

                    // Make sure tooltip doesn't go off-screen
                    const tooltipRect = this.tooltip.getBoundingClientRect();
                    if (e.pageY + offset + tooltipRect.height > window.innerHeight) {
                        this.tooltip.style.top = (e.pageY - tooltipRect.height - offset) + 'px';
                    } else {
                        this.tooltip.style.top = (e.pageY + offset) + 'px';
                    }
                }
            });
        }
    }

    /**
     * Show tooltip with content
     * @param {string} content - HTML content for the tooltip
     */
    show(content) {
        this.tooltip.innerHTML = content;
        this.tooltip.style.display = 'block';
    }

    /**
     * Hide tooltip
     */
    hide() {
        this.tooltip.style.display = 'none';
    }

    /**
     * Add tooltip to an element
     * @param {HTMLElement} element - Element to add tooltip to
     * @param {string|Function} content - Content for tooltip or function returning content
     */
    addTooltip(element, content) {
        element.addEventListener('mouseenter', () => {
            const tooltipContent = typeof content === 'function' ? content() : content;
            this.show(tooltipContent);
        });

        element.addEventListener('mouseleave', () => {
            this.hide();
        });
    }
}

// Create a singleton instance
const tooltipManager = new TooltipManager();

// Make it available globally
window.tooltipManager = tooltipManager;


===== FILE: DirectImageLoader.js =====
/**
 * DirectImageLoader.js
 * A special utility to load character images directly from the file system
 * This ensures the image gets loaded even when relative paths aren't working
 */

window.DirectImageLoader = {
    // Base paths to try in order
    basePaths: [
        '',
        '/',
        './',
        '../',
        '../../'
    ],
    
    // Character image lookup table
    characterImages: {
        'Aqualia': 'assets/images/Character Art/Aqualia.png',
        'Drakarion': 'assets/images/Character Art/Drakarion.png',
        'Zephyr': 'assets/images/Character Art/Zephyr.png',
        'Lumina': 'assets/images/Character Art/Lumina.png',
        'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
        'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
        'Caste': 'assets/images/Character Art/Caste.png'
    },
    
    // Store characters data globally
    charactersData: null,
    
    /**
     * Load characters data from JSON
     */
    loadCharactersData: async function() {
        try {
            const response = await fetch('data/characters.json');
            const data = await response.json();
            this.charactersData = data.characters;
            console.log('DirectImageLoader: Loaded characters data', this.charactersData);
        } catch (err) {
            console.error('DirectImageLoader: Failed to load characters.json', err);
        }
    },
    
    /**
     * Get an image element for a character
     * @param {string} characterName - The name of the character
     * @returns {HTMLImageElement} - Image element with the character art
     */
    getCharacterImage: function(characterName) {
        if (!this.characterImages[characterName]) {
            console.error(`No image path defined for character: ${characterName}`);
            return null;
        }
        
        const img = new Image();
        const imagePath = this.characterImages[characterName];
        
        // For debugging, track when the image loads or fails
        img.onload = () => console.log(`SUCCESS: Loaded character image for ${characterName} from ${img.src}`);
        img.onerror = () => console.error(`FAILED: Could not load character image for ${characterName} from ${img.src}`);
        
        // Set the source directly
        img.src = imagePath;
        
        return img;
    },
    
    /**
     * Insert character images directly into the DOM, replacing placeholders
     * This is called automatically when the page loads
     */
    injectCharacterImages: function() {
        // Check if we're in a battle screen
        const battleUI = document.getElementById('battle-ui');
        if (!battleUI) return;
        
        // SKIP if there's any active animation in progress
        const activeAnimations = document.querySelectorAll('.character-moving, [id^="clone-"]');
        if (activeAnimations.length > 0) {
            console.log('DirectImageLoader: Skipping image injection during active animation');
            return;
        }
        
        console.log('DirectImageLoader: Checking for character circles to replace with images');
        
        // Look for characters that should have images
        Object.keys(this.characterImages).forEach(characterName => {
            // Look for character elements with this name
            document.querySelectorAll('.character-circle').forEach(circle => {
                // SKIP if this circle is already part of an animation clone
                if (circle.closest('[id^="clone-"]')) return;
                
                // SKIP if circle already has art to avoid redundant processing
                if (circle.querySelector('.character-art')) return;
                
                // SKIP if circle has the artLoaded attribute
                if (circle.dataset.artLoaded === 'true') return;
                
                // Check if this is a container for the character we're looking for
                const container = circle.closest('.flex.flex-col');
                if (!container) return;
                
                const nameElement = container.querySelector('.text-sm.font-semibold');
                if (!nameElement || nameElement.textContent !== characterName) return;
                
                // Get character ID from the circle ID if available
                const circleId = circle.id;
                let characterId = null;
                let teamInfo = null;
                
                if (circleId) {
                    const idMatch = circleId.match(/character-(player|enemy)_(\d+)/);
                    if (idMatch) {
                        teamInfo = idMatch[1]; // 'player' or 'enemy'
                        characterId = idMatch[2]; // numeric ID
                    }
                }
                
                console.log(`Found ${characterName} element (${teamInfo}_${characterId}), injecting image`);
                
                // Set up the container for images
                circle.classList.add('character-art-container');
                circle.style.backgroundColor = 'transparent'; // Changed to transparent
                circle.style.boxShadow = 'none'; // Removed shadow
                
                // Mark this circle as having art loaded
                circle.dataset.artLoaded = 'true';
                circle.dataset.characterName = characterName;
                if (characterId) circle.dataset.characterId = characterId;
                if (teamInfo) circle.dataset.team = teamInfo;
                
                // Check for cached image in the global cache
                let img;
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[characterName]) {
                    console.log(`Using cached image for ${characterName}`);
                    img = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                } else {
                    // Create a new image if no cache available
                    img = new Image();
                    img.src = this.characterImages[characterName];
                    
                    // Add to global cache for future use
                    if (!window.CHARACTER_IMAGE_CACHE) window.CHARACTER_IMAGE_CACHE = {};
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                }
                
                img.className = 'character-art';
                img.alt = characterName;
                img.dataset.characterName = characterName;
                if (characterId) img.dataset.characterId = characterId;
                if (teamInfo) img.dataset.team = teamInfo;
                
                img.style.width = '80px';
                img.style.height = '120px';
                img.style.objectFit = 'contain';
                img.style.position = 'absolute';
                
                // Look for custom art positioning in the characters data
                let customPositioning = false;
                if (this.charactersData) {
                    // Try to find the character data
                    const characterData = this.charactersData.find(c => c.name === characterName);
                    if (characterData && characterData.art) {
                        console.log(`Found custom art settings for ${characterName}`, characterData.art);
                        // Apply custom positioning
                        if (characterData.art.top) {
                            img.style.top = characterData.art.top;
                            img.dataset.originalTop = characterData.art.top; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.left) {
                            img.style.left = characterData.art.left;
                            img.dataset.originalLeft = characterData.art.left; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.width) img.style.width = characterData.art.width;
                        if (characterData.art.height) img.style.height = characterData.art.height;
                    }
                }
                
                // Use default positioning only if no custom positioning found
                if (!customPositioning) {
                    img.style.top = '-52px';
                    img.dataset.originalTop = '-52px';
                    img.style.left = '-2px';
                    img.dataset.originalLeft = '-2px';
                }
                
                img.style.zIndex = '10';
                img.style.pointerEvents = 'none';
                
                // Empty the text and add the image
                circle.textContent = '';
                circle.appendChild(img);
            });
        });
    }
};

// Global flag to disable DirectImageLoader during animations
window.disableDirectImageLoader = false;

// Run image injector when DOM is ready
window.addEventListener('load', async function() {
    // Load character data first
    await window.DirectImageLoader.loadCharactersData();
    
    // Wait a bit for battle UI to initialize
    setTimeout(() => {
        window.DirectImageLoader.injectCharacterImages();
    }, 1000);
    
    // Also check periodically for new characters that might appear
    // Use a longer interval (reduced from 3000ms to 5000ms) and check the disable flag
    let intervalId = setInterval(() => {
        if (window.disableDirectImageLoader) {
            console.log('DirectImageLoader: Skipping periodic check (disabled)');
            return;
        }
        window.DirectImageLoader.injectCharacterImages();
    }, 5000);
    
    // Store the interval ID in the DirectImageLoader object
    window.DirectImageLoader.intervalId = intervalId;
});

// Add utility function to temporarily disable the DirectImageLoader during animations
window.disableDirectImageLoaderDuringAnimation = function() {
    window.disableDirectImageLoader = true;
    console.log('DirectImageLoader: Disabled during animation');
    
    // Re-enable after a short delay
    setTimeout(() => {
        window.disableDirectImageLoader = false;
        console.log('DirectImageLoader: Re-enabled after animation');
    }, 2000); // 2 seconds should cover most animations
};

console.log('DirectImageLoader initialized for character art');


===== FILE: ImageDebugger.js =====
/**
 * ImageDebugger.js
 * Utility for debugging image loading issues in the game
 * Debug button removed as character art implementation is now stable
 */


window.ImageDebugger = {
    /**
     * Test loading an image from various paths
     * @param {string} imageName - Base name of the image file (e.g., "Aqualia.png")
     * @returns {Promise<string>} - Promise resolving to the working path or error message
     */
    testImagePaths: async function(imageName) {
        // Set up possible paths to test
        const paths = [
            `./assets/images/Character Art/${imageName}`,
            `/assets/images/Character Art/${imageName}`,
            `assets/images/Character Art/${imageName}`,
            `../assets/images/Character Art/${imageName}`,
            `C:/Personal/AutoBattler/assets/images/Character Art/${imageName}`,
            `../../assets/images/Character Art/${imageName}`
        ];
        
        const results = {};
        
        // Create a div to display loading status in the UI
        const debugDiv = document.createElement('div');
        debugDiv.style.position = 'fixed';
        debugDiv.style.top = '10px';
        debugDiv.style.right = '10px';
        debugDiv.style.backgroundColor = 'rgba(0,0,0,0.8)';
        debugDiv.style.color = 'white';
        debugDiv.style.padding = '10px';
        debugDiv.style.zIndex = '9999';
        debugDiv.style.maxWidth = '400px';
        debugDiv.style.maxHeight = '400px';
        debugDiv.style.overflow = 'auto';
        debugDiv.style.fontFamily = 'monospace';
        debugDiv.style.fontSize = '12px';
        debugDiv.innerHTML = '<h3>Image Path Testing</h3>';
        document.body.appendChild(debugDiv);
        
        // Test each path
        for (const path of paths) {
            const result = await this.testSinglePath(path, debugDiv);
            results[path] = result;
        }
        
        // Add a close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.marginTop = '10px';
        closeButton.style.padding = '5px 10px';
        closeButton.addEventListener('click', () => document.body.removeChild(debugDiv));
        debugDiv.appendChild(closeButton);
        
        // Return the results summary
        return results;
    },
    
    /**
     * Test loading a single image path
     * @param {string} path - Path to test
     * @param {HTMLElement} debugDiv - Debug display element
     * @returns {Promise<string>} - Promise resolving to success or error message
     */
    testSinglePath: function(path, debugDiv) {
        return new Promise((resolve) => {
            const img = new Image();
            const statusElement = document.createElement('div');
            statusElement.innerHTML = `Testing: ${path} <span style="color:yellow">â³</span>`;
            debugDiv.appendChild(statusElement);
            
            // Set a timeout for loading
            const timeout = setTimeout(() => {
                statusElement.innerHTML = `Testing: ${path} <span style="color:orange">âŒ› Timed out after 5s</span>`;
                resolve('Timed out');
            }, 5000);
            
            img.onload = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:green">âœ“ Success (${img.width}x${img.height})</span>`;
                
                // Display the image as thumbnail
                const thumb = document.createElement('img');
                thumb.src = path;
                thumb.style.width = '50px';
                thumb.style.height = '50px';
                thumb.style.objectFit = 'contain';
                thumb.style.marginLeft = '10px';
                statusElement.appendChild(thumb);
                
                resolve('Success');
            };
            
            img.onerror = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:red">âœ— Failed</span>`;
                resolve('Failed');
            };
            
            img.src = path;
        });
    },
    
    // Character-specific debug methods removed as they're no longer needed
};

// Global debug functions removed

console.log('ImageDebugger initialized - debugging UI elements removed.');


===== FILE: TeamBuilderImageLoader.js =====
/**
 * TeamBuilderImageLoader.js
 * Loads and injects character art into the Team Builder UI
 * Based on the existing DirectImageLoader.js functionality
 */

// Create a global cache for character images that persists beyond class instances
window.CHARACTER_IMAGE_CACHE = window.CHARACTER_IMAGE_CACHE || {};

class TeamBuilderImageLoader {
    constructor() {
        this.characterData = null;
        this.processedContainers = new WeakSet(); // Track processed containers to avoid reprocessing
        this.loadedCharacters = new Set(); // Track which characters already have art loaded
        this.cachedImages = new Map(); // NEW: Cache for character images to prevent flickering
        this.checkInterval = 2000; // Check every 2 seconds (reduced frequency)
        this.imageCheckTimer = null;
        this.debugMode = false; // Control logging verbosity
        this.lastProcessTime = Date.now();
        this.characterImages = {
            'Aqualia': 'assets/images/Character Art/Aqualia.png',
            'Drakarion': 'assets/images/Character Art/Drakarion.png',
            'Zephyr': 'assets/images/Character Art/Zephyr.png',
            'Lumina': 'assets/images/Character Art/Lumina.png',
            'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
            'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
            'Caste': 'assets/images/Character Art/Caste.png'
        };
    }

    /**
    * Initialize the image loader
    */
async initialize() {
    console.log('TeamBuilderImageLoader: Initializing...');
    
    // Load character data
    try {
    const response = await fetch('data/characters.json');
    this.characterData = await response.json();
    console.log('TeamBuilderImageLoader: Character data loaded');
    } catch (err) {
    console.error('TeamBuilderImageLoader: Failed to load character data', err);
    this.characterData = { characters: [] }; // Empty fallback
    }
    
    // Start periodic checking for new character elements
    this.startImageCheck();
    
    // Do an initial check with debug enabled
    setTimeout(() => {
    console.log('TeamBuilderImageLoader: Performing initial detailed check...');
    this.forceCheck(true);
    
    // Preload all character images immediately
    this.preloadCharacterImages();
    }, 1000);
}
    
    /**
     * Preload and cache all available character images
     */
    async preloadCharacterImages() {
        console.log('TeamBuilderImageLoader: Preloading all character images...');
        
        // Get all characters that have images defined
        const charactersWithArt = Object.keys(this.characterImages);
        if (charactersWithArt.length === 0) {
            console.warn('TeamBuilderImageLoader: No character images defined');
            return;
        }
        
        // Preload each character's image
        for (const characterName of charactersWithArt) {
            try {
                const imagePath = this.characterImages[characterName];
                if (!imagePath) continue;
                
                console.log(`TeamBuilderImageLoader: Preloading ${characterName}'s image...`);
                
                // Create a new image element
                const img = new Image();
                
                // Set up onload handler
                img.onload = () => {
                    // Store in global cache
                    window.CHARACTER_IMAGE_CACHE[characterName] = img;
                    console.log(`TeamBuilderImageLoader: ${characterName}'s image preloaded and stored in global cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    // Also store in instance cache
                    this.cachedImages.set(characterName, img);
                    this.loadedCharacters.add(characterName);
                };
                
                // Set the source to trigger loading
                img.src = imagePath;
            } catch (err) {
                console.error(`TeamBuilderImageLoader: Error preloading ${characterName}'s image`, err);
            }
        }
    }
    


    /**
     * Start periodically checking for character elements that need art
     */
    startImageCheck() {
        // Clear any existing timer
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
        }
        
        // Set up periodic check - just basic checking, no forced updates
        this.imageCheckTimer = setInterval(() => {
            this.checkAndLoadImages();
        }, this.checkInterval);
        
        // Run an immediate check
        this.checkAndLoadImages();
    }

    /**
     * Check for character elements and load images if needed
     */
    checkAndLoadImages() {
        // Throttle checks to prevent excessive processing
        const now = Date.now();
        if (now - this.lastProcessTime < 500) { // minimum 500ms between full checks
            return;
        }
        this.lastProcessTime = now;
        
        // Find all character containers EXCEPT the detail container
        // We now handle detail container separately to avoid observer issues
        const containers = document.querySelectorAll('.hero-avatar-container:not(.detail-icon-container)');
        
        if (this.debugMode) {
            console.log(`TeamBuilderImageLoader: Checking ${containers.length} avatar containers`);
        }
        
        // First pass: immediately hide all circles where art is available
        containers.forEach(container => {
            const characterName = container.dataset.characterName;
            if (characterName && this.characterImages[characterName]) {
                // This character has art available, immediately hide the circle
                const avatarCircle = container.querySelector('.hero-avatar, .detail-icon');
                if (avatarCircle) {
                    avatarCircle.style.display = 'none';
                    avatarCircle.style.backgroundColor = 'transparent';
                    avatarCircle.textContent = ''; // Clear any letter placeholders
                }
                
                // Add the has-art class to the container for CSS targeting
                container.classList.add('has-art');
            }
        });
        
        // Now process containers that need art
        let artLoadedInThisPass = false;
        
        containers.forEach(container => {
            // Always process detail view containers, otherwise check if already processed
            const isDetailView = container.classList.contains('detail-icon-container');
            if (!isDetailView && this.processedContainers.has(container)) {
                return;
            }
            
            const characterId = container.dataset.characterId;
            const characterName = container.dataset.characterName;
            
            // Skip if no character ID
            if (!characterId) return;
            
            // Process and load art for this character if needed
            if (this.loadCharacterArt(container, characterId, characterName)) {
                artLoadedInThisPass = true;
            }
        });
        
        // Report if we actually loaded art in this pass (helps with debugging)
        if (artLoadedInThisPass && this.debugMode) {
            console.log('TeamBuilderImageLoader: New art was loaded in this check pass');
        }
    }

    /**
     * Load art for a specific character
     * @returns {boolean} Whether new art was loaded
     */
    loadCharacterArt(container, characterId, characterName) {
        // Special handling for character details view
        const isDetailView = container.classList.contains('detail-icon-container');
        
        // If this is the detail view, always process it (even if processed before)
        // This helps ensure the art is always shown in the character details panel
        if (!isDetailView) {
            // For non-detail views, mark container as processed to avoid multiple attempts
            this.processedContainers.add(container);
        }
        
        // Check if this character has art defined
        if (!this.characterImages[characterName]) {
            if (this.debugMode) {
                console.log(`TeamBuilderImageLoader: No art defined for ${characterName}`);
            }
            
            // Don't add placeholders anymore - just return false and let containers be invisible
            return false; // No art defined
        }
        
        // Critical: If character is already loaded, just make sure container is properly styled
        if (this.loadedCharacters.has(characterName)) {
            const artWrapper = container.querySelector('.hero-art-wrapper');
            
            if (artWrapper) {
                artWrapper.style.display = 'block';
                
                // If no inner content in wrapper, we need to add the image
                // (for newly created UI elements)
                if (artWrapper.innerHTML.trim() === '') {
                    this.createAndAddArt(container, characterId, characterName, false);
                    return true; // Consider as new art being added
                }
            }
            
            return false; // No new art loaded
        }
        
        // If we get here, character needs art and hasn't been loaded yet
        return this.createAndAddArt(container, characterId, characterName, true);
    }

    /**
     * Create and add character art to a container
     * @param {HTMLElement} container - The container element
     * @param {string} characterId - Character ID
     * @param {string} characterName - Character name
     * @param {boolean} isFirstLoad - Whether this is the first time loading this character
     * @returns {boolean} Whether the art was successfully added
     */
    async createAndAddArt(container, characterId, characterName, isFirstLoad) {
        // Find character data
        const character = this.findCharacterData(characterId, characterName);
        if (!character) {
            console.log(`TeamBuilderImageLoader: Character data not found for ${characterName}`);
            return false;
        }
        
        // Check if the wrapper exists
        const artWrapper = container.querySelector('.hero-art-wrapper');
        
        if (!artWrapper) {
            console.error('TeamBuilderImageLoader: No art wrapper found for', characterName);
            return false;
        }
        
        // Try to load the image
        try {
            const imagePath = this.characterImages[characterName];
            
            // Check if we already have a cached image for this character
            let img;
            if (this.cachedImages.has(characterName)) {
                // Use the cached image data to create a new image element
                img = this.cachedImages.get(characterName).cloneNode(true);
                console.log(`TeamBuilderImageLoader: Using cached image for ${characterName}`);
            } else {
                // Load the image for the first time
                const imageExists = await this.checkImageExists(imagePath);
                
                if (!imageExists) {
                    console.log(`TeamBuilderImageLoader: No image found for ${characterName}`);
                    return false;
                }
                
                // Create a new image element
                img = document.createElement('img');
                img.src = imagePath;
                img.onload = () => {
                    // Cache the loaded image for future use
                    this.cachedImages.set(characterName, img.cloneNode(true));
                    
                    // Also store in global cache for persistent access
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                    console.log(`TeamBuilderImageLoader: Added ${characterName} to global image cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    console.log(`TeamBuilderImageLoader: Cached image for ${characterName}`);
                };
            }
            
            // Determine if this is a detail view
            const isDetailView = container.classList.contains('detail-icon-container');
            
            // Use teamBuilderArt if available, otherwise fall back to regular art
            let artSettings;
            
            if (isDetailView) {
                // For detail view, use special positioning
                artSettings = character.detailArt || character.teamBuilderArt || character.art || {};
                
                // If no specific settings, use these defaults for detail view
                if (!artSettings.left) artSettings.left = '-30px';
                if (!artSettings.top) artSettings.top = '-45px';
                if (!artSettings.width) artSettings.width = '140px';
                if (!artSettings.height) artSettings.height = '140px';
            } else {
                // Regular view
                artSettings = character.teamBuilderArt || character.art || {};
            }
            
            // Set image properties
            img.className = 'character-art team-builder-art';
            img.alt = characterName;
            
            // Apply position settings
            img.style.position = 'absolute';
            img.style.left = artSettings.left || '0px';
            img.style.top = artSettings.top || '0px';
            
            if (artSettings.width) {
                img.style.width = artSettings.width;
            }
            
            if (artSettings.height) {
                img.style.height = artSettings.height;
            }
            
            // Store original positions for animation handling
            img.dataset.originalLeft = artSettings.left || '0px';
            img.dataset.originalTop = artSettings.top || '0px';
            
            // PRESERVE EXISTING ART: Check if art already exists before replacing
            const existingArt = artWrapper.querySelector('.character-art');
            if (!existingArt) {
                // Only clear and add if there's no existing art
                artWrapper.innerHTML = '';
                artWrapper.appendChild(img);
            }
            
            artWrapper.style.display = 'block';
            
            // Set all parent elements with appropriate classes
            container.classList.add('has-art'); // Mark container as having art
            
            // Add has-art to the parent card/content element if it exists
            const heroCard = container.closest('.hero-card');
            if (heroCard) heroCard.classList.add('has-art');
            
            const slotContent = container.closest('.slot-content');
            if (slotContent) slotContent.classList.add('has-art');
            
            const detailHero = container.closest('.detail-hero');
            if (detailHero) detailHero.classList.add('has-art');
            
            // Record that we've loaded this character's art
            // This is important to avoid reloading across different containers
            this.loadedCharacters.add(characterName);
            
            // Always log for detail view to help track issues
            if (isFirstLoad || isDetailView) {
                console.log(`TeamBuilderImageLoader: Loaded art for ${characterName}${isDetailView ? ' (detail view)' : ''}`);
            }
            
            return true;
        } catch (err) {
            console.error(`TeamBuilderImageLoader: Error loading art for ${characterName}`, err);
            return false;
        }
    }

    /**
     * Find character data by ID or name
     */
    findCharacterData(id, name) {
        if (!this.characterData || !this.characterData.characters) {
            return null;
        }
        
        // Try to find by ID first
        let character = this.characterData.characters.find(c => c.id == id);
        
        // Fall back to finding by name
        if (!character && name) {
            character = this.characterData.characters.find(c => 
                c.name.toLowerCase() === name.toLowerCase()
            );
        }
        
        return character;
    }

    /**
     * Manually trigger a check for new images and reset processing cache
     * @param {boolean} debug - Enable debug output
     * @param {boolean} resetCache - Whether to reset the processed containers cache
     */
    forceCheck(debug = false, resetCache = false) {
        // Temporarily enable debug mode if requested
        const prevDebugMode = this.debugMode;
        this.debugMode = debug;
        
        if (debug) {
            console.log("TeamBuilderImageLoader: Force checking images");
        }
        
        // Reset the processed containers cache if requested
        // This will force reprocessing of all containers
        if (resetCache) {
            if (debug) {
                console.log("TeamBuilderImageLoader: Resetting processed containers cache");
            }
            this.processedContainers = new WeakSet();
            this.loadedCharacters = new Set();
        }
        
        // Check for new images
        this.checkAndLoadImages();
        
        // Restore previous debug mode
        this.debugMode = prevDebugMode;
    }

    /**
     * Check if an image exists
     */
    async checkImageExists(imagePath) {
        try {
            const response = await fetch(imagePath, { method: 'HEAD' });
            return response.ok;
        } catch (err) {
            return false;
        }
    }

    /**
     * Clean up resources
     */
    destroy() {
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
            this.imageCheckTimer = null;
        }
    }
}

// Export the class
// Create DOM observer to ensure character art is never removed
window.setupCharacterArtMutationObserver = function() {
    // First, completely disconnect any existing observer to ensure clean slate
    if (window.characterArtObserver) {
        window.characterArtObserver.disconnect();
        window.characterArtObserver = null;
        console.log('Reset existing character art observer');
    }
    
    console.log('Setting up character art mutation observer');
    
    // Static flag to completely disable observer when needed
    window.observerDisabled = false;
    
    // Throttling variable
    let throttleId = null;
    // Boolean flag to prevent re-entrance
    let isRestoring = false;
    
    // Create a mutation observer to watch for DOM changes
    window.characterArtObserver = new MutationObserver(function(mutations) {
        // Skip if globally disabled or already processing or throttled
        if (window.observerDisabled || isRestoring || throttleId) return;
        
        // Check if any mutation is directly affecting a detail container
        // If so, skip processing entirely
        const shouldSkip = mutations.some(mutation => {
            return mutation.target.closest('.detail-icon-container') !== null;
        });
        
        if (shouldSkip) return;
        
        // Set up throttling with requestAnimationFrame instead of setTimeout
        if (throttleId) return; // already scheduled
        
        throttleId = requestAnimationFrame(() => {
            try {
                // Set isRestoring flag to prevent re-entrance
                isRestoring = true;
                
                // Temporarily disconnect the observer to prevent self-triggering
                window.characterArtObserver.disconnect();
                
                // Use a flag to track if we did any art restoration
                let didRestoreArt = false;
                
                // Process mutations
                mutations.forEach(function(mutation) {
                    // Only process if we have element changes and not in a detail container
                    if ((mutation.type === 'childList' || mutation.type === 'attributes') && 
                        !mutation.target.closest('.detail-icon-container')) {
                        
                        // Check for any character containers that are missing their art
                        // EXPLICITLY EXCLUDE the detail-icon-container to avoid any processing
                        document.querySelectorAll('.hero-avatar-container[data-character-name]:not(.detail-icon-container)').forEach(container => {
                            const characterName = container.dataset.characterName;
                            
                            // Only process if we have this character in our cache
                            if (window.CHARACTER_IMAGE_CACHE[characterName]) {
                                // EARLY EXIT: Skip if art already present
                                if (container.querySelector('.character-art')) return;
                                
                                // EARLY EXIT: Skip if already synced in this animation frame
                                if (container.dataset.artSynced === '1') return;
                                container.dataset.artSynced = '1';
                                
                                // Check if art wrapper exists
                                const artWrapper = container.querySelector('.hero-art-wrapper');
                                
                                // Clean any duplicate arts before proceeding
                                if (artWrapper) {
                                    const extraArts = artWrapper.querySelectorAll('.character-art:not(:first-child)');
                                    extraArts.forEach(el => el.remove());
                                }
                                
                                // If art wrapper is missing, create it
                                let wrapper = artWrapper;
                                if (!wrapper) {
                                    wrapper = document.createElement('div');
                                    wrapper.className = 'hero-art-wrapper';
                                    wrapper.style.display = 'block';
                                    container.appendChild(wrapper);
                                }
                                
                                // Clone from global cache and add
                                const newImg = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                                newImg.style.visibility = 'visible';
                                newImg.style.display = 'block';
                                wrapper.appendChild(newImg);
                                
                                // Force proper class hierarchy
                                container.classList.add('has-art');
                                
                                // Add has-art to parent elements
                                const heroCard = container.closest('.hero-card');
                                if (heroCard) heroCard.classList.add('has-art');
                                
                                const slotContent = container.closest('.slot-content');
                                if (slotContent) slotContent.classList.add('has-art');
                                
                                // Track successful restoration
                                const added = true; // Flag to track if we actually added art
                                if (added) console.log(`Restored art for ${characterName}`);
                                didRestoreArt = true;
                            }
                        });
                    }
                });
                
                // Only log if we actually did something
                if (didRestoreArt) {
                    console.log('Observer restored art for some characters');
                }
            } finally {
                // Reset throttle ID
                throttleId = null;
                // Reset isRestoring flag
                isRestoring = false;
                
                // Reconnect the observer after processing
                if (!window.observerDisabled) {
                    // Reconnect only to the targeted containers
                    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
                    targets.forEach(t => window.characterArtObserver.observe(t, {
                        childList: true,
                        subtree: true,
                        attributes: true
                    }));
                }
            }
        }, 50); // Increase throttle to 50ms for more stability
    });

    // Observe only the grids that actually recycle DOM
    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
    targets.forEach(t => window.characterArtObserver.observe(t, {
        childList: true, // Watch for added/removed nodes
        subtree: true,   // Watch the entire subtree
        attributes: true // Watch for attribute changes
    }));
};

// Utility to temporarily disable observer during complex DOM operations
window.disableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = true;
        window.characterArtObserver.disconnect();
        console.log('Character art observer disabled');
    }
};

// Utility to re-enable observer
window.enableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = false;
        // Observe only the necessary containers
        const targets = document.querySelectorAll('#heroes-grid, #team-slots');
        targets.forEach(t => window.characterArtObserver.observe(t, {
            childList: true,
            subtree: true,
            attributes: true
        }));
        console.log('Character art observer re-enabled');
    }
};

window.TeamBuilderImageLoader = TeamBuilderImageLoader;


===== FILE: game.js =====
/**
 * Main game initialization file
 * This will be the entry point for the AutoBattler game
 *
 * @version 0.5.0.3 (Updated with BattleManager Instantiation & Deferred Scene Add)
 */

// Global variables
let teamManager;
let teamBuilderUI;
let battleManager; // Declared here
let gameConfig = {
    width: 2000,
    height: 1200
};

// Check if BattleUI is defined
function checkBattleUI() {
    if (typeof window.BattleUI === 'undefined') {
        console.warn('BattleUI (DOM version) not defined when game.js loads! This might be ok if only using Phaser.');
    } else {
        console.log('BattleUI (DOM version) is defined and available!');
    }
}

// Wait for DOM to load before initializing the game
window.onload = async function() {
    console.log('Game loading...');

    // Check BattleUI status
    checkBattleUI();

    // Try to load config file
    await loadConfigFile();
    console.log('Config loaded, gameConfig:', gameConfig);

    // Initialize team manager
    teamManager = new TeamManager();
    console.log('TeamManager initialized');

    // Initialize team builder UI
    teamBuilderUI = new TeamBuilderUI(teamManager);
    console.log('TeamBuilderUI created, initializing...');
    await teamBuilderUI.initialize();
    console.log('TeamBuilderUI initialized');

    // Initialize Battle Manager (Crucial Step)
    // Check if BattleManager class exists before creating instance
    if (typeof window.BattleManager === 'function') {
        // Pass null for the scene initially, as Phaser isn't fully ready yet.
        // Pass the ID of your battle log container.
        battleManager = new window.BattleManager(null, 'battle-log-content'); // Instantiate the manager
        window.battleManager = battleManager; // Assign the INSTANCE to window.battleManager (lowercase 'b')
        console.log('BattleManager instance created and assigned to window.battleManager');

         // Optional but recommended: Initialize the BattleManager if it has an async initialize method
         if (battleManager && typeof battleManager.initialize === 'function') {
             // Make sure to await if initialize is async
             // *** NOTE: We removed the auto-creation of BattleUI from BattleManager.initialize ***
             await battleManager.initialize();
             console.log('BattleManager initialized (without auto-creating DOM BattleUI)');
             // BattleBridge will be initialized later by BattleScene with both components
         } else {
             console.log('BattleManager instance created (no separate initialize method found or needed).');
             // BattleBridge will be initialized later by BattleScene with both components
         }

    } else {
        console.error('BattleManager class definition not found on window! Cannot create BattleManager instance.');
        // Stop execution or show an error here
        alert("Critical Error: BattleManager class not found. Battle cannot start.");
        return; // Stop further execution in onload
    }

    // Initialize Phaser game (will be used for battle scene)
    try {
        window.game = initPhaserGame(); // Phaser game instance is assigned here
        console.log('Phaser game initialized successfully');

        // --- POTENTIAL FUTURE STEP: Link BattleManager to Phaser Scene ---
        // (Conceptual code remains unchanged)

    } catch (error) {
        console.error('Failed to initialize Phaser game:', error);
        alert('Failed to initialize Phaser. Battle cannot start.');
    }

    // --- ADDED BLOCK: Defer Adding BattleScene ---
    // Now that Phaser game instance should exist, try adding the scene
    if (window.game && window.BattleScene) {
        if (!window.game.scene.getScene('BattleScene')) { // Check if not already added
            try {
                window.game.scene.add('BattleScene', window.BattleScene);
                console.log('BattleScene added to game post-initialization.');
            } catch (sceneError) {
                 console.error("Error adding BattleScene to game:", sceneError);
                 alert("Failed to add BattleScene. Check console.");
            }
        } else {
             console.log('BattleScene was already added to the game instance.');
        }
    } else {
         if(!window.game) console.warn('Phaser game instance (window.game) not available to add scene.');
         if(!window.BattleScene) console.warn('BattleScene class not found when attempting to add scene post-initialization. Check script load order in index.html.');
    }
    // --- END ADDED BLOCK ---


    // --- Ensure Managers are Exposed Globally ---
    window.teamManager = teamManager;
    window.teamBuilderUI = teamBuilderUI;
    window.battleManager = battleManager; // Expose the created instance
    console.log("Managers exposed globally for debugging.");
};

/**
 * Load the project configuration file
 */
async function loadConfigFile() {
    // ... (loadConfigFile function remains unchanged) ...
    try {
        const response = await fetch('project.config');
        const configText = await response.text();

        // Parse the config file
        const configLines = configText.split('\n');
        let currentSection = '';

        configLines.forEach(line => {
            line = line.trim();

            // Section header
            if (line.startsWith('[') && line.endsWith(']')) {
                currentSection = line.substring(1, line.length - 1);
                return;
            }

            // Parse key-value pairs
            if (line.includes('=')) {
                const parts = line.split('=');
                const key = parts[0].trim();
                let value = parts[1].trim();

                // Remove quotes if present
                if (value.startsWith('"') && value.endsWith('"')) {
                    value = value.substring(1, value.length - 1);
                }

                // Store game dimensions
                if (currentSection === 'game') {
                    if (key === 'width') {
                        gameConfig.width = parseInt(value);
                    } else if (key === 'height') {
                        gameConfig.height = parseInt(value);
                    } else if (key === 'title') {
                        document.title = value;
                    }
                }
            }
        });

        console.log('Loaded game config:', gameConfig);
    } catch (error) {
        console.error('Error loading config file:', error);
        // Use default values if config file cannot be loaded
    }
}


/**
 * Initialize the Phaser game
 * @returns {Phaser.Game | null} The initialized Phaser game instance or null on error
 */
function initPhaserGame() {
    try {
        // Make sure Phaser is loaded
        if (typeof Phaser === 'undefined') {
            console.error('Phaser is not loaded! Make sure Phaser library is included before game.js');
            return null;
        }

        // Make sure PhaserConfig is loaded
        if (typeof window.PhaserConfig === 'undefined') {
            console.error('PhaserConfig is not loaded! Creating emergency configuration...');

            // Create emergency PhaserConfig (Consider moving this to a separate error handling file)
            window.PhaserConfig = {
                initContainer: function(id) {
                     const container = document.getElementById(id) || document.createElement('div');
                     if (!container.id) {
                         container.id = id;
                         document.body.appendChild(container);
                     }
                     // Ensure styling for visibility control
                     container.style.position = 'absolute'; // Or relevant positioning
                     container.style.top = '0';
                     container.style.left = '0';
                     container.style.width = '100%'; // Or specific dimensions
                     container.style.height = '100%';
                     container.style.zIndex = '1'; // Ensure it can be layered
                     container.style.display = 'none'; // Start hidden
                     return container;
                },
                create: function(config) {
                     return {
                         type: Phaser.AUTO,
                         width: config.width || 1280,
                         height: config.height || 720,
                         parent: 'game-container', // Should match initContainer ID
                         backgroundColor: '#333344',
                         scene: [] // Start with empty scene array
                     };
                }
            };
             console.error('PhaserConfig emergency fallback created. Check script load order.');
             // Re-check after creating fallback
             if (typeof window.PhaserConfig === 'undefined') {
                 throw new Error("Failed to create PhaserConfig fallback.");
             }
        }

        // Create Phaser container using our utility
        const phaserContainer = window.PhaserConfig.initContainer('game-container');
        if (!phaserContainer) {
             throw new Error("Failed to initialize Phaser container.");
        }

        // Create Phaser configuration
        const config = window.PhaserConfig.create(gameConfig);
        if (!config) {
             throw new Error("Failed to create Phaser configuration.");
        }

        // Initialize Phaser game
        let game = new Phaser.Game(config);
        if (!game) {
             throw new Error("Phaser.Game constructor failed.");
        }

        // Make sure we have a global reference *immediately* after creation
        window.game = game;

        // --- SCENE ADDITION REMOVED FROM HERE ---
        // The BattleScene will be added later in the onload function

        // Hide Phaser container initially as we start with DOM UI
        if (phaserContainer) {
            phaserContainer.style.display = 'none';
        }

        return game; // Return the game instance
    } catch (error) {
        console.error('Error initializing Phaser game:', error);
        alert('There was an error initializing the battle system. Please refresh the page and try again.');
        // Attempt to clean up partially created elements if possible
        const phaserContainer = document.getElementById('phaser-container'); // Use correct ID
        if(phaserContainer && phaserContainer.parentNode) {
            phaserContainer.parentNode.removeChild(phaserContainer);
        }
        return null;
    }
}


// Add a utility function to check if Phaser is ready
window.isPhaserReady = function() {
    return (
        typeof Phaser !== 'undefined' &&
        window.game && // Check if game instance exists
        window.game.scene && // Check if scene manager exists
        typeof window.game.scene.start === 'function' // Check if core scene method exists
    );
};

// Note: Global exposure is now handled at the end of the onload function
// to ensure variables are assigned before being exposed.

===== FILE: Ability.js =====
/**
 * Ability Class
 * Represents special abilities that characters can use in battle
 */

class Ability {
    /**
     * Create a new Ability
     * @param {string} name - The name of the ability
     * @param {number} damage - Base damage or healing amount
     * @param {number} cooldown - Number of turns before ability can be used again
     * @param {boolean} isHealing - Whether ability heals or damages
     * @param {object} effects - Additional effects (status effects, buffs, etc.)
     */
    constructor(name, damage, cooldown, isHealing = false, effects = {}) {
        this.name = name;
        this.damage = damage;
        this.cooldown = cooldown;
        this.currentCooldown = 0;
        this.isHealing = isHealing;
        this.effects = effects;
    }

    // Methods to be implemented
}


===== FILE: Character.js =====
/**
 * Character Class
 * Base class for all battling units in the AutoBattler game
 */

class Character {
    /**
     * Create a new Character
     * @param {string} name - Character name
     * @param {string} type - Element/type (fire, water, etc.)
     * @param {number} hp - Health points
     * @param {number} attack - Attack power
     * @param {number} defense - Defense value
     * @param {number} x - X position on screen
     * @param {number} y - Y position on screen
     * @param {number} color - Color representation (hexadecimal)
     */
    constructor(name, type, hp, attack, defense, x, y, color) {
        this.name = name;
        this.type = type;
        this.maxHp = hp;
        this.currentHp = hp;
        this.attack = attack;
        this.defense = defense;
        this.x = x;
        this.y = y;
        this.color = color;
        this.sprite = null;
        this.text = null;
        this.abilities = [];
        this.abilityCooldowns = {};
    }

    // Methods to be implemented
}


===== FILE: DirectImageLoader.js =====
/**
 * DirectImageLoader.js
 * A special utility to load character images directly from the file system
 * This ensures the image gets loaded even when relative paths aren't working
 */

window.DirectImageLoader = {
    // Base paths to try in order
    basePaths: [
        '',
        '/',
        './',
        '../',
        '../../'
    ],
    
    // Character image lookup table
    characterImages: {
        'Aqualia': 'assets/images/Character Art/Aqualia.png',
        'Drakarion': 'assets/images/Character Art/Drakarion.png',
        'Zephyr': 'assets/images/Character Art/Zephyr.png',
        'Lumina': 'assets/images/Character Art/Lumina.png',
        'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
        'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
        'Caste': 'assets/images/Character Art/Caste.png'
    },
    
    // Store characters data globally
    charactersData: null,
    
    /**
     * Load characters data from JSON
     */
    loadCharactersData: async function() {
        try {
            const response = await fetch('data/characters.json');
            const data = await response.json();
            this.charactersData = data.characters;
            console.log('DirectImageLoader: Loaded characters data', this.charactersData);
        } catch (err) {
            console.error('DirectImageLoader: Failed to load characters.json', err);
        }
    },
    
    /**
     * Get an image element for a character
     * @param {string} characterName - The name of the character
     * @returns {HTMLImageElement} - Image element with the character art
     */
    getCharacterImage: function(characterName) {
        if (!this.characterImages[characterName]) {
            console.error(`No image path defined for character: ${characterName}`);
            return null;
        }
        
        const img = new Image();
        const imagePath = this.characterImages[characterName];
        
        // For debugging, track when the image loads or fails
        img.onload = () => console.log(`SUCCESS: Loaded character image for ${characterName} from ${img.src}`);
        img.onerror = () => console.error(`FAILED: Could not load character image for ${characterName} from ${img.src}`);
        
        // Set the source directly
        img.src = imagePath;
        
        return img;
    },
    
    /**
     * Insert character images directly into the DOM, replacing placeholders
     * This is called automatically when the page loads
     */
    injectCharacterImages: function() {
        // Check if we're in a battle screen
        const battleUI = document.getElementById('battle-ui');
        if (!battleUI) return;
        
        // SKIP if there's any active animation in progress
        const activeAnimations = document.querySelectorAll('.character-moving, [id^="clone-"]');
        if (activeAnimations.length > 0) {
            console.log('DirectImageLoader: Skipping image injection during active animation');
            return;
        }
        
        console.log('DirectImageLoader: Checking for character circles to replace with images');
        
        // Look for characters that should have images
        Object.keys(this.characterImages).forEach(characterName => {
            // Look for character elements with this name
            document.querySelectorAll('.character-circle').forEach(circle => {
                // SKIP if this circle is already part of an animation clone
                if (circle.closest('[id^="clone-"]')) return;
                
                // SKIP if circle already has art to avoid redundant processing
                if (circle.querySelector('.character-art')) return;
                
                // SKIP if circle has the artLoaded attribute
                if (circle.dataset.artLoaded === 'true') return;
                
                // Check if this is a container for the character we're looking for
                const container = circle.closest('.flex.flex-col');
                if (!container) return;
                
                const nameElement = container.querySelector('.text-sm.font-semibold');
                if (!nameElement || nameElement.textContent !== characterName) return;
                
                // Get character ID from the circle ID if available
                const circleId = circle.id;
                let characterId = null;
                let teamInfo = null;
                
                if (circleId) {
                    const idMatch = circleId.match(/character-(player|enemy)_(\d+)/);
                    if (idMatch) {
                        teamInfo = idMatch[1]; // 'player' or 'enemy'
                        characterId = idMatch[2]; // numeric ID
                    }
                }
                
                console.log(`Found ${characterName} element (${teamInfo}_${characterId}), injecting image`);
                
                // Set up the container for images
                circle.classList.add('character-art-container');
                circle.style.backgroundColor = 'transparent'; // Changed to transparent
                circle.style.boxShadow = 'none'; // Removed shadow
                
                // Mark this circle as having art loaded
                circle.dataset.artLoaded = 'true';
                circle.dataset.characterName = characterName;
                if (characterId) circle.dataset.characterId = characterId;
                if (teamInfo) circle.dataset.team = teamInfo;
                
                // Check for cached image in the global cache
                let img;
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[characterName]) {
                    console.log(`Using cached image for ${characterName}`);
                    img = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                } else {
                    // Create a new image if no cache available
                    img = new Image();
                    img.src = this.characterImages[characterName];
                    
                    // Add to global cache for future use
                    if (!window.CHARACTER_IMAGE_CACHE) window.CHARACTER_IMAGE_CACHE = {};
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                }
                
                img.className = 'character-art';
                img.alt = characterName;
                img.dataset.characterName = characterName;
                if (characterId) img.dataset.characterId = characterId;
                if (teamInfo) img.dataset.team = teamInfo;
                
                img.style.width = '80px';
                img.style.height = '120px';
                img.style.objectFit = 'contain';
                img.style.position = 'absolute';
                
                // Look for custom art positioning in the characters data
                let customPositioning = false;
                if (this.charactersData) {
                    // Try to find the character data
                    const characterData = this.charactersData.find(c => c.name === characterName);
                    if (characterData && characterData.art) {
                        console.log(`Found custom art settings for ${characterName}`, characterData.art);
                        // Apply custom positioning
                        if (characterData.art.top) {
                            img.style.top = characterData.art.top;
                            img.dataset.originalTop = characterData.art.top; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.left) {
                            img.style.left = characterData.art.left;
                            img.dataset.originalLeft = characterData.art.left; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.width) img.style.width = characterData.art.width;
                        if (characterData.art.height) img.style.height = characterData.art.height;
                    }
                }
                
                // Use default positioning only if no custom positioning found
                if (!customPositioning) {
                    img.style.top = '-52px';
                    img.dataset.originalTop = '-52px';
                    img.style.left = '-2px';
                    img.dataset.originalLeft = '-2px';
                }
                
                img.style.zIndex = '10';
                img.style.pointerEvents = 'none';
                
                // Empty the text and add the image
                circle.textContent = '';
                circle.appendChild(img);
            });
        });
    }
};

// Global flag to disable DirectImageLoader during animations
window.disableDirectImageLoader = false;

// Run image injector when DOM is ready
window.addEventListener('load', async function() {
    // Load character data first
    await window.DirectImageLoader.loadCharactersData();
    
    // Wait a bit for battle UI to initialize
    setTimeout(() => {
        window.DirectImageLoader.injectCharacterImages();
    }, 1000);
    
    // Also check periodically for new characters that might appear
    // Use a longer interval (reduced from 3000ms to 5000ms) and check the disable flag
    let intervalId = setInterval(() => {
        if (window.disableDirectImageLoader) {
            console.log('DirectImageLoader: Skipping periodic check (disabled)');
            return;
        }
        window.DirectImageLoader.injectCharacterImages();
    }, 5000);
    
    // Store the interval ID in the DirectImageLoader object
    window.DirectImageLoader.intervalId = intervalId;
});

// Add utility function to temporarily disable the DirectImageLoader during animations
window.disableDirectImageLoaderDuringAnimation = function() {
    window.disableDirectImageLoader = true;
    console.log('DirectImageLoader: Disabled during animation');
    
    // Re-enable after a short delay
    setTimeout(() => {
        window.disableDirectImageLoader = false;
        console.log('DirectImageLoader: Re-enabled after animation');
    }, 2000); // 2 seconds should cover most animations
};

console.log('DirectImageLoader initialized for character art');


===== FILE: ImageDebugger.js =====
/**
 * ImageDebugger.js
 * Utility for debugging image loading issues in the game
 * Debug button removed as character art implementation is now stable
 */


window.ImageDebugger = {
    /**
     * Test loading an image from various paths
     * @param {string} imageName - Base name of the image file (e.g., "Aqualia.png")
     * @returns {Promise<string>} - Promise resolving to the working path or error message
     */
    testImagePaths: async function(imageName) {
        // Set up possible paths to test
        const paths = [
            `./assets/images/Character Art/${imageName}`,
            `/assets/images/Character Art/${imageName}`,
            `assets/images/Character Art/${imageName}`,
            `../assets/images/Character Art/${imageName}`,
            `C:/Personal/AutoBattler/assets/images/Character Art/${imageName}`,
            `../../assets/images/Character Art/${imageName}`
        ];
        
        const results = {};
        
        // Create a div to display loading status in the UI
        const debugDiv = document.createElement('div');
        debugDiv.style.position = 'fixed';
        debugDiv.style.top = '10px';
        debugDiv.style.right = '10px';
        debugDiv.style.backgroundColor = 'rgba(0,0,0,0.8)';
        debugDiv.style.color = 'white';
        debugDiv.style.padding = '10px';
        debugDiv.style.zIndex = '9999';
        debugDiv.style.maxWidth = '400px';
        debugDiv.style.maxHeight = '400px';
        debugDiv.style.overflow = 'auto';
        debugDiv.style.fontFamily = 'monospace';
        debugDiv.style.fontSize = '12px';
        debugDiv.innerHTML = '<h3>Image Path Testing</h3>';
        document.body.appendChild(debugDiv);
        
        // Test each path
        for (const path of paths) {
            const result = await this.testSinglePath(path, debugDiv);
            results[path] = result;
        }
        
        // Add a close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.marginTop = '10px';
        closeButton.style.padding = '5px 10px';
        closeButton.addEventListener('click', () => document.body.removeChild(debugDiv));
        debugDiv.appendChild(closeButton);
        
        // Return the results summary
        return results;
    },
    
    /**
     * Test loading a single image path
     * @param {string} path - Path to test
     * @param {HTMLElement} debugDiv - Debug display element
     * @returns {Promise<string>} - Promise resolving to success or error message
     */
    testSinglePath: function(path, debugDiv) {
        return new Promise((resolve) => {
            const img = new Image();
            const statusElement = document.createElement('div');
            statusElement.innerHTML = `Testing: ${path} <span style="color:yellow">â³</span>`;
            debugDiv.appendChild(statusElement);
            
            // Set a timeout for loading
            const timeout = setTimeout(() => {
                statusElement.innerHTML = `Testing: ${path} <span style="color:orange">âŒ› Timed out after 5s</span>`;
                resolve('Timed out');
            }, 5000);
            
            img.onload = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:green">âœ“ Success (${img.width}x${img.height})</span>`;
                
                // Display the image as thumbnail
                const thumb = document.createElement('img');
                thumb.src = path;
                thumb.style.width = '50px';
                thumb.style.height = '50px';
                thumb.style.objectFit = 'contain';
                thumb.style.marginLeft = '10px';
                statusElement.appendChild(thumb);
                
                resolve('Success');
            };
            
            img.onerror = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:red">âœ— Failed</span>`;
                resolve('Failed');
            };
            
            img.src = path;
        });
    },
    
    // Character-specific debug methods removed as they're no longer needed
};

// Global debug functions removed

console.log('ImageDebugger initialized - debugging UI elements removed.');


===== FILE: TeamBuilderImageLoader.js =====
/**
 * TeamBuilderImageLoader.js
 * Loads and injects character art into the Team Builder UI
 * Based on the existing DirectImageLoader.js functionality
 */

// Create a global cache for character images that persists beyond class instances
window.CHARACTER_IMAGE_CACHE = window.CHARACTER_IMAGE_CACHE || {};

class TeamBuilderImageLoader {
    constructor() {
        this.characterData = null;
        this.processedContainers = new WeakSet(); // Track processed containers to avoid reprocessing
        this.loadedCharacters = new Set(); // Track which characters already have art loaded
        this.cachedImages = new Map(); // NEW: Cache for character images to prevent flickering
        this.checkInterval = 2000; // Check every 2 seconds (reduced frequency)
        this.imageCheckTimer = null;
        this.debugMode = false; // Control logging verbosity
        this.lastProcessTime = Date.now();
        this.characterImages = {
            'Aqualia': 'assets/images/Character Art/Aqualia.png',
            'Drakarion': 'assets/images/Character Art/Drakarion.png',
            'Zephyr': 'assets/images/Character Art/Zephyr.png',
            'Lumina': 'assets/images/Character Art/Lumina.png',
            'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
            'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
            'Caste': 'assets/images/Character Art/Caste.png'
        };
    }

    /**
    * Initialize the image loader
    */
async initialize() {
    console.log('TeamBuilderImageLoader: Initializing...');
    
    // Load character data
    try {
    const response = await fetch('data/characters.json');
    this.characterData = await response.json();
    console.log('TeamBuilderImageLoader: Character data loaded');
    } catch (err) {
    console.error('TeamBuilderImageLoader: Failed to load character data', err);
    this.characterData = { characters: [] }; // Empty fallback
    }
    
    // Start periodic checking for new character elements
    this.startImageCheck();
    
    // Do an initial check with debug enabled
    setTimeout(() => {
    console.log('TeamBuilderImageLoader: Performing initial detailed check...');
    this.forceCheck(true);
    
    // Preload all character images immediately
    this.preloadCharacterImages();
    }, 1000);
}
    
    /**
     * Preload and cache all available character images
     */
    async preloadCharacterImages() {
        console.log('TeamBuilderImageLoader: Preloading all character images...');
        
        // Get all characters that have images defined
        const charactersWithArt = Object.keys(this.characterImages);
        if (charactersWithArt.length === 0) {
            console.warn('TeamBuilderImageLoader: No character images defined');
            return;
        }
        
        // Preload each character's image
        for (const characterName of charactersWithArt) {
            try {
                const imagePath = this.characterImages[characterName];
                if (!imagePath) continue;
                
                console.log(`TeamBuilderImageLoader: Preloading ${characterName}'s image...`);
                
                // Create a new image element
                const img = new Image();
                
                // Set up onload handler
                img.onload = () => {
                    // Store in global cache
                    window.CHARACTER_IMAGE_CACHE[characterName] = img;
                    console.log(`TeamBuilderImageLoader: ${characterName}'s image preloaded and stored in global cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    // Also store in instance cache
                    this.cachedImages.set(characterName, img);
                    this.loadedCharacters.add(characterName);
                };
                
                // Set the source to trigger loading
                img.src = imagePath;
            } catch (err) {
                console.error(`TeamBuilderImageLoader: Error preloading ${characterName}'s image`, err);
            }
        }
    }
    


    /**
     * Start periodically checking for character elements that need art
     */
    startImageCheck() {
        // Clear any existing timer
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
        }
        
        // Set up periodic check - just basic checking, no forced updates
        this.imageCheckTimer = setInterval(() => {
            this.checkAndLoadImages();
        }, this.checkInterval);
        
        // Run an immediate check
        this.checkAndLoadImages();
    }

    /**
     * Check for character elements and load images if needed
     */
    checkAndLoadImages() {
        // Throttle checks to prevent excessive processing
        const now = Date.now();
        if (now - this.lastProcessTime < 500) { // minimum 500ms between full checks
            return;
        }
        this.lastProcessTime = now;
        
        // Find all character containers EXCEPT the detail container
        // We now handle detail container separately to avoid observer issues
        const containers = document.querySelectorAll('.hero-avatar-container:not(.detail-icon-container)');
        
        if (this.debugMode) {
            console.log(`TeamBuilderImageLoader: Checking ${containers.length} avatar containers`);
        }
        
        // First pass: immediately hide all circles where art is available
        containers.forEach(container => {
            const characterName = container.dataset.characterName;
            if (characterName && this.characterImages[characterName]) {
                // This character has art available, immediately hide the circle
                const avatarCircle = container.querySelector('.hero-avatar, .detail-icon');
                if (avatarCircle) {
                    avatarCircle.style.display = 'none';
                    avatarCircle.style.backgroundColor = 'transparent';
                    avatarCircle.textContent = ''; // Clear any letter placeholders
                }
                
                // Add the has-art class to the container for CSS targeting
                container.classList.add('has-art');
            }
        });
        
        // Now process containers that need art
        let artLoadedInThisPass = false;
        
        containers.forEach(container => {
            // Always process detail view containers, otherwise check if already processed
            const isDetailView = container.classList.contains('detail-icon-container');
            if (!isDetailView && this.processedContainers.has(container)) {
                return;
            }
            
            const characterId = container.dataset.characterId;
            const characterName = container.dataset.characterName;
            
            // Skip if no character ID
            if (!characterId) return;
            
            // Process and load art for this character if needed
            if (this.loadCharacterArt(container, characterId, characterName)) {
                artLoadedInThisPass = true;
            }
        });
        
        // Report if we actually loaded art in this pass (helps with debugging)
        if (artLoadedInThisPass && this.debugMode) {
            console.log('TeamBuilderImageLoader: New art was loaded in this check pass');
        }
    }

    /**
     * Load art for a specific character
     * @returns {boolean} Whether new art was loaded
     */
    loadCharacterArt(container, characterId, characterName) {
        // Special handling for character details view
        const isDetailView = container.classList.contains('detail-icon-container');
        
        // If this is the detail view, always process it (even if processed before)
        // This helps ensure the art is always shown in the character details panel
        if (!isDetailView) {
            // For non-detail views, mark container as processed to avoid multiple attempts
            this.processedContainers.add(container);
        }
        
        // Check if this character has art defined
        if (!this.characterImages[characterName]) {
            if (this.debugMode) {
                console.log(`TeamBuilderImageLoader: No art defined for ${characterName}`);
            }
            
            // Don't add placeholders anymore - just return false and let containers be invisible
            return false; // No art defined
        }
        
        // Critical: If character is already loaded, just make sure container is properly styled
        if (this.loadedCharacters.has(characterName)) {
            const artWrapper = container.querySelector('.hero-art-wrapper');
            
            if (artWrapper) {
                artWrapper.style.display = 'block';
                
                // If no inner content in wrapper, we need to add the image
                // (for newly created UI elements)
                if (artWrapper.innerHTML.trim() === '') {
                    this.createAndAddArt(container, characterId, characterName, false);
                    return true; // Consider as new art being added
                }
            }
            
            return false; // No new art loaded
        }
        
        // If we get here, character needs art and hasn't been loaded yet
        return this.createAndAddArt(container, characterId, characterName, true);
    }

    /**
     * Create and add character art to a container
     * @param {HTMLElement} container - The container element
     * @param {string} characterId - Character ID
     * @param {string} characterName - Character name
     * @param {boolean} isFirstLoad - Whether this is the first time loading this character
     * @returns {boolean} Whether the art was successfully added
     */
    async createAndAddArt(container, characterId, characterName, isFirstLoad) {
        // Find character data
        const character = this.findCharacterData(characterId, characterName);
        if (!character) {
            console.log(`TeamBuilderImageLoader: Character data not found for ${characterName}`);
            return false;
        }
        
        // Check if the wrapper exists
        const artWrapper = container.querySelector('.hero-art-wrapper');
        
        if (!artWrapper) {
            console.error('TeamBuilderImageLoader: No art wrapper found for', characterName);
            return false;
        }
        
        // Try to load the image
        try {
            const imagePath = this.characterImages[characterName];
            
            // Check if we already have a cached image for this character
            let img;
            if (this.cachedImages.has(characterName)) {
                // Use the cached image data to create a new image element
                img = this.cachedImages.get(characterName).cloneNode(true);
                console.log(`TeamBuilderImageLoader: Using cached image for ${characterName}`);
            } else {
                // Load the image for the first time
                const imageExists = await this.checkImageExists(imagePath);
                
                if (!imageExists) {
                    console.log(`TeamBuilderImageLoader: No image found for ${characterName}`);
                    return false;
                }
                
                // Create a new image element
                img = document.createElement('img');
                img.src = imagePath;
                img.onload = () => {
                    // Cache the loaded image for future use
                    this.cachedImages.set(characterName, img.cloneNode(true));
                    
                    // Also store in global cache for persistent access
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                    console.log(`TeamBuilderImageLoader: Added ${characterName} to global image cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    console.log(`TeamBuilderImageLoader: Cached image for ${characterName}`);
                };
            }
            
            // Determine if this is a detail view
            const isDetailView = container.classList.contains('detail-icon-container');
            
            // Use teamBuilderArt if available, otherwise fall back to regular art
            let artSettings;
            
            if (isDetailView) {
                // For detail view, use special positioning
                artSettings = character.detailArt || character.teamBuilderArt || character.art || {};
                
                // If no specific settings, use these defaults for detail view
                if (!artSettings.left) artSettings.left = '-30px';
                if (!artSettings.top) artSettings.top = '-45px';
                if (!artSettings.width) artSettings.width = '140px';
                if (!artSettings.height) artSettings.height = '140px';
            } else {
                // Regular view
                artSettings = character.teamBuilderArt || character.art || {};
            }
            
            // Set image properties
            img.className = 'character-art team-builder-art';
            img.alt = characterName;
            
            // Apply position settings
            img.style.position = 'absolute';
            img.style.left = artSettings.left || '0px';
            img.style.top = artSettings.top || '0px';
            
            if (artSettings.width) {
                img.style.width = artSettings.width;
            }
            
            if (artSettings.height) {
                img.style.height = artSettings.height;
            }
            
            // Store original positions for animation handling
            img.dataset.originalLeft = artSettings.left || '0px';
            img.dataset.originalTop = artSettings.top || '0px';
            
            // PRESERVE EXISTING ART: Check if art already exists before replacing
            const existingArt = artWrapper.querySelector('.character-art');
            if (!existingArt) {
                // Only clear and add if there's no existing art
                artWrapper.innerHTML = '';
                artWrapper.appendChild(img);
            }
            
            artWrapper.style.display = 'block';
            
            // Set all parent elements with appropriate classes
            container.classList.add('has-art'); // Mark container as having art
            
            // Add has-art to the parent card/content element if it exists
            const heroCard = container.closest('.hero-card');
            if (heroCard) heroCard.classList.add('has-art');
            
            const slotContent = container.closest('.slot-content');
            if (slotContent) slotContent.classList.add('has-art');
            
            const detailHero = container.closest('.detail-hero');
            if (detailHero) detailHero.classList.add('has-art');
            
            // Record that we've loaded this character's art
            // This is important to avoid reloading across different containers
            this.loadedCharacters.add(characterName);
            
            // Always log for detail view to help track issues
            if (isFirstLoad || isDetailView) {
                console.log(`TeamBuilderImageLoader: Loaded art for ${characterName}${isDetailView ? ' (detail view)' : ''}`);
            }
            
            return true;
        } catch (err) {
            console.error(`TeamBuilderImageLoader: Error loading art for ${characterName}`, err);
            return false;
        }
    }

    /**
     * Find character data by ID or name
     */
    findCharacterData(id, name) {
        if (!this.characterData || !this.characterData.characters) {
            return null;
        }
        
        // Try to find by ID first
        let character = this.characterData.characters.find(c => c.id == id);
        
        // Fall back to finding by name
        if (!character && name) {
            character = this.characterData.characters.find(c => 
                c.name.toLowerCase() === name.toLowerCase()
            );
        }
        
        return character;
    }

    /**
     * Manually trigger a check for new images and reset processing cache
     * @param {boolean} debug - Enable debug output
     * @param {boolean} resetCache - Whether to reset the processed containers cache
     */
    forceCheck(debug = false, resetCache = false) {
        // Temporarily enable debug mode if requested
        const prevDebugMode = this.debugMode;
        this.debugMode = debug;
        
        if (debug) {
            console.log("TeamBuilderImageLoader: Force checking images");
        }
        
        // Reset the processed containers cache if requested
        // This will force reprocessing of all containers
        if (resetCache) {
            if (debug) {
                console.log("TeamBuilderImageLoader: Resetting processed containers cache");
            }
            this.processedContainers = new WeakSet();
            this.loadedCharacters = new Set();
        }
        
        // Check for new images
        this.checkAndLoadImages();
        
        // Restore previous debug mode
        this.debugMode = prevDebugMode;
    }

    /**
     * Check if an image exists
     */
    async checkImageExists(imagePath) {
        try {
            const response = await fetch(imagePath, { method: 'HEAD' });
            return response.ok;
        } catch (err) {
            return false;
        }
    }

    /**
     * Clean up resources
     */
    destroy() {
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
            this.imageCheckTimer = null;
        }
    }
}

// Export the class
// Create DOM observer to ensure character art is never removed
window.setupCharacterArtMutationObserver = function() {
    // First, completely disconnect any existing observer to ensure clean slate
    if (window.characterArtObserver) {
        window.characterArtObserver.disconnect();
        window.characterArtObserver = null;
        console.log('Reset existing character art observer');
    }
    
    console.log('Setting up character art mutation observer');
    
    // Static flag to completely disable observer when needed
    window.observerDisabled = false;
    
    // Throttling variable
    let throttleId = null;
    // Boolean flag to prevent re-entrance
    let isRestoring = false;
    
    // Create a mutation observer to watch for DOM changes
    window.characterArtObserver = new MutationObserver(function(mutations) {
        // Skip if globally disabled or already processing or throttled
        if (window.observerDisabled || isRestoring || throttleId) return;
        
        // Check if any mutation is directly affecting a detail container
        // If so, skip processing entirely
        const shouldSkip = mutations.some(mutation => {
            return mutation.target.closest('.detail-icon-container') !== null;
        });
        
        if (shouldSkip) return;
        
        // Set up throttling with requestAnimationFrame instead of setTimeout
        if (throttleId) return; // already scheduled
        
        throttleId = requestAnimationFrame(() => {
            try {
                // Set isRestoring flag to prevent re-entrance
                isRestoring = true;
                
                // Temporarily disconnect the observer to prevent self-triggering
                window.characterArtObserver.disconnect();
                
                // Use a flag to track if we did any art restoration
                let didRestoreArt = false;
                
                // Process mutations
                mutations.forEach(function(mutation) {
                    // Only process if we have element changes and not in a detail container
                    if ((mutation.type === 'childList' || mutation.type === 'attributes') && 
                        !mutation.target.closest('.detail-icon-container')) {
                        
                        // Check for any character containers that are missing their art
                        // EXPLICITLY EXCLUDE the detail-icon-container to avoid any processing
                        document.querySelectorAll('.hero-avatar-container[data-character-name]:not(.detail-icon-container)').forEach(container => {
                            const characterName = container.dataset.characterName;
                            
                            // Only process if we have this character in our cache
                            if (window.CHARACTER_IMAGE_CACHE[characterName]) {
                                // EARLY EXIT: Skip if art already present
                                if (container.querySelector('.character-art')) return;
                                
                                // EARLY EXIT: Skip if already synced in this animation frame
                                if (container.dataset.artSynced === '1') return;
                                container.dataset.artSynced = '1';
                                
                                // Check if art wrapper exists
                                const artWrapper = container.querySelector('.hero-art-wrapper');
                                
                                // Clean any duplicate arts before proceeding
                                if (artWrapper) {
                                    const extraArts = artWrapper.querySelectorAll('.character-art:not(:first-child)');
                                    extraArts.forEach(el => el.remove());
                                }
                                
                                // If art wrapper is missing, create it
                                let wrapper = artWrapper;
                                if (!wrapper) {
                                    wrapper = document.createElement('div');
                                    wrapper.className = 'hero-art-wrapper';
                                    wrapper.style.display = 'block';
                                    container.appendChild(wrapper);
                                }
                                
                                // Clone from global cache and add
                                const newImg = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                                newImg.style.visibility = 'visible';
                                newImg.style.display = 'block';
                                wrapper.appendChild(newImg);
                                
                                // Force proper class hierarchy
                                container.classList.add('has-art');
                                
                                // Add has-art to parent elements
                                const heroCard = container.closest('.hero-card');
                                if (heroCard) heroCard.classList.add('has-art');
                                
                                const slotContent = container.closest('.slot-content');
                                if (slotContent) slotContent.classList.add('has-art');
                                
                                // Track successful restoration
                                const added = true; // Flag to track if we actually added art
                                if (added) console.log(`Restored art for ${characterName}`);
                                didRestoreArt = true;
                            }
                        });
                    }
                });
                
                // Only log if we actually did something
                if (didRestoreArt) {
                    console.log('Observer restored art for some characters');
                }
            } finally {
                // Reset throttle ID
                throttleId = null;
                // Reset isRestoring flag
                isRestoring = false;
                
                // Reconnect the observer after processing
                if (!window.observerDisabled) {
                    // Reconnect only to the targeted containers
                    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
                    targets.forEach(t => window.characterArtObserver.observe(t, {
                        childList: true,
                        subtree: true,
                        attributes: true
                    }));
                }
            }
        }, 50); // Increase throttle to 50ms for more stability
    });

    // Observe only the grids that actually recycle DOM
    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
    targets.forEach(t => window.characterArtObserver.observe(t, {
        childList: true, // Watch for added/removed nodes
        subtree: true,   // Watch the entire subtree
        attributes: true // Watch for attribute changes
    }));
};

// Utility to temporarily disable observer during complex DOM operations
window.disableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = true;
        window.characterArtObserver.disconnect();
        console.log('Character art observer disabled');
    }
};

// Utility to re-enable observer
window.enableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = false;
        // Observe only the necessary containers
        const targets = document.querySelectorAll('#heroes-grid, #team-slots');
        targets.forEach(t => window.characterArtObserver.observe(t, {
            childList: true,
            subtree: true,
            attributes: true
        }));
        console.log('Character art observer re-enabled');
    }
};

window.TeamBuilderImageLoader = TeamBuilderImageLoader;

