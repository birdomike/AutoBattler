

===== FILE: AbilityProcessor.js =====
/**
 * AbilityProcessor.js
 * Processes ability effects and execution
 * Version 0.5.26.1 - Initial implementation of AbilityProcessor component
 * 
 * REFACTORING PURPOSE:
 * This component extracts ability processing logic from BattleManager.js as part
 * of the modular refactoring effort, following the Clean As You Go approach.
 * It handles all aspects of applying ability effects to targets, processing different
 * effect types, and managing ability interactions.
 */

class AbilityProcessor {
    /**
     * Create a new Ability Processor
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        
        // Log initialization with version info
        console.log("[AbilityProcessor] Version 0.5.26.1 - Initializing AbilityProcessor component");
    }

    /**
     * Apply the effect of an action to its target
     * @param {Object} action - The action to apply
     * REFACTORING: Extracted from BattleManager.applyActionEffect and BattleFlowController.applyActionEffect
     */
    applyActionEffect(action) {
        // Defensive check for null/undefined action
        if (!action) {
            console.error("[AbilityProcessor] Cannot apply effect of undefined action");
            return;
        }

        // Get team info for clearer logging
        const actorTeam = action.team;
        const targetTeam = actorTeam === 'player' ? 'enemy' : 'player';
        
        // Handle array of targets (for multi-target abilities)
        if (Array.isArray(action.target)) {
            // Process each target individually
            for (const target of action.target) {
                // Create a single-target version of the action
                const singleAction = {...action, target};
                this.applyActionEffect(singleAction);
            }
            return;
        }
        
        // Check if this is an action with the new effects array
        if (action.ability && action.ability.effects && Array.isArray(action.ability.effects) && action.ability.effects.length > 0) {
            // Store the target's original health before processing effects
            const originalHealth = action.target.currentHp;
            
            // New effect system - process each effect in the array
            for (const effect of action.ability.effects) {
                this.processEffect(effect, action.actor, action.target, action.ability);
            }
            
            // After processing all effects, check if health has changed
            const newHealth = action.target.currentHp;
            const healthChange = originalHealth - newHealth;
            
            // If health decreased (damage was dealt)
            if (healthChange > 0) {
                console.log(`[AbilityProcessor] Effects array reduced ${action.target.name}'s health by ${healthChange}`);
                
                // Dispatch CHARACTER_DAMAGED event using BattleManager facade
                if (this.battleManager.dispatchDamageEvent) {
                    this.battleManager.dispatchDamageEvent(action.target, healthChange, action.actor, action.ability);
                }
                // Fallback to direct battleBridge call
                else if (window.battleBridge) {
                    try {
                        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
                            character: action.target,
                            target: action.target,
                            newHealth: action.target.currentHp,
                            maxHealth: action.target.stats.hp,
                            amount: healthChange,
                            source: action.actor,
                            ability: action.ability
                        });
                    } catch (error) {
                        console.error('[AbilityProcessor] Error dispatching CHARACTER_DAMAGED event:', error);
                    }
                }
            } 
            // If health increased (healing was applied)
            else if (healthChange < 0) {
                const healAmount = Math.abs(healthChange);
                console.log(`[AbilityProcessor] Effects array increased ${action.target.name}'s health by ${healAmount}`);
                
                // Dispatch CHARACTER_HEALED event using BattleManager facade
                if (this.battleManager.dispatchHealingEvent) {
                    this.battleManager.dispatchHealingEvent(action.target, healAmount, action.actor, action.ability);
                }
                // Fallback to direct battleBridge call
                else if (window.battleBridge) {
                    try {
                        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_HEALED, {
                            character: action.target,
                            target: action.target,
                            newHealth: action.target.currentHp,
                            maxHealth: action.target.stats.hp,
                            amount: healAmount,
                            source: action.actor,
                            ability: action.ability
                        });
                    } catch (error) {
                        console.error('[AbilityProcessor] Error dispatching CHARACTER_HEALED event:', error);
                    }
                }
            }
            
            return;
        }
        
        // Legacy action processing
        if (action.ability && (action.ability.isHealing || action.ability.damageType === 'healing')) {
            // Defensive check for HealingProcessor
            if (!this.battleManager.healingProcessor) {
                console.error("[AbilityProcessor] HealingProcessor component not found! Cannot apply healing.");
                return; // Exit early if component is missing
            }
            
            // Call the HealingProcessor to apply the healing and get results
            const result = this.battleManager.healingProcessor.applyHealing(
                action.target,
                action.damage,           // The pre-calculated potential healing amount
                action.actor,            // Source of healing
                action.ability,          // Ability used
                action.ability.name || 'healing'  // Healing type
            );
            
            // Get healing results
            const actualHealing = result.actualHealing;
            const revived = result.revived;
            
            // Check and reset death status if needed
            if (revived) {
                this.battleManager.healingProcessor.checkAndResetDeathStatus(action.target);
            }
            
            // Include team info in the log message for healing too
            const targetTeam = action.target.team;
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Add scaling information to healing message
            if (action.scalingText) {
                this.battleManager.logMessage(`${targetInfo} is healed for ${actualHealing} HP ${action.scalingText}! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, 'success');
            } else {
                this.battleManager.logMessage(`${targetInfo} is healed for ${actualHealing} HP! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, 'success');
            }
            
            // Process healing-related passive abilities
            
            // 1. onHealed for the target
            if (actualHealing > 0) {
                this.battleManager.processPassiveAbilities('onHealed', action.target, {
                    source: action.actor,
                    healAmount: actualHealing,
                    ability: action.ability,
                    healPercent: action.target.stats.hp > 0 ? actualHealing / action.target.stats.hp : 0 // Add healing percentage
                });
                
                // Show passive trigger visual feedback if using BattleUI
                if (this.battleManager.battleUI && this.battleManager.battleUI.showPassiveEffect) {
                    this.battleManager.battleUI.showPassiveEffect(action.target, 'Healing received');
                }
            }
            
            // 2. onHealingDone for the healer
            if (actualHealing > 0 && action.actor !== action.target) { // Only trigger for healing others
                this.battleManager.processPassiveAbilities('onHealingDone', action.actor, {
                    target: action.target,
                    healAmount: actualHealing,
                    ability: action.ability,
                    healPercent: action.target.stats.hp > 0 ? actualHealing / action.target.stats.hp : 0 // Add healing percentage
                });
                
                // Show passive trigger visual feedback if using BattleUI
                if (this.battleManager.battleUI && this.battleManager.battleUI.showPassiveEffect) {
                    this.battleManager.battleUI.showPassiveEffect(action.actor, 'Healing done');
                }
            }
            
            // Process revival passive if character was revived
            if (revived) {
                this.battleManager.processPassiveAbilities('onRevive', action.target, {
                    reviver: action.actor,
                    ability: action.ability
                });
            }
            
            // Add regeneration status if it's a healing ability
            if (Math.random() < 0.5) { // 50% chance
            // Updated to use consistent 5-parameter format with explicit source and stacks
                this.battleManager.addStatusEffect(action.target, 'regen', action.actor, 2, 1);
                }
        } else if (action.ability && action.ability.damageType === 'utility') {
            // Utility ability - special effects instead of damage
            const targetTeam = action.target.team;
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Handle different utility effects
            if (action.ability.name === "Evasive Maneuver") {
                // Add evasion effect (this is just a placeholder, evasion mechanic would need to be implemented)
                this.battleManager.logMessage(`${targetInfo} becomes harder to hit!`, 'info');
                this.battleManager.addStatusEffect(action.target, 'defense_up', 2);
            } else {
                // Generic utility effect message
                this.battleManager.logMessage(`${targetInfo} is affected by ${action.ability.name}!`, 'info');
            }
        } else {
            // Damaging action
            // Declare variables for tracking damage and killed state
            let actualDamage = 0;
            let killed = false;
            
             // Ensure DamageCalculator component is available
            if (!this.battleManager.damageCalculator) {
                 console.error('[AbilityProcessor] DamageCalculator component not found! Cannot apply damage.');
                 return; // Or handle error appropriately
            }

            // Directly use DamageCalculator to apply damage and get results
            const result = this.battleManager.damageCalculator.applyDamage(
                action.target,
                action.damage,        // The pre-calculated potential damage
                action.actor,
                action.ability,
                action.damageType || 'physical' // Pass damage type or default
            );

            // Store the result values locally for subsequent processing
            actualDamage = result.actualDamage; // Assign from result
            killed = result.killed;             // Assign from result
            
            // Include team info in the log message for clarity when characters share names
            // For targets, we need to use opposite team designation from the actor
            const targetTeam = action.team === 'player' ? 'enemy' : 'player';
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Add scaling information to damage message
            if (action.scalingText) {
                this.battleManager.logMessage(`${targetInfo} takes ${actualDamage} damage ${action.scalingText}! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, action.useAbility ? 'error' : 'default');
            } else {
                this.battleManager.logMessage(`${targetInfo} takes ${actualDamage} damage! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, action.useAbility ? 'error' : 'default');
            }
            
            // Process damage-related passive abilities
            
            // 1. onDamageTaken for the target
            if (actualDamage > 0) {
                this.battleManager.processPassiveAbilities('onDamageTaken', action.target, {
                    source: action.actor,
                    damageAmount: actualDamage,
                    ability: action.ability,
                    wasCritical: false, // TODO: Add critical hit tracking
                    reflectionDepth: 0 // Initialize reflection depth tracking
                });
            }
            
            // 2. onDamageDealt for the attacker
            if (actualDamage > 0) {
                this.battleManager.processPassiveAbilities('onDamageDealt', action.actor, {
                    target: action.target,
                    damageAmount: actualDamage,
                    ability: action.ability,
                    wasCritical: false, // TODO: Add critical hit tracking
                    damagePercent: action.target.stats.hp > 0 ? actualDamage / action.target.stats.hp : 0 // Add damage percentage
                });
            }
            
            // Handle defeat logic separately from damage application
            if (killed) {
                action.target.isDefeated = true;
                action.target.currentHp = 0; // Ensure HP doesn't go below 0
                // Use the same targetInfo for defeat message
                this.battleManager.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error'); // Added coffin emoji for visibility
                
                // Process defeat passive abilities
                this.battleManager.processPassiveAbilities('onDefeat', action.target, {
                    killer: action.actor,
                    ability: action.ability
                });
                
                // Process on-kill passive ability with visual feedback
                const killResults = this.battleManager.processPassiveAbilities('onKill', action.actor, {
                    defeated: action.target,
                    ability: action.ability
                });
                
                // Show visual feedback for kill effects if there were executed passives
                if (killResults && killResults.length > 0 && this.battleManager.battleUI && this.battleManager.battleUI.showPassiveEffect) {
                    const passiveNames = killResults
                        .filter(result => result.executed)
                        .map(result => {
                            // Extract passive name from message if available
                            if (result.message && result.message.includes("'s")) {
                                return result.message.split("'s")[1].trim();
                            }
                            return 'Kill Effect';
                        });
                    
                    if (passiveNames.length > 0) {
                        // Show the passive effect visualization
                        this.battleManager.battleUI.showPassiveEffect(action.actor, passiveNames[0]);
                    }
                }
            }
        }
    }

    /**
     * Process a single effect from an ability's effects array
     * @param {Object} effect - The effect to process
     * @param {Object} actor - The character using the ability
     * @param {Object} target - The target of the effect
     * @param {Object} ability - The ability being used
     * REFACTORING: Extracted from BattleManager.processEffect
     */
    processEffect(effect, actor, target, ability) {
        // Defensive checks for null/undefined parameters
        if (!effect) {
            console.error("[AbilityProcessor] Cannot process undefined effect");
            return;
        }
        if (!actor) {
            console.error("[AbilityProcessor] Cannot process effect with undefined actor");
            return;
        }
        if (!target) {
            console.error("[AbilityProcessor] Cannot process effect with undefined target");
            return;
        }

        // Get team identifiers for logging
        const actorTeamId = actor.team === 'player' ? ' (ally)' : ' (enemy)';
        const targetTeamId = target.team === 'player' ? ' (ally)' : ' (enemy)';
        const actorInfo = `${actor.name}${actorTeamId}`;
        const targetInfo = `${target.name}${targetTeamId}`;
        
        // Check if this effect should apply based on team relationships
        const isTargetAlly = target.team === actor.team || target.isAllyOf === true;
        
        // Skip if effect shouldn't apply to allies but target is an ally
        if (effect.targetAllies === false && isTargetAlly) {
            console.debug(`[AbilityProcessor] Skipping effect on ${target.name}: ally=${isTargetAlly}, effect allows allies: false`);
            return; // Skip this effect
        }
        
        // Skip if effect shouldn't apply to enemies but target is an enemy
        if (effect.targetEnemies === false && !isTargetAlly) {
            console.debug(`[AbilityProcessor] Skipping effect on ${target.name}: ally=${isTargetAlly}, effect allows enemies: false`);
            return; // Skip this effect
        }
        
        console.debug(`[AbilityProcessor] Processing effect on ${target.name}: isAlly=${isTargetAlly}, effect allows allies: ${effect.targetAllies !== false}, effect allows enemies: ${effect.targetEnemies !== false}`);
        
        // Handle different effect types
        switch (effect.type) {
            case 'Damage':
            case 'damage':
                // Only apply damage if target is an enemy or area damage specifically allows allies
                if (!isTargetAlly || effect.targetAllies === true) {
                    // Check if DamageCalculator component is available
                    if (!this.battleManager.damageCalculator) {
                        console.error("[AbilityProcessor] DamageCalculator component not found! Cannot calculate damage.");
                        return; // Exit early if component is missing
                    }
                    
                    // Calculate damage for this specific effect
                    const damageResult = this.battleManager.damageCalculator.calculateDamage(actor, target, ability, effect);
                    const damage = damageResult.damage;
                    
                    // Apply damage to target
                    target.currentHp = Math.max(0, target.currentHp - damage);
                    
                    // Log the damage
                    if (damageResult.scalingText) {
                        this.battleManager.logMessage(`${targetInfo} takes ${damage} damage ${damageResult.scalingText}! (HP: ${target.currentHp}/${target.stats.hp})`, 'error');
                    } else {
                        this.battleManager.logMessage(`${targetInfo} takes ${damage} damage! (HP: ${target.currentHp}/${target.stats.hp})`, 'error');
                    }
                    
                    // Dispatch CHARACTER_DAMAGED event using BattleManager facade
                    if (this.battleManager.dispatchDamageEvent && damage > 0) {
                        this.battleManager.dispatchDamageEvent(target, damage, actor, ability);
                    }
                    // Fallback to direct battleBridge call
                    else if (window.battleBridge && damage > 0) {
                        try {
                            window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
                                character: target,
                                target: target, // Keep both for backwards compatibility
                                newHealth: target.currentHp,
                                maxHealth: target.stats.hp,
                                amount: damage,
                                source: actor,
                                ability: ability
                            });
                        } catch (error) {
                            console.error('[AbilityProcessor] Error dispatching CHARACTER_DAMAGED event:', error);
                        }
                    }
                    
                    // Check if target died
                    if (target.currentHp <= 0) {
                        target.isDead = true;
                        target.currentHp = 0; // Ensure HP doesn't go below 0
                        this.battleManager.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error');
                        
                        // Process defeat and kill passives
                        this.battleManager.processPassiveAbilities('onDefeat', target, {
                            killer: actor,
                            ability: ability
                        });
                        
                        this.battleManager.processPassiveAbilities('onKill', actor, {
                            defeated: target,
                            ability: ability
                        });
                    }
                    
                    // Process damage-related passive abilities
                    if (damage > 0) {
                        // onDamageTaken for the target
                        this.battleManager.processPassiveAbilities('onDamageTaken', target, {
                            source: actor,
                            damageAmount: damage,
                            ability: ability,
                            wasCritical: damageResult.isCritical || false,
                            reflectionDepth: 0 // Initialize reflection depth tracking
                        });
                        
                        // onDamageDealt for the attacker
                        this.battleManager.processPassiveAbilities('onDamageDealt', actor, {
                            target: target,
                            damageAmount: damage,
                            ability: ability,
                            wasCritical: damageResult.isCritical || false
                        });
                    }
                }
                break;
                
            case 'Healing':
            case 'healing':
                // Only apply healing if target is an ally or area healing specifically allows enemies
                if (isTargetAlly || effect.targetEnemies === true) {
                    // Check if HealingProcessor component is available
                    if (!this.battleManager.healingProcessor) {
                        console.error("[AbilityProcessor] HealingProcessor component not found! Cannot apply healing.");
                        return; // Exit early if component is missing
                    }
                    
                    // Calculate the healing amount using damage calculator as a base (healers use damage calculation too)
                    const healResult = this.battleManager.damageCalculator.calculateDamage(actor, target, ability, effect);
                    const healAmount = healResult.damage; // We reuse damage calculation for healing
                    
                    // Apply healing using the HealingProcessor
                    const result = this.battleManager.healingProcessor.applyHealing(
                        target,
                        healAmount,     // The calculated healing amount
                        actor,          // Source of healing
                        ability,        // Ability used
                        effect.type || 'healing'  // Healing type
                    );
                    
                    // Get actual healing applied and revival status
                    const actualHealing = result.actualHealing;
                    const revived = result.revived;
                    
                    // Check and reset death status if needed
                    if (revived) {
                        this.battleManager.healingProcessor.checkAndResetDeathStatus(target);
                    }
                    
                    // Log the healing with scaling info if available
                    if (healResult.scalingText) {
                        this.battleManager.logMessage(`${targetInfo} is healed for ${actualHealing} HP ${healResult.scalingText}! (HP: ${target.currentHp}/${target.stats.hp})`, 'success');
                    } else {
                        this.battleManager.logMessage(`${targetInfo} is healed for ${actualHealing} HP! (HP: ${target.currentHp}/${target.stats.hp})`, 'success');
                    }
                    
                    // Process healing-related passive abilities
                    if (actualHealing > 0) {
                        // onHealed for the target
                        this.battleManager.processPassiveAbilities('onHealed', target, {
                            source: actor,
                            healAmount: actualHealing,
                            ability: ability
                        });
                        
                        // onHealingDone for the healer (if not self-healing)
                        if (actor !== target) {
                            this.battleManager.processPassiveAbilities('onHealingDone', actor, {
                                target: target,
                                healAmount: actualHealing,
                                ability: ability
                            });
                        }
                    }
                    
                    // Process revival passive if character was revived
                    if (revived) {
                        this.battleManager.processPassiveAbilities('onRevive', target, {
                            reviver: actor,
                            ability: ability
                        });
                    }
                }
                break;
                
            case 'ApplyStatus':
            case 'applyStatus':
                // Check if StatusEffectManager component is available
                if (!this.battleManager.statusEffectManager) {
                    console.error("[AbilityProcessor] StatusEffectManager component not found! Cannot apply status effect.");
                    return; // Exit early if component is missing
                }
                
                // Apply status based on team relationships
                // Buffs typically go to allies, debuffs to enemies
                const statusId = effect.statusEffectId;
                const duration = effect.duration || 2;
                let applyStatus = true;
                
                // Get the definition to check if it's a buff or debuff
                const statusDef = this.battleManager.statusEffectLoader ? 
                    this.battleManager.statusEffectLoader.getDefinition(statusId) : 
                    (this.battleManager.statusEffectDefinitions ? this.battleManager.statusEffectDefinitions[statusId] : null);
                
                const isBuffType = statusDef && (statusDef.type === 'Buff' || statusDef.type === 'HoT' || statusDef.type === 'Shield');
                const isDebuffType = statusDef && (statusDef.type === 'Debuff' || statusDef.type === 'DoT' || statusDef.type === 'Control');
                
                // Check default targeting behavior if not explicitly specified
                // By default, buffs go to allies and debuffs go to enemies
                if (effect.targetAllies === undefined && effect.targetEnemies === undefined) {
                    if (isBuffType && !isTargetAlly) applyStatus = false;
                    if (isDebuffType && isTargetAlly) applyStatus = false;
                }
                
                // Check if the status effect has a chance component
                if (effect.chance && effect.chance < 1.0) {
                    // Only apply if random roll succeeds
                    applyStatus = applyStatus && (Math.random() < effect.chance);
                    if (!applyStatus) {
                        this.battleManager.logMessage(`${actorInfo}'s attempt to inflict ${statusId} failed!`, 'info');
                    }
                }
                
                // Apply the status effect if applicable
                if (applyStatus) {
                    // Get status name for better messaging
                    const statusName = statusDef ? statusDef.name : statusId;
                    
                    // Apply status effect using the StatusEffectManager
                    const applied = this.battleManager.statusEffectManager.addStatusEffect(target, statusId, actor, duration, 1); // Added explicit stacks parameter
                    
                    if (applied) {
                        // Log the application
                        if (isBuffType) {
                            this.battleManager.logMessage(`${targetInfo} gains ${statusName} for ${duration} turns!`, 'success');
                        } else {
                            this.battleManager.logMessage(`${targetInfo} is afflicted with ${statusName} for ${duration} turns!`, 'error');
                        }
                        
                        // Update status icons
                        this.battleManager.statusEffectManager.updateStatusIcons(target);
                    }
                }
                break;
                
            case 'StatBuff':
            case 'statBuff':
                // Apply stat buffs based on team relationships
                // By default, positive stat mods go to allies, negative to enemies
                const isPositiveMod = !effect.value || effect.value > 0;
                
                // Skip if doesn't match team targeting rules
                if ((isPositiveMod && !isTargetAlly && effect.targetEnemies !== true) ||
                    (!isPositiveMod && isTargetAlly && effect.targetAllies !== true)) {
                    break;
                }
                
                // Not fully implemented yet, will add in Pass 6 with status effect system refactor
                this.battleManager.logMessage(`${targetInfo} receives a stat modification from ${actorInfo}!`, 'info');
                
                // For now, map common stat buffs to existing status effects
                if (effect.targetStat === 'Attack') {
                    // Updated to use consistent 5-parameter format with explicit source and stacks
                    this.battleManager.addStatusEffect(target, isPositiveMod ? 'status_atk_up' : 'status_atk_down', actor, effect.duration || 3, 1);
                } else if (effect.targetStat === 'Defense') {
                    // Updated to use consistent 5-parameter format with explicit source and stacks
                    this.battleManager.addStatusEffect(target, isPositiveMod ? 'status_def_up' : 'status_def_down', actor, effect.duration || 3, 1);
                }
                break;
                
            default:
                // Unknown effect type
                this.battleManager.logMessage(`Unknown effect type: ${effect.type}`, 'info');
        }
    }

    /**
     * Apply a random status effect to a character
     * @param {Object} target - The character to affect
     * REFACTORING: Extracted from BattleManager.applyRandomStatusEffect
     */
    applyRandomStatusEffect(target) {
        // Defensive check for target
        if (!target) {
            console.error("[AbilityProcessor] Cannot apply random status effect to undefined target");
            return;
        }

        // Defensive check for StatusEffectManager
        if (!this.battleManager.statusEffectManager) {
            console.error("[AbilityProcessor] StatusEffectManager component not found! Cannot apply random status effect.");
            return;
        }
        
        // Get all damage over time effects from definitions if available
        let possibleEffects = [];
        let statusDefinitions = null;
        
        // Get status definitions based on which component is available
        if (this.battleManager.statusEffectLoader) {
            // New implementation with loader
            statusDefinitions = this.battleManager.statusEffectLoader.getAllDefinitions();
        } else if (this.battleManager.statusEffectDefinitions) {
            // Original implementation
            statusDefinitions = this.battleManager.statusEffectDefinitions;
        }
        
        if (statusDefinitions) {
            // Get all DoT effects from the definitions
            const dotEffects = Object.entries(statusDefinitions)
                .filter(([id, def]) => def.type === 'DoT' || def.type === 'Debuff')
                .map(([id, def]) => ({ id, duration: def.defaultDuration || 2 }));
            
            if (dotEffects.length > 0) {
                possibleEffects = dotEffects;
            }
        }
        
        // Fallback to hardcoded effects if no definitions or filtered list is empty
        if (possibleEffects.length === 0) {
            possibleEffects = [
                { id: 'status_burn', duration: 2 },
                { id: 'status_stun', duration: 1 },
                { id: 'status_spd_down', duration: 2 }
            ];
        }
        
        // Select a random effect
        const randomEffect = possibleEffects[Math.floor(Math.random() * possibleEffects.length)];
        
        // Apply the effect
        const applied = this.battleManager.statusEffectManager.addStatusEffect(
            target, 
            randomEffect.id, 
            null, // No source for random effects
            randomEffect.duration,
            1 // Explicit stacks parameter
        );
        
        if (applied) {
            // Get effect name for better messaging
            let effectName = randomEffect.id;
            if (statusDefinitions && statusDefinitions[randomEffect.id]) {
                effectName = statusDefinitions[randomEffect.id].name || randomEffect.id;
            }
            
            // Log the application with team identifier
            const targetTeamId = target.team === 'player' ? ' (ally)' : ' (enemy)';
            this.battleManager.logMessage(`${target.name}${targetTeamId} is afflicted with ${effectName} for ${randomEffect.duration} turns!`, 'error');
            
            // Update status icons
            this.battleManager.statusEffectManager.updateStatusIcons(target);
        }
    }
}

// Make AbilityProcessor available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.AbilityProcessor = AbilityProcessor;
  console.log("AbilityProcessor class definition loaded and exported to window.AbilityProcessor");
}

// Legacy global assignment for maximum compatibility
window.AbilityProcessor = AbilityProcessor;

===== FILE: ActionGenerator.js =====
/**
 * ActionGenerator.js
 * Generates character actions for combat
 * Version 0.5.26.3_Hotfix3 - Added comprehensive target validation
 */
class ActionGenerator {
    /**
     * Create a new Action Generator
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        
        // Store references to required components
        this.targetingSystem = battleManager.targetingSystem;
        this.damageCalculator = battleManager.damageCalculator;
        
        // Log initialization with version info
        console.log("[ActionGenerator] Version 0.5.26.3_Hotfix3 - Initializing ActionGenerator component");
    }

    /**
     * Generate an action for a character
     * @param {Object} character - The character
     * @param {string} team - 'player' or 'enemy'
     * @returns {Object|null} The action or null
     */
    generateCharacterAction(character, team) {
        // 1. Parameter validation
        if (!character) {
            console.error("[ActionGenerator] Cannot generate action: character is null or undefined");
            return null;
        }
        
        // HOTFIX3: Validate that character has required properties
        if (!this.validateCharacter(character)) {
            console.error(`[ActionGenerator] Character ${character.name || 'unknown'} failed validation, cannot generate action`);
            return null;
        }
        
        // 2. Character state validation
        if (character.isDead || character.currentHp <= 0) {
            return null;
        }
        
        // 3. Assign team to character if not already set
        character.team = team;
        
        // 4. Check for status effects preventing action
        const characterId = character.uniqueId || character.id;
        if (this.battleManager.statusEffects[characterId]?.stun) {
            this.battleManager.logMessage(`${character.name} is stunned and cannot act!`, 'info');
            return null;
        }
        
        // 5. Ability selection
        const selectedAbility = this.selectAbility(character);
        const useAbility = !!selectedAbility;
        
        // 6. Target selection using TargetingSystem
        let target = null;
        
        if (this.targetingSystem) {
            // FIXED FRIENDLY FIRE BUG: Pre-filter potential targets for auto-attacks
            let potentialTargetsForSystem;
            
            if (!selectedAbility) {
                // For auto-attacks, only include valid enemies
                const allLivingCharacters = [...this.battleManager.playerTeam, ...this.battleManager.enemyTeam]
                    .filter(char => this.validateCharacter(char) && char && !char.isDead && char.currentHp > 0);
                
                const oppositeTeam = character.team === 'player' ? 'enemy' : 'player';
                potentialTargetsForSystem = allLivingCharacters.filter(char => char.team === oppositeTeam);
                
                // TEMPORARY DIAGNOSTIC - Remove after bug fix
                console.log(`[ActionGenerator] AUTO-ATTACK for ${character.name} (Team: ${character.team}). Potential ENEMY targets:`, 
                    potentialTargetsForSystem.map(p => ({name: p.name, team: p.team})));
                if (potentialTargetsForSystem.length === 0) {
                    console.warn(`[ActionGenerator] AUTO-ATTACK for ${character.name}: No valid enemy targets found!`);
                }
            } else {
                // For specific abilities, use a broader list as the ability's own targeting logic will apply
                potentialTargetsForSystem = [...this.battleManager.playerTeam, ...this.battleManager.enemyTeam]
                    .filter(char => this.validateCharacter(char) && char && !char.isDead && char.currentHp > 0);
                
                // TEMPORARY DIAGNOSTIC - Remove after bug fix
                console.log(`[ActionGenerator] ABILITY (${selectedAbility.name}) for ${character.name}. All potential targets:`, 
                    potentialTargetsForSystem.map(p => ({name: p.name, team: p.team})));
            }
            
            // TEMPORARY DIAGNOSTIC - Remove after bug fix
            console.log(`[ActionGenerator] Actor: ${character.name} (Team: ${character.team})`);
            console.log(`[ActionGenerator] selectedAbility: ${selectedAbility ? selectedAbility.name : 'Auto-Attack'}`);
            console.log(`[ActionGenerator] Potential targets for TargetingSystem:`, 
                potentialTargetsForSystem.map(p => ({name: p.name, team: p.team, hp: p.currentHp, defeated: p.isDead })));
            
            target = this.targetingSystem.selectTarget(character, selectedAbility, potentialTargetsForSystem);
        } else {
            // Fallback targeting
            console.warn("[ActionGenerator] TargetingSystem not available, using fallback targeting");
            target = this.fallbackTargeting(character, team);
        }
        
        // 7. If no valid target, return null
        if (!target) {
            console.warn(`[ActionGenerator] No valid target found for ${character.name}`);
            return null;
        }
        
        // HOTFIX7: Handle multi-target validation for abilities targeting multiple enemies
        // Check if target is an array (multi-target ability like 'AllEnemies')
        if (Array.isArray(target)) {
            console.log(`[ActionGenerator] Multi-target ability detected for ${character.name} with ${target.length} targets`);
            
            // Validate each individual target in the array
            const validTargets = [];
            let hasInvalidTarget = false;
            
            for (let i = 0; i < target.length; i++) {
                const individualTarget = target[i];
                
                // Skip null targets or validate each target
                if (!individualTarget) {
                    console.warn(`[ActionGenerator] Null target found in multi-target array at index ${i}`);
                    continue; // Skip this target but continue processing others
                }
                
                if (!this.validateCharacter(individualTarget)) {
                    console.error(`[ActionGenerator] Target ${individualTarget.name || 'unknown'} at index ${i} failed validation`);
                    hasInvalidTarget = true;
                    continue; // Skip invalid targets
                }
                
                // If it passed validation, add to valid targets
                validTargets.push(individualTarget);
            }
            
            // If we have no valid targets, abort the action
            if (validTargets.length === 0) {
                console.error(`[ActionGenerator] All targets in multi-target ability failed validation, aborting action`);
                return null;
            }
            
            // Replace target array with only valid targets
            target = validTargets.length === 1 ? validTargets[0] : validTargets;
            
            // Log if we filtered out any invalid targets
            if (hasInvalidTarget) {
                console.warn(`[ActionGenerator] Some targets were invalid and filtered out. Proceeding with ${validTargets.length} valid targets.`);
            }
        } else {
            // Single target validation (original behavior)
            // Validate the single target
            if (!this.validateCharacter(target)) {
                console.error(`[ActionGenerator] Target ${target.name || 'unknown'} failed validation, aborting action`);
                return null;
            }
        }
        
        // 8. Calculate damage for selected action
        // HOTFIX8: Handle multi-target abilities properly for damage calculation
        let damageResult;
        let multiTargetDamageResults = [];
        
        // If we're dealing with a multi-target ability (target is an array)
        if (Array.isArray(target)) {
            console.log(`[ActionGenerator] Creating multi-target action for ${character.name} with ${target.length} targets`);
            
            // Calculate damage for each individual target
            for (let i = 0; i < target.length; i++) {
                const individualTarget = target[i];
                
                // Calculate damage for this specific target
                const individualDamageResult = this.calculateDamageForAction(character, individualTarget, selectedAbility);
                
                // Store the result with the target
                multiTargetDamageResults.push({
                    target: individualTarget,
                    damageResult: individualDamageResult
                });
            }
            
            // Use the first damage result for the main action
            // (BattleFlowController will handle processing each target)
            damageResult = multiTargetDamageResults.length > 0 ? 
                multiTargetDamageResults[0].damageResult : 
                {
                    damage: 0,
                    scalingText: '',
                    scalingStat: 0,
                    damageType: selectedAbility ? (selectedAbility.damageType || 'physical') : 'physical'
                };
        } else {
            // Regular single-target damage calculation
            damageResult = this.calculateDamageForAction(character, target, selectedAbility);
        }
        
        // 9. Create and return the action object
        const action = {
            actor: character,
            target: target,
            team: team,
            useAbility: useAbility,
            ability: selectedAbility,
            damage: damageResult.damage,
            scalingText: damageResult.scalingText,
            scalingStat: damageResult.scalingStat,
            damageType: damageResult.damageType
        };
        
        // Set actionType and abilityName properties for proper event dispatching
        if (useAbility && selectedAbility) {
            action.actionType = 'ability';
            action.abilityName = selectedAbility.name;
        } else {
            action.actionType = 'autoAttack';
            action.abilityName = 'Auto Attack';
        }
        
        // Add multi-target data if applicable
        if (multiTargetDamageResults.length > 0) {
            action.isMultiTarget = true;
            action.targetDamages = multiTargetDamageResults.map(result => ({
                target: result.target,
                damage: result.damageResult.damage
            }));
        }
        
        // DIAGNOSTIC: Log the final action object
        console.log(`[ActionGenerator.generateCharacterAction] Final action for ${action.actor?.name}: actionType='${action.actionType}', abilityName='${action.abilityName}', selectedAbility:`, action.ability);
        console.log(`[ActionGenerator.generateCharacterAction] FULL ACTION OBJECT:`, JSON.parse(JSON.stringify(action)));
        
        return action;
    }
    
    /**
     * HOTFIX3: Validate that a character has all required properties
     * @param {Object} character - The character to validate
     * @returns {boolean} True if character has all required properties
     */
    validateCharacter(character) {
        // Basic validation check
        if (!character) return false;
        
        // Must have name property
        if (!character.name) {
            console.error("[ActionGenerator] Character validation failed: missing name property");
            return false;
        }
        
        // Must have stats object
        if (!character.stats) {
            console.error(`[ActionGenerator] Character '${character.name}' validation failed: missing stats object`);
            return false;
        }
        
        // Stats must have required properties
        const requiredStats = ['hp', 'attack', 'defense', 'speed'];
        for (const stat of requiredStats) {
            if (typeof character.stats[stat] !== 'number') {
                console.error(`[ActionGenerator] Character '${character.name}' validation failed: missing or invalid ${stat} stat`);
                return false;
            }
        }
        
        // Must have currentHp property
        if (typeof character.currentHp !== 'number') {
            console.error(`[ActionGenerator] Character '${character.name}' validation failed: missing or invalid currentHp property`);
            return false;
        }
        
        // Must have abilities array
        if (!Array.isArray(character.abilities)) {
            console.error(`[ActionGenerator] Character '${character.name}' validation failed: abilities is not an array`);
            return false;
        }
        
        // Passed all checks
        return true;
    }
    
    /**
     * Select an ability for a character to use
     * @param {Object} character - The character
     * @returns {Object|null} Selected ability or null for basic attack
     */
    selectAbility(character) {
        // 1. Get available abilities (not on cooldown and NOT passive)
        const availableAbilities = character.abilities?.filter(ability => {
            // Skip if ability is undefined or null
            if (!ability) return false;
            
            // Skip passive abilities explicitly marked as such
            if (ability.abilityType === 'Passive' || ability.abilityType === 'passive') return false;
            
            // Also skip abilities with passive-specific properties
            if (ability.passiveTrigger || ability.passiveBehavior) return false;
            
            // Only include abilities not on cooldown
            return ability.currentCooldown === 0;
        }) || [];
        
        // 2. If no abilities available, use basic attack
        if (availableAbilities.length === 0) {
            console.log('[ActionGenerator.selectAbility] Character has no available abilities, using auto-attack');
            return null;
        }
        
        // 3. Debug logging
        console.debug(`[ActionGenerator] ${character.name} has ${availableAbilities.length} available active abilities`);
        console.log('[ActionGenerator.selectAbility] Available abilities:', availableAbilities.map(a => a.name));
        
        // 4. Try to use BattleBehaviors system for ability selection
        let selectedAbility = null;
        
        // NEW LOG A: Check if battleBehaviors is available
        console.log('[ActionGenerator.selectAbility] NEW LOG A - BattleBehaviors available? ', 
                    !!this.battleManager.battleBehaviors, 
                    'battleBehaviors type:', typeof this.battleManager.battleBehaviors);
        
        if (this.battleManager.battleBehaviors) {
            // NEW LOG B: Log details about the battleBehaviors object
            console.log('[ActionGenerator.selectAbility] NEW LOG B - Character actionDecisionLogic:', 
                         character.actionDecisionLogic);
            console.log('[ActionGenerator.selectAbility] NEW LOG C - battleBehaviors methods:', 
                        {
                            hasBehavior: typeof this.battleManager.battleBehaviors.hasBehavior === 'function',
                            decideAction: typeof this.battleManager.battleBehaviors.decideAction === 'function',
                            getDefaultActionDecisionBehavior: typeof this.battleManager.battleBehaviors.getDefaultActionDecisionBehavior === 'function'
                        });
            
            // Check required methods are functions
            if (typeof this.battleManager.battleBehaviors.hasBehavior !== 'function') {
                console.error('[ActionGenerator.selectAbility] ERROR: this.battleManager.battleBehaviors.hasBehavior is NOT a function!');
            }
            if (typeof this.battleManager.battleBehaviors.decideAction !== 'function') {
                console.error('[ActionGenerator.selectAbility] ERROR: this.battleManager.battleBehaviors.decideAction is NOT a function!');
            }
            
            // Create context for action decision
            const decisionContext = {
                actor: character,
                availableAbilities: availableAbilities,
                battleManager: this.battleManager,
                teamManager: { getCharacterTeam: (char) => char.team }
            };
            
            // NEW LOG D: Log decision context
            console.log('[ActionGenerator.selectAbility] NEW LOG D - Decision context created:', 
                        { actorName: decisionContext.actor.name, availableAbilityCount: decisionContext.availableAbilities.length });
            
            try {
                // NEW LOG E: About to determine which behavior to use
                console.log('[ActionGenerator.selectAbility] NEW LOG E - About to determine behavior. Character actionDecisionLogic:', character.actionDecisionLogic);
                
                // Check if character has specific actionDecisionLogic
                const decisionLogic = character.actionDecisionLogic;
                
                // NEW LOG F: Log behavior choice
                const usingCustomLogic = decisionLogic && this.battleManager.battleBehaviors.hasBehavior(decisionLogic);
                console.log('[ActionGenerator.selectAbility] NEW LOG F - Using', 
                            usingCustomLogic ? `custom logic: ${decisionLogic}` : 'default action decision behavior');
                
                // Try to get default behavior before using it
                const defaultBehavior = this.battleManager.battleBehaviors.getDefaultActionDecisionBehavior && 
                                        this.battleManager.battleBehaviors.getDefaultActionDecisionBehavior();
                console.log('[ActionGenerator.selectAbility] NEW LOG G - Default behavior:', defaultBehavior);
                
                // Use that behavior if available, otherwise use default
                if (usingCustomLogic) {
                    // NEW LOG H: About to call decideAction with custom logic
                    console.log('[ActionGenerator.selectAbility] NEW LOG H - About to call decideAction with custom logic:', decisionLogic);
                    
                    selectedAbility = this.battleManager.battleBehaviors.decideAction(decisionLogic, decisionContext);
                    
                    // NEW LOG I: Result from decideAction with custom logic
                    console.log('[ActionGenerator.selectAbility] NEW LOG I - Result from decideAction (custom):', 
                                selectedAbility ? selectedAbility.name : 'null (auto-attack)');
                } else {
                    // NEW LOG J: About to call decideAction with default logic
                    console.log('[ActionGenerator.selectAbility] NEW LOG J - About to call decideAction with default logic:', defaultBehavior);
                    
                    selectedAbility = this.battleManager.battleBehaviors.decideAction(
                        defaultBehavior,
                        decisionContext
                    );
                    
                    // NEW LOG K: Result from decideAction with default logic
                    console.log('[ActionGenerator.selectAbility] NEW LOG K - Result from decideAction (default):', 
                                selectedAbility ? selectedAbility.name : 'null (auto-attack)');
                }
                
                // If an ability was selected, set its cooldown
                if (selectedAbility) {
                    console.log('[ActionGenerator.selectAbility] NEW LOG L - Setting cooldown for selected ability:', selectedAbility.name);
                    selectedAbility.currentCooldown = selectedAbility.cooldown || 3;
                    return selectedAbility; // Return immediately if behavior system provided a result
                }
            } catch (error) {
                console.error('[ActionGenerator] Error in action decision behavior:', error);
                selectedAbility = null;
            }
        } else {
            // 5. Fallback ability selection when behavior system not available
            console.log('[ActionGenerator.selectAbility] Using fallback ability selection (behavior system not available)');
            // 50% chance to use an ability if available
            if (Math.random() > 0.5) {
                selectedAbility = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                // Set cooldown
                selectedAbility.currentCooldown = selectedAbility.cooldown || 3;
                console.log('[ActionGenerator.selectAbility] Fallback selected:', selectedAbility.name);
            } else {
                console.log('[ActionGenerator.selectAbility] Fallback chose auto-attack');
            }
        }
        
        return selectedAbility;
    }
    
    /**
     * Fallback targeting when TargetingSystem is not available
     * @param {Object} character - The character taking action
     * @param {string} team - The character's team ('player' or 'enemy')
     * @returns {Object|null} Selected target or null
     */
    fallbackTargeting(character, team) {
        // HOTFIX3: Ensure proper team-based targeting with validation
        const oppositeTeam = team === 'player' ? 'enemy' : 'player';
        const teamToTarget = oppositeTeam === 'player' ? this.battleManager.playerTeam : this.battleManager.enemyTeam;
        
        if (!teamToTarget || teamToTarget.length === 0) {
            console.warn(`[ActionGenerator] No ${oppositeTeam} team available for targeting`);
            return null;
        }
        
        // Filter for living, valid targets
        const validTargets = teamToTarget.filter(target => {
            return target && 
                  target.currentHp > 0 && 
                  !target.isDead &&
                  this.validateCharacter(target); // HOTFIX3: Add validation check
        });
        
        if (validTargets.length === 0) {
            console.warn(`[ActionGenerator] No valid targets found in ${oppositeTeam} team`);
            return null;
        }
        
        // Select a random target
        return validTargets[Math.floor(Math.random() * validTargets.length)];
    }
    
    /**
     * Calculate damage for an action
     * @param {Object} attacker - The character taking action
     * @param {Object} target - The target of the action
     * @param {Object|null} ability - The ability being used (null for auto-attack)
     * @returns {Object} Damage calculation result
     */
    calculateDamageForAction(attacker, target, ability) {
        // HOTFIX8: Handle multi-target arrays that might be passed directly
        if (Array.isArray(target)) {
            console.error(`[ActionGenerator] calculateDamageForAction received a target array instead of a single target. This is likely a bug in the multi-target handling code. Using first valid target.`);
            // Try to find a valid target in the array
            let validTarget = null;
            for (const individualTarget of target) {
                if (individualTarget && typeof individualTarget === 'object' && individualTarget.name) {
                    validTarget = individualTarget;
                    break;
                }
            }
            
            // If we found a valid target, use it; otherwise abort
            if (validTarget) {
                console.warn(`[ActionGenerator] Using ${validTarget.name} as fallback from target array`);
                target = validTarget;
            } else {
                console.error(`[ActionGenerator] No valid targets found in target array`);
                return {
                    damage: 0,
                    scalingText: '',
                    scalingStat: 0,
                    damageType: ability ? (ability.damageType || 'physical') : 'physical'
                };
            }
        }
        
        // HOTFIX3: Validate characters before calculating damage
        if (!this.validateCharacter(attacker)) {
            console.error(`[ActionGenerator] Cannot calculate damage: attacker '${attacker?.name || 'unknown'}' failed validation`);
            return {
                damage: 0,
                scalingText: '',
                scalingStat: 0,
                damageType: ability ? (ability.damageType || 'physical') : 'physical'
            };
        }
        
        if (!this.validateCharacter(target)) {
            console.error(`[ActionGenerator] Cannot calculate damage: target '${target?.name || 'unknown'}' failed validation`);
            return {
                damage: 0,
                scalingText: '',
                scalingStat: 0,
                damageType: ability ? (ability.damageType || 'physical') : 'physical'
            };
        }
        
        // Use DamageCalculator if available
        if (this.damageCalculator) {
            return this.damageCalculator.calculateDamage(attacker, target, ability);
        }
        
        // Fallback to BattleManager's method if DamageCalculator not available
        if (this.battleManager.calculateDamage) {
            return this.battleManager.calculateDamage(attacker, target, ability);
        }
        
        // Extreme fallback - return minimal safe values
        console.error("[ActionGenerator] No damage calculation method available!");
        return {
            damage: attacker.stats.attack || 10,
            scalingText: '',
            scalingStat: 0,
            damageType: ability ? (ability.damageType || 'physical') : 'physical'
        };
    }
}

// Make ActionGenerator available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.ActionGenerator = ActionGenerator;
    console.log("ActionGenerator class definition loaded and exported to window.ActionGenerator");
}

// Legacy global assignment for maximum compatibility
window.ActionGenerator = ActionGenerator;

===== FILE: TargetingSystem.js =====
/**
 * TargetingSystem.js
 * Handles target selection for abilities and attacks
 * Version 0.5.26.3_Hotfix - Fixed API mismatch with battleBehaviors.selectTarget
 */

class TargetingSystem {
    /**
     * Create a new Targeting System
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        
        // Log initialization with version info
        console.log("[TargetingSystem] Version 0.5.26.3_Hotfix - Initializing TargetingSystem component");
    }

    /**
     * Select a target for an ability
     * @param {Object} actor - The actor performing the ability
     * @param {Object} ability - The ability being used
     * @param {Array} potentialTargets - Array of potential targets
     * @returns {Object|Array} Selected target(s)
     */
    selectTarget(actor, ability, potentialTargets) {
        // 1. Defensive parameter validation
        if (!actor) {
            console.error("[TargetingSystem] Cannot select target for undefined actor");
            return null;
        }
        
        if (!potentialTargets || !Array.isArray(potentialTargets) || potentialTargets.length === 0) {
            console.warn(`[TargetingSystem] No valid targets available for ${actor.name}`);
            return null;
        }
        
        // 2. Determine the appropriate targeting behavior
        const targetingBehavior = this.resolveTargetingBehavior(actor, ability);
        
        // 3. Create targeting context
        const targetingContext = this.createTargetingContext(actor, ability, potentialTargets);
        
        // 4. Execute targeting behavior
        try {
            if (!this.battleManager.battleBehaviors) {
                console.error("[TargetingSystem] BattleBehaviors not available!");
                // Fallback to simple random enemy targeting
                return this.fallbackTargeting(actor, potentialTargets);
            }
            
            // HOTFIX: Use selectTarget method instead of executeTargetingBehavior
            // This fixes the API mismatch with BattleBehaviors system
            const target = this.battleManager.battleBehaviors.selectTarget(
                targetingBehavior, 
                targetingContext
            );
            
            // 5. Process targeting result
            return this.processTargetingResult(target, actor, ability);
            
        } catch (error) {
            console.error(`[TargetingSystem] Error executing targeting behavior '${targetingBehavior}':`, error);
            // Fallback to simple targeting
            return this.fallbackTargeting(actor, potentialTargets);
        }
    }
    
    /**
     * Determine which targeting behavior to use based on the actor and ability
     * @param {Object} actor - The actor performing the ability
     * @param {Object} ability - The ability being used
     * @returns {string} The targeting behavior to use
     */
    resolveTargetingBehavior(actor, ability) {
        // TEMPORARY DIAGNOSTIC - Remove after bug fix
        console.log(`[TargetingSystem.resolveTargetingBehavior] Actor: ${actor.name} (Team: ${actor.team})`);
        console.log(`[TargetingSystem.resolveTargetingBehavior] Ability: ${ability ? ability.name : 'Auto-Attack'}, Type: ${ability?.targetType || 'N/A'}, Logic: ${ability?.targetingLogic || 'N/A'}`);
        
        if (!this.battleManager.battleBehaviors) {
            console.log(`[TargetingSystem.resolveTargetingBehavior] No battleBehaviors available, using default 'targetRandomEnemy'`);
            return 'targetRandomEnemy'; // Default behavior
        }
        
        // 1. Check if ability has explicit targeting logic
        if (ability && ability.targetingLogic) {
            console.log(`[TargetingSystem.resolveTargetingBehavior] Using explicit targetingLogic: ${ability.targetingLogic}`);
            return ability.targetingLogic;
        }
        
        // 2. Use type-based targeting if specified
        if (ability && ability.targetType) {
            const typeBehavior = this.battleManager.battleBehaviors.getTargetingBehaviorFromType(ability.targetType);
            if (typeBehavior) {
                console.log(`[TargetingSystem.resolveTargetingBehavior] Using targetType mapping: ${ability.targetType} â†’ ${typeBehavior}`);
                return typeBehavior;
            }
        }
        
        // 3. Use smart targeting based on ability properties
        if (ability) {
            // Healing abilities target allies by default
            if (ability.isHealing || ability.damageType === 'healing') {
                console.log(`[TargetingSystem.resolveTargetingBehavior] Using healing targeting behavior: targetLowestHpAlly`);
                return 'targetLowestHpAlly';
            }
            
            // Utility abilities (buffs) often target self
            if (ability.damageType === 'utility') {
                console.log(`[TargetingSystem.resolveTargetingBehavior] Using utility targeting behavior: targetSelf`);
                return 'targetSelf';
            }
            
            // AoE abilities use appropriate multi-target behavior
            if (ability.isAoE || ability.targetType === 'AllEnemies') {
                console.log(`[TargetingSystem.resolveTargetingBehavior] Using AoE targeting behavior: targetAllEnemies`);
                return 'targetAllEnemies';
            }
        }
        
        // 4. Fall back to default targeting behavior
        const defaultBehavior = this.battleManager.battleBehaviors.getDefaultTargetingBehavior() || 'targetRandomEnemy';
        console.log(`[TargetingSystem.resolveTargetingBehavior] Using default targeting behavior: ${defaultBehavior}`);
        return defaultBehavior;
    }
    
    /**
     * Create a targeting context for the behavior system
     * @param {Object} actor - The actor performing the ability
     * @param {Object} ability - The ability being used
     * @param {Array} potentialTargets - Array of potential targets
     * @returns {Object} The targeting context
     */
    createTargetingContext(actor, ability, potentialTargets) {
        // Filter for living targets only
        const livingTargets = potentialTargets.filter(target => {
            return target && target.currentHp > 0 && !target.isDead;
        });
        
        // Create standard context object expected by targeting behaviors
        return {
            actor: actor,
            potentialTargets: livingTargets,
            teamManager: this.battleManager.teamManager,
            ability: ability,
            battleManager: this.battleManager
        };
    }
    
    /**
     * Process the targeting result to handle edge cases
     * @param {Object|Array|null} target - The targeting result
     * @param {Object} actor - The actor performing the ability
     * @param {Object} ability - The ability being used
     * @returns {Object|Array|null} The processed target(s)
     */
    processTargetingResult(target, actor, ability) {
        // Handle null or undefined result
        if (!target) {
            console.warn(`[TargetingSystem] No target found for ${actor.name}'s ${ability ? ability.name : 'attack'}`);
            return null;
        }
        
        // TEMPORARY DIAGNOSTIC - Remove after bug fix
        console.log(`[TargetingSystem.processTargetingResult] Initial target for ${actor.name}'s ${ability ? ability.name : 'Auto-Attack'}: ${Array.isArray(target) ? `[${target.map(t => t.name).join(', ')}]` : target.name}`);
        
        // Arrays are valid for multi-target abilities
        if (Array.isArray(target)) {
            // Filter out any invalid targets
            const validTargets = target.filter(t => {
                const isValid = t && t.currentHp > 0 && !t.isDead;
                
                // TEMPORARY DIAGNOSTIC - Remove after bug fix
                console.log(`  Multi-target check: ${t?.name || 'undefined'} (HP: ${t?.currentHp || 'N/A'}, isDead: ${t?.isDead || 'N/A'}) - Valid: ${isValid}`);
                
                return isValid;
            });
            
            if (validTargets.length === 0) {
                console.warn(`[TargetingSystem] No valid targets in multi-target selection for ${actor.name}`);
                return null;
            }
            
            // TEMPORARY DIAGNOSTIC - Remove after bug fix
            console.log(`[TargetingSystem.processTargetingResult] Final multi-targets: [${validTargets.map(t => t.name).join(', ')}]`);
            
            return validTargets;
        }
        
        // Single target - verify it's valid
        const isValidSingleTarget = target.currentHp > 0 && !target.isDead;
        
        // TEMPORARY DIAGNOSTIC - Remove after bug fix
        console.log(`[TargetingSystem.processTargetingResult] Single target check: ${target.name} (HP: ${target.currentHp}, isDead: ${target.isDead}, Team: ${target.team}) - Valid: ${isValidSingleTarget}`);
        
        if (!isValidSingleTarget) {
            console.warn(`[TargetingSystem] Selected target ${target.name} is not valid (HP: ${target.currentHp}, isDead: ${target.isDead})`);
            return null;
        }
        
        // TEMPORARY DIAGNOSTIC - Remove after bug fix
        console.log(`[TargetingSystem.processTargetingResult] Final single target: ${target.name} (Team: ${target.team})`);
        
        return target;
    }
    
    /**
     * Simple fallback targeting when behavior system fails
     * @param {Object} actor - The actor performing the ability
     * @param {Array} potentialTargets - Array of potential targets
     * @returns {Object|null} A simple target selection
     */
    fallbackTargeting(actor, potentialTargets) {
        // Filter for living targets of the opposite team
        const actorTeam = actor.team;
        const opposingTeam = actorTeam === 'player' ? 'enemy' : 'player';
        
        const validTargets = potentialTargets.filter(target => {
            return target && 
                  target.currentHp > 0 && 
                  !target.isDead && 
                  target.team === opposingTeam;
        });
        
        if (validTargets.length === 0) {
            return null;
        }
        
        // Select a random target
        return validTargets[Math.floor(Math.random() * validTargets.length)];
    }
}

// Make TargetingSystem available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.TargetingSystem = TargetingSystem;
  console.log("TargetingSystem class definition loaded and exported to window.TargetingSystem");
}

// Legacy global assignment for maximum compatibility
window.TargetingSystem = TargetingSystem;

===== FILE: BattleFlowController.js =====
/**
 * BattleFlowController.js
 * Controls the flow of battle, turn sequencing, and action execution
 */

class BattleFlowController {
    /**
     * Create a new Battle Flow Controller
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        this.currentTurn = 0;
        this.turnInProgress = false;
        this.actionQueue = [];
        this.turnActions = [];
    }

    /**
     * Start a battle with the given teams
     * @param {Array} playerTeam - Array of player characters
     * @param {Array} enemyTeam - Array of enemy characters
     */
    async startBattle(playerTeam, enemyTeam) {
        try {
            console.log("[BattleFlowController] Starting battle with proper implementation");
            
            // Load status effect definitions if needed
            if (!this.battleManager.statusEffectDefinitions) {
                try {
                    await this.battleManager.loadStatusEffectDefinitions();
                    console.log('[BattleFlowController] Status effect definitions loaded');
                } catch (error) {
                    console.warn('[BattleFlowController] Could not load status effect definitions:', error);
                    // Setup fallback definitions
                    this.battleManager.setupFallbackStatusEffects();
                }
            }
            
            // Initialize behavior system if needed
            if (!this.battleManager.battleBehaviors) {
                try {
                    await this.battleManager.initializeBehaviorSystem();
                    console.log('[BattleFlowController] Battle behavior system initialized');
                } catch (error) {
                    console.warn('[BattleFlowController] Could not initialize behavior system:', error);
                }
            }
            
            // Check UI based on mode
            if (this.battleManager.uiMode === "phaser") {
                console.log('[BattleFlowController] Using Phaser scene for battle visualization');
            } else if (this.battleManager.uiMode === "dom" && !this.battleManager.battleUI) {
                // Only initialize DOM UI if in DOM mode and UI not already initialized
                console.log('[BattleFlowController] Initializing DOM battle UI');
                if (typeof window.BattleUI === 'undefined') {
                    console.error('[BattleFlowController] BattleUI class is not defined!');
                } else {
                    this.battleManager.battleUI = new window.BattleUI(this.battleManager.scene, this.battleManager);
                    this.battleManager.battleUI.initialize();
                }
            }

            // Validate player team
            if (!playerTeam || !Array.isArray(playerTeam)) {
                console.warn('[BattleFlowController] Invalid playerTeam provided, using empty array');
                playerTeam = [];
            }
            
            // Deep copy the player team to avoid reference issues
            const playerTeamCopy = playerTeam.length > 0 ? JSON.parse(JSON.stringify(playerTeam)) : [];
            console.log(`[BattleFlowController] PlayerTeam before preparation: ${playerTeamCopy.length} heroes`);            
            // DIAGNOSTIC (REMOVE LATER): Added log before player team preparation
            console.log('[BattleFlowController.startBattle] Attempting to prepare player team via BattleManager.');
            
            // Store the prepared player team directly in BattleManager
            this.battleManager.playerTeam = this.battleManager.prepareTeamForBattle(playerTeamCopy);
            console.log(`[BattleFlowController] PlayerTeam after preparation: ${this.battleManager.playerTeam.length} heroes`);
            
            // Check if enemy team is empty or undefined and generate one if needed
            if (!enemyTeam || enemyTeam.length === 0) {
                console.log('[BattleFlowController] No enemy team provided, generating a random one');
                // Create a simple enemy team
                enemyTeam = [
                    {
                        id: 4,
                        name: "Vaelgor",
                        type: "dark",
                        role: "Knight",
                        stats: {
                            hp: 120,
                            attack: 18,
                            defense: 12
                        },
                        abilities: [
                            {
                                name: "Shadow Strike",
                                damage: 28,
                                cooldown: 3,
                                isHealing: false,
                                description: "Attacks from the shadows for heavy damage"
                            },
                            {
                                name: "Void Barrier",
                                damage: 20,
                                cooldown: 4,
                                isHealing: true,
                                description: "Creates a barrier of dark energy that absorbs damage"
                            }
                        ]
                    },
                    {
                        id: 3,
                        name: "Sylvanna",
                        type: "nature",
                        role: "Ranger",
                        stats: {
                            hp: 90,
                            attack: 15,
                            defense: 15
                        },
                        abilities: [
                            {
                                name: "Vine Whip",
                                damage: 20,
                                cooldown: 2,
                                isHealing: false,
                                description: "Strikes with vines that can ensnare the target"
                            },
                            {
                                name: "Nature's Blessing",
                                damage: 25,
                                cooldown: 4,
                                isHealing: true,
                                description: "Channels the power of nature to heal wounds"
                            }
                        ]
                    },
                    {
                        id: 5,
                        name: "Lumina",
                        type: "light",
                        role: "Cleric",
                        stats: {
                            hp: 85,
                            attack: 16,
                            defense: 14
                        },
                        abilities: [
                            {
                                name: "Holy Smite",
                                damage: 22,
                                cooldown: 3,
                                isHealing: false,
                                description: "Channels divine light into a powerful attack"
                            },
                            {
                                name: "Divine Protection",
                                damage: 26,
                                cooldown: 4,
                                isHealing: true,
                                description: "Surrounds an ally with divine light, healing wounds"
                            }
                        ]
                    }
                ];
            }
            
            // Validate enemy team
            if (!enemyTeam || !Array.isArray(enemyTeam)) {
                console.warn('[BattleFlowController] Invalid enemyTeam provided, using empty array');
                enemyTeam = [];
            }
            
            // Deep copy the enemy team
            const enemyTeamCopy = enemyTeam.length > 0 ? JSON.parse(JSON.stringify(enemyTeam)) : [];
            console.log(`[BattleFlowController] EnemyTeam before preparation: ${enemyTeamCopy.length} enemies`);
            
            // DIAGNOSTIC (REMOVE LATER): Added log before enemy team preparation
            console.log('[BattleFlowController.startBattle] Attempting to prepare enemy team via BattleManager.');
            
            // Store the prepared enemy team directly in BattleManager
            this.battleManager.enemyTeam = this.battleManager.prepareTeamForBattle(enemyTeamCopy);
            console.log(`[BattleFlowController] EnemyTeam after preparation: ${this.battleManager.enemyTeam.length} enemies`);
            
            // Reset battle state variables
            this.battleManager.currentTurn = 0;
            this.battleManager.battleActive = true;
            this.battleManager.isPaused = false;
            this.battleManager.activeCharacterIndex = 0;
            this.battleManager.actionQueue = [];
            this.battleManager.turnActions = [];
            this.battleManager.turnInProgress = false;
            this.battleManager.statusEffects = {};
            
            // TEMPORARY DIAGNOSTIC - Remove after bug fix
            console.log(`[BattleFlowController] DIAGNOSTIC - Post-initialization team status:`);
            console.log(`  Player Team (${this.battleManager.playerTeam.length} characters):`, 
                this.battleManager.playerTeam.map(c => ({ name: c.name, team: c.team, hp: c.currentHp })));
            console.log(`  Enemy Team (${this.battleManager.enemyTeam.length} characters):`, 
                this.battleManager.enemyTeam.map(c => ({ name: c.name, team: c.team, hp: c.currentHp })));
            
            // Initialize passive trigger tracking at battle level
            this.battleManager.passiveTriggersThisBattle = new Map();
            
            // Render characters on UI if DOM mode
            if (this.battleManager.battleUI) {
                this.battleManager.battleUI.renderCharacters(this.battleManager.playerTeam, this.battleManager.enemyTeam);
            }
            
            // Log battle start
            this.battleManager.logMessage('Battle started!', 'info');
            this.battleManager.logMessage(`${this.battleManager.playerTeam.length} heroes vs ${this.battleManager.enemyTeam.length} enemies`, 'info');
            console.log('[BattleFlowController] Battle started with teams:', this.battleManager.playerTeam, this.battleManager.enemyTeam);
            
            // Process battle start passive abilities for all characters
            [...this.battleManager.playerTeam, ...this.battleManager.enemyTeam].forEach(character => {
                if (character.currentHp > 0) {
                    this.battleManager.processPassiveAbilities('onBattleStart', character);
                }
            });
            
            // Start first turn by calling our own method directly
            this.startNextTurn();
            
        } catch (error) {
            console.error('[BattleFlowController] Error starting battle:', error);
            throw error;
        }
    }

    /**
     * Starts the next turn in the battle sequence
     * Migrated from BattleManager.startNextTurn
     */
    async startNextTurn() {
        // Guard clauses
        if (!this.battleManager.battleActive) {
            console.log("[BattleFlowController] Battle not active, cannot start next turn");
            return;
        }
        
        if (this.battleManager.isPaused || this.battleManager.turnInProgress) {
            console.log("[BattleFlowController] Battle is paused or turn already in progress, cannot start next turn");
            return;
        }
        
        // Increment turn counter
        this.battleManager.currentTurn++;
        
        // Log turn started message
        this.battleManager.logMessage(`Turn ${this.battleManager.currentTurn} started`, 'info');
        
        // Set turn in progress flag
        this.battleManager.turnInProgress = true;
        
        // Reset passive triggers for all characters
        this.battleManager.playerTeam.forEach(char => {
            if (char) char.passiveTriggeredThisTurn = {};
        });
        this.battleManager.enemyTeam.forEach(char => {
            if (char) char.passiveTriggeredThisTurn = {};
        });
        
        // Update UI if available
        if (this.battleManager.battleUI) {
            this.battleManager.battleUI.update();
        }
        
        // Process passive abilities for turn start
        this.battleManager.processPassiveAbilities('onTurnStart', null, { turnNumber: this.battleManager.currentTurn });
        
        // Process status effects
        this.battleManager.processStatusEffects();
        
        // Reset action queues
        this.battleManager.actionQueue = [];
        this.battleManager.turnActions = [];
        
        // Generate turn actions
        this.battleManager.generateTurnActions();
        
        // REORDERED: Now determine the current character AFTER generating actions
        const currentChar = this.battleManager.actionQueue && this.battleManager.actionQueue.length > 0 
            ? this.battleManager.actionQueue[0]?.actor 
            : null;
        
        // Dispatch TURN_STARTED event directly through battleBridge
        if (window.battleBridge) {
            try {
                console.log(`[BattleFlowController] Dispatching TURN_STARTED for turn ${this.battleManager.currentTurn}`);
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.TURN_STARTED, {
                    character: currentChar, // Use 'character' for consistency
                    currentCharacter: currentChar, // Keep for backward compatibility
                    turnNumber: this.battleManager.currentTurn
                });
            } catch (error) {
                console.error('[BattleFlowController] Error dispatching TURN_STARTED event:', error);
            }
        }
        
        // Schedule next action
        setTimeout(() => {
            this.battleManager.executeNextAction();
        }, 500);
    }

    /**
     * Generate a set of actions for the current turn
     */
    generateTurnActions() {
        console.log("[BattleFlowController] generateTurnActions called - SHELL IMPLEMENTATION");
        return this.battleManager.generateTurnActions();
    }

    /**
     * Execute the next action in the queue
     * Migrated from BattleManager.executeNextAction
     */
    async executeNextAction() {
        // Guard clauses
        if (!this.battleManager.battleActive || this.battleManager.isPaused) {
            this.battleManager.turnInProgress = false;
            return;
        }
        
        if (this.battleManager.actionQueue.length === 0) {
            this.finishTurn();
            return;
        }
        
        const action = this.battleManager.actionQueue.shift();
        
        // Check if the actor is still alive before proceeding
        if (action.actor.isDefeated || action.actor.currentHp <= 0) {
            console.log(`Skipping action for defeated character: ${action.actor.name}`);
            // Skip to next action
            this.executeNextAction();
            return;
        }
        
        // Check if the target is still alive (unless it's a healing ability)
        const isHealing = action.ability && (action.ability.isHealing || action.ability.damageType === 'healing');
        if (!isHealing && (action.target.isDefeated || action.target.currentHp <= 0)) {
            // Target is defeated, find a new target
            console.log(`Original target defeated, finding new target for ${action.actor.name}`);
            
            // Determine possible targets based on team
            const possibleTargets = action.team === 'player' ? this.battleManager.enemyTeam : this.battleManager.playerTeam;
            
            // Filter for living targets
            const livingTargets = possibleTargets.filter(target => !target.isDefeated && target.currentHp > 0);
            
            if (livingTargets.length === 0) {
                // No valid targets left, skip this action
                console.log(`No valid targets left for ${action.actor.name}, skipping action`);
                this.executeNextAction();
                return;
            }
            
            // Select a new random target
            action.target = livingTargets[Math.floor(Math.random() * livingTargets.length)];
            console.log(`New target selected: ${action.target.name}`);
            
            // Recalculate damage for the new target
            const { damage, scalingText, scalingStat } = this.battleManager.calculateDamage(action.actor, action.target, action.ability);
            action.damage = damage;
            action.scalingText = scalingText;
            action.scalingStat = scalingStat;
        }
        
        // Add team to actor and target if not set
        if (!action.actor.team) {
            action.actor.team = action.team;
        }
        
        if (!action.target.team) {
            action.target.team = action.team === 'player' ? 'enemy' : 'player';
        }
        
        // Generate uniqueId for actor and target if needed
        if (!action.actor.uniqueId) {
            action.actor.uniqueId = `${action.actor.team}_${action.actor.id}`;
        }
        
        if (!action.target.uniqueId) {
            action.target.uniqueId = `${action.target.team}_${action.target.id}`;
        }
        
        // Log the action
        let message;
        // Add team info to actor and target names for better clarity
        const actorName = `${action.actor.name}${action.team === 'player' ? ' (ally)' : ' (enemy)'}`;        
        const targetName = `${action.target.name}${action.team === 'player' ? ' (enemy)' : ' (ally)'}`;        
        
        if (action.useAbility) {
            // Handle different ability types in log message
            if (action.ability.isHealing || action.ability.damageType === 'healing') {
                message = `${actorName} uses [${action.ability.name}] to heal ${targetName}!`;
            } else if (action.ability.damageType === 'utility') {
                message = `${actorName} uses [${action.ability.name}]!`;
            } else {
                message = `${actorName} uses [${action.ability.name}] on ${targetName}!`;
            }
        } else {
            message = `${actorName} attacks ${targetName} for ${action.damage} damage!`;
        }
        this.battleManager.logMessage(message, 'action');
        
        // Generate and log proper action declaration for the battle log
        if (action && action.actor) {
            console.log(`[BattleFlowController.applyActionEffect] Entered for Battle Log. Action received:`, JSON.parse(JSON.stringify(action)));
            
            // Add team identifiers for clarity
            const actorName = `${action.actor.name}${action.team === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Create the message based on action type and target type
            let actionDeclaration = "";
            
            if (action.useAbility && action.ability) {
                // Format for different targeting scenarios
                if (Array.isArray(action.target)) {
                    const targetCount = action.target.length;
                    actionDeclaration = `${actorName} uses [${action.ability.name}] on ${targetCount} targets!`;
                } else {
                    const targetName = `${action.target.name}${action.target.team === 'player' ? ' (ally)' : ' (enemy)'}`;
                    actionDeclaration = `${actorName} uses [${action.ability.name}] on ${targetName}!`;
                }
            } else {
                // Auto attack message
                const targetName = action.target ? `${action.target.name}${action.target.team === 'player' ? ' (ally)' : ' (enemy)'}` : "target";
                actionDeclaration = `${actorName} performs an auto attack on ${targetName}!`;
            }
            
            // Log the action declaration
            console.log(`[BattleFlowController.applyActionEffect] Built actionDeclaration for Battle Log: "${actionDeclaration}"`); 
            console.log(`[BattleFlowController.applyActionEffect] Action object for this declaration:`, JSON.parse(JSON.stringify(action)));
            if (this.battleManager && typeof this.battleManager.logMessage === 'function') {
                console.log(`[BattleFlowController.applyActionEffect] Calling this.battleManager.logMessage for action declaration.`);
                this.battleManager.logMessage(actionDeclaration, 'action');
            } else {
                console.error('[BattleFlowController.applyActionEffect] this.battleManager.logMessage is NOT available or not a function for action declaration!');
            }
        }
        
        // Dispatch CHARACTER_ACTION event directly via BattleBridge
        if (window.battleBridge) {
            try {
                console.log(`[BattleFlowController] Dispatching CHARACTER_ACTION event for ${action.actor.name}`);
                
                // TEMPORARY DIAGNOSTIC - Remove after bug fix
                if (action && action.actor && action.target) {
                    console.log(`[BattleFlowController DIAGNOSTIC] Processed action: ${action.actor.name} (Team: ${action.actor.team}) targeting ${action.target.name ? action.target.name : 'multi-target'} (Target Team: ${action.target.team ? action.target.team : 'N/A'}). Is same team (if single target): ${action.target.name && action.actor.team === action.target.team}`);
                }
                
                if (action.useAbility) {
                    // For ability actions
                    window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_ACTION, {
                        character: action.actor,
                        action: {
                            type: 'ability',
                            actionType: 'ability', // Ensure both type and actionType are set for consistency
                            name: action.ability.name,
                            abilityName: action.ability.name,
                            target: action.target
                        }
                    });
                } else {
                    // For auto-attack actions
                    window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_ACTION, {
                        character: action.actor,
                        action: {
                            type: 'autoAttack',
                            actionType: 'autoAttack', // Ensure both type and actionType are set for consistency
                            name: 'Auto Attack',
                            abilityName: 'Auto Attack', // Add abilityName for consistency
                            target: action.target
                        }
                    });
                }
            } catch (error) {
                console.error('[BattleFlowController] Error dispatching CHARACTER_ACTION event:', error);
            }
        }
        
        // Apply action effect directly
        console.log('[BFC executeNextAction] About to call this.applyActionEffect. Action Actor:', action?.actor?.name, 'Action Type:', action?.actionType);
        console.log('[BFC executeNextAction] Is this.battleManager.applyActionEffect the BattleBridge patched version? (Look for "BattleBridge: applyActionEffect patched method called" in its definition if we log the function itself). Function Def:', this.battleManager.applyActionEffect.toString().substring(0, 200) + "..."); // Log first 200 chars of function
        await this.applyActionEffect(action);
        
        // DIAGNOSTIC: Trace executeNextAction flow - Remove later
        console.log(`>>> BFC.executeNextAction: Effect applied for ${action?.actor?.name}.`);
        
        console.log(`>>> BFC.executeNextAction: Checking battle end...`);
        if (await this.checkBattleEnd()) {
            console.log(`>>> BFC.executeNextAction: Battle ended, returning.`);
            return; // Battle ended, don't continue
        }
        console.log(`>>> BFC.executeNextAction: Battle not ended.`);
        
        console.log(`>>> BFC.executeNextAction: Scheduling next action...`);
        const actualDelay = this.battleManager.actionDelay / this.battleManager.speedMultiplier;
        setTimeout(() => {
            this.executeNextAction();
        }, actualDelay);
    }

    /**
     * Apply the effect of an action to its target
     * Migrated from BattleManager.applyActionEffect
     * @param {Object} action - The action to apply
     */
    async applyActionEffect(action) {
        // [DEBUGGING] Log the action object
        console.log(`[BattleFlowController.applyActionEffect] Entered. Action received:`, JSON.parse(JSON.stringify(action)));
        // Get team info for clearer logging
        const actorTeam = action.team;
        const targetTeam = actorTeam === 'player' ? 'enemy' : 'player';
        
        // HOTFIX8: Enhanced multi-target handling
        // Handle array of targets (for multi-target abilities)
        if (Array.isArray(action.target)) {
            console.log(`[BattleFlowController] Processing multi-target action with ${action.target.length} targets`);
            
            // TEMPORARY DEBUG (v0.5.27.2_Hotfix2): Log whether we have targetDamages
            if (action.isMultiTarget && action.targetDamages) {
                console.log(`[DEBUG 0.5.27.2] Action has ${action.targetDamages.length} pre-calculated target damages`);
            }
            
            // Process each target individually
            for (let i = 0; i < action.target.length; i++) {
                const target = action.target[i];
                
                // Create a single-target version of the action
                const singleAction = {...action, target};
                
                // HOTFIX8: Use pre-calculated damage if available
                if (action.isMultiTarget && action.targetDamages && action.targetDamages[i]) {
                    singleAction.damage = action.targetDamages[i].damage;
                    console.log(`[BattleFlowController] Using pre-calculated damage ${singleAction.damage} for target ${target.name}`);
                }
                
                await this.applyActionEffect(singleAction);
            }
            return;
        }
        
        // Check if this is an action with the new effects array
        if (action.ability && action.ability.effects && Array.isArray(action.ability.effects) && action.ability.effects.length > 0) {
            // Store the target's original health before processing effects
            const originalHealth = action.target.currentHp;
            
            // New effect system - process each effect in the array
            for (const effect of action.ability.effects) {
                this.battleManager.processEffect(effect, action.actor, action.target, action.ability);
            }
            
            // After processing all effects, check if health has changed
            const newHealth = action.target.currentHp;
            const healthChange = originalHealth - newHealth;
            
            // If health decreased (damage was dealt)
            if (healthChange > 0) {
                console.log(`Effects array reduced ${action.target.name}'s health by ${healthChange}`);
                
                // Dispatch CHARACTER_DAMAGED event
                if (window.battleBridge && healthChange > 0) {
                    try {
                        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
                            character: action.target,
                            target: action.target,
                            newHealth: action.target.currentHp,
                            maxHealth: action.target.stats.hp,
                            amount: healthChange,
                            source: action.actor,
                            ability: action.ability
                        });
                    } catch (error) {
                        console.error('[BattleFlowController] Error dispatching CHARACTER_DAMAGED event:', error);
                    }
                }
            } 
            // If health increased (healing was applied)
            else if (healthChange < 0) {
                const healAmount = Math.abs(healthChange);
                console.log(`Effects array increased ${action.target.name}'s health by ${healAmount}`);
                
                // Dispatch CHARACTER_HEALED event
                if (window.battleBridge && healAmount > 0) {
                    try {
                        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_HEALED, {
                            character: action.target,
                            target: action.target,
                            newHealth: action.target.currentHp,
                            maxHealth: action.target.stats.hp,
                            amount: healAmount,
                            source: action.actor,
                            ability: action.ability
                        });
                    } catch (error) {
                        console.error('[BattleFlowController] Error dispatching CHARACTER_HEALED event:', error);
                    }
                }
            }
            
            return;
        }
        
        // Legacy action processing
        if (action.ability && (action.ability.isHealing || action.ability.damageType === 'healing')) {
            // Defensive check for HealingProcessor
            if (!this.battleManager.healingProcessor) {
                console.error("[BattleFlowController] HealingProcessor component not found! Cannot apply healing.");
                return; // Exit early if component is missing
            }
            
            // Call the HealingProcessor to apply the healing and get results
            const result = this.battleManager.healingProcessor.applyHealing(
                action.target,
                action.damage,           // The pre-calculated potential healing amount
                action.actor,            // Source of healing
                action.ability,          // Ability used
                action.ability.name || 'healing'  // Healing type
            );
            
            // Get healing results
            const actualHealing = result.actualHealing;
            const revived = result.revived;
            
            // Check and reset death status if needed
            if (revived) {
                this.battleManager.healingProcessor.checkAndResetDeathStatus(action.target);
            }
            
            // Include team info in the log message for healing too
            const targetTeam = action.target.team;
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Add scaling information to healing message
            if (action.scalingText) {
                this.battleManager.logMessage(`${targetInfo} is healed for ${actualHealing} HP ${action.scalingText}! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, 'success');
            } else {
                this.battleManager.logMessage(`${targetInfo} is healed for ${actualHealing} HP! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, 'success');
            }
            
            // Process healing-related passive abilities
            
            // 1. onHealed for the target
            if (actualHealing > 0) {
                this.battleManager.processPassiveAbilities('onHealed', action.target, {
                    source: action.actor,
                    healAmount: actualHealing,
                    ability: action.ability,
                    healPercent: action.target.stats.hp > 0 ? actualHealing / action.target.stats.hp : 0 // Add healing percentage
                });
                
                // Show passive trigger visual feedback if using BattleUI
                if (this.battleManager.battleUI && this.battleManager.battleUI.showPassiveEffect) {
                    this.battleManager.battleUI.showPassiveEffect(action.target, 'Healing received');
                }
            }
            
            // 2. onHealingDone for the healer
            if (actualHealing > 0 && action.actor !== action.target) { // Only trigger for healing others
                this.battleManager.processPassiveAbilities('onHealingDone', action.actor, {
                    target: action.target,
                    healAmount: actualHealing,
                    ability: action.ability,
                    healPercent: action.target.stats.hp > 0 ? actualHealing / action.target.stats.hp : 0 // Add healing percentage
                });
                
                // Show passive trigger visual feedback if using BattleUI
                if (this.battleManager.battleUI && this.battleManager.battleUI.showPassiveEffect) {
                    this.battleManager.battleUI.showPassiveEffect(action.actor, 'Healing done');
                }
            }
            
            // Process revival passive if character was revived
            if (revived) {
                this.battleManager.processPassiveAbilities('onRevive', action.target, {
                    reviver: action.actor,
                    ability: action.ability
                });
            }
            
            // Add regeneration status if it's a healing ability
            if (Math.random() < 0.5) { // 50% chance
                this.battleManager.addStatusEffect(action.target, 'regen', 2);
            }
        } else if (action.ability && action.ability.damageType === 'utility') {
            // Utility ability - special effects instead of damage
            const targetTeam = action.target.team;
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Handle different utility effects
            if (action.ability.name === "Evasive Maneuver") {
                // Add evasion effect (this is just a placeholder, evasion mechanic would need to be implemented)
                this.battleManager.logMessage(`${targetInfo} becomes harder to hit!`, 'info');
                this.battleManager.addStatusEffect(action.target, 'defense_up', 2);
            } else {
                // Generic utility effect message
                this.battleManager.logMessage(`${targetInfo} is affected by ${action.ability.name}!`, 'info');
            }
        } else {
            // Damaging action
            // Declare variables for tracking damage and killed state
            let actualDamage = 0;
            let killed = false;
            
             // Ensure DamageCalculator component is available
            if (!this.battleManager.damageCalculator) {
                 console.error('[BattleFlowController] DamageCalculator component not found! Cannot apply damage.');
                 return; // Or handle error appropriately
            }

            // Directly use DamageCalculator to apply damage and get results
            const result = this.battleManager.damageCalculator.applyDamage(
                action.target,
                action.damage,        // The pre-calculated potential damage
                action.actor,
                action.ability,
                action.damageType || 'physical' // Pass damage type or default
            );

            // Store the result values locally for subsequent processing
            actualDamage = result.actualDamage; // Assign from result
            killed = result.killed;             // Assign from result
            
            // Include team info in the log message for clarity when characters share names
            // For targets, we need to use opposite team designation from the actor
            const targetTeam = action.team === 'player' ? 'enemy' : 'player';
            const targetInfo = `${action.target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            
            // Add scaling information to damage message
            if (action.scalingText) {
                this.battleManager.logMessage(`${targetInfo} takes ${actualDamage} damage ${action.scalingText}! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, action.useAbility ? 'error' : 'default');
            } else {
                this.battleManager.logMessage(`${targetInfo} takes ${actualDamage} damage! (HP: ${action.target.currentHp}/${action.target.stats.hp})`, action.useAbility ? 'error' : 'default');
            }
            
            // Process damage-related passive abilities
            
            // 1. onDamageTaken for the target
            if (actualDamage > 0) {
                this.battleManager.processPassiveAbilities('onDamageTaken', action.target, {
                    source: action.actor,
                    damageAmount: actualDamage,
                    ability: action.ability,
                    wasCritical: false, // TODO: Add critical hit tracking
                    reflectionDepth: 0 // Initialize reflection depth tracking
                });
            }
            
            // 2. onDamageDealt for the attacker
            if (actualDamage > 0) {
                this.battleManager.processPassiveAbilities('onDamageDealt', action.actor, {
                    target: action.target,
                    damageAmount: actualDamage,
                    ability: action.ability,
                    wasCritical: false, // TODO: Add critical hit tracking
                    damagePercent: action.target.stats.hp > 0 ? actualDamage / action.target.stats.hp : 0 // Add damage percentage
                });
            }
            
            // Handle defeat logic separately from damage application
            if (killed) {
                action.target.isDefeated = true;
                action.target.currentHp = 0; // Ensure HP doesn't go below 0
                // Use the same targetInfo for defeat message
                this.battleManager.logMessage(`${targetInfo} is defeated! âš°ï¸`, 'error'); // Added coffin emoji for visibility
                
                // Process defeat passive abilities
                this.battleManager.processPassiveAbilities('onDefeat', action.target, {
                    killer: action.actor,
                    ability: action.ability
                });
                
                // Process on-kill passive ability with visual feedback
                const killResults = this.battleManager.processPassiveAbilities('onKill', action.actor, {
                    defeated: action.target,
                    ability: action.ability
                });
                
                // Show visual feedback for kill effects if there were executed passives
                if (killResults && killResults.length > 0 && this.battleManager.battleUI && this.battleManager.battleUI.showPassiveEffect) {
                    const passiveNames = killResults
                        .filter(result => result.executed)
                        .map(result => {
                            // Extract passive name from message if available
                            if (result.message && result.message.includes("'s")) {
                                return result.message.split("'s")[1].trim();
                            }
                            return 'Kill Effect';
                        });
                    
                    if (passiveNames.length > 0) {
                        // Show the passive effect visualization
                        this.battleManager.battleUI.showPassiveEffect(action.actor, passiveNames[0]);
                    }
                }
            }
        }
    }
    
    /**
     * Finish the current turn
     */
    async finishTurn() {
        // Set turn flag to false
        this.battleManager.turnInProgress = false;
        
        // Reduce ability cooldowns for all characters on both teams
        console.log('[BattleFlowController] Reducing ability cooldowns at end of turn');
        
        // Process player team cooldowns
        this.battleManager.playerTeam.forEach(character => {
            if (character && character.abilities && Array.isArray(character.abilities)) {
                character.abilities.forEach(ability => {
                    if (ability && ability.currentCooldown && ability.currentCooldown > 0) {
                        ability.currentCooldown--;
                        console.log(`[BattleFlowController] Reduced ${character.name}'s ${ability.name} cooldown to ${ability.currentCooldown}`);
                    }
                });
            }
        });
        
        // Process enemy team cooldowns
        this.battleManager.enemyTeam.forEach(character => {
            if (character && character.abilities && Array.isArray(character.abilities)) {
                character.abilities.forEach(ability => {
                    if (ability && ability.currentCooldown && ability.currentCooldown > 0) {
                        ability.currentCooldown--;
                        console.log(`[BattleFlowController] Reduced ${character.name}'s ${ability.name} cooldown to ${ability.currentCooldown}`);
                    }
                });
            }
        });
        
        // Delegate end-of-turn passive processing
        this.battleManager.processPassiveAbilities('onTurnEnd', { controller: this });
        
        // Delegate turn summary logging
        this.battleManager.displayTurnSummary();
        
        // Check if battle has ended
        const battleOver = await this.checkBattleEnd();
        
        // If battle continues, schedule next turn
        if (!battleOver) {
            const baseDelay = this.battleManager.turnDelay;
            const speedMultiplier = this.battleManager.speedMultiplier;
            const actualDelay = baseDelay / speedMultiplier;
            
            setTimeout(() => this.startNextTurn(), actualDelay);
        }
        
        // Dispatch TURN_ENDED event
        if (window.battleBridge) {
            try {
                console.log('[BattleFlowController] Dispatching TURN_ENDED event');
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.TURN_ENDED, {
                    turnNumber: this.battleManager.currentTurn
                });
            } catch (error) {
                console.error('[BattleFlowController] Error dispatching TURN_ENDED event:', error);
            }
        }
    }

    /**
     * Check if the battle is over
     * @returns {boolean} True if the battle is over
     */
    async checkBattleEnd() {
        // Count defeated members in each team- UPDATED: Use isDefeated for consistency with applyActionEffect
const playerDefeated = this.battleManager.playerTeam.filter(char => char.isDefeated || char.currentHp <= 0).length;
const enemyDefeated = this.battleManager.enemyTeam.filter(char => char.isDefeated || char.currentHp <= 0).length;
        
        // Determine if all players or all enemies are defeated
        const allPlayersDefeated = playerDefeated >= this.battleManager.playerTeam.length;
        const allEnemiesDefeated = enemyDefeated >= this.battleManager.enemyTeam.length;
        
        // If battle has ended, call endBattle with appropriate result
        if (allPlayersDefeated || allEnemiesDefeated) {
            let result = 'draw';
            
            if (allPlayersDefeated && !allEnemiesDefeated) {
                result = 'defeat';
            } else if (!allPlayersDefeated && allEnemiesDefeated) {
                result = 'victory';
            }
            
            await this.endBattle(result);
            return true;
        }
        
        return false;
    }
    
    /**
     * End the battle with the given result
     * @param {string} result - The battle result ('victory', 'defeat', or 'draw')
     */
    async endBattle(result) {
        // TEMPORARY DEBUGGING: Log entry to endBattle with result
        console.log("[DEBUG BattleFlowController] endBattle called with result:", result);
        console.trace("[DEBUG BattleFlowController] endBattle entry stack trace");
        
        // Set battle state to inactive
        this.battleManager.battleActive = false;
        
        // Clear the turn timer
        clearTimeout(this.battleManager.turnTimer);
        
        // Delegate end-of-battle passive processing
        this.battleManager.processPassiveAbilities('onBattleEnd', { result });
        
        // Log battle result
        const resultMessages = {
            'victory': 'Victory! All enemies have been defeated.',
            'defeat': 'Defeat! Your team has been defeated.',
            'draw': 'Draw! Both teams have been defeated.'
        };
        
        this.battleManager.logMessage(resultMessages[result], 'battle-result');
        
        // Dispatch BATTLE_ENDED Event
        if (window.battleBridge) {
            try {
                console.log(`[BattleFlowController] Dispatching BATTLE_ENDED event. Winner: ${result}`);
                // TEMPORARY DEBUGGING: Log what we're about to dispatch and stack trace
                console.log("[DEBUG BattleFlowController] Directly dispatching BATTLE_ENDED via battleBridge. Winner:", result);
                console.trace("[DEBUG BattleFlowController] Direct dispatch stack trace");
                
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_ENDED, { winner: result });
            } catch (error) { 
                console.error('[BattleFlowController] Error dispatching BATTLE_ENDED event:', error); 
            }
        }
        
        // Delegate DOM UI update
        if (this.battleManager.battleUI) {
            console.log("[DEBUG BattleFlowController] Calling battleUI.showBattleResult with result:", result);
            this.battleManager.battleUI.showBattleResult(result);
        }
    }
}

// Make BattleFlowController available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.BattleFlowController = BattleFlowController;
  console.log("BattleFlowController class definition loaded and exported to window.BattleFlowController");
}

// Legacy global assignment for maximum compatibility
window.BattleFlowController = BattleFlowController;

===== FILE: BattleInitializer.js =====
/**
 * BattleInitializer.js
 * Handles initialization and preparation of battle data and components
 */

class BattleInitializer {
    /**
     * Create a new Battle Initializer
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        
        // Store references to dependencies to avoid frequent property access
        this.passiveTriggerTracker = battleManager.passiveTriggerTracker;
    }

    /**
     * Initialize teams and characters for battle
     * @param {Array} rawPlayerTeam - Raw player team data
     * @param {Array} rawEnemyTeam - Raw enemy team data
     * @returns {Object} - Object with playerTeam and enemyTeam properties
     */
    initializeTeamsAndCharacters(rawPlayerTeam, rawEnemyTeam) {
        console.log(`[BattleInitializer] Initializing teams for battle`);
        
        // Reset passive tracking for the new battle if available
        if (this.passiveTriggerTracker) {
            this.passiveTriggerTracker.resetBattleTracking();
        } else {
            console.warn("[BattleInitializer] PassiveTriggerTracker not available for battle reset");
        }
        
        // Process teams with JSON.parse/stringify to ensure independence
        const processedPlayerTeam = JSON.parse(JSON.stringify(rawPlayerTeam || []));
        const processedEnemyTeam = JSON.parse(JSON.stringify(rawEnemyTeam || []));
        
        // Perform enhanced initialization of teams
        const initializedPlayerTeam = this.ensureCompleteCharacterInitialization(
            processedPlayerTeam, 
            'player'
        );
        
        const initializedEnemyTeam = this.ensureCompleteCharacterInitialization(
            processedEnemyTeam, 
            'enemy'
        );
        
        console.log(`[BattleInitializer] Teams initialized: ${initializedPlayerTeam.length} players, ${initializedEnemyTeam.length} enemies`);
        
        return {
            playerTeam: initializedPlayerTeam,
            enemyTeam: initializedEnemyTeam
        };
    }

    /**
     * Force initialization of character stats and properties
     * @param {Array} team - Team of characters to initialize
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} Initialized team
     */
    ensureCompleteCharacterInitialization(team, teamType) {
        if (!team || !Array.isArray(team)) {
            console.error(`[BattleInitializer] Cannot initialize ${teamType} team: Invalid or missing team data`);
            return [];
        }
        
        console.log(`[BattleInitializer] Starting initialization for ${teamType} team with ${team.length} characters`);
        
        // Create complete team with proper initialization
        return team.map((character, index) => {
            // Skip invalid characters
            if (!character) {
                console.warn(`[BattleInitializer] Skipping invalid character at index ${index} in ${teamType} team`);
                return null;
            }
            
            try {
                // Create a new character object with all required properties
                const completeChar = {
                    ...character,
                    name: character.name || `Unknown ${teamType} ${index}`,
                    team: teamType,
                    
                    // TEMPORARY DIAGNOSTIC - Remove after bug fix
                    _prevTeam: character.team, // Store previous team value for debugging
                    uniqueId: character.uniqueId || `${teamType}_${character.name || 'unknown'}_${character.id || index}`,
                    id: character.id || `char_${Math.random().toString(36).substr(2, 9)}`,
                    currentHp: character.currentHp !== undefined ? character.currentHp : (character.stats?.hp || 100),
                    isDead: character.isDead || false
                };
                
                // Ensure stats object exists and has required properties
                completeChar.stats = completeChar.stats || {};
                completeChar.stats.hp = completeChar.stats.hp || 100;
                completeChar.stats.attack = completeChar.stats.attack || 10;
                completeChar.stats.defense = completeChar.stats.defense || 5;
                completeChar.stats.speed = completeChar.stats.speed || 10;
                completeChar.stats.strength = completeChar.stats.strength || 10;
                completeChar.stats.intellect = completeChar.stats.intellect || 10;
                completeChar.stats.spirit = completeChar.stats.spirit || 10;
                
                // Ensure abilities array exists
                completeChar.abilities = Array.isArray(completeChar.abilities) ? completeChar.abilities : [];
                
                // Initialize ability cooldowns and identify passive abilities
                completeChar.passiveAbilities = [];
                
                // Filter out any undefined abilities and ensure all abilities have basic properties
                completeChar.abilities = completeChar.abilities.filter(ability => ability != null).map(ability => {
                    // Ensure ability has basic required properties
                    ability.name = ability.name || 'Unnamed Ability';
                    ability.id = ability.id || `ability_${Math.random().toString(36).substr(2, 9)}`;
                    ability.currentCooldown = ability.currentCooldown || 0;
                    return ability;
                });
                
                // Now identify passive abilities after filtering
                completeChar.abilities.forEach(ability => {
                    // Identify passive abilities and store them separately for quick reference
                    if (ability.abilityType === 'Passive') {
                        completeChar.passiveAbilities.push(ability);
                    }
                });
                
                // Do final validation check for critical properties
                if (!completeChar.name) {
                    console.error(`[BattleInitializer] Character initialization missing name property after processing, using default`);
                    completeChar.name = `Unknown ${teamType} ${index}`;
                }
                
                if (typeof completeChar.currentHp !== 'number') {
                    console.error(`[BattleInitializer] Character ${completeChar.name} has invalid currentHp after processing, using default`);
                    completeChar.currentHp = completeChar.stats.hp || 100;
                }
                
                // TEMPORARY DIAGNOSTIC - Remove after bug fix
                console.log(`[BattleInitializer] ensureCompleteCharacterInitialization for ${completeChar.name}: team=${completeChar.team}, prevTeam=${completeChar._prevTeam || 'undefined'}`);
                
                console.log(`[BattleInitializer] Completed initialization for ${completeChar.name} (${teamType})`);
                return completeChar;
            } catch (error) {
                console.error(`[BattleInitializer] Error during character initialization at index ${index}:`, error);
                console.error(`[BattleInitializer] Character data that caused error:`, JSON.stringify(character));
                // Return null to filter out this character
                return null;
            }
        }).filter(char => char !== null); // Filter out any null entries
    }
    
    /**
     * Prepare a team for battle by setting initial values
     * @param {Array} team - Array of character objects
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} - Prepared team for battle
     */
    prepareTeamForBattle(team, teamType) {
        // Validate input parameters
        if (!team || !Array.isArray(team)) {
            console.error(`[BattleInitializer] Invalid team provided for ${teamType}, using empty array`);
            return [];
        }
        
        if (!teamType || (teamType !== 'player' && teamType !== 'enemy')) {
            console.error(`[BattleInitializer] Invalid teamType '${teamType}', must be 'player' or 'enemy'`);
            return [];
        }
        
        console.log(`[BattleInitializer] Preparing ${teamType} team with ${team.length} characters`);
        
        // Map characters to battle-ready format and filter out nulls
        const preparedTeam = team.map((character, index) => {
            // Character validation
            if (!character) {
                console.error(`[BattleInitializer] Null character at index ${index} in ${teamType} team`);
                return null;
            }
            
            // No need for deep copy since we already copied at the higher level
            const battleChar = character;
            
            // Set battle-specific properties
            if (battleChar.stats && typeof battleChar.stats.hp === 'number') {
                battleChar.currentHp = battleChar.stats.hp;
            } else {
                console.warn(`[BattleInitializer] Character at index ${index} has invalid stats.hp, using default value 100`);
                battleChar.currentHp = 100;
                battleChar.stats = battleChar.stats || {};
                battleChar.stats.hp = 100;
            }
            
            battleChar.isDead = false;
            
            // Ensure character has a unique ID
            if (!battleChar.id) {
                battleChar.id = this.generateCharacterId();
            }
            
            // Create a more robust uniqueId that includes team info and name
            battleChar.uniqueId = `${teamType}_${battleChar.name}_${battleChar.id}`;
            
            // Store team info on the character
            battleChar.team = teamType;
            
            // TEMPORARY DIAGNOSTIC - Remove after bug fix
            console.log(`[BattleInitializer] Final .team for ${battleChar.name}: ${battleChar.team}`);
            
            // Initialize ability cooldowns and identify passive abilities
            if (battleChar.abilities) {
                battleChar.passiveAbilities = [];
                
                battleChar.abilities.forEach(ability => {
                    // Initialize cooldown for active abilities
                    ability.currentCooldown = 0;
                    
                    // Identify passive abilities and store them separately for quick reference
                    if (ability.abilityType === 'Passive') {
                        battleChar.passiveAbilities.push(ability);
                    }
                });
            }
            
            return battleChar;
        }).filter(char => char !== null); // Filter out any null entries
        
        console.log(`[BattleInitializer] Finished preparing ${teamType} team: ${preparedTeam.length} valid characters`);
        return preparedTeam;
    }

    /**
     * Generate a unique ID for a character
     * @returns {string} A unique ID
     */
    generateCharacterId() {
        return 'char_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Initialize the battle components
     */
    async initialize() {
        console.log("[BattleInitializer] initialize called");
        return this.battleManager.initialize();
    }

    /**
     * Import the behavior system
     */
    async initializeBehaviorSystem() {
        console.log("[BattleInitializer] initializeBehaviorSystem called");
        return this.battleManager.initializeBehaviorSystem();
    }
}

// Make BattleInitializer available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.BattleInitializer = BattleInitializer;
  console.log("BattleInitializer class definition loaded and exported to window.BattleInitializer");
}

// Legacy global assignment for maximum compatibility
window.BattleInitializer = BattleInitializer;


===== FILE: BattleManager-new.js =====
/**
 * Battle Manager
 * Controls the flow of battle and combat logic
 * Updated to work with the Tailwind CSS-based BattleUI
 * Version 0.5.1.2b - Added CHARACTER_ACTION event dispatching for action indicators
 * Version 0.5.1.3 - Added refactoring toggle mechanism
 */

class BattleManager {
    /**
     * Create a new Battle Manager
     * @param {Phaser.Scene} scene - The Phaser scene for the battle
     * @param {string} battleLogId - ID of the HTML element for battle log
     */
    constructor(scene, battleLogId) {
        this.scene = scene;
        this.battleLogId = battleLogId;
        this.playerTeam = [];
        this.enemyTeam = [];
        this.currentTurn = 0;
        this.isAutoBattle = true;
        this.battleActive = false;
        this.isPaused = false;
        this.turnDelay = 6000; // Delay between turns (ms) - doubled from 3000ms for slower pace
        this.actionDelay = 3200; // Delay between actions (ms) - doubled from 1600ms for slower pace
        this.speedMultiplier = 1; // Battle speed (1x, 2x, 4x)
        this.battleUI = null;
        this.turnTimer = null;
        this.activeCharacterIndex = 0;
        this.actionQueue = [];
        this.turnActions = [];
        this.turnInProgress = false;
        this.statusEffects = {}; // Store status effects by character ID
        this.battleBehaviors = null; // Will hold the behavior system when loaded
        this.statusEffectDefinitions = null; // Will hold status effect definitions from JSON
        this.uiMode = "dom"; // UI mode: "dom" or "phaser"
        
        // Create a simple teamManager for compatibility with behavior system
        this.teamManager = {
            getCharacterTeam: (character) => character.team
        };

        // REFACTORING: Toggle mechanism for refactored implementation
        this.useNewImplementation = false; // Toggle to switch between original and new code

        // REFACTORING: References to component managers
        this.battleFlowController = null;
        this.battleInitializer = null;
        this.statusEffectManager = null;
        this.statusEffectDefinitionLoader = null;
        this.damageCalculator = null;
        this.healingProcessor = null;
        this.typeEffectivenessCalculator = null;
        this.abilityProcessor = null;
        this.actionGenerator = null;
        this.targetingSystem = null;
        this.passiveAbilityManager = null;
        this.passiveTriggerTracker = null;
        this.battleEventDispatcher = null;
        this.battleLogManager = null;
    }
    
    /**
     * Display a summary of all characters' health at the end of a turn
     */
    displayTurnSummary() {
        // REFACTORING: Use new implementation if toggle is enabled
        if (this.useNewImplementation && this.battleLogManager) {
            return this.battleLogManager.displayTurnSummary();
        }

        // Original implementation
        this.logMessage('------ END OF TURN SUMMARY ------', 'info');
        
        // Show player team summary
        this.logMessage('Player Team:', 'info');
        this.playerTeam.forEach(character => {
            const status = character.isDead ? 'ðŸ’€ DEFEATED' : `HP: ${character.currentHp}/${character.stats.hp}`;
            const statusColor = character.isDead ? 'error' : 
                               (character.currentHp < character.stats.hp * 0.3) ? 'error' :
                               (character.currentHp < character.stats.hp * 0.7) ? 'action' : 'success';
            this.logMessage(`  ${character.name}: ${status}`, statusColor);
        });
        
        // Show enemy team summary
        this.logMessage('Enemy Team:', 'info');
        this.enemyTeam.forEach(character => {
            const status = character.isDead ? 'ðŸ’€ DEFEATED' : `HP: ${character.currentHp}/${character.stats.hp}`;
            const statusColor = character.isDead ? 'error' : 
                               (character.currentHp < character.stats.hp * 0.3) ? 'error' :
                               (character.currentHp < character.stats.hp * 0.7) ? 'action' : 'success';
            this.logMessage(`  ${character.name}: ${status}`, statusColor);
        });
        
        this.logMessage('--------------------------------', 'info');
    }
    
    /**
     * Load status effect definitions from JSON file
     */
    async loadStatusEffectDefinitions() {
        // REFACTORING: Use new implementation if toggle is enabled
        if (this.useNewImplementation && this.statusEffectDefinitionLoader) {
            this.statusEffectDefinitions = await this.statusEffectDefinitionLoader.loadDefinitions();
            return this.statusEffectDefinitions;
        }

        // Original implementation
        try {
            // First try to load from data directory
            console.log('Attempting to load status effect definitions from data directory...');
            try {
                const response = await fetch('/data/status_effects.json');
                if (!response.ok) {
                    throw new Error(`Failed to load data/status_effects.json: ${response.status}`);
                }
                const data = await response.json();
                this.statusEffectDefinitions = {};
                
                // Process each status effect
                if (data && data.status_effects && Array.isArray(data.status_effects)) {
                    data.status_effects.forEach(effect => {
                        if (effect && effect.id) {
                            this.statusEffectDefinitions[effect.id] = effect;
                        }
                    });
                }
                
                console.log(`Loaded ${Object.keys(this.statusEffectDefinitions).length} status effect definitions from data directory`);
            } catch (e) {
                console.warn('Failed to load from data directory:', e.message);
                // Try fallback to root directory
                try {
                    const response = await fetch('/status_effects.json');
                    if (!response.ok) {
                        throw new Error(`Failed to load status_effects.json: ${response.status}`);
                    }
                    const data = await response.json();
                    this.statusEffectDefinitions = {};
                    
                    // Process each status effect
                    if (data && data.status_effects && Array.isArray(data.status_effects)) {
                        data.status_effects.forEach(effect => {
                            if (effect && effect.id) {
                                this.statusEffectDefinitions[effect.id] = effect;
                            }
                        });
                    }
                    
                    console.log(`Loaded ${Object.keys(this.statusEffectDefinitions).length} status effect definitions from root directory`);
                } catch (fallbackError) {
                    console.warn('Failed to load from root directory:', fallbackError.message);
                    throw e;
                }
            }
        } catch (error) {
            console.error('Error loading status effect definitions:', error);
            // Create basic fallback definitions
            this.setupFallbackStatusEffects();
            throw error;
        }
    }
    
    /**
     * Setup fallback status effect definitions if loading fails
     */
    setupFallbackStatusEffects() {
        // REFACTORING: Use new implementation if toggle is enabled
        if (this.useNewImplementation && this.statusEffectDefinitionLoader) {
            return this.statusEffectDefinitionLoader.setupFallbackDefinitions();
        }

        // Original implementation
        console.log('Setting up fallback status effect definitions');
        this.statusEffectDefinitions = {
            'status_burn': {
                id: 'status_burn',
                name: 'Burn',
                description: 'Taking fire damage over time',
                type: 'DoT',
                defaultDuration: 2,
                maxStacks: 1,
                behavior: {
                    trigger: 'onTurnStart',
                    action: 'Damage',
                    valueType: 'PercentMaxHP',
                    value: 0.05
                }
            },
            'status_regen': {
                id: 'status_regen',
                name: 'Regeneration',
                description: 'Healing over time',
                type: 'HoT',
                defaultDuration: 3,
                maxStacks: 1,
                behavior: {
                    trigger: 'onTurnStart',
                    action: 'Heal',
                    valueType: 'PercentMaxHP',
                    value: 0.05
                }
            }
        };
        return this.statusEffectDefinitions;
    }

    /**
     * Initialize the battle manager
     */
    async initialize() {
        console.log('BattleManager: Initializing...');
        
        // REFACTORING: Initialize all component managers if toggle is enabled
        if (this.useNewImplementation) {
            try {
                console.log('BattleManager: Using new refactored implementation');
                
                // Initialize component managers (importing dynamically to avoid circular dependencies)
                try {
                    // Import all required manager classes
                    const BattleFlowController = (await import('./BattleFlowController.js')).default;
                    const BattleInitializer = (await import('./BattleInitializer.js')).default;
                    const StatusEffectManager = (await import('../status/StatusEffectManager.js')).default;
                    const StatusEffectDefinitionLoader = (await import('../status/StatusEffectDefinitionLoader.js')).default;
                    const DamageCalculator = (await import('../damage/DamageCalculator.js')).default;
                    const HealingProcessor = (await import('../damage/HealingProcessor.js')).default;
                    const TypeEffectivenessCalculator = (await import('../damage/TypeEffectivenessCalculator.js')).default;
                    const AbilityProcessor = (await import('../abilities/AbilityProcessor.js')).default;
                    const ActionGenerator = (await import('../abilities/ActionGenerator.js')).default;
                    const TargetingSystem = (await import('../abilities/TargetingSystem.js')).default;
                    const PassiveAbilityManager = (await import('../passives/PassiveAbilityManager.js')).default;
                    const PassiveTriggerTracker = (await import('../passives/PassiveTriggerTracker.js')).default;
                    const BattleEventDispatcher = (await import('../events/BattleEventDispatcher.js')).default;
                    const BattleLogManager = (await import('../events/BattleLogManager.js')).default;
                    
                    // Create instances of all managers
                    this.battleFlowController = new BattleFlowController(this);
                    this.battleInitializer = new BattleInitializer(this);
                    this.statusEffectManager = new StatusEffectManager(this);
                    this.statusEffectDefinitionLoader = new StatusEffectDefinitionLoader(this);
                    this.damageCalculator = new DamageCalculator(this);
                    this.healingProcessor = new HealingProcessor(this);
                    this.typeEffectivenessCalculator = new TypeEffectivenessCalculator(this);
                    this.abilityProcessor = new AbilityProcessor(this);
                    this.actionGenerator = new ActionGenerator(this);
                    this.targetingSystem = new TargetingSystem(this);
                    this.passiveAbilityManager = new PassiveAbilityManager(this);
                    this.passiveTriggerTracker = new PassiveTriggerTracker(this);
                    this.battleEventDispatcher = new BattleEventDispatcher(this);
                    this.battleLogManager = new BattleLogManager(this, this.battleEventDispatcher);
                    
                    // Set up relationships between managers
                    this.passiveAbilityManager.setTriggerTracker(this.passiveTriggerTracker);
                    
                    console.log('BattleManager: All component managers initialized successfully');
                } catch (error) {
                    console.error('BattleManager: Error initializing component managers:', error);
                    // Fall back to original implementation on error
                    this.useNewImplementation = false;
                    console.log('BattleManager: Falling back to original implementation due to initialization error');
                }
            } catch (error) {
                console.error('BattleManager: Error in new implementation path:', error);
                // Fall back to original implementation on any error
                this.useNewImplementation = false;
            }
        }
        
        // Continue with original implementation if toggle is disabled or fallback needed
        try {
            // Load status effect definitions
            try {
                await this.loadStatusEffectDefinitions();
                console.log('BattleManager: Status effect definitions loaded');
            } catch (error) {
                console.warn('BattleManager: Status effect definitions not available, using fallback behavior:', error);
            }
            
            // Initialize behavior system if available
            try {
                await this.initializeBehaviorSystem();
                console.log('BattleManager: Behavior system initialized');
            } catch (error) {
                console.warn('BattleManager: Behavior system not available, using legacy behavior:', error);
            }
                        
            console.log('BattleManager: Initialized');
        } catch (e) {
            console.error('Error initializing battle UI:', e);
            
            // Try a fallback approach for debugging
            console.log('Checking available UI classes:', {
                'window.BattleUI': typeof window.BattleUI,
                'global BattleUI': typeof BattleUI
            });
        }
    }
    
    /**
     * Start a battle with the given teams
     * @param {Array} playerTeam - Array of player characters
     * @param {Array} enemyTeam - Array of enemy characters
     */
    async startBattle(playerTeam, enemyTeam) {
        // REFACTORING: Use new implementation if toggle is enabled
        if (this.useNewImplementation && this.battleFlowController) {
            return this.battleFlowController.startBattle(playerTeam, enemyTeam);
        }

        // Original implementation
        // Make sure status effect definitions are loaded
        if (!this.statusEffectDefinitions) {
            try {
                await this.loadStatusEffectDefinitions();
            } catch (error) {
                console.warn('Could not load status effect definitions:', error);
            }
        }
        
        // Make sure behavior system is loaded
        if (!this.battleBehaviors) {
            try {
                await this.initializeBehaviorSystem();
            } catch (error) {
                console.warn('Could not initialize behavior system:', error);
            }
        }
        
        // Make sure the UI is initialized and ready
        if (!this.battleUI || !this.battleUI.isSetup) {
            console.log('Re-initializing battle UI before battle start, uiMode:', this.uiMode);
            try {
                // Check UI mode to determine which UI to initialize
                if (this.uiMode === "phaser") {
                    console.log('Using Phaser scene for battle visualization, skipping DOM UI initialization');
                } else {
                    // Initialize DOM UI for "dom" mode
                    if (!this.battleUI) {
                        if (typeof window.BattleUI === 'undefined') {
                            console.error('BattleUI class is not defined! Cannot create BattleUI instance.');
                            throw new Error('BattleUI class is not defined!');
                        }
                        console.log('Creating new DOM BattleUI instance');
                        this.battleUI = new window.BattleUI(this.scene, this);
                    }
                    this.battleUI.initialize();
                }
            } catch (error) {
                console.error('Failed to initialize BattleUI:', error);
                throw error;
            }
        }

        // Validate playerTeam and ensure it's an array
        if (!playerTeam || !Array.isArray(playerTeam)) {
            console.warn('Invalid playerTeam provided to startBattle, using empty array');
            playerTeam = [];
        }
        
        // Deep copy the player team to avoid reference issues
        const playerTeamCopy = playerTeam.length > 0 ? JSON.parse(JSON.stringify(playerTeam)) : [];
        console.log(`PlayerTeam before preparation: ${playerTeamCopy.length} heroes`);
        this.playerTeam = this.prepareTeamForBattle(playerTeamCopy);
        console.log(`PlayerTeam after preparation: ${this.playerTeam.length} heroes`);
        
        // Validate player team was prepared correctly
        if (this.playerTeam.length === 0 && playerTeam.length > 0) {
            console.error('Failed to prepare player team properly. Original length:', playerTeam.length);
        }
        
        // Check if enemy team is empty or undefined and generate one if needed
        if (!enemyTeam || enemyTeam.length === 0) {
            console.log('No enemy team provided, generating a random one');
            // Create a simple enemy team for testing
            enemyTeam = [
                {
                    id: 4,
                    name: "Vaelgor",
                    type: "dark",
                    role: "Knight",
                    stats: {
                        hp: 120,
                        attack: 18,
                        defense: 12
                    },
                    abilities: [
                        {
                            name: "Shadow Strike",
                            damage: 28,
                            cooldown: 3,
                            isHealing: false,
                            description: "Attacks from the shadows for heavy damage"
                        },
                        {
                            name: "Void Barrier",
                            damage: 20,
                            cooldown: 4,
                            isHealing: true,
                            description: "Creates a barrier of dark energy that absorbs damage"
                        }
                    ]
                },
                {
                    id: 3,
                    name: "Sylvanna",
                    type: "nature",
                    role: "Ranger",
                    stats: {
                        hp: 90,
                        attack: 15,
                        defense: 15
                    },
                    abilities: [
                        {
                            name: "Vine Whip",
                            damage: 20,
                            cooldown: 2,
                            isHealing: false,
                            description: "Strikes with vines that can ensnare the target"
                        },
                        {
                            name: "Nature's Blessing",
                            damage: 25,
                            cooldown: 4,
                            isHealing: true,
                            description: "Channels the power of nature to heal wounds"
                        }
                    ]
                },
                {
                    id: 5,
                    name: "Lumina",
                    type: "light",
                    role: "Cleric",
                    stats: {
                        hp: 85,
                        attack: 16,
                        defense: 14
                    },
                    abilities: [
                        {
                            name: "Holy Smite",
                            damage: 22,
                            cooldown: 3,
                            isHealing: false,
                            description: "Channels divine light into a powerful attack"
                        },
                        {
                            name: "Divine Protection",
                            damage: 26,
                            cooldown: 4,
                            isHealing: true,
                            description: "Surrounds an ally with divine light, healing wounds"
                        }
                    ]
                }
            ];
        }
        
        // Validate enemyTeam and ensure it's an array
        if (!enemyTeam || !Array.isArray(enemyTeam)) {
            console.warn('Invalid enemyTeam provided to startBattle, using empty array');
            enemyTeam = [];
        }
        
        // Deep copy the enemy team to avoid reference issues
        const enemyTeamCopy = enemyTeam.length > 0 ? JSON.parse(JSON.stringify(enemyTeam)) : [];
        console.log(`EnemyTeam before preparation: ${enemyTeamCopy.length} enemies`);
        this.enemyTeam = this.prepareTeamForBattle(enemyTeamCopy);
        console.log(`EnemyTeam after preparation: ${this.enemyTeam.length} enemies`);
        
        // Validate enemy team was prepared correctly
        if (this.enemyTeam.length === 0 && enemyTeam.length > 0) {
            console.error('Failed to prepare enemy team properly. Original length:', enemyTeam.length);
        }
        
        // Reset battle state
        this.currentTurn = 0;
        this.battleActive = true;
        this.isPaused = false;
        this.activeCharacterIndex = 0;
        this.actionQueue = [];
        this.turnActions = [];
        this.turnInProgress = false;
        this.statusEffects = {};
        
        // Initialize passive trigger tracking at battle level
        this.passiveTriggersThisBattle = new Map();
        
        // Render characters on UI
        if (this.battleUI) {
            this.battleUI.renderCharacters(this.playerTeam, this.enemyTeam);
        }
        
        // Log battle start
        this.logMessage('Battle started!');
        this.logMessage(`${this.playerTeam.length} heroes vs ${this.enemyTeam.length} enemies`);
        console.log('Battle started with teams:', this.playerTeam, this.enemyTeam);
        
        // Process battle start passive abilities for all characters
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            if (character.currentHp > 0) {
                this.processPassiveAbilities('onBattleStart', character);
            }
        });
        
        // Start first turn
        this.startNextTurn();
    }
    
    // Rest of the BattleManager methods...
    // ... (include all other methods here with the toggle mechanism)

    /**
     * Log a message to the battle log
     * @param {string} message - The message to log
     * @param {string} type - The type of message (default, info, success, action, error)
     */
    logMessage(message, type = 'default') {
        // REFACTORING: Use new implementation if toggle is enabled
        if (this.useNewImplementation && this.battleLogManager) {
            return this.battleLogManager.logMessage(message, type);
        }

        // Original implementation
        // Log to console for debugging
        console.log(`[Battle] ${message}`);
        
        // Dispatch event through BattleBridge if available and in phaser UI mode
        if (window.battleBridge && this.uiMode === "phaser") {
            window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG, {
                message: message,
                type: type
            });
        }
        
        // Continue with DOM UI log if in DOM mode
        if (this.uiMode === "dom" && this.battleUI) {
            this.battleUI.log(message, type);
        }
    }
}

// Export as ES Module
export default BattleManager;

// Also make available as a global
if (typeof window !== 'undefined') {
    window.BattleManager = BattleManager;
}


===== FILE: DamageCalculator.js =====
/**
 * DamageCalculator.js
 * 
 * A specialized component for handling all damage calculations in the battle system.
 * This component is extracted from BattleManager as part of the Stage 4 refactoring plan
 * to improve modularity and separation of concerns.
 * 
 * Version 0.5.26.3_Hotfix2 - Added defensive checks for target.stats to prevent TypeError
 * 
 * Handles:
 * - Damage formula calculations
 * - Stat scaling (STR/INT)
 * - Type effectiveness multipliers
 * - Critical hit calculations
 * - Damage variance
 * - Defense reduction
 * - Damage application
 * - Character health state tracking
 */
class DamageCalculator {
    /**
     * @param {BattleManager} battleManager - Reference to the BattleManager for access to shared utilities
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        console.log('DamageCalculator: Initialized');
    }

    /**
     * Calculate damage based on attacker, target, and ability parameters
     * 
     * @param {Character} attacker - The character dealing damage
     * @param {Character} target - The character receiving damage
     * @param {Object|null} ability - The ability being used (null for auto-attacks)
     * @param {Object|null} effect - The specific effect causing damage (for multi-effect abilities)
     * @returns {Object} - Object containing damage amount and metadata like scalingText, scalingStat, etc.
     */
    calculateDamage(attacker, target, ability, effect = null) {
        // Define default return value for error cases
        const defaultReturn = { 
            damage: 0, 
            scalingText: '', 
            scalingStat: null, 
            scalingStatName: '',
            damageType: 'physical',
            isCritical: false,
            typeMultiplier: 1 
        };
    
        // Handle missing parameters with early returns and logging
        if (!attacker) {
            console.error("DamageCalculator: Missing attacker in calculateDamage");
            return defaultReturn;
        }
        if (!target) {
            console.error("DamageCalculator: Missing target in calculateDamage");
            return defaultReturn;
        }
        
        // HOTFIX2: Check for missing stats objects
        if (!attacker.stats) {
            console.error(`DamageCalculator: Attacker '${attacker.name || 'unknown'}' is missing stats object`);
            return defaultReturn;
        }
        if (!target.stats) {
            console.error(`DamageCalculator: Target '${target.name || 'unknown'}' is missing stats object`);
            return defaultReturn;
        }

        // Base damage setup
        let baseDamage = 0;
        let damageType = "physical"; // Default to physical damage
        let scalingStat = "attack";  // Default scaling stat
        let scaleFactor = 0;         // Default no scaling
        let attackerStat = 0;        // Will hold the stat value

        // Determine base damage and type based on ability or auto-attack
        if (ability) {
            // Ability-based damage calculation
            baseDamage = ability.damage || 0;
            
            // Check for specific effect damage if provided
            if (effect && effect.damage) {
                baseDamage = effect.damage;
            }
            
            // Get damage type and scaling information from ability
            damageType = ability.damageType || "physical";
            
            // Set scaling stat based on ability damage type
            if (damageType === "physical") {
                scalingStat = "strength";
                scaleFactor = 0.5; // 50% of strength adds to damage
            } else if (damageType === "spell") {
                scalingStat = "intellect";
                scaleFactor = 0.5; // 50% of intellect adds to damage
            }
            
            // Use ability's specific scale factor if defined
            if (ability.scaleFactor !== undefined) {
                scaleFactor = ability.scaleFactor;
            }
            
            // Override scaling stat if ability specifies one
            if (ability.scalingStat) {
                scalingStat = ability.scalingStat;
            }
        } else {
            // Auto-attack calculation (no ability)
            baseDamage = attacker.stats.attack || 0;
            damageType = "physical";
            // Auto-attacks don't have stat scaling beyond the base attack value
        }

        // Get the appropriate attacker stat for scaling - HOTFIX2: Use safe access with defaults
        if (scalingStat === "strength") {
            attackerStat = attacker.stats.strength || 0;
        } else if (scalingStat === "intellect") {
            attackerStat = attacker.stats.intellect || 0;
        } else if (scalingStat === "spirit") {
            attackerStat = attacker.stats.spirit || 0;
        } else {
            attackerStat = attacker.stats[scalingStat] || 0;
        }

        // Apply stat scaling to base damage
        const statScaling = attackerStat * scaleFactor;
        let totalDamage = baseDamage + statScaling;

        // Apply type effectiveness multiplier if both types are available
        let typeMultiplier = 1;
        if (attacker.type && target.type) {
            // Use TypeEffectivenessCalculator if available, otherwise fallback to BattleManager
            if (this.battleManager.useNewImplementation && this.battleManager.typeEffectivenessCalculator) {
                typeMultiplier = this.battleManager.typeEffectivenessCalculator.calculateTypeMultiplier(attacker.type, target.type);
            } else {
                typeMultiplier = this.battleManager.calculateTypeMultiplier(attacker.type, target.type);
            }
        }
        
        totalDamage *= typeMultiplier;

        // Apply defense reduction (diminishing returns formula) - HOTFIX2: Use safe access
        // Higher defense gives diminishing damage reduction
        const defenseValue = target.stats.defense || 0; // Hotfix line - already has || 0 but stats obj is verified above
        const defenseReductionFactor = 1 - (defenseValue / (defenseValue + 100));
        totalDamage *= defenseReductionFactor;

        // Random variance (Â±20%)
        const variance = 0.8 + (Math.random() * 0.4); // 0.8 to 1.2 range
        totalDamage *= variance;

        // Critical hit calculation (10% chance for 50% more damage)
        let criticalMultiplier = 1;
        let isCritical = false;
        
        // Check if this is a critical hit
        if (Math.random() < 0.1) { // 10% chance
            criticalMultiplier = 1.5; // 50% more damage
            isCritical = true;
            
            // Add to battle log if it's a critical hit
            if (this.battleManager.battleLog) {
                this.battleManager.battleLog.push(`CRITICAL HIT!`);
            }
        }
        
        totalDamage *= criticalMultiplier;

        // Round to nearest integer
        totalDamage = Math.round(totalDamage);
        
        // Ensure minimum damage of 1 (unless complete immunity)
        if (totalDamage < 1 && typeMultiplier > 0) {
            totalDamage = 1;
        }
        
        // Format scaling information and stat name for output
        let scalingText = '';
        let scalingStatName = '';
        
        // Prepare scaling text if applicable (for ability tooltips and battle log)
        if (statScaling > 0) {
            const roundedScaling = Math.round(statScaling);
            
            if (scalingStat === "strength") {
                scalingStatName = "Strength";
            } else if (scalingStat === "intellect") {
                scalingStatName = "Intellect";
            } else if (scalingStat === "spirit") {
                scalingStatName = "Spirit";
            } else {
                scalingStatName = scalingStat.charAt(0).toUpperCase() + scalingStat.slice(1);
            }
            
            scalingText = `(+${roundedScaling} from ${scalingStatName})`;
            
            if (isCritical) {
                scalingText += " [CRITICAL]";
            }
        }
        
        // Add final damage text to battle log
        if (this.battleManager.battleLog) {
            const logText = scalingText ? `${totalDamage} ${scalingText}` : totalDamage.toString();
            this.battleManager.battleLog.push(logText);
        }

        // Return a comprehensive object with all metadata
        return {
            damage: totalDamage,
            scalingText: scalingText,
            scalingStat: attackerStat,
            scalingStatName: scalingStatName,
            damageType: damageType,
            isCritical: isCritical,
            typeMultiplier: typeMultiplier
        };
    }

/**
 * Applies damage to a target character
 * @param {Object} target - The character receiving damage
 * @param {number} amount - The amount of damage to apply
 * @param {Object} source - The character or entity causing the damage
 * @param {Object} ability - The ability used to cause the damage (optional)
 * @param {string} damageType - The type of damage being dealt (physical, spell, etc.)
 * @returns {Object} Object containing actualDamage and killed status
 */
applyDamage(target, amount, source, ability, damageType) {
    // Validate input parameters
    if (!target || typeof amount !== 'number') {
        console.error('[DamageCalculator] Invalid parameters for applyDamage:', { target, amount });
        return { actualDamage: 0, killed: false };
    }
    
    // HOTFIX2: Check for missing stats object
    if (!target.stats) {
        console.error(`[DamageCalculator] Target '${target.name || 'unknown'}' is missing stats object in applyDamage`);
        return { actualDamage: 0, killed: false };
    }

    // Store old health for comparison
    const oldHealth = target.currentHp;
    
    // Apply damage to target (minimum health is 0)
    target.currentHp = Math.max(0, target.currentHp - Math.max(0, amount));
    
    // Calculate actual damage done (after applying to health)
    const actualDamage = oldHealth - target.currentHp;
    
    // Determine if character was killed by this damage (but don't set isDefeated)
    const killed = oldHealth > 0 && target.currentHp <= 0;
    
    // Dispatch damage event
    if (this.battleManager.dispatchDamageEvent) {
        // Use the new facade method
        this.battleManager.dispatchDamageEvent(target, actualDamage, source, ability);
    } else if (window.battleBridge && actualDamage > 0) {
        // Fallback to direct battleBridge call if facade not available
        try {
            window.battleBridge.dispatchEvent(
                window.battleBridge.eventTypes.CHARACTER_DAMAGED, 
                {
                    character: target,
                    target: target,
                    newHealth: target.currentHp,
                    maxHealth: target.stats.hp,
                    amount: actualDamage,
                    source: source,
                    ability: ability
                }
            );
        } catch (error) {
            console.error('[DamageCalculator] Error dispatching CHARACTER_DAMAGED event:', error);
        }
    }
    
    // Return both the actual damage dealt and whether it would kill the target
    return { actualDamage, killed };
}
}

// Make DamageCalculator available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.DamageCalculator = DamageCalculator;
    console.log("DamageCalculator class definition loaded and exported to window.DamageCalculator");
}

// Legacy global assignment for maximum compatibility
window.DamageCalculator = DamageCalculator;

===== FILE: HealingProcessor.js =====
/**
 * HealingProcessor.js
 * Handles healing calculations and application
 * Extracted from BattleManager.js/BattleFlowController.js as part of Stage 4 refactoring
 */

class HealingProcessor {
    /**
     * Create a new Healing Processor
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        console.log('HealingProcessor initialized');
    }

    /**
     * Apply healing to a character
     * @param {Object} target - The character to heal
     * @param {number} amount - Amount of healing to apply
     * @param {Object|null} source - The character causing the healing (if any)
     * @param {Object|null} ability - The ability used (if any)
     * @param {string} healType - The type of healing
     * @returns {Object} Result containing actualHealing and revived status
     */
    applyHealing(target, amount, source, ability, healType = 'healing') {
        if (!target) {
            console.error('[HealingProcessor] Cannot heal null target');
            return { actualHealing: 0, revived: false };
        }

        // Store if character was defeated before healing
        const wasDefeated = target.isDefeated === true;
        
        // Store original HP for comparison
        const originalHp = target.currentHp;
        
        // Calculate new HP (capped at maximum HP)
        const newHp = Math.min(target.stats.hp, target.currentHp + amount);
        
        // Calculate actual healing done
        const actualHealing = newHp - originalHp;
        
        // Apply the healing
        target.currentHp = newHp;
        
        // Determine if character was revived
        let revived = false;
        if (wasDefeated && target.currentHp > 0) {
            revived = true;
            // Note: We don't reset isDefeated here - that's handled by checkAndResetDeathStatus
        }

        // Dispatch healing event through BattleManager facade if available
        if (this.battleManager.dispatchHealingEvent && actualHealing > 0) {
            this.battleManager.dispatchHealingEvent(target, actualHealing, source, ability);
        } 
        // Fallback to direct battleBridge call if facade not available
        else if (window.battleBridge && actualHealing > 0) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_HEALED, {
                    character: target, 
                    target: target, // Include both for compatibility
                    newHealth: target.currentHp, 
                    maxHealth: target.stats.hp,
                    amount: actualHealing, 
                    source: source, 
                    ability: ability
                });
            } catch (error) {
                console.error('[HealingProcessor] Error dispatching CHARACTER_HEALED event:', error);
            }
        }

        const result = { actualHealing, revived };
        
        return result;
    }

    /**
     * Check if a character should be revived and reset their death state
     * @param {Object} character - The character to check
     * @returns {boolean} True if character was revived
     */
    checkAndResetDeathStatus(character) {
        if (!character) return false;
        
        // If character is marked as defeated but has health, resurrect them
        if (character.isDefeated && character.currentHp > 0) {
            character.isDefeated = false;
            
            // Add team identifier for clarity in log message
            const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
            this.battleManager.logMessage(`${character.name}${teamIdentifier} has been revived!`, 'success');
            
            return true; // Character was revived
        }
        return false; // No revival occurred
    }
}

// Make HealingProcessor available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.HealingProcessor = HealingProcessor;
    console.log("HealingProcessor class definition loaded and exported to window.HealingProcessor");
}

// Legacy global assignment for maximum compatibility 
window.HealingProcessor = HealingProcessor;


===== FILE: TypeEffectivenessCalculator.js =====
/**
 * TypeEffectivenessCalculator.js
 * Calculates type advantage multipliers and effects
 * Enhanced with full 22-type system based on Type Effectiveness Table.md
 * Version 0.6.0 - 2025-05-07
 */

class TypeEffectivenessCalculator {
    /**
     * Create a new Type Effectiveness Calculator
     * @param {Object} battleManager - The main battle manager instance
     */
    constructor(battleManager) {
        // Store the reference to BattleManager passed from the constructor
        this.battleManager = battleManager;
        // Basic check to ensure battleManager was passed
        if (!this.battleManager) {
            console.error("TypeEffectivenessCalculator: BattleManager instance was not provided!");
        }
        
        // Initialize type data
        this.typeData = null;
        this.initialized = false;
        
        // Load the type effectiveness data
        this.loadTypeData();
    }
    
    /**
     * Load type effectiveness data from JSON
     */
    async loadTypeData() {
        try {
            const response = await fetch('data/type_effectiveness.json');
            if (!response.ok) {
                throw new Error(`Failed to fetch type data: ${response.status} ${response.statusText}`);
            }
            
            this.typeData = await response.json();
            this.initialized = true;
            console.log('TypeEffectivenessCalculator: Type data loaded successfully');
        } catch (error) {
            console.error('TypeEffectivenessCalculator: Failed to load type data.', error);
            // Initialize with default fallback data
            this.typeData = this.getDefaultTypeData();
            this.initialized = true;
        }
    }
    
    /**
     * Get default type data as fallback if JSON fails to load
     * @returns {Object} Default minimal type data
     */
    getDefaultTypeData() {
        console.warn('TypeEffectivenessCalculator: Using default minimal type data as fallback');
        return {
            advantages: {
                fire: ['nature'],
                water: ['fire'],
                nature: ['water'],
                light: ['dark'],
                dark: ['light']
            },
            disadvantages: {
                fire: ['water'],
                water: ['nature'],
                nature: ['fire'],
                light: ['metal'],
                dark: ['physical']
            },
            immunities: {
                metal: ['poison'],
                ethereal: ['physical']
            },
            specialCases: [
                {"attacker": "light", "defender": "ethereal", "multiplier": 3.0}
            ]
        };
    }

    /**
     * Calculate type advantage multiplier
     * @param {string} attackerType - Attacker's type
     * @param {string} defenderType - Defender's type
     * @returns {number} Damage multiplier
     */
    calculateTypeMultiplier(attackerType, defenderType) {
        // Normalize types to lowercase for case-insensitive comparison
        attackerType = attackerType?.toLowerCase();
        defenderType = defenderType?.toLowerCase();
        
        // Safety check for undefined or null types
        if (!attackerType || !defenderType) {
            return 1.0; // Neutral if types are missing
        }

        // Wait for initialization if needed
        if (!this.initialized || !this.typeData) {
            console.warn('TypeEffectivenessCalculator: Type data not yet loaded. Using neutral multiplier');
            return 1.0;
        }

        // Helper function for logging messages
        const logTypeMessage = (relationship, messageText) => {
            const messageType = relationship === 'advantage' ? 'success' : 
                              relationship === 'disadvantage' ? 'info' : 
                              relationship === 'immune' ? 'warning' : 
                              relationship === 'special' ? 'critical' : 'info';
            
            if (this.battleManager && typeof this.battleManager.logMessage === 'function') {
                this.battleManager.logMessage(messageText, messageType);
            } else {
                // Fallback log if battleManager is unavailable
                console.warn(`TypeEffectivenessCalculator: ${messageText}`);
            }
        };

        // Check for immunities first (no damage)
        if (this.typeData.immunities[defenderType]?.includes(attackerType)) {
            const message = `${this.capitalizeType(defenderType)} is immune to ${this.capitalizeType(attackerType)}!`;
            logTypeMessage('immune', message);
            return 0.0; // Immunity = no damage
        }

        // Check for special cases
        const specialCase = this.typeData.specialCases.find(sc => 
            sc.attacker.toLowerCase() === attackerType && 
            sc.defender.toLowerCase() === defenderType);
        
        if (specialCase) {
            const message = `${this.capitalizeType(attackerType)} deals massive damage to ${this.capitalizeType(defenderType)}!`;
            logTypeMessage('special', message);
            return specialCase.multiplier;
        }

        // Check for advantages (strong against)
        if (this.typeData.advantages[attackerType]?.includes(defenderType)) {
            const message = `${this.capitalizeType(attackerType)} is super effective against ${this.capitalizeType(defenderType)}!`;
            logTypeMessage('advantage', message);
            return 1.5; // +50% damage
        }

        // Check for disadvantages (weak against)
        if (this.typeData.disadvantages[attackerType]?.includes(defenderType)) {
            const message = `${this.capitalizeType(attackerType)} is not very effective against ${this.capitalizeType(defenderType)}.`;
            logTypeMessage('disadvantage', message);
            return 0.5; // -50% damage
        }

        // No special relationship, return neutral multiplier
        return 1.0;
    }

    /**
     * Helper to capitalize the first letter of a type name
     * @param {string} type - Type name to capitalize
     * @returns {string} Capitalized type name
     */
    capitalizeType(type) {
        if (!type) return '';
        return type.charAt(0).toUpperCase() + type.slice(1);
    }

    /**
     * Get descriptive text for a type relationship (for tooltips and UI)
     * @param {string} attackerType - Attacker's type
     * @param {string} defenderType - Defender's type
     * @returns {string} Descriptive text about the type relationship
     */
    getTypeAdvantageText(attackerType, defenderType) {
        // Normalize types to lowercase
        attackerType = attackerType?.toLowerCase();
        defenderType = defenderType?.toLowerCase();
        
        // Safety check for undefined or null types
        if (!attackerType || !defenderType || !this.initialized) {
            return '';
        }

        // Check for immunities
        if (this.typeData.immunities[defenderType]?.includes(attackerType)) {
            return `${this.capitalizeType(defenderType)} is immune to ${this.capitalizeType(attackerType)}`;
        }

        // Check for special cases
        const specialCase = this.typeData.specialCases.find(sc => 
            sc.attacker.toLowerCase() === attackerType && 
            sc.defender.toLowerCase() === defenderType);
        
        if (specialCase) {
            return `${this.capitalizeType(attackerType)} deals ${specialCase.multiplier}x damage to ${this.capitalizeType(defenderType)}`;
        }

        // Check for advantages
        if (this.typeData.advantages[attackerType]?.includes(defenderType)) {
            return `${this.capitalizeType(attackerType)} is strong against ${this.capitalizeType(defenderType)}`;
        }

        // Check for disadvantages
        if (this.typeData.disadvantages[attackerType]?.includes(defenderType)) {
            return `${this.capitalizeType(attackerType)} is weak against ${this.capitalizeType(defenderType)}`;
        }

        return ''; // No special relationship
    }
}

// Export for ES modules (Commented out)
// This line is commented out because BattleManager currently initializes components
// by looking for them directly on the global 'window' object (e.g., new window.TypeEffectivenessCalculator()).
// Using 'export default' can sometimes cause timing issues with when the class becomes available
// globally if the file is loaded as a standard <script defer> instead of type="module".
// By relying solely on the global assignment below, we ensure compatibility with the current loading strategy.
// export default TypeEffectivenessCalculator;

// Also make available as a global for compatibility with BattleManager initialization
if (typeof window !== 'undefined') {
    window.TypeEffectivenessCalculator = TypeEffectivenessCalculator;
    // Add a log to confirm *when* this global assignment happens during page load
    console.log("TypeEffectivenessCalculator class definition loaded and explicitly assigned to window.TypeEffectivenessCalculator.");
} else {
    console.error("TypeEffectivenessCalculator: 'window' object not found. Cannot assign class globally.");
}

===== FILE: BattleEventDispatcher.js =====
/**
 * BattleEventDispatcher.js
 * Handles dispatching battle events to UI and other systems
 * Version 0.5.28.1 - Initial implementation
 */

class BattleEventDispatcher {
    /**
     * Create a new Battle Event Dispatcher
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        this.initialized = false;
        this.eventListeners = new Map(); // Store custom event listeners
        
        // Reference to battleBridge event types
        this.eventTypes = window.battleBridge?.eventTypes || this.getDefaultEventTypes();
        
        // Verify battleBridge availability
        if (window.battleBridge) {
            this.initialized = true;
            console.log("[BattleEventDispatcher] Initialized with battleBridge");
        } else {
            console.warn("[BattleEventDispatcher] battleBridge not found - events may not dispatch correctly");
        }
    }

    /**
     * Get default event types if battleBridge is not available
     * @returns {Object} Default event type constants
     */
    getDefaultEventTypes() {
        return {
            BATTLE_INITIALIZED: 'battle_initialized',
            BATTLE_STARTED: 'battle_started',
            BATTLE_ENDED: 'battle_ended',
            TURN_STARTED: 'turn_started',
            TURN_ENDED: 'turn_ended',
            CHARACTER_ACTION: 'character_action',
            CHARACTER_DAMAGED: 'character_damaged',
            CHARACTER_HEALED: 'character_healed',
            CHARACTER_DEFEATED: 'character_defeated',
            STATUS_EFFECT_APPLIED: 'status_effect_applied',
            STATUS_EFFECT_REMOVED: 'status_effect_removed',
            STATUS_EFFECT_UPDATED: 'status_effect_updated',
            STATUS_EFFECTS_CHANGED: 'status_effects_changed',
            ABILITY_USED: 'ability_used',
            PASSIVE_TRIGGERED: 'passive_triggered',
            BATTLE_UI_INTERACTION: 'battle_ui_interaction',
            BATTLE_LOG: 'battle_log'
        };
    }

    /**
     * Dispatch a battle event
     * @param {string} eventType - The type of event
     * @param {Object} eventData - The event data
     * @returns {boolean} True if dispatched successfully
     */
    dispatchEvent(eventType, eventData) {
        // Parameter validation
        if (!eventType) {
            console.error("[BattleEventDispatcher] Invalid event type: null or undefined");
            return false;
        }
        
        if (!eventData || typeof eventData !== 'object') {
            console.warn("[BattleEventDispatcher] Event data should be an object, using empty object instead");
            eventData = {};
        }
        
        // Console logging for debugging
        console.log(`[BattleEventDispatcher] Dispatching ${eventType}`);
        
        // First, notify custom listeners
        this.notifyListeners(eventType, eventData);
        
        // Then dispatch via battleBridge if available
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(eventType, eventData);
                return true;
            } catch (error) {
                console.error(`[BattleEventDispatcher] Error dispatching ${eventType} via battleBridge:`, error);
            }
        }
        
        return false;
    }

    /**
     * Add an event handler for a specific event type
     * @param {string} eventType - The type of event to listen for
     * @param {Function} handler - The handler function
     * @returns {boolean} True if handler was added successfully
     */
    addEventHandler(eventType, handler) {
        if (!eventType || typeof handler !== 'function') {
            console.error("[BattleEventDispatcher] Invalid eventType or handler");
            return false;
        }
        
        if (!this.eventListeners.has(eventType)) {
            this.eventListeners.set(eventType, []);
        }
        
        this.eventListeners.get(eventType).push(handler);
        return true;
    }

    /**
     * Remove an event handler
     * @param {string} eventType - The type of event
     * @param {Function} handler - The handler function to remove
     * @returns {boolean} True if handler was removed successfully
     */
    removeEventHandler(eventType, handler) {
        if (!eventType || !this.eventListeners.has(eventType)) {
            return false;
        }
        
        const listeners = this.eventListeners.get(eventType);
        const index = listeners.indexOf(handler);
        
        if (index !== -1) {
            listeners.splice(index, 1);
            return true;
        }
        
        return false;
    }

    /**
     * Notify all listeners for a specific event type
     * @param {string} eventType - The type of event
     * @param {Object} eventData - The event data
     */
    notifyListeners(eventType, eventData) {
        if (!this.eventListeners.has(eventType)) {
            return;
        }
        
        const listeners = this.eventListeners.get(eventType);
        listeners.forEach(handler => {
            try {
                handler(eventData);
            } catch (error) {
                console.error(`[BattleEventDispatcher] Error in event handler for ${eventType}:`, error);
            }
        });
    }

    /**
     * Dispatch a battle log message event
     * @param {string} message - The log message
     * @param {string} type - The message type (default, warning, error, etc.)
     * @returns {boolean} True if dispatched successfully
     */
    dispatchBattleLogEvent(message, type = 'default') {
        return this.dispatchEvent(this.eventTypes.BATTLE_LOG || 'battle_log', {
            message,
            type
        });
    }

    /**
     * Dispatch a character damaged event
     * @param {Object} target - The damaged character
     * @param {number} amount - The damage amount
     * @param {Object} source - The damage source
     * @param {Object} ability - The ability used
     * @returns {boolean} True if dispatched successfully
     */
    dispatchCharacterDamagedEvent(target, amount, source = null, ability = null) {
        // Validate parameters
        if (!target) {
            console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_DAMAGED: target is missing");
            return false;
        }
        
        if (typeof amount !== 'number' || isNaN(amount)) {
            console.warn("[BattleEventDispatcher] Invalid damage amount:", amount);
            amount = 0;
        }
        
        // Create a standardized event with both property naming patterns
        return this.dispatchEvent(this.eventTypes.CHARACTER_DAMAGED || 'character_damaged', {
            character: target, // Primary standardized property
            target: target,    // Backward compatibility
            newHealth: target.currentHp,
            maxHealth: target.stats?.hp || 100,
            amount,
            source,
            ability
        });
    }

    /**
     * Dispatch a character healed event
     * @param {Object} target - The healed character
     * @param {number} amount - The healing amount
     * @param {Object} source - The healing source
     * @param {Object} ability - The ability used
     * @returns {boolean} True if dispatched successfully
     */
    dispatchCharacterHealedEvent(target, amount, source = null, ability = null) {
        // Validate parameters
        if (!target) {
            console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_HEALED: target is missing");
            return false;
        }
        
        if (typeof amount !== 'number' || isNaN(amount)) {
            console.warn("[BattleEventDispatcher] Invalid healing amount:", amount);
            amount = 0;
        }
        
        // Create a standardized event with both property naming patterns
        return this.dispatchEvent(this.eventTypes.CHARACTER_HEALED || 'character_healed', {
            character: target, // Primary standardized property
            target: target,    // Backward compatibility
            newHealth: target.currentHp,
            maxHealth: target.stats?.hp || 100,
            amount,
            source,
            ability
        });
    }

    /**
     * Dispatch a character action event
     * @param {Object} character - The acting character
     * @param {Object} action - The action data
     * @returns {boolean} True if dispatched successfully
     */
    dispatchCharacterActionEvent(character, action) {
        // Validate parameters
        if (!character) {
            console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_ACTION: character is missing");
            return false;
        }
        
        if (!action) {
            console.warn("[BattleEventDispatcher] Invalid action data, using empty object");
            action = {};
        }
        
        // Create event data
        return this.dispatchEvent(this.eventTypes.CHARACTER_ACTION || 'character_action', {
            character,
            action
        });
    }

    /**
     * Dispatch a status effect applied event
     * @param {Object} character - The affected character
     * @param {string} statusId - The status effect ID
     * @param {number} duration - The status effect duration
     * @param {number} stacks - The number of stacks
     * @param {Object} statusDefinition - The status effect definition
     * @returns {boolean} True if dispatched successfully
     */
    dispatchStatusEffectAppliedEvent(character, statusId, duration, stacks = 1, statusDefinition = null) {
        // Validate parameters
        if (!character) {
            console.error("[BattleEventDispatcher] Cannot dispatch STATUS_EFFECT_APPLIED: character is missing");
            return false;
        }
        
        if (!statusId) {
            console.error("[BattleEventDispatcher] Cannot dispatch STATUS_EFFECT_APPLIED: statusId is missing");
            return false;
        }
        
        // Create event data
        return this.dispatchEvent(this.eventTypes.STATUS_EFFECT_APPLIED || 'status_effect_applied', {
            character,
            statusId,
            duration,
            stacks,
            statusDefinition
        });
    }

    /**
     * Dispatch a status effect removed event
     * @param {Object} character - The affected character
     * @param {string} statusId - The status effect ID
     * @param {Object} statusDefinition - The status effect definition
     * @returns {boolean} True if dispatched successfully
     */
    dispatchStatusEffectRemovedEvent(character, statusId, statusDefinition = null) {
        // Validate parameters
        if (!character) {
            console.error("[BattleEventDispatcher] Cannot dispatch STATUS_EFFECT_REMOVED: character is missing");
            return false;
        }
        
        if (!statusId) {
            console.error("[BattleEventDispatcher] Cannot dispatch STATUS_EFFECT_REMOVED: statusId is missing");
            return false;
        }
        
        // Create event data
        return this.dispatchEvent(this.eventTypes.STATUS_EFFECT_REMOVED || 'status_effect_removed', {
            character,
            statusId,
            statusDefinition
        });
    }

    /**
     * Dispatch a passive triggered event
     * @param {Object} character - The character with the passive
     * @param {string} triggerType - The passive trigger type
     * @param {Object} passiveData - The passive ability data
     * @param {*} result - The result of the passive trigger
     * @returns {boolean} True if dispatched successfully
     */
    dispatchPassiveTriggeredEvent(character, triggerType, passiveData, result = null) {
        // Validate parameters
        if (!character) {
            console.error("[BattleEventDispatcher] Cannot dispatch PASSIVE_TRIGGERED: character is missing");
            return false;
        }
        
        if (!triggerType) {
            console.warn("[BattleEventDispatcher] Passive trigger type missing");
            triggerType = 'unknown';
        }
        
        // Create event data
        return this.dispatchEvent(this.eventTypes.PASSIVE_TRIGGERED || 'passive_triggered', {
            character,
            triggerType,
            passiveData,
            result
        });
    }

    /**
     * Dispatch a battle ended event
     * @param {string} winner - The winning team ('player', 'enemy', or 'draw')
     * @param {string} reason - The reason for battle end
     * @returns {boolean} True if dispatched successfully
     */
    dispatchBattleEndedEvent(winner, reason = 'standard') {
        // TEMPORARY DEBUGGING: Log entry into this method and received parameters
        console.log("[DEBUG BattleEventDispatcher] dispatchBattleEndedEvent ENTERED. Received winner:", winner, "Received reason:", reason);
        
        // Validate parameters - FIXED: Now accepts both 'victory'/'defeat' and 'player'/'enemy' values
        const validWinners = ['victory', 'defeat', 'draw', 'player', 'enemy']; // Include all acceptable terms
        if (!winner || !validWinners.includes(winner)) {
            console.warn(`[BattleEventDispatcher] Received truly invalid winner value: '${winner}', defaulting to 'draw' as a fallback. This should be investigated.`);
            winner = 'draw'; // Fallback for genuinely unknown values
        }
        
        // TEMPORARY DEBUGGING: Log about to dispatch values and stack trace
        console.log("[DEBUG BattleEventDispatcher] dispatchBattleEndedEvent ABOUT TO DISPATCH. Dispatching winner:", winner, "Dispatching reason:", reason);
        console.trace("[DEBUG BattleEventDispatcher] dispatchBattleEndedEvent dispatch point stack trace");
        
        // Create event data
        return this.dispatchEvent(this.eventTypes.BATTLE_ENDED || 'battle_ended', {
            winner,
            reason
        });
    }

    /**
     * Dispatch a turn started event
     * @param {number} turnNumber - The current turn number
     * @param {Object} currentCharacter - The character taking the turn
     * @returns {boolean} True if dispatched successfully
     */
    dispatchTurnStartedEvent(turnNumber, currentCharacter) {
        // Validate parameters
        if (!currentCharacter) {
            console.error("[BattleEventDispatcher] Cannot dispatch TURN_STARTED: currentCharacter is missing");
            return false;
        }
        
        // Create event data with both property naming patterns
        return this.dispatchEvent(this.eventTypes.TURN_STARTED || 'turn_started', {
            turnNumber,
            currentCharacter,   // Original naming
            character: currentCharacter  // Standardized naming
        });
    }
}

// Make BattleEventDispatcher available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleEventDispatcher = BattleEventDispatcher;
    console.log("BattleEventDispatcher class definition loaded and exported to window.BattleEventDispatcher");
}

// Legacy global assignment for maximum compatibility
window.BattleEventDispatcher = BattleEventDispatcher;

===== FILE: BattleLogManager.js =====
/**
 * BattleLogManager.js
 * Manages battle log messages and formatting
 * Version 0.5.28.2 - Combined implementation and cleanup
 */

class BattleLogManager {
    /**
     * Create a new Battle Log Manager
     * @param {Object} battleManager - The main battle manager
     * @param {Object} eventDispatcher - The event dispatcher
     */
    constructor(battleManager, eventDispatcher) {
        this.battleManager = battleManager;
        this.eventDispatcher = eventDispatcher;
        
        // Validate dependencies
        if (!this.eventDispatcher) {
            console.warn("[BattleLogManager] EventDispatcher not provided, messages won't be dispatched");
        }
        
        // Initialize validation lists
        this.validTypes = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy', 'status'];
        
        // Log initialization
        console.log("[BattleLogManager] Initialized");
    }

    /**
     * Log a message to the battle log
     * @param {string} message - The message to log
     * @param {string} type - The type of message (default, info, success, action, error)
     * @returns {boolean} True if logged successfully
     */
    logMessage(message, type = 'default') {
        console.log(`[BattleLogManager.logMessage] Received to display: "${message}", Type: "${type}"`);
        // Parameter validation
        if (!message) {
            console.warn("[BattleLogManager] Empty message not logged");
            return false;
        }
        
        // Ensure type is valid
        if (!this.validTypes.includes(type)) {
            console.warn(`[BattleLogManager] Invalid type '${type}', defaulting to 'default'`);
            type = 'default';
        }
        
        // TEMPORARY DEBUGGING: Check for 'draw' message and log stack trace
        if (typeof message === 'string' && message.includes("The battle ended in a draw.")) {
            console.warn("DEBUG: 'The battle ended in a draw.' is about to be logged by BattleLogManager.logMessage!");
            console.log("DEBUG: Full message being logged:", message);
            console.trace("DEBUG: BattleLogManager.logMessage draw message stack trace"); // This will show the call stack
        }
        
        // Log to console for debugging
        console.log(`[BattleLog ${type}]: ${message}`);
        
        // Dispatch via eventDispatcher if available
        if (this.eventDispatcher && this.eventDispatcher.dispatchBattleLogEvent) {
            return this.eventDispatcher.dispatchBattleLogEvent(message, type);
        }
        
        // Direct fallback if no eventDispatcher
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
                    message: message,
                    type: type
                });
                return true;
            } catch (error) {
                console.error('[BattleLogManager] Error dispatching log message:', error);
            }
        }
        
        return false;
    }

    /**
     * Format a message with character information
     * @param {string} message - The base message
     * @param {Object} character - The character
     * @param {string} type - The message type
     * @returns {string} The formatted message
     */
    formatMessage(message, character, type = 'default') {
        // If no character provided, return original message
        if (!character) {
            return message;
        }
        
        // Add team identifier
        const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
        return `${character.name}${teamIdentifier} ${message}`;
    }

    /**
     * Display a summary of all characters' health at the end of a turn
     * @returns {boolean} True if summary was displayed successfully
     */
    displayTurnSummary() {
        this.logMessage('------ END OF TURN SUMMARY ------', 'info');
        
        // Show player team summary
        this.logMessage('Player Team:', 'info');
        
        if (!this.battleManager || !Array.isArray(this.battleManager.playerTeam)) {
            this.logMessage('Error: Player team not available', 'error');
        } else {
            this.battleManager.playerTeam.forEach(character => {
                const status = character.isDead ? 'ðŸ’€ DEFEATED' : 
                              `HP: ${character.currentHp}/${character.stats.hp}`;
                const statusColor = this.determineHealthColor(character);
                this.logMessage(`  ${character.name}: ${status}`, statusColor);
            });
        }
        
        // Show enemy team summary
        this.logMessage('Enemy Team:', 'info');
        
        if (!this.battleManager || !Array.isArray(this.battleManager.enemyTeam)) {
            this.logMessage('Error: Enemy team not available', 'error');
        } else {
            this.battleManager.enemyTeam.forEach(character => {
                const status = character.isDead ? 'ðŸ’€ DEFEATED' : 
                              `HP: ${character.currentHp}/${character.stats.hp}`;
                const statusColor = this.determineHealthColor(character);
                this.logMessage(`  ${character.name}: ${status}`, statusColor);
            });
        }
        
        this.logMessage('--------------------------------', 'info');
        
        return true;
    }

    /**
     * Determine the color to use for health status
     * @param {Object} character - The character
     * @returns {string} The color type to use
     */
    determineHealthColor(character) {
        if (!character) return 'default';
        
        if (character.isDead) return 'error';
        
        const healthPercent = character.currentHp / character.stats.hp;
        
        if (healthPercent < 0.3) return 'error';
        if (healthPercent < 0.7) return 'action';
        return 'success';
    }
}

// Make BattleLogManager available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleLogManager = BattleLogManager;
    console.log("BattleLogManager class definition loaded and exported to window.BattleLogManager");
}

// Legacy global assignment for maximum compatibility
window.BattleLogManager = BattleLogManager;


===== FILE: BattleBehaviors.js =====
/**
 * BattleBehaviors.js (FALLBACK VERSION)
 * 
 * Simple non-ES Module version of the battle behavior system.
 * This file provides basic functionality without requiring complex imports.
 */

// Define a global variable to store the battle behaviors
window.battleBehaviors = window.battleBehaviors || {
    /**
     * Selects a target for an ability or action based on targeting logic
     * @param {string|null} targetingLogic - Name of targeting logic to use
     * @param {object} context - Targeting context
     * @returns {Character|Character[]|null} - Selected target(s) or null if no valid target
     */
    selectTarget: function(targetingLogic, context) {
        console.log(`Using targeting logic: ${targetingLogic}`);
        
        // Default targeting - find random enemy
        const targets = context.potentialTargets.filter(t => 
            t.team !== context.actor.team && t.currentHp > 0
        );
        
        // Decide based on targeting type
        switch(targetingLogic) {
            case 'targetLowestHpEnemy':
                // Find enemy with lowest HP
                if (targets.length === 0) return null;
                return targets.sort((a, b) => 
                    (a.currentHp / a.stats.hp) - (b.currentHp / b.stats.hp)
                )[0];
                
            case 'targetLowestHpAlly':
                // Find ally with lowest HP
                const allies = context.potentialTargets.filter(t => 
                    t.team === context.actor.team && t.currentHp > 0 && t.currentHp < t.stats.hp
                );
                if (allies.length === 0) {
                    // If no injured allies, target self
                    return context.actor;
                }
                return allies.sort((a, b) => 
                    (a.currentHp / a.stats.hp) - (b.currentHp / b.stats.hp)
                )[0];
                
            case 'targetSelf':
                // Target self
                return context.actor;
                
            default:
                // Random enemy
                return targets.length > 0 ? 
                    targets[Math.floor(Math.random() * targets.length)] : null;
        }
    },
    
    /**
     * Decides which ability to use (or basic attack)
     * @param {string|null} decisionLogic - Name of action decision logic to use
     * @param {object} context - Action decision context
     * @returns {object|null} - Selected ability or null for basic attack
     */
    decideAction: function(decisionLogic, context) {
        console.log(`Using action decision logic: ${decisionLogic}`);
        
        // Check if there are any available abilities
        if (!context.availableAbilities || context.availableAbilities.length === 0) {
            return null; // Use basic attack
        }
        
        // Decide based on logic type
        switch(decisionLogic) {
            case 'alwaysUseAbilities':
                // Always use an ability if available
                return context.availableAbilities[
                    Math.floor(Math.random() * context.availableAbilities.length)
                ];
                
            case 'prioritizeHealing':
                // Check for healing abilities if there are injured allies
                const healingAbilities = context.availableAbilities.filter(a => 
                    a.isHealing || a.damageType === 'healing'
                );
                
                // Check if there are injured allies
                const allies = context.actor.team === 'player' ? 
                    context.battleManager.playerTeam : context.battleManager.enemyTeam;
                const injuredAllies = allies.filter(a => 
                    a.currentHp > 0 && a.currentHp < a.stats.hp * 0.7
                );
                
                // If there are healing abilities and injured allies, use one
                if (healingAbilities.length > 0 && injuredAllies.length > 0) {
                    return healingAbilities[
                        Math.floor(Math.random() * healingAbilities.length)
                    ];
                }
                
                // Otherwise, 50% chance to use a damage ability
                return Math.random() > 0.5 && context.availableAbilities.length > 0 ? 
                    context.availableAbilities[
                        Math.floor(Math.random() * context.availableAbilities.length)
                    ] : null;
                
            case 'defaultActionDecision':
            default:
                // 50% chance to use ability
                return Math.random() > 0.5 && context.availableAbilities.length > 0 ? 
                    context.availableAbilities[
                        Math.floor(Math.random() * context.availableAbilities.length)
                    ] : null;
        }
    },
    
    /**
     * Processes a passive ability
     * @param {string} passiveName - Name of passive behavior to execute
     * @param {object} context - Passive context
     * @returns {object} - Result of the passive ability
     */
    processPassive: function(passiveName, context) {
        console.log(`Processing passive: ${passiveName} for trigger: ${context.trigger}`);
        return { executed: true, message: 'Passive ability activated' };
    },
    
    /**
     * Executes a passive behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executePassiveBehavior: function(name, context) {
        // Implementations for common passive behaviors
        switch(name) {
            case 'passive_ApplyRegenOnTurnStart':
                if (context.trigger === 'onTurnStart' && Math.random() < 0.5) {
                    context.battleManager.addStatusEffect(context.actor, 'status_regen', 2);
                    return { executed: true, message: 'Grants Regeneration!' };
                }
                return { executed: false };
                
            case 'passive_DamageReflectOnHit':
                if (context.trigger === 'onDamageTaken' && context.additionalData.source) {
                    const reflectAmount = Math.round(context.additionalData.damageAmount * 0.2);
                    if (reflectAmount > 0) {
                        context.battleManager.applyDamage(
                            context.additionalData.source, // target
                            reflectAmount, // damage
                            context.actor, // source
                            null, // ability
                            'reflected' // damageType
                        );
                        return { executed: true, message: `Reflects ${reflectAmount} damage back to attacker!` };
                    }
                }
                return { executed: false };
                
            case 'passive_ApplyStatusOnHit':
                if (context.trigger === 'onDamageTaken' && 
                    context.additionalData.source && 
                    Math.random() < 0.3) {
                    
                    const statusId = context.ability.passiveData?.statusId || 'status_spd_down';
                    const duration = context.ability.passiveData?.duration || 2;
                    
                    context.battleManager.addStatusEffect(
                        context.additionalData.source,
                        statusId,
                        duration
                    );
                    return { executed: true, message: 'Inflicts a status effect on the attacker!' };
                }
                return { executed: false };
                
            case 'passive_TeamBuffOnBattleStart':
                if (context.trigger === 'onBattleStart') {
                    const statusId = context.ability.passiveData?.statusId || 'status_atk_up';
                    const duration = context.ability.passiveData?.duration || 3;
                    
                    const allies = context.battleManager.getAllCharacters().filter(character => 
                        character.team === context.actor.team && !character.isDead
                    );
                    
                    allies.forEach(ally => {
                        context.battleManager.addStatusEffect(ally, statusId, duration);
                    });
                    
                    return { executed: true, message: 'Buffs the team at the start of battle!' };
                }
                return { executed: false };
                
            default:
                // For unknown passives, log and return a generic result
                console.log(`No specific handling for passive '${name}', using generic behavior.`);
                return { executed: true, message: 'Activated!' };
        }
    },
    
    /**
     * Utility function to check if a specific behavior exists
     * @param {string} behaviorName - Name of the behavior to check
     * @returns {boolean} - Whether the behavior exists
     */
    hasBehavior: function(behaviorName) {
        // We'll assume we have these behaviors for simplicity
        const knownBehaviors = [
            'targetRandomEnemy',
            'targetLowestHpEnemy',
            'targetLowestHpAlly',
            'targetSelf',
            'defaultActionDecision',
            'alwaysUseAbilities',
            'prioritizeHealing'
        ];
        
        return knownBehaviors.includes(behaviorName);
    },
    
    /**
     * Utility function to get the default targeting behavior
     * @returns {string} - Name of the default targeting behavior
     */
    getDefaultTargetingBehavior: function() {
        return 'targetRandomEnemy';
    },
    
    /**
     * Utility function to get the default action decision behavior
     * @returns {string} - Name of the default action decision behavior
     */
    getDefaultActionDecisionBehavior: function() {
        return 'defaultActionDecision';
    },
    
    /**
     * Maps targetType strings to targeting behavior names
     * @param {string} targetType - Type of targeting from ability data
     * @returns {string} - Name of the corresponding targeting behavior
     */
    getTargetingBehaviorFromType: function(targetType) {
        const mapping = {
            'SingleEnemy': 'targetRandomEnemy',
            'AllEnemies': 'targetRandomEnemy', // Simplified
            'Self': 'targetSelf',
            'SingleAlly': 'targetLowestHpAlly',
            'AllAllies': 'targetLowestHpAlly', // Simplified
            'LowestHpEnemy': 'targetLowestHpEnemy',
            'HighestHpEnemy': 'targetRandomEnemy', // Simplified
            'LowestHpAlly': 'targetLowestHpAlly'
        };
        
        return mapping[targetType] || 'targetRandomEnemy';
    }
};

// CRITICAL FIX: Register with uppercase 'B' for BattleManager compatibility
window.BattleBehaviors = window.battleBehaviors;

// Enhanced debugging to confirm it's being used
window.battleBehaviors.decideAction = function(decisionLogic, context) {
    console.log(`[DEBUG] BattleBehaviors.decideAction called... First line of the method`);
    console.log(`[DEBUG] BattleBehaviors.decideAction called with logic: ${decisionLogic}`);
    console.log(`[DEBUG] Actor:`, context.actor ? context.actor.name : 'undefined');
    console.log(`[DEBUG] Available abilities:`, context.availableAbilities?.map(a => a.name) || []);
    
    // Delegate to the original implementation
    // Check if there are any available abilities
    if (!context.availableAbilities || context.availableAbilities.length === 0) {
        return null; // Use basic attack
    }
    
    // Decide based on logic type
    switch(decisionLogic) {
        case 'alwaysUseAbilities':
            // Always use an ability if available
            return context.availableAbilities[
                Math.floor(Math.random() * context.availableAbilities.length)
            ];
            
        case 'prioritizeHealing':
            // Check for healing abilities if there are injured allies
            const healingAbilities = context.availableAbilities.filter(a => 
                a.isHealing || a.damageType === 'healing'
            );
            
            // Check if there are injured allies
            const allies = context.actor.team === 'player' ? 
                context.battleManager.playerTeam : context.battleManager.enemyTeam;
            const injuredAllies = allies.filter(a => 
                a.currentHp > 0 && a.currentHp < a.stats.hp * 0.7
            );
            
            // If there are healing abilities and injured allies, use one
            if (healingAbilities.length > 0 && injuredAllies.length > 0) {
                return healingAbilities[
                    Math.floor(Math.random() * healingAbilities.length)
                ];
            }
            
            // Otherwise, 50% chance to use a damage ability
            return Math.random() > 0.5 && context.availableAbilities.length > 0 ? 
                context.availableAbilities[
                    Math.floor(Math.random() * context.availableAbilities.length)
                ] : null;
            
        case 'defaultActionDecision':
        default:
            // 50% chance to use ability
            return Math.random() > 0.5 && context.availableAbilities.length > 0 ? 
                context.availableAbilities[
                    Math.floor(Math.random() * context.availableAbilities.length)
                ] : null;
    }
};

// Let the console know this loaded
console.log('Fallback BattleBehaviors.js loaded successfully (registered as both window.battleBehaviors and window.BattleBehaviors)');


===== FILE: SafetyLoader.js =====
/**
 * SafetyLoader.js
 * 
 * This script ensures that the BattleManager is properly initialized
 * even if there are timing issues with script loading.
 */

(function() {
    console.log('Safety loader activated...');
    
    // Check periodically until BattleManager is available
    const maxAttempts = 10;
    let attempts = 0;
    
    function checkAndFixBattleManager() {
        attempts++;
        console.log(`Checking BattleManager availability (attempt ${attempts}/${maxAttempts})...`);
        
        if (typeof window.BattleManager === 'function') {
            console.log('BattleManager is properly defined!');
            return;
        }
        
        if (typeof BattleManager === 'function') {
            console.log('BattleManager exists but is not properly assigned to window - fixing...');
            window.BattleManager = BattleManager;
            return;
        }
        
        if (attempts >= maxAttempts) {
            console.error('Failed to find BattleManager after multiple attempts');
            return;
        }
        
        // Try again in a moment
        setTimeout(checkAndFixBattleManager, 500);
    }
    
    // Start checking after a short delay
    setTimeout(checkAndFixBattleManager, 100);
    
    // Also check when the page is fully loaded
    window.addEventListener('load', function() {
        console.log('Window loaded - doing final BattleManager check...');
        
        if (typeof window.BattleManager !== 'function' && typeof BattleManager === 'function') {
            console.log('Window loaded but BattleManager not assigned - fixing...');
            window.BattleManager = BattleManager;
        }
    });
})();


===== FILE: StatusEffectFixes.js =====
/**
 * StatusEffectFixes.js
 * 
 * This script patches the BattleManager's status effect handling
 * to ensure it works properly in the absence of actual status_effects.json
 */

(function() {
    console.log('Applying status effect fixes...');
    
    // Check if BattleManager exists
    if (typeof window.BattleManager !== 'function') {
        console.error('BattleManager not found when applying status effect fixes!');
        return;
    }
    
    // Create a backup of the original loadStatusEffectDefinitions method
    const originalLoadMethod = window.BattleManager.prototype.loadStatusEffectDefinitions;
    
    // Replace with our enhanced version that has better fallbacks
    window.BattleManager.prototype.loadStatusEffectDefinitions = async function() {
        console.log('Enhanced loadStatusEffectDefinitions running...');
        
        try {
            // Check if definitions are already loaded
            if (this.statusEffectDefinitions) {
                return this.statusEffectDefinitions;
            }
            
            console.log('Attempting to fetch status effect definitions...');
            
            // First try the original method
            try {
                // Call the original method
                const result = await originalLoadMethod.call(this);
                // A better check for valid result
                if (result && typeof result === 'object' && Object.keys(result).length > 0) {
                    console.log('Original status effect loading succeeded!');
                    return result;
                }
                
                // Don't throw an error, just use fallbacks silently
                console.log('Original method returned no status effects, using fallbacks...');
                throw new Error('Using fallbacks instead');
            } catch (originalError) {
                console.log('Using built-in status effect definitions as fallback');
                
                // Create default status effect definitions
                console.log('Creating default status effect definitions as fallback');
                const defaultDefinitions = {
                    'burn': {
                        id: 'burn',
                        name: 'Burn',
                        description: 'Taking fire damage over time',
                        icon: 'assets/images/icons/status/burn.png',
                        type: 'DoT',
                        defaultDuration: 2,
                        maxStacks: 1,
                        behavior: {
                            trigger: 'onTurnStart',
                            action: 'Damage',
                            valueType: 'PercentMaxHP',
                            value: 0.08,
                            damageType: 'fire'
                        }
                    },
                    'regen': {
                        id: 'regen',
                        name: 'Regeneration',
                        description: 'Healing over time',
                        icon: 'assets/images/icons/status/regen.png',
                        type: 'HoT',
                        defaultDuration: 3,
                        maxStacks: 1,
                        behavior: {
                            trigger: 'onTurnStart',
                            action: 'Heal',
                            valueType: 'PercentMaxHP',
                            value: 0.05
                        }
                    },
                    'stun': {
                        id: 'stun',
                        name: 'Stunned',
                        description: 'Unable to take actions',
                        icon: 'assets/images/icons/status/stun.png',
                        type: 'Control',
                        defaultDuration: 1,
                        maxStacks: 1,
                        behavior: {
                            modifier: 'PreventAction',
                            value: true
                        }
                    },
                    'attack_up': {
                        id: 'attack_up',
                        name: 'Attack Up',
                        description: 'Attack increased by 50%',
                        icon: 'assets/images/icons/status/attack_up.png',
                        type: 'Buff',
                        defaultDuration: 3,
                        maxStacks: 1,
                        behavior: {
                            modifier: 'StatModification',
                            stat: 'Attack',
                            value: 0.5,
                            isMultiplier: true
                        }
                    },
                    'defense_up': {
                        id: 'defense_up',
                        name: 'Defense Up',
                        description: 'Defense increased by 50%',
                        icon: 'assets/images/icons/status/defense_up.png',
                        type: 'Buff',
                        defaultDuration: 3,
                        maxStacks: 1,
                        behavior: {
                            modifier: 'StatModification',
                            stat: 'Defense',
                            value: 0.5,
                            isMultiplier: true
                        }
                    }
                };
                
                this.statusEffectDefinitions = defaultDefinitions;
                console.log('Using default status effect definitions');
                return defaultDefinitions;
            }
        } catch (error) {
            console.error('Unexpected error loading status effect definitions:', error);
            // Return an empty object as fallback
            this.statusEffectDefinitions = {};
            return {};
        }
    };
    
    console.log('Status effect fixes applied successfully');
})();


===== FILE: PassiveAbilityManager.js =====
/**
 * PassiveAbilityManager.js
 * Manages execution of passive abilities
 * Version 0.5.27.2_Hotfix - Enhanced character validation
 */

class PassiveAbilityManager {
    /**
     * Create a new PassiveAbilityManager
     * @param {Object} battleManager - The BattleManager instance
     * @param {Object} passiveTriggerTracker - The PassiveTriggerTracker instance
     */
    constructor(battleManager, passiveTriggerTracker) {
        this.battleManager = battleManager;
        this.passiveTriggerTracker = passiveTriggerTracker;
        
        // Log initialization
        console.log("[PassiveAbilityManager] Initializing...");
    }
    
    /**
     * Validate character has required properties for passive processing
     * @param {Object} character - The character to validate
     * @returns {boolean} True if character is valid
     */
    validateCharacter(character) {
        // Basic null check
        if (!character) {
            console.error("[PassiveAbilityManager] Invalid character parameter (null or undefined)");
            return false;
        }
        
        // Check for required properties
        if (!character.name) {
            console.error("[PassiveAbilityManager] Invalid character: missing name property");
            return false;
        }
        
        // Must have stats object for passive calculations
        if (!character.stats) {
            console.error(`[PassiveAbilityManager] Character '${character.name}' missing stats object`);
            return false;
        }
        
        // Check for health properties
        if (typeof character.currentHp !== 'number') {
            console.error(`[PassiveAbilityManager] Character '${character.name}' missing currentHp property`);
            return false;
        }
        
        // Check for passives
        if (!Array.isArray(character.passiveAbilities)) {
            // This is not necessarily an error - just no passives to process
            console.debug(`[PassiveAbilityManager] Character '${character.name}' has no passive abilities array`);
            return false;
        }
        
        // Check defeat state for early return
        if (character.isDead || character.currentHp <= 0) {
            console.debug(`[PassiveAbilityManager] Character '${character.name}' is defeated (${character.currentHp}/${character.stats.hp})`);
            return false;
        }
        
        // Check if passives array is empty
        if (character.passiveAbilities.length === 0) {
            console.debug(`[PassiveAbilityManager] Character '${character.name}' has empty passives array`);
            return false;
        }
        
        return true;
    }
    
    /**
     * Process passive abilities for a specific trigger event
     * @param {string} trigger - The trigger event (e.g., 'onTurnStart', 'onDamageTaken')
     * @param {Object} character - The character whose passives should be checked
     * @param {Object} additionalData - Additional context data for the passive
     * @returns {Array} Array of executed passive results
     */
    processPassiveAbilities(trigger, character, additionalData = {}) {
        // Parameter validation
        if (!trigger || typeof trigger !== 'string') {
            console.error("[PassiveAbilityManager] Invalid trigger parameter:", trigger);
            return [];
        }
        
        // Enhanced character validation
        if (!this.validateCharacter(character)) {
            return [];
        }
        
        // Will store results from executed passives
        const results = [];
        
        // Check for battle behaviors
        if (!this.battleManager.battleBehaviors) {
            console.warn("[PassiveAbilityManager] Battle behaviors system not available");
            return results;
        }
        
        // Check for PassiveTriggerTracker
        if (!this.passiveTriggerTracker) {
            console.warn("[PassiveAbilityManager] PassiveTriggerTracker not available");
        }
        
        // Process each passive ability
        character.passiveAbilities.forEach(ability => {
            // Skip if ability is invalid
            if (!ability || !ability.passiveTrigger) return;
            
            // Skip if this passive has already been triggered this turn for this trigger type
            const passiveId = ability.id || ability.name;
            
            // Check if this passive has already been triggered (if tracker available)
            if (this.passiveTriggerTracker && this.passiveTriggerTracker.hasFiredThisTurn(character, passiveId, trigger)) {
                console.debug(`[PassiveAbilityManager] Skipping duplicate trigger of ${passiveId} for ${character.name}, already triggered this turn`);
                return; // Skip this passive ability
            }
            
            // Special handling for onBattleStart trigger - battle-level tracking
            if (trigger === 'onBattleStart' && this.passiveTriggerTracker && 
                this.passiveTriggerTracker.hasFiredThisBattle(character, passiveId, trigger)) {
                console.debug(`[PassiveAbilityManager] Skipping duplicate battle start trigger: ${ability.name} for ${character.name}`);
                return; // Skip this passive ability
            }
            
            // Check if this passive matches the current trigger
            if (this.canTriggerPassive(character, ability, trigger)) {
                const result = this.executePassiveBehavior(character, ability, trigger, additionalData);
                
                // If passive executed successfully
                if (result && result.executed) {
                    // Record trigger if tracker available
                    if (this.passiveTriggerTracker) {
                        this.passiveTriggerTracker.recordTrigger(character, passiveId, trigger);
                    }
                    
                    results.push(result);
                    
                    // Log passive activation message
                    this.logPassiveActivation(character, result);
                }
            }
        });
        
        return results;
    }
    
    /**
     * Check if a passive ability can trigger
     * @param {Object} character - The character
     * @param {Object} ability - The passive ability
     * @param {string} trigger - The trigger type
     * @returns {boolean} True if passive can trigger
     */
    canTriggerPassive(character, ability, trigger) {
        // Must match trigger type
        if (ability.passiveTrigger !== trigger) return false;
        
        // Must have behavior
        if (!ability.passiveBehavior) return false;
        
        // Must have behavior registered
        if (!this.battleManager.battleBehaviors.hasBehavior(ability.passiveBehavior)) return false;
        
        // Check max stacks if configured and tracker available
        if (this.passiveTriggerTracker) {
            const maxStacks = this.passiveTriggerTracker.getMaxStacksForPassive(ability);
            if (maxStacks && this.passiveTriggerTracker.hasReachedMaxStacks(character, ability.id || ability.name, trigger, maxStacks)) {
                console.debug(`[PassiveAbilityManager] ${ability.name} has reached max stacks (${maxStacks})`);
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Execute a passive ability behavior
     * @param {Object} character - The character
     * @param {Object} ability - The passive ability
     * @param {string} trigger - The trigger type
     * @param {Object} additionalData - Additional data for context
     * @returns {Object|null} The result of execution or null if failed
     */
    executePassiveBehavior(character, ability, trigger, additionalData) {
        try {
            // Create context for the passive behavior
            const passiveContext = {
                actor: character,
                ability: ability,
                battleManager: this.battleManager,
                teamManager: this.battleManager.teamManager || { getCharacterTeam: (char) => char.team },
                trigger: trigger,
                additionalData: additionalData
            };
            
            // Get the behavior function name
            const behaviorName = ability.passiveBehavior;
            
            // Execute the passive behavior
            return this.battleManager.battleBehaviors.executePassiveBehavior(behaviorName, passiveContext);
        } catch (error) {
            console.error(`[PassiveAbilityManager] Error executing passive ability '${ability.name}':`, error);
            return null;
        }
    }
    
    /**
     * Log passive ability activation
     * @param {Object} character - The character
     * @param {Object} result - The execution result
     */
    logPassiveActivation(character, result) {
        if (result && result.message) {
            const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
            this.battleManager.logMessage(`${character.name}${teamIdentifier}'s passive ability: ${result.message}`, 'action');
        }
    }
    
    /**
     * Get passives for a specific trigger type
     * @param {Object} character - The character to check
     * @param {string} trigger - The trigger type
     * @returns {Array} Matching passive abilities
     */
    getPassivesByTriggerType(character, trigger) {
        if (!character || !character.passiveAbilities || !trigger) {
            return [];
        }
        
        return character.passiveAbilities.filter(ability => 
            ability && ability.passiveTrigger === trigger
        );
    }
}

// Make PassiveAbilityManager available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.PassiveAbilityManager = PassiveAbilityManager;
  console.log("PassiveAbilityManager class definition loaded and exported to window.PassiveAbilityManager");
}

// Legacy global assignment for maximum compatibility
window.PassiveAbilityManager = PassiveAbilityManager;

// Try exporting as an ES module if supported
try {
  if (typeof module !== 'undefined') {
    module.exports = PassiveAbilityManager;
  }
} catch (e) {
  console.log('ES Module export not supported in this environment');
}


===== FILE: PassiveTriggerTracker.js =====
/**
 * PassiveTriggerTracker.js
 * Tracks passive ability trigger history for both turn-based and battle-wide tracking
 * Version 0.5.27.1 - Full implementation of trigger tracking system
 */

class PassiveTriggerTracker {
    /**
     * Create a new Passive Trigger Tracker
     */
    constructor() {
        this.turnTriggers = new Map(); // Tracking for current turn {key: boolean}
        this.battleTriggers = new Map(); // Tracking for entire battle {key: count}
    }

    /**
     * Reset tracking for a new turn
     * Should be called at the beginning of each turn
     */
    resetTurnTracking() {
        console.log("[PassiveTriggerTracker] Resetting turn-based tracking");
        this.turnTriggers.clear();
    }

    /**
     * Reset tracking for a new battle
     * Should be called when a new battle starts
     */
    resetBattleTracking() {
        console.log("[PassiveTriggerTracker] Resetting battle-wide tracking");
        this.turnTriggers.clear();
        this.battleTriggers.clear();
    }

    /**
     * Generate a consistent tracking key for passive triggers
     * @param {Object|string} character - Character object or character ID
     * @param {string} passiveId - Passive ability ID or name
     * @param {string} trigger - Trigger type (onTurnStart, onDamageTaken, etc.)
     * @returns {string} A unique key for this trigger
     */
    _generateTriggerKey(character, passiveId, trigger) {
        // Extract ID from character object if a full character was passed
        const characterId = typeof character === 'object' ? 
            (character.uniqueId || character.id) : character;
        
        if (!characterId || !passiveId || !trigger) {
            console.warn("[PassiveTriggerTracker] Invalid parameters for trigger key generation", {
                characterId, passiveId, trigger
            });
            // Return a placeholder key to prevent errors
            return `invalid_${Date.now()}`;
        }
        
        return `${characterId}_${passiveId}_${trigger}`;
    }

    /**
     * Check if a passive has already been triggered this turn
     * @param {Object|string} character - Character object or character ID
     * @param {string} passiveId - Passive ability ID or name
     * @param {string} trigger - Trigger type
     * @returns {boolean} True if already triggered this turn
     */
    hasFiredThisTurn(character, passiveId, trigger) {
        const key = this._generateTriggerKey(character, passiveId, trigger);
        return this.turnTriggers.has(key);
    }
    
    /**
     * Check if a passive has already been triggered this battle
     * @param {Object|string} character - Character object or character ID
     * @param {string} passiveId - Passive ability ID or name
     * @param {string} trigger - Trigger type
     * @returns {boolean} True if already triggered this battle
     */
    hasFiredThisBattle(character, passiveId, trigger) {
        const key = this._generateTriggerKey(character, passiveId, trigger);
        return this.battleTriggers.has(key);
    }

    /**
     * Record that a passive was triggered
     * @param {Object|string} character - Character object or character ID
     * @param {string} passiveId - Passive ability ID or name
     * @param {string} trigger - Trigger type
     */
    recordTrigger(character, passiveId, trigger) {
        const key = this._generateTriggerKey(character, passiveId, trigger);
        
        // Record for turn-based tracking
        this.turnTriggers.set(key, true);
        
        // Record for battle-wide tracking with count
        const currentCount = this.battleTriggers.get(key) || 0;
        this.battleTriggers.set(key, currentCount + 1);
        
        console.debug(`[PassiveTriggerTracker] Recorded trigger: ${key} (${currentCount + 1} times this battle)`);
    }
    
    /**
     * Get the number of times a passive has triggered for a character in this battle
     * @param {Object|string} character - Character object or character ID
     * @param {string} passiveId - Passive ability ID or name
     * @param {string} trigger - Trigger type
     * @returns {number} The number of times the passive has triggered
     */
    getTriggerCount(character, passiveId, trigger) {
        const key = this._generateTriggerKey(character, passiveId, trigger);
        return this.battleTriggers.get(key) || 0;
    }
    
    /**
     * Check if a passive has reached its maximum stack count
     * Some passives can only trigger a limited number of times per battle
     * @param {Object|string} character - Character object or character ID
     * @param {string} passiveId - Passive ability ID or name
     * @param {string} trigger - Trigger type
     * @param {number} maxStacks - Maximum number of triggers allowed
     * @returns {boolean} True if maximum stack count reached
     */
    hasReachedMaxStacks(character, passiveId, trigger, maxStacks) {
        if (!maxStacks || maxStacks <= 0) {
            return false; // No limit if maxStacks is not provided or invalid
        }
        
        const count = this.getTriggerCount(character, passiveId, trigger);
        return count >= maxStacks;
    }
    
    /**
     * Get the maximum number of stacks (triggers) for a passive ability
     * Based on passive ability configuration or defaults to unlimited
     * @param {Object} ability - The passive ability object
     * @returns {number|null} Maximum stacks or null for unlimited
     */
    getMaxStacksForPassive(ability) {
        if (!ability) return null;
        
        // Check for passive data configuration
        if (ability.passiveData && typeof ability.passiveData.maxTriggers === 'number') {
            return ability.passiveData.maxTriggers;
        }
        
        // Check for ability property
        if (typeof ability.maxTriggers === 'number') {
            return ability.maxTriggers;
        }
        
        // Default to unlimited (null)
        return null;
    }
}

// Make PassiveTriggerTracker available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.PassiveTriggerTracker = PassiveTriggerTracker;
  console.log("PassiveTriggerTracker class definition loaded and exported to window.PassiveTriggerTracker");
}

// Legacy global assignment for maximum compatibility
window.PassiveTriggerTracker = PassiveTriggerTracker;

// Try exporting as an ES module if supported
try {
  if (typeof module !== 'undefined') {
    module.exports = PassiveTriggerTracker;
  }
} catch (e) {
  console.log('ES Module export not supported in this environment');
}


===== FILE: StatusEffectDefinitionLoader.js =====
class StatusEffectDefinitionLoader {
    constructor() {
        this.effectDefinitions = new Map();
        // Use setupFallbackDefinitions initially
        this.setupFallbackDefinitions();
        // Then try to load from JSON
        this.primeDefinitions();
        console.log('[StatusEffectDefinitionLoader] Initialized with fallback definitions, attempting to load JSON data...');
    }

    /**
     * Prime the definition loader with data from either JSON or fallback definitions.
     * This method ensures that status effect definitions are available from *some* source.
     * First attempts to load from JSON files, and if that fails uses fallback definitions.
     * @returns {Promise<boolean>} - Promise resolving to success status
     */
    async primeDefinitions() {
        console.log('[StatusEffectDefinitionLoader] Priming status effect definitions...');
        
        try {
            // Try to load from JSON first
            const jsonSuccess = await this.loadDefinitionsFromJson();
            if (jsonSuccess) {
                console.log('[StatusEffectDefinitionLoader] Successfully loaded definitions from JSON');
                return true;
            }
            
            // If JSON loading failed, ensure fallback definitions are set up
            console.log('[StatusEffectDefinitionLoader] JSON loading failed, using fallback definitions');
            const fallbackSuccess = this.setupFallbackDefinitions();
            
            return fallbackSuccess;
        } catch (error) {
            // If anything went wrong during JSON loading, use fallbacks
            console.error('[StatusEffectDefinitionLoader] Error during definition loading:', error);
            console.log('[StatusEffectDefinitionLoader] Using fallback definitions due to error');
            
            // Ensure fallbacks are set up
            const fallbackSuccess = this.setupFallbackDefinitions();
            
            // Even if fallbacks failed (shouldn't happen), return true to allow game to continue
            return fallbackSuccess;
        }
    }

    /**
     * Normalize effect definition to a standard internal format
     * @param {Object} definition - The status effect definition to normalize
     * @returns {Object} - The normalized definition
     */
    normalizeDefinition(definition) {
        // Create a copy of the definition to avoid modifying the original
        const normalized = { ...definition };
        
        // Ensure required properties exist
        normalized.id = definition.id;
        normalized.name = definition.name;
        normalized.description = definition.description;
        
        // Normalize duration (use defaultDuration if duration is not present)
        if (typeof definition.duration !== 'number' && typeof definition.defaultDuration === 'number') {
            normalized.duration = definition.defaultDuration;
        }
        
        // Normalize stackable property (infer from maxStacks if not present)
        if (typeof definition.stackable !== 'boolean' && typeof definition.maxStacks === 'number') {
            normalized.stackable = definition.maxStacks > 1;
            normalized.maxStacks = definition.maxStacks;
        }
        
        // Normalize icon path
        if (definition.icon && !definition.iconPath) {
            normalized.iconPath = definition.icon;
        } else if (!normalized.iconPath && !normalized.icon) {
            // Fallback icon if none provided
            normalized.iconPath = `assets/images/icons/status/status-icons/${normalized.id.replace('status_', '')}.png`;
        }
        
        // Handle behavior-based effect types
        if (definition.behavior && !definition.effectType) {
            // Determine effectType from behavior
            if (definition.behavior.trigger === 'onTurnStart') {
                if (definition.behavior.action === 'Damage') {
                    normalized.effectType = 'damage';
                    normalized.value = definition.behavior.value || 5;
                } else if (definition.behavior.action === 'Heal') {
                    normalized.effectType = 'healing';
                    normalized.value = definition.behavior.value || 5;
                }
            } else if (definition.behavior.modifier === 'StatModification') {
                normalized.effectType = 'statModifier';
                normalized.stat = definition.behavior.stat?.toLowerCase() || 'attack';
                normalized.value = definition.behavior.value || 5;
            } else if (definition.behavior.modifier === 'AbsorbDamage') {
                normalized.effectType = 'shield';
                normalized.value = definition.behavior.value || 10;
            } else if (definition.behavior.modifier === 'PreventAction') {
                normalized.effectType = 'control';
            } else if (definition.type === 'Buff' || definition.type === 'Debuff') {
                // Use the type property as a fallback
                normalized.effectType = definition.type.toLowerCase();
            } else {
                normalized.effectType = 'utility';  // Default fallback
            }
        }
        
        // Add missing properties for the internal format if needed
        if (!normalized.effectType) {
            normalized.effectType = 'utility';
        }
        
        return normalized;
    }

    /**
     * Load status effect definitions from JSON file
     * @param {string} [primaryPath='data/status_effects.json'] - Primary path to load from
     * @param {string} [fallbackPath='/status_effects.json'] - Fallback path if primary fails
     * @returns {Promise<boolean>} - Promise resolving to success status
     */
    async loadDefinitionsFromJson(primaryPath = 'data/status_effects.json', fallbackPath = '/status_effects.json') {
        console.log('[StatusEffectDefinitionLoader] Loading status effect definitions from JSON...');
        
        try {
            // First try to load from primary path (data directory)
            try {
                console.log(`[StatusEffectDefinitionLoader] Attempting to load from ${primaryPath}...`);
                const response = await fetch(primaryPath);
                if (!response.ok) {
                    throw new Error(`Failed to load ${primaryPath}: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                return this._processDefinitionData(data, 'primary path');
            } catch (primaryError) {
                console.warn(`[StatusEffectDefinitionLoader] Failed to load from ${primaryPath}:`, primaryError.message);
                
                // Try fallback path (root directory)
                try {
                    console.log(`[StatusEffectDefinitionLoader] Attempting to load from ${fallbackPath}...`);
                    const response = await fetch(fallbackPath);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${fallbackPath}: ${response.status} ${response.statusText}`);
                    }
                    const data = await response.json();
                    return this._processDefinitionData(data, 'fallback path');
                } catch (fallbackError) {
                    console.warn(`[StatusEffectDefinitionLoader] Failed to load from ${fallbackPath}:`, fallbackError.message);
                    throw primaryError; // Throw original error
                }
            }
        } catch (error) {
            console.error('[StatusEffectDefinitionLoader] Error loading status effect definitions:', error);
            console.log('[StatusEffectDefinitionLoader] Using fallback definitions only.');
            return false;
        }
    }
    
    /**
     * Private helper to process loaded definition data
     * @private
     * @param {Object} effectsData - The loaded JSON data
     * @param {string} source - Description of the data source for logging
     * @returns {boolean} - Success status
     */
    _processDefinitionData(effectsData, source) {
        if (!effectsData) {
            console.error(`[StatusEffectDefinitionLoader] No data received from ${source}`);
            return false;
        }
        
        // Handle different possible JSON formats
        let effectsArray = [];
        if (Array.isArray(effectsData)) {
            effectsArray = effectsData;
        } else if (typeof effectsData === 'object' && effectsData !== null) {
            // Check if it's wrapped in a "status_effects" property (common format)
            if (effectsData.status_effects && Array.isArray(effectsData.status_effects)) {
                effectsArray = effectsData.status_effects;
                console.log(`[StatusEffectDefinitionLoader] Extracted array from status_effects property with ${effectsArray.length} effects`);
            } else {
                // If it's an object with effect IDs as keys, convert to array
                effectsArray = Object.values(effectsData);
                console.log(`[StatusEffectDefinitionLoader] Converted object to array with ${effectsArray.length} effects`);
            }
        } else {
            console.error(`[StatusEffectDefinitionLoader] Expected status effect data but got: ${typeof effectsData}`);
            return false;
        }
        
        // Process the effects array
        let validCount = 0;
        effectsArray.forEach(definition => {
            if (this.validateDefinition(definition)) {
                // Normalize the definition to match our expected format
                const normalizedDef = this.normalizeDefinition(definition);
                this.effectDefinitions.set(normalizedDef.id, normalizedDef);
                validCount++;
            } else {
                // Warning is handled by validateDefinition's detailed error messages
            }
        });
        
        console.log(`[StatusEffectDefinitionLoader] Loaded ${validCount} valid status effect definitions from ${source}`);
        return validCount > 0;
    }
    
    /**
     * Legacy method to maintain backward compatibility
     * @private
     */
    _loadDefinitionsAsync() {
        console.warn('[StatusEffectDefinitionLoader] _loadDefinitionsAsync is deprecated, use loadDefinitionsFromJson instead');
        return this.loadDefinitionsFromJson();
    }

    validateDefinition(definition) {
        // Check required fields
        if (!definition || typeof definition !== 'object') {
            console.debug('[StatusEffectDefinitionLoader] Definition is not an object');
            return false;
        }
        
        if (!definition.id || typeof definition.id !== 'string') {
            console.debug('[StatusEffectDefinitionLoader] Missing or invalid id property');
            return false;
        }
        
        if (!definition.name || typeof definition.name !== 'string') {
            console.debug(`[StatusEffectDefinitionLoader] Missing or invalid name for effect: ${definition.id}`);
            return false;
        }
        
        if (!definition.description || typeof definition.description !== 'string') {
            console.debug(`[StatusEffectDefinitionLoader] Missing or invalid description for effect: ${definition.id}`);
            return false;
        }
        
        // Check duration - allow defaultDuration as an alternative field name
        const hasDuration = (
            (typeof definition.duration === 'number' && (definition.duration > 0 || definition.duration === -1)) ||
            (typeof definition.defaultDuration === 'number' && (definition.defaultDuration > 0 || definition.defaultDuration === -1))
        );
        
        if (!hasDuration) {
            console.debug(`[StatusEffectDefinitionLoader] Invalid or missing duration for effect: ${definition.id}`);
            return false;
        }
        
        // Check if stackable is boolean or if maxStacks is present (alternative to stackable)
        const hasStackInfo = (
            typeof definition.stackable === 'boolean' ||
            typeof definition.maxStacks === 'number'
        );
        
        if (!hasStackInfo) {
            console.debug(`[StatusEffectDefinitionLoader] Missing stacking information for effect: ${definition.id}`);
            return false;
        }
        
        // Additional validations based on effect type or behavior
        if (definition.effectType) {
            // Original format validation
            if (definition.effectType === 'damage' && typeof definition.value !== 'number') {
                console.debug(`[StatusEffectDefinitionLoader] Missing or invalid value for damage effect: ${definition.id}`);
                return false;
            }
            
            if (definition.effectType === 'healing' && typeof definition.value !== 'number') {
                console.debug(`[StatusEffectDefinitionLoader] Missing or invalid value for healing effect: ${definition.id}`);
                return false;
            }
            
            if (definition.effectType === 'statModifier') {
                if (!definition.stat || typeof definition.stat !== 'string') {
                    console.debug(`[StatusEffectDefinitionLoader] Missing or invalid stat for stat modifier effect: ${definition.id}`);
                    return false;
                }
                if (typeof definition.value !== 'number') {
                    console.debug(`[StatusEffectDefinitionLoader] Missing or invalid value for stat modifier effect: ${definition.id}`);
                    return false;
                }
            }
        } else if (definition.behavior) {
            // New format validation - behavior-based effects
            // Minimal validation - we'll normalize during processing
            if (typeof definition.behavior !== 'object') {
                console.debug(`[StatusEffectDefinitionLoader] Invalid behavior property for effect: ${definition.id}`);
                return false;
            }
        }
        
        return true;
    }

    /**
     * Setup fallback status effect definitions if loading fails
     * Provides a comprehensive set of default status effects that
     * cover all common game scenarios.
     * @returns {boolean} - Success status
     */
    setupFallbackDefinitions() {
        console.log('[StatusEffectDefinitionLoader] Setting up fallback definitions');
        
        // Clear existing definitions to ensure we don't have duplicates
        this.effectDefinitions.clear();
        
        // HOTFIX (0.5.27.2_Hotfix1): Add additional common status effect IDs with "status_" prefix
        // This addresses issues with status_regen and status_spd_down specifically
        
        // Core status effects as fallback
        const fallbackEffects = [
            {
                id: 'burn',
                name: 'Burn',
                description: 'Taking damage over time from fire',
                effectType: 'damage',
                value: 5,
                duration: 3,
                stackable: true,
                maxStacks: 3,
                iconPath: 'assets/images/icons/status/status-icons/burn.png'
            },
            {
                id: 'poison',
                name: 'Poison',
                description: 'Taking damage over time from toxins',
                effectType: 'damage',
                value: 4,
                duration: 4,
                stackable: true,
                maxStacks: 5,
                iconPath: 'assets/images/icons/status/status-icons/poison.png'
            },
            {
                id: 'bleed',
                name: 'Bleed',
                description: 'Taking damage over time from bleeding',
                effectType: 'damage',
                value: 6,
                duration: 3,
                stackable: true,
                maxStacks: 3,
                iconPath: 'assets/images/icons/status/status-icons/bleed.png'
            },
            {
                id: 'stun',
                name: 'Stun',
                description: 'Unable to take actions',
                effectType: 'control',
                duration: 1,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/stun.png'
            },
            {
                id: 'freeze',
                name: 'Freeze',
                description: 'Unable to take actions and vulnerable to damage',
                effectType: 'control',
                duration: 2,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/freeze.png'
            },
            {
                id: 'regeneration',
                name: 'Regeneration',
                description: 'Recovering health over time',
                effectType: 'healing',
                value: 5,
                duration: 3,
                stackable: true,
                maxStacks: 3,
                iconPath: 'assets/images/icons/status/status-icons/regeneration.png'
            },
            {
                id: 'attackUp',
                name: 'Attack Up',
                description: 'Attack power is increased',
                effectType: 'statModifier',
                stat: 'attack',
                value: 5,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/attackUp.png'
            },
            {
                id: 'defenseUp',
                name: 'Defense Up',
                description: 'Defense is increased',
                effectType: 'statModifier',
                stat: 'defense',
                value: 5,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/defenseUp.png'
            },
            {
                id: 'attackDown',
                name: 'Attack Down',
                description: 'Attack power is decreased',
                effectType: 'statModifier',
                stat: 'attack',
                value: -5,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/attackDown.png'
            },
            {
                id: 'defenseDown',
                name: 'Defense Down',
                description: 'Defense is decreased',
                effectType: 'statModifier',
                stat: 'defense',
                value: -5,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/defenseDown.png'
            },
            {
                id: 'speedUp',
                name: 'Speed Up',
                description: 'Speed is increased',
                effectType: 'statModifier',
                stat: 'speed',
                value: 2,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/speedUp.png'
            },
            {
                id: 'speedDown',
                name: 'Speed Down',
                description: 'Speed is decreased',
                effectType: 'statModifier',
                stat: 'speed',
                value: -2,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/speedDown.png'
            },
            {
                id: 'shield',
                name: 'Shield',
                description: 'Absorbs incoming damage',
                effectType: 'shield',
                value: 10,
                duration: 3,
                stackable: false,
                iconPath: 'assets/images/icons/status/status-icons/shield.png'
            }
        ];
        
        // Add fallback definitions to map
        fallbackEffects.forEach(effect => {
            this.effectDefinitions.set(effect.id, effect);
        });
        
        // HOTFIX (0.5.27.2_Hotfix1): Add specific definitions for problematic status effects
        // Add status_regen effect
        this.effectDefinitions.set('status_regen', {
            id: 'status_regen',
            name: 'Regeneration',
            description: 'Recovering health over time',
            effectType: 'healing',
            value: 5,
            duration: 3,
            stackable: true,
            maxStacks: 3,
            iconPath: 'assets/images/icons/status/status-icons/regeneration.png',
            behavior: {
                trigger: 'onTurnStart',
                action: 'Heal',
                valueType: 'PercentMaxHP',
                value: 0.05
            }
        });
        
        // Add status_spd_down effect
        this.effectDefinitions.set('status_spd_down', {
            id: 'status_spd_down',
            name: 'Speed Down',
            description: 'Speed is decreased',
            effectType: 'statModifier',
            stat: 'speed',
            value: -2,
            duration: 3,
            stackable: false,
            iconPath: 'assets/images/icons/status/status-icons/speeddown.png'
        });
        
        console.log(`[StatusEffectDefinitionLoader] Added ${fallbackEffects.length + 2} fallback definitions (including specific additions for status_regen and status_spd_down)`);
        
        return true; // Indicate successful setup
    }

    generateFallbackDefinition(effectId) {
        // HOTFIX: Helper to generate meaningful fallback definitions based on the effectId
        // Handles specific problematic status effects like status_regen and status_spd_down
        const lowerEffectId = effectId.toLowerCase();
        
        // Auto-detect effect type based on name
        let effectType = 'unknown';
        let duration = 2;
        let value = 0;
        let stackable = false;
        let stat = null;
        let name = `Unknown Effect (${effectId})`;
        let description = 'An unknown status effect';
        let iconPath = 'assets/images/icons/status/status-icons/unknown.png';
        
        // Try to intelligently determine effect type from ID
        if (lowerEffectId.includes('burn') || lowerEffectId.includes('poison') || lowerEffectId.includes('bleed')) {
            effectType = 'damage';
            value = 5;
            duration = 3;
            stackable = true;
            name = lowerEffectId.includes('burn') ? 'Burn' : 
                  lowerEffectId.includes('poison') ? 'Poison' : 'Bleed';
            description = `Taking damage over time from ${name.toLowerCase()}`;
            iconPath = `assets/images/icons/status/status-icons/${name.toLowerCase()}.png`;
        }
        else if (lowerEffectId.includes('regen') || lowerEffectId.includes('heal')) {
            effectType = 'healing';
            value = 5;
            duration = 3;
            stackable = true;
            name = 'Regeneration';
            description = 'Recovering health over time';
            iconPath = 'assets/images/icons/status/status-icons/regeneration.png';
        }
        else if (lowerEffectId.includes('stun') || lowerEffectId.includes('freeze') || lowerEffectId.includes('paralyze')) {
            effectType = 'control';
            duration = 1;
            name = lowerEffectId.includes('stun') ? 'Stun' : 
                  lowerEffectId.includes('freeze') ? 'Freeze' : 'Paralyze';
            description = 'Unable to take actions';
            iconPath = `assets/images/icons/status/status-icons/${name.toLowerCase()}.png`;
        }
        else if (lowerEffectId.includes('shield') || lowerEffectId.includes('protect')) {
            effectType = 'shield';
            value = 10;
            duration = 2;
            name = 'Shield';
            description = 'Absorbs incoming damage';
            iconPath = 'assets/images/icons/status/status-icons/shield.png';
        }
        // Stat modifiers
        else if (lowerEffectId.includes('atk') || lowerEffectId.includes('attack')) {
            effectType = 'statModifier';
            stat = 'attack';
            value = lowerEffectId.includes('down') ? -5 : 5;
            duration = 3;
            name = value > 0 ? 'Attack Up' : 'Attack Down';
            description = `Attack power is ${value > 0 ? 'increased' : 'decreased'}`;
            iconPath = `assets/images/icons/status/status-icons/${name.replace(' ', '').toLowerCase()}.png`;
        }
        else if (lowerEffectId.includes('def') || lowerEffectId.includes('defense')) {
            effectType = 'statModifier';
            stat = 'defense';
            value = lowerEffectId.includes('down') ? -5 : 5;
            duration = 3;
            name = value > 0 ? 'Defense Up' : 'Defense Down';
            description = `Defense is ${value > 0 ? 'increased' : 'decreased'}`;
            iconPath = `assets/images/icons/status/status-icons/${name.replace(' ', '').toLowerCase()}.png`;
        }
        else if (lowerEffectId.includes('spd') || lowerEffectId.includes('speed')) {
            effectType = 'statModifier';
            stat = 'speed';
            value = lowerEffectId.includes('down') ? -2 : 2;
            duration = 3;
            name = value > 0 ? 'Speed Up' : 'Speed Down';
            description = `Speed is ${value > 0 ? 'increased' : 'decreased'}`;
            iconPath = `assets/images/icons/status/status-icons/${name.replace(' ', '').toLowerCase()}.png`;
        }
        
        const fallbackDefinition = {
            id: effectId,
            name: name,
            description: description,
            effectType: effectType,
            duration: duration,
            stackable: stackable,
            iconPath: iconPath
        };
        
        // Add type-specific properties
        if (effectType === 'damage' || effectType === 'healing' || effectType === 'shield') {
            fallbackDefinition.value = value;
        }
        if (effectType === 'statModifier') {
            fallbackDefinition.stat = stat;
            fallbackDefinition.value = value;
        }
        if (stackable) {
            fallbackDefinition.maxStacks = 3; // Default max stacks
        }
        
        // For healing effects like regeneration, add a behavior property
        if (effectType === 'healing') {
            fallbackDefinition.behavior = {
                trigger: 'onTurnStart',
                action: 'Heal',
                valueType: 'PercentMaxHP',
                value: 0.05
            };
        }
        
        console.warn(`[StatusEffectDefinitionLoader] Generated fallback definition for '${effectId}': ${JSON.stringify(fallbackDefinition)}`);
        return fallbackDefinition;
    }
    
    getDefinition(effectId) {
        if (!effectId) {
            console.warn('[StatusEffectDefinitionLoader] getDefinition called with null/undefined effectId');
            return null;
        }
        
        // HOTFIX (0.5.27.2_Hotfix8): Immediately generate and cache missing definitions
        if (!this.effectDefinitions.has(effectId)) {
            // Generate a fallback definition and cache it for future use
            const fallbackDefinition = this.generateFallbackDefinition(effectId);
            this.effectDefinitions.set(effectId, fallbackDefinition);
            
            // Log generation but not as a warning
            console.log(`[StatusEffectDefinitionLoader] Generated and cached fallback definition for: ${effectId}`);
        }
        
        return this.effectDefinitions.get(effectId);
    }
}

// Make StatusEffectDefinitionLoader available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.StatusEffectDefinitionLoader = StatusEffectDefinitionLoader;
    console.log("StatusEffectDefinitionLoader class definition loaded and exported to window.StatusEffectDefinitionLoader");
}

// Legacy global assignment for maximum compatibility
window.StatusEffectDefinitionLoader = StatusEffectDefinitionLoader;

===== FILE: StatusEffectManager.js =====
class StatusEffectManager {
    constructor(battleManager, definitionLoader) {
        this.battleManager = battleManager;
        this.definitionLoader = definitionLoader;
        console.log('[StatusEffectManager] Initialized with definition loader');
    }

    processStatusEffects(character) {
        if (!character || !character.statusEffects || !Array.isArray(character.statusEffects)) {
            return; // Nothing to process
        }

        // Track effects to remove after processing
        const effectsToRemove = [];
        
        // Process each status effect
        character.statusEffects.forEach(effect => {
            try {
                // Get definition for this effect
                const definition = this.definitionLoader.getDefinition(effect.id);
                if (!definition) return; // Skip if definition not found
                
                // Skip processing if character is defeated (unless it's a revival effect)
                if (character.defeated && definition.effectType !== 'revival') {
                    return;
                }
                
                // Process based on effect type
                switch (definition.effectType) {
                    case 'damage':
                        this._processDamageEffect(character, effect, definition);
                        break;
                    case 'healing':
                        this._processHealingEffect(character, effect, definition);
                        break;
                    case 'statModifier':
                        // Stat modifiers are applied when added and removed when expired
                        // No per-turn processing needed
                        break;
                    case 'shield':
                        // Shields are handled during damage calculation
                        // No per-turn processing needed
                        break;
                    case 'control':
                        // Control effects are checked during action selection
                        // No per-turn processing needed
                        break;
                }
                
                // Decrease duration
                if (effect.duration > 0) { // Skip permanent effects (-1)
                    effect.duration--;
                    
                    // Mark for removal if duration reached 0
                    if (effect.duration <= 0) {
                        effectsToRemove.push(effect.id);
                    }
                }
            } catch (err) {
                console.error(`[StatusEffectManager] Error processing effect ${effect.id}:`, err);
            }
        });
        
        // Remove expired effects
        effectsToRemove.forEach(effectId => {
            this.removeStatusEffect(character, effectId);
        });
        
        // Update UI
        this.updateStatusIcons(character);
    }

    /**
     * Add a status effect to a character
     * @param {Object} character - The character to apply the effect to
     * @param {string} effectId - The ID of the effect to apply
     * @param {Object|null} source - The character causing the effect (or null if no specific source)
     * @param {number} duration - How many turns the effect lasts
     * @param {number} stacks - Number of stacks to apply (for stackable effects)
     * @returns {boolean} - Whether the effect was successfully applied
     */
    addStatusEffect(character, effectId, source, duration, stacks = 1) {
        // Parameter validation and position checking
        if (!character || !effectId) {
            console.warn('[StatusEffectManager] Invalid parameters to addStatusEffect: missing character or effectId');
            return false;
        }
        
        // PARAMETER VALIDATION: Check for potential parameter misalignment
        if (typeof source === 'number' && (duration === undefined || typeof duration === 'object')) {
            console.warn(`[StatusEffectManager] POTENTIAL PARAMETER MISALIGNMENT in addStatusEffect call for '${effectId}'`);
            console.warn(`[StatusEffectManager] The 'source' parameter appears to be a number (${source}), which might be duration mistakenly passed as source.`);
            console.warn(`[StatusEffectManager] Correct parameter order: addStatusEffect(character, effectId, source, duration, stacks)`);
            
            // HOTFIX: Attempt to fix parameter order if it appears to be misaligned
            // If source is a number and duration is undefined or an object, assume source was meant to be duration
            if (duration === undefined) {
                duration = source;
                source = null;
                console.warn(`[StatusEffectManager] Auto-corrected parameters: using ${duration} as duration and null as source`);
            }
        }
        
        // HOTFIX: Ensure duration is always a number to prevent circular references
        if (typeof duration !== 'number') {
            console.error(`[StatusEffectManager] Invalid duration parameter (${typeof duration}) in addStatusEffect for '${effectId}'`);
            // Get definition to use its default duration
            const definition = this.definitionLoader.getDefinition(effectId);
            // Use definition's duration, or a fallback value of 3
            duration = (definition && typeof definition.duration === 'number') ? definition.duration : 3;
            console.log(`[StatusEffectManager] Using default duration: ${duration}`);
        }
        
        // Ensure character has statusEffects array
        if (!character.statusEffects) {
            character.statusEffects = [];
        }
        
        // Get definition for this effect
        const definition = this.definitionLoader.getDefinition(effectId);
        if (!definition) {
            console.warn(`[StatusEffectManager] Cannot apply unknown effect: ${effectId}`);
            return false;
        }
        
        // Check for existing effect
        const existingEffect = character.statusEffects.find(e => e.id === effectId);
        
        if (existingEffect) {
            // Effect already exists - handle based on stacking rules
            if (definition.stackable) {
                // Increase stacks (up to max)
                const newStacks = Math.min(
                    (existingEffect.stacks || 1) + stacks, 
                    definition.maxStacks || 99
                );
                existingEffect.stacks = newStacks;
                
                // Reset duration if the new duration is longer
                if (duration > existingEffect.duration) {
                    existingEffect.duration = duration;
                }
                
                // Log stacking behavior
                this.battleManager.logMessage(
                    `${character.name} (${character.team === 'player' ? 'ally' : 'enemy'}) now has ${newStacks} stacks of ${definition.name}!`,
                    'status'
                );
            } else {
                // Non-stacking - just refresh duration
                existingEffect.duration = duration;
                
                // Log refresh
                this.battleManager.logMessage(
                    `${definition.name} refreshed on ${character.name} (${character.team === 'player' ? 'ally' : 'enemy'})!`,
                    'status'
                );
            }
        } else {
            // New effect - create and add
            const newEffect = {
                id: effectId,
                duration: duration,
                sourceId: source ? source.uniqueId : null, // CORRECTED: Store source uniqueId instead of source object
                stacks: definition.stackable ? stacks : 1
            };
            
            character.statusEffects.push(newEffect);
            
            // Apply immediate effects for certain types
            if (definition.effectType === 'statModifier') {
                this._applyStatModifier(character, definition, newEffect.stacks);
            }
            
            // Log new effect
            this.battleManager.logMessage(
                `${character.name} (${character.team === 'player' ? 'ally' : 'enemy'}) is affected by ${definition.name}!`,
                'status'
            );
        }
        
        // Dispatch event to update UI
        this.updateStatusIcons(character);
        
        return true;
    }

    removeStatusEffect(character, effectId) {
        if (!character || !character.statusEffects || !effectId) {
            return false;
        }
        
        // Find the effect index
        const effectIndex = character.statusEffects.findIndex(e => e.id === effectId);
        if (effectIndex === -1) {
            return false; // Effect not found
        }
        
        // Get the effect
        const effect = character.statusEffects[effectIndex];
        
        // Get definition for this effect
        const definition = this.definitionLoader.getDefinition(effectId);
        if (!definition) {
            // Just remove it if we can't find the definition
            character.statusEffects.splice(effectIndex, 1);
            return true;
        }
        
        // Handle cleanup for certain effect types
        if (definition.effectType === 'statModifier') {
            this._removeStatModifier(character, definition, effect.stacks);
        }
        
        // Remove the effect
        character.statusEffects.splice(effectIndex, 1);
        
        // Log removal if not defeated
        if (!character.defeated) {
            this.battleManager.logMessage(
                `${definition.name} has worn off from ${character.name} (${character.team === 'player' ? 'ally' : 'enemy'})!`,
                'status'
            );
        }
        
        // Update UI
        this.updateStatusIcons(character);
        
        return true;
    }

    getActiveEffects(character) {
        if (!character || !character.statusEffects) {
            return [];
        }
        
        // Return copy of status effects with enriched data
        return character.statusEffects.map(effect => {
            const definition = this.definitionLoader.getDefinition(effect.id);
            if (!definition) {
                return {
                    ...effect,
                    name: `Unknown Effect (${effect.id})`,
                    description: 'An unknown status effect',
                    iconPath: 'assets/images/icons/status/status-icons/unknown.png',
                    effectType: 'unknown'
                };
            }
            
            return {
                ...effect,
                name: definition.name,
                description: definition.description,
                iconPath: definition.iconPath,
                effectType: definition.effectType
            };
        });
    }

    updateStatusIcons(character) {
        if (!character) return;
        
        // We use the battleBridge to communicate with the UI
        try {
            // Get bridge instance using correct accessor pattern
            const battleBridge = window.getBattleBridge ? window.getBattleBridge() : window.battleBridge;
            
            if (battleBridge && typeof battleBridge.dispatchEvent === 'function') {
                // v0.5.27.4_StatusEffectParameterFix: Use STATUS_EFFECT_UPDATED instead of STATUS_EFFECTS_CHANGED
                // for consistency with BridgeEventFix
                battleBridge.dispatchEvent(battleBridge.eventTypes.STATUS_EFFECT_UPDATED, {
                    character: character,
                    effects: this.getActiveEffects(character)
                });
            } else {
                // Fallback 1: Try through BattleManager if that's the pattern used elsewhere
                if (this.battleManager && this.battleManager.dispatchUIEvent) {
                    // Try to use the constant from BattleBridge if available
                    const eventType = window.battleBridge?.eventTypes?.STATUS_EFFECT_UPDATED || 'status_effect_updated';
                    this.battleManager.dispatchUIEvent(eventType, {
                        character: character,
                        effects: this.getActiveEffects(character)
                    });
                } else {
                    console.log("[StatusEffectManager] Status effects changed but event dispatcher not available");
                }
            }
        } catch (err) {
            console.error('[StatusEffectManager] Error dispatching STATUS_EFFECT_UPDATED event:', err);
        }
    }

    hasEffectType(character, effectType) {
        if (!character || !character.statusEffects) return false;
        
        return character.statusEffects.some(effect => {
            const definition = this.definitionLoader.getDefinition(effect.id);
            return definition && definition.effectType === effectType;
        });
    }

    hasEffect(character, effectId) {
        if (!character || !character.statusEffects) return false;
        return character.statusEffects.some(effect => effect.id === effectId);
    }

    getEffectValue(character, effectId) {
        if (!character || !character.statusEffects) return 0;
        
        const effect = character.statusEffects.find(e => e.id === effectId);
        if (!effect) return 0;
        
        const definition = this.definitionLoader.getDefinition(effectId);
        if (!definition) return 0;
        
        // Return base value * stacks
        return definition.value * (effect.stacks || 1);
    }

    getEffectStacks(character, effectId) {
        if (!character || !character.statusEffects) return 0;
        
        const effect = character.statusEffects.find(e => e.id === effectId);
        if (!effect) return 0;
        
        return effect.stacks || 1;
    }

    // Private helper methods
    _processDamageEffect(character, effect, definition) {
        if (!character || character.defeated) return;
        
        // Calculate damage based on stacks
        const baseDamage = definition.value;
        const stacks = effect.stacks || 1;
        const damage = baseDamage * stacks;
        
        // Apply damage
        if (damage > 0) {
            this.battleManager.logMessage(
                `${character.name} (${character.team === 'player' ? 'ally' : 'enemy'}) takes ${damage} damage from ${definition.name}!`,
                'damage'
            );
            
            // Resolve the source character from sourceId
            // UPDATED in v0.6.0.3: Use BattleUtilities.getCharacterByUniqueId instead of battleManager.getCharacterByUniqueId
            // This aligns with Phase 3 refactoring where utility methods were moved out of BattleManager
            let sourceCharacter = null;
            const sourceIdToFind = effect.sourceId || (effect.source && typeof effect.source === 'object' ? effect.source.uniqueId : null);
            
            if (sourceIdToFind) {
                if (window.BattleUtilities) {
                    sourceCharacter = BattleUtilities.getCharacterByUniqueId(
                        sourceIdToFind,
                        this.battleManager.playerTeam, // Pass playerTeam
                        this.battleManager.enemyTeam  // Pass enemyTeam
                    );
                } else {
                    console.warn("[StatusEffectManager] BattleUtilities not available for getCharacterByUniqueId lookup.");
                    sourceCharacter = null;
                }
            }
            
            // Legacy handling for string name sources (not implemented - old approach not reliable)
            
            // HOTFIX (0.5.27.2_Hotfix8): Use applyDamage instead of dealDamage
            this.battleManager.applyDamage(
                character,         // target
                damage,            // amount
                sourceCharacter,   // source (resolved from sourceId, can be null)
                null,              // ability (null for status effects)
                effect.id || 'status_effect'  // damageType (use effect.id if available)
            );
        }
    }

    _processHealingEffect(character, effect, definition) {
        if (!character) return;
        
        // Calculate healing based on stacks
        const baseHealing = definition.value;
        const stacks = effect.stacks || 1;
        const healing = baseHealing * stacks;
        
        // Apply healing
        if (healing > 0) {
            this.battleManager.logMessage(
                `${character.name} (${character.team === 'player' ? 'ally' : 'enemy'}) restores ${healing} health from ${definition.name}!`,
                'healing'
            );
            
            // Use appropriate method from BattleManager
            if (typeof this.battleManager.applyHealing === 'function') {
                // Resolve the source character from sourceId
                // UPDATED in v0.6.0.3: Use BattleUtilities.getCharacterByUniqueId instead of battleManager.getCharacterByUniqueId
                // This aligns with Phase 3 refactoring where utility methods were moved out of BattleManager
                let sourceCharacter = null;
                const sourceIdToFind = effect.sourceId || (effect.source && typeof effect.source === 'object' ? effect.source.uniqueId : null);
                
                if (sourceIdToFind) {
                    if (window.BattleUtilities) {
                        sourceCharacter = BattleUtilities.getCharacterByUniqueId(
                            sourceIdToFind,
                            this.battleManager.playerTeam, // Pass playerTeam
                            this.battleManager.enemyTeam  // Pass enemyTeam
                        );
                    } else {
                        console.warn("[StatusEffectManager] BattleUtilities not available for getCharacterByUniqueId lookup.");
                        sourceCharacter = null;
                    }
                }
                
                // Legacy handling for string name sources (not implemented - old approach not reliable)

                const finalSourceForApplyHealing = sourceCharacter || character; // Fallback to the target character for self-effects
                
                // HOTFIX (0.5.27.2_Hotfix8): Fix parameter order - character being healed must be first
                this.battleManager.applyHealing(
                    character,       // target (character being healed)
                    healing,         // amount
                    finalSourceForApplyHealing, // source (resolved from sourceId or fallback to self)
                    null,              // ability (null for status effects)
                    definition.name || 'Regeneration'   // healType (use definition.name if available)
                );
            } else {
                // Fallback for older versions
                character.stats.hp = Math.min(
                    character.stats.hp + healing,
                    character.stats.maxHp
                );
                
                // Check if this healing revived the character
                if (character.defeated && character.stats.hp > 0) {
                    character.defeated = false;
                    this.battleManager.logMessage(
                        `${character.name} (${character.team === 'player' ? 'ally' : 'enemy'}) has been revived!`,
                        'revival'
                    );
                }
            }
        }
    }

    _applyStatModifier(character, definition, stacks) {
        if (!character || !definition.stat) return;
        
        // Calculate total modifier
        const totalModifier = definition.value * (stacks || 1);
        
        // Skip if no effect
        if (totalModifier === 0) return;
        
        // Apply the modifier
        // Store original value if not already stored
        if (character.originalStats === undefined) {
            character.originalStats = {};
        }
        
        if (character.originalStats[definition.stat] === undefined) {
            character.originalStats[definition.stat] = character.stats[definition.stat];
        }
        
        // Apply the modifier
        character.stats[definition.stat] += totalModifier;
        
        // Log the change
        const direction = totalModifier > 0 ? 'increased' : 'decreased';
        this.battleManager.logMessage(
            `${character.name}'s ${definition.stat} ${direction} by ${Math.abs(totalModifier)}!`,
            'status'
        );
    }

    _removeStatModifier(character, definition, stacks) {
        if (!character || !definition.stat) return;
        
        // Calculate total modifier
        const totalModifier = definition.value * (stacks || 1);
        
        // Skip if no effect
        if (totalModifier === 0) return;
        
        // Check if we have original stats
        if (character.originalStats && character.originalStats[definition.stat] !== undefined) {
            // Restore original value
            character.stats[definition.stat] = character.originalStats[definition.stat];
            delete character.originalStats[definition.stat];
            
            // Clean up originalStats if empty
            if (Object.keys(character.originalStats).length === 0) {
                delete character.originalStats;
            }
        } else {
            // Fallback: just remove the modifier
            character.stats[definition.stat] -= totalModifier;
        }
    }
}

// Make StatusEffectManager available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.StatusEffectManager = StatusEffectManager;
    console.log("StatusEffectManager class definition loaded and exported to window.StatusEffectManager");
}

// Legacy global assignment for maximum compatibility
window.StatusEffectManager = StatusEffectManager;


===== FILE: BattleUtilities.js =====
/**
 * BattleUtilities
 * Static utility functions for battle operations
 */

class BattleUtilities {
    /**
     * Get all characters from both teams
     * @param {Array} playerTeam - The player's team array.
     * @param {Array} enemyTeam - The enemy's team array.
     * @returns {Array} - Combined array of all characters, or an empty array if inputs are invalid.
     */
    static getAllCharacters(playerTeam, enemyTeam) {
        if (!Array.isArray(playerTeam) || !Array.isArray(enemyTeam)) {
            console.warn("[BattleUtilities] Invalid team data provided to getAllCharacters.");
            return [];
        }
        return [...playerTeam, ...enemyTeam];
    }
    
    /**
     * Get a character by its uniqueId from any team
     * @param {string} uniqueId - The uniqueId of the character to find.
     * @param {Array} playerTeam - The player's team array.
     * @param {Array} enemyTeam - The enemy's team array.
     * @returns {Object|null} - The character object or null if not found.
     */
    static getCharacterByUniqueId(uniqueId, playerTeam, enemyTeam) {
        if (!uniqueId) return null;
        
        // Check if arguments are valid arrays
        if (!Array.isArray(playerTeam) || !Array.isArray(enemyTeam)) {
            console.warn("[BattleUtilities] Invalid team data provided to getCharacterByUniqueId.");
            return null;
        }
        
        // Check player team
        let foundChar = playerTeam.find(char => char && char.uniqueId === uniqueId);
        if (foundChar) return foundChar;
        
        // Check enemy team
        foundChar = enemyTeam.find(char => char && char.uniqueId === uniqueId);
        
        // Add a log if a character is not found for a given ID, can be helpful for debugging
        if (!foundChar) {
            console.warn(`[BattleUtilities.getCharacterByUniqueId] Character with uniqueId '${uniqueId}' not found.`);
        }
        
        return foundChar || null;
    }
    
    /**
     * Shuffle an array randomly
     * @param {Array} array - The array to shuffle
     * @returns {Array} The shuffled array
     */
    static shuffleArray(array) {
        if (!Array.isArray(array)) {
            console.warn("[BattleUtilities] Invalid array provided to shuffleArray.");
            return [];
        }
        
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    /**
     * Safely stringify an object, handling circular references
     * @param {Object} obj - The object to stringify
     * @param {number} [space] - Number of spaces for indentation (optional)
     * @returns {string} The stringified object with circular references replaced
     */
    static safeBattleStringify(obj, space = null) {
        if (obj === undefined || obj === null) {
            return JSON.stringify(obj);
        }
        
        try {
            const seen = new WeakSet();
            return JSON.stringify(obj, (key, value) => {
                // Handle circular references
                if (typeof value === 'object' && value !== null) {
                    if (seen.has(value)) {
                        return '[Circular Reference]';
                    }
                    seen.add(value);
                }
                return value;
            }, space);
        } catch (error) {
            console.error("[BattleUtilities] Error in safeBattleStringify:", error);
            return `{"error":"Failed to stringify object: ${error.message}"}`;
        }
    }
}

// Make BattleUtilities available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleUtilities = BattleUtilities;
    console.log("BattleUtilities class definition loaded and exported to window.BattleUtilities");
}

// Legacy global assignment for maximum compatibility
window.BattleUtilities = BattleUtilities;


===== FILE: ActionDecisionBehaviors.js =====
/**
 * ActionDecisionBehaviors.js
 * 
 * Collection of action decision behavior functions for the battle system.
 * These functions determine how characters decide which ability to use (or basic attack).
 */

import behaviorRegistry from './BehaviorRegistry.js';

/**
 * Context object expected for action decision behaviors:
 * {
 *   actor: Character,              // The character taking the action
 *   availableAbilities: Object[],  // List of abilities with cooldown === 0
 *   battleManager: BattleManager,  // Reference to BattleManager for battle state
 *   teamManager: TeamManager       // Reference to TeamManager for team data
 * }
 */

/**
 * Default 50% chance to use an ability if available (matches original behavior)
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_Random50Percent(context) {
    const { availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null; // Null indicates basic attack
    }
    
    // 50% chance to use an ability (from original BattleManager)
    if (Math.random() > 0.5) {
        // Select random ability from available ones
        const randomIndex = Math.floor(Math.random() * availableAbilities.length);
        return availableAbilities[randomIndex];
    }
    
    // Use basic attack
    return null;
}

/**
 * Uses weighted random selection for ability choice
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_WeightedRandomAbility(context) {
    const { actor, availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null; // Null indicates basic attack
    }
    
    // Use character's abilityAffinity if defined, or default to 0.7 (70% chance to consider ability)
    const abilityAffinity = actor.abilityAffinity || 0.7;
    
    // Check if we should consider using an ability at all
    if (Math.random() < abilityAffinity) {
        // Calculate total weight of all available abilities
        let totalWeight = 0;
        for (const ability of availableAbilities) {
            // Use ability's selectionWeight or default to 1.0
            const weight = ability.selectionWeight || 1.0;
            totalWeight += weight;
        }
        
        // Generate random weight
        let randomWeight = Math.random() * totalWeight;
        
        // Find the ability that corresponds to this weight
        for (const ability of availableAbilities) {
            const weight = ability.selectionWeight || 1.0;
            randomWeight -= weight;
            
            if (randomWeight <= 0) {
                return ability;
            }
        }
        
        // Fallback in case of rounding errors
        return availableAbilities[availableAbilities.length - 1];
    }
    
    // Use basic attack
    return null;
}

/**
 * Prioritizes healing abilities when allies are below health threshold
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_PrioritizeHeal(context) {
    const { actor, availableAbilities, teamManager, battleManager } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Get actor's team
    const actorTeam = teamManager.getCharacterTeam(actor);
    
    // Check team health status
    // UPDATED in v0.6.0.2: Use BattleUtilities.getAllCharacters instead of battleManager.getAllCharacters
    // This aligns with Phase 3 refactoring where utility methods were moved out of BattleManager
    const allCharacters = window.BattleUtilities
        ? window.BattleUtilities.getAllCharacters(battleManager.playerTeam, battleManager.enemyTeam)
        : [...battleManager.playerTeam, ...battleManager.enemyTeam]; // Fallback for backward compatibility
    
    const allies = allCharacters.filter(character => 
        teamManager.getCharacterTeam(character) === actorTeam && !character.defeated
    );
    
    // Calculate average health percentage of team
    let totalHealthPercent = 0;
    allies.forEach(ally => {
        totalHealthPercent += (ally.currentHp / ally.stats.hp);
    });
    const avgHealthPercent = totalHealthPercent / allies.length;
    
    // Check if any ally is below 50% health
    const needsHealing = allies.some(ally => (ally.currentHp / ally.stats.hp) < 0.5);
    
    // If healing is needed
    if (needsHealing) {
        // Find healing abilities
        const healingAbilities = availableAbilities.filter(ability => 
            ability.isHealing || ability.damageType === 'healing'
        );
        
        if (healingAbilities.length > 0) {
            // Get the healing ability with highest selectionWeight
            return healingAbilities.reduce((best, current) => {
                const currentWeight = current.selectionWeight || 1.0;
                const bestWeight = best.selectionWeight || 1.0;
                return currentWeight > bestWeight ? current : best;
            }, healingAbilities[0]);
        }
    }
    
    // If team is healthy or no healing abilities available
    // Use weighted random selection like normal
    return decideAction_WeightedRandomAbility(context);
}

/**
 * Always prioritizes offensive abilities
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_PrioritizeOffense(context) {
    const { availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Filter out healing/utility abilities
    const offensiveAbilities = availableAbilities.filter(ability => 
        !ability.isHealing && ability.damageType !== 'healing' && ability.damageType !== 'utility'
    );
    
    if (offensiveAbilities.length > 0) {
        // Select the offensive ability with highest selectionWeight
        return offensiveAbilities.reduce((best, current) => {
            const currentWeight = current.selectionWeight || 1.0;
            const bestWeight = best.selectionWeight || 1.0;
            return currentWeight > bestWeight ? current : best;
        }, offensiveAbilities[0]);
    }
    
    // If no offensive abilities available, fall back to weighted random selection
    return decideAction_WeightedRandomAbility(context);
}

/**
 * Prioritizes defensive abilities, especially when health is low
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_Defensive(context) {
    const { actor, availableAbilities, teamManager, battleManager } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Calculate health percentage
    const healthPercent = actor.currentHp / actor.stats.hp;
    
    // Check if health is below 50%
    const isLowHealth = healthPercent < 0.5;
    
    // Higher chance to use abilities when health is low
    const abilityAffinity = isLowHealth ? 0.9 : 0.7;
    
    // First check if we should consider using an ability at all
    if (Math.random() < abilityAffinity) {
        // Categorize available abilities
        const defensiveAbilities = availableAbilities.filter(ability => {
            // Consider abilities that provide shields, healing, or defensive buffs
            if (ability.isHealing || ability.damageType === 'healing') return true;
            if (ability.damageType === 'utility') return true;
            
            // Check for defensive effects in the effects array
            if (ability.effects && Array.isArray(ability.effects)) {
                return ability.effects.some(effect => 
                    (effect.type === 'ApplyStatus' && 
                    ['status_def_up', 'status_shield', 'status_regen', 'status_evade'].includes(effect.statusEffectId)) ||
                    (effect.type === 'StatBuff' && 
                    ['Defense', 'MaxHP'].includes(effect.targetStat))
                );
            }
            
            return false;
        });
        
        // If low health and defensive abilities available, use them
        if (isLowHealth && defensiveAbilities.length > 0) {
            // Select defensive ability with highest weight
            return defensiveAbilities.reduce((best, current) => {
                const currentWeight = current.selectionWeight || 1.0;
                const bestWeight = best.selectionWeight || 1.0;
                return currentWeight > bestWeight ? current : best;
            }, defensiveAbilities[0]);
        }
        
        // Otherwise use weighted selection from all abilities
        // Calculate total weight with higher weight for defensive abilities
        let totalWeight = 0;
        for (const ability of availableAbilities) {
            let weight = ability.selectionWeight || 1.0;
            
            // Increase weight for defensive abilities
            if (defensiveAbilities.includes(ability)) {
                weight *= 1.5; // 50% higher weight for defensive abilities
            }
            
            totalWeight += weight;
        }
        
        // Generate random weight
        let randomWeight = Math.random() * totalWeight;
        
        // Find the ability that corresponds to this weight
        for (const ability of availableAbilities) {
            let weight = ability.selectionWeight || 1.0;
            
            // Increase weight for defensive abilities
            if (defensiveAbilities.includes(ability)) {
                weight *= 1.5;
            }
            
            randomWeight -= weight;
            
            if (randomWeight <= 0) {
                return ability;
            }
        }
        
        // Fallback in case of rounding errors
        return availableAbilities[availableAbilities.length - 1];
    }
    
    // Use basic attack
    return null;
}

/**
 * Always tries to use abilities if available, prioritizing by selection weight
 * @param {object} context - Action decision context
 * @returns {object|null} - Selected ability or null for basic attack
 */
function decideAction_AlwaysUseAbilities(context) {
    const { availableAbilities } = context;
    
    // If no abilities are available, use basic attack
    if (!availableAbilities || availableAbilities.length === 0) {
        return null;
    }
    
    // Select the ability with highest selectionWeight
    return availableAbilities.reduce((best, current) => {
        const currentWeight = current.selectionWeight || 1.0;
        const bestWeight = best.selectionWeight || 1.0;
        return currentWeight > bestWeight ? current : best;
    }, availableAbilities[0]);
}

// Register all action decision behaviors
behaviorRegistry.registerActionDecisionBehavior('decideAction_Random50Percent', decideAction_Random50Percent, true); // Set as default
behaviorRegistry.registerActionDecisionBehavior('decideAction_WeightedRandomAbility', decideAction_WeightedRandomAbility);
behaviorRegistry.registerActionDecisionBehavior('decideAction_PrioritizeHeal', decideAction_PrioritizeHeal);
behaviorRegistry.registerActionDecisionBehavior('decideAction_PrioritizeOffense', decideAction_PrioritizeOffense);
behaviorRegistry.registerActionDecisionBehavior('decideAction_AlwaysUseAbilities', decideAction_AlwaysUseAbilities);
behaviorRegistry.registerActionDecisionBehavior('decideAction_Defensive', decideAction_Defensive);

// Export individual behaviors for direct use if needed
export {
    decideAction_Random50Percent,
    decideAction_WeightedRandomAbility,
    decideAction_PrioritizeHeal,
    decideAction_PrioritizeOffense,
    decideAction_AlwaysUseAbilities,
    decideAction_Defensive
};


===== FILE: BattleBehaviors.js =====
/**
 * BattleBehaviors.js
 * 
 * Main entry point for the battle behavior system.
 * Imports and re-exports all behavior functionality.
 */

import behaviorRegistry from './BehaviorRegistry.js';

// Import all behaviors to ensure they're registered
import * as targetingBehaviors from './TargetingBehaviors.js';
import * as actionDecisionBehaviors from './ActionDecisionBehaviors.js';
import * as passiveBehaviors from './PassiveBehaviors.js';

/**
 * A centralized interface for executing behavior functions
 */
class BattleBehaviors {
    constructor() {
        this.registry = behaviorRegistry;
    }
    
    /**
     * Selects a target for an ability or action based on targeting logic
     * @param {string|null} targetingLogic - Name of targeting logic to use
     * @param {object} context - Targeting context
     * @returns {Character|Character[]|null} - Selected target(s) or null if no valid target
     */
    selectTarget(targetingLogic, context) {
        return this.registry.executeTargetingBehavior(targetingLogic, context);
    }
    
    /**
     * Decides which ability to use (or basic attack)
     * @param {string|null} decisionLogic - Name of action decision logic to use
     * @param {object} context - Action decision context
     * @returns {object|null} - Selected ability or null for basic attack
     */
    decideAction(decisionLogic, context) {
        return this.registry.executeActionDecisionBehavior(decisionLogic, context);
    }
    
    /**
     * Processes a passive ability
     * @param {string} passiveName - Name of passive behavior to execute
     * @param {object} context - Passive context
     * @returns {object} - Result of the passive ability
     */
    executePassiveBehavior(passiveName, context) {
        return this.registry.executePassiveBehavior(passiveName, context);
    }
    
    /**
     * Utility function to check if a specific behavior exists
     * @param {string} behaviorName - Name of the behavior to check
     * @returns {boolean} - Whether the behavior exists
     */
    hasBehavior(behaviorName) {
        return !!this.registry.allBehaviors[behaviorName];
    }
    
    /**
     * Utility function to get the default targeting behavior
     * @returns {string} - Name of the default targeting behavior
     */
    getDefaultTargetingBehavior() {
        return this.registry.defaultTargetingBehavior;
    }
    
    /**
     * Utility function to get the default action decision behavior
     * @returns {string} - Name of the default action decision behavior
     */
    getDefaultActionDecisionBehavior() {
        return this.registry.defaultActionDecisionBehavior;
    }
    
    /**
     * Maps targetType strings to targeting behavior names
     * @param {string} targetType - Type of targeting from ability data
     * @returns {string} - Name of the corresponding targeting behavior
     */
    getTargetingBehaviorFromType(targetType) {
        const mapping = {
            'SingleEnemy': 'targetRandomEnemy',
            'AllEnemies': 'targetAllEnemies',
            'Self': 'targetSelf',
            'SingleAlly': 'targetLowestHpAlly',
            'AllAllies': 'targetAllAllies',
            'LowestHpEnemy': 'targetLowestHpEnemy',
            'HighestHpEnemy': 'targetHighestHpEnemy',
            'LowestHpAlly': 'targetLowestHpAlly'
        };
        
        return mapping[targetType] || this.registry.defaultTargetingBehavior;
    }
}

// Create and export singleton instance
const battleBehaviors = new BattleBehaviors();
export default battleBehaviors;

// Re-export everything for convenience
export {
    behaviorRegistry,
    targetingBehaviors,
    actionDecisionBehaviors,
    passiveBehaviors
};


===== FILE: BehaviorRegistry.js =====
/**
 * BehaviorRegistry.js
 * 
 * Centralized registry for all behavior functions used in the battle system.
 * This enables a flexible "behavior delegation" pattern where specific logic
 * can be referenced by name and dynamically executed.
 */

class BehaviorRegistry {
    constructor() {
        // Initialize registries for different behavior types
        this.targetingBehaviors = {};
        this.actionDecisionBehaviors = {};
        this.passiveBehaviors = {};
        
        // Track all registered behaviors for debugging
        this.allBehaviors = {};
        
        // Default behaviors
        this.defaultTargetingBehavior = null;
        this.defaultActionDecisionBehavior = null;
    }

    /**
     * Register a targeting behavior function
     * @param {string} name - Unique name to reference this behavior
     * @param {Function} behaviorFn - The behavior function
     * @param {boolean} isDefault - Whether this should be the default behavior
     * @returns {BehaviorRegistry} - For method chaining
     */
    registerTargetingBehavior(name, behaviorFn, isDefault = false) {
        this.targetingBehaviors[name] = behaviorFn;
        this.allBehaviors[name] = { type: 'targeting', fn: behaviorFn };
        
        if (isDefault) {
            this.defaultTargetingBehavior = name;
        }
        
        return this;
    }

    /**
     * Register an action decision behavior function
     * @param {string} name - Unique name to reference this behavior
     * @param {Function} behaviorFn - The behavior function
     * @param {boolean} isDefault - Whether this should be the default behavior
     * @returns {BehaviorRegistry} - For method chaining
     */
    registerActionDecisionBehavior(name, behaviorFn, isDefault = false) {
        this.actionDecisionBehaviors[name] = behaviorFn;
        this.allBehaviors[name] = { type: 'actionDecision', fn: behaviorFn };
        
        if (isDefault) {
            this.defaultActionDecisionBehavior = name;
        }
        
        return this;
    }

    /**
     * Register a passive behavior function
     * @param {string} name - Unique name to reference this behavior
     * @param {Function} behaviorFn - The behavior function
     * @returns {BehaviorRegistry} - For method chaining
     */
    registerPassiveBehavior(name, behaviorFn) {
        this.passiveBehaviors[name] = behaviorFn;
        this.allBehaviors[name] = { type: 'passive', fn: behaviorFn };
        
        return this;
    }

    /**
     * Get a targeting behavior function by name
     * @param {string} name - Name of the behavior to retrieve
     * @returns {Function|null} - The behavior function or null if not found
     */
    getTargetingBehavior(name) {
        // If name is null/undefined or behavior doesn't exist, return default
        if (!name || !this.targetingBehaviors[name]) {
            if (this.defaultTargetingBehavior) {
                return this.targetingBehaviors[this.defaultTargetingBehavior];
            }
            console.warn(`No targeting behavior found for '${name}' and no default set`);
            return null;
        }
        
        return this.targetingBehaviors[name];
    }

    /**
     * Get an action decision behavior function by name
     * @param {string} name - Name of the behavior to retrieve
     * @returns {Function|null} - The behavior function or null if not found
     */
    getActionDecisionBehavior(name) {
        // If name is null/undefined or behavior doesn't exist, return default
        if (!name || !this.actionDecisionBehaviors[name]) {
            if (this.defaultActionDecisionBehavior) {
                return this.actionDecisionBehaviors[this.defaultActionDecisionBehavior];
            }
            console.warn(`No action decision behavior found for '${name}' and no default set`);
            return null;
        }
        
        return this.actionDecisionBehaviors[name];
    }

    /**
     * Get a passive behavior function by name
     * @param {string} name - Name of the behavior to retrieve
     * @returns {Function|null} - The behavior function or null if not found
     */
    getPassiveBehavior(name) {
        // If name is null/undefined or behavior doesn't exist, return null
        if (!name || !this.passiveBehaviors[name]) {
            console.warn(`No passive behavior found for '${name}'`);
            return null;
        }
        
        return this.passiveBehaviors[name];
    }

    /**
     * Execute a targeting behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executeTargetingBehavior(name, context) {
        const behaviorFn = this.getTargetingBehavior(name);
        if (!behaviorFn) return null;
        
        try {
            return behaviorFn(context);
        } catch (error) {
            console.error(`Error executing targeting behavior '${name}':`, error);
            // Fall back to default if available
            if (name !== this.defaultTargetingBehavior && this.defaultTargetingBehavior) {
                console.warn(`Falling back to default targeting behavior`);
                return this.executeTargetingBehavior(this.defaultTargetingBehavior, context);
            }
            return null;
        }
    }

    /**
     * Execute an action decision behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executeActionDecisionBehavior(name, context) {
        const behaviorFn = this.getActionDecisionBehavior(name);
        if (!behaviorFn) return null;
        
        try {
            return behaviorFn(context);
        } catch (error) {
            console.error(`Error executing action decision behavior '${name}':`, error);
            // Fall back to default if available
            if (name !== this.defaultActionDecisionBehavior && this.defaultActionDecisionBehavior) {
                console.warn(`Falling back to default action decision behavior`);
                return this.executeActionDecisionBehavior(this.defaultActionDecisionBehavior, context);
            }
            return null;
        }
    }

    /**
     * Execute a passive behavior with provided context
     * @param {string} name - Name of the behavior to execute
     * @param {object} context - Data to pass to the behavior function
     * @returns {object|null} - Result of the behavior function or null if not found
     */
    executePassiveBehavior(name, context) {
        const behaviorFn = this.getPassiveBehavior(name);
        if (!behaviorFn) return null;
        
        try {
            return behaviorFn(context);
        } catch (error) {
            console.error(`Error executing passive behavior '${name}':`, error);
            return null;
        }
    }

    /**
     * Utility method to list all registered behaviors
     * @returns {object} - Map of all registered behaviors by type
     */
    listAllBehaviors() {
        return {
            targeting: Object.keys(this.targetingBehaviors),
            actionDecision: Object.keys(this.actionDecisionBehaviors),
            passive: Object.keys(this.passiveBehaviors),
            defaultTargeting: this.defaultTargetingBehavior,
            defaultActionDecision: this.defaultActionDecisionBehavior
        };
    }
}

// Create singleton instance
const behaviorRegistry = new BehaviorRegistry();

// Export singleton
export default behaviorRegistry;


===== FILE: BehaviorRegistryTest.js =====
/**
 * BehaviorRegistryTest.js
 * 
 * A simple test utility to validate the behavior registry system.
 * This can be run directly in the browser console.
 */

import battleBehaviors from './BattleBehaviors.js';

/**
 * Test mock character
 */
class MockCharacter {
    constructor(name, team, hp = 100, attk = 10, def = 5, spd = 10) {
        this.name = name;
        this.team = team;
        this.stats = { hp, attack: attk, defense: def, speed: spd };
        this.currentHp = hp;
        this.defeated = false;
    }
}

/**
 * Test mock TeamManager
 */
class MockTeamManager {
    constructor() {
        this.characterTeams = new Map();
    }
    
    getCharacterTeam(character) {
        return character.team;
    }
    
    addCharacter(character, team) {
        character.team = team;
        this.characterTeams.set(character, team);
    }
}

/**
 * Test mock BattleManager
 */
class MockBattleManager {
    constructor() {
        this.characters = [];
        this.statusEffects = new Map();
    }
    
    getAllCharacters() {
        return this.characters;
    }
    
    addCharacter(character) {
        this.characters.push(character);
    }
    
    addStatusEffect(character, statusId, duration) {
        if (!this.statusEffects.has(character)) {
            this.statusEffects.set(character, []);
        }
        
        this.statusEffects.get(character).push({
            id: statusId,
            duration,
            appliedAt: Date.now()
        });
        
        console.log(`Added status ${statusId} to ${character.name} for ${duration} turns`);
    }
    
    applyDamage(target, amount, source, ability, type) {
        console.log(`${source.name} deals ${amount} ${type || ''} damage to ${target.name}`);
        target.currentHp -= amount;
        if (target.currentHp <= 0) {
            target.defeated = true;
            console.log(`${target.name} is defeated!`);
        }
    }
}

/**
 * Run tests for targeting behaviors
 */
function testTargetingBehaviors() {
    console.log("=== Testing Targeting Behaviors ===");
    
    // Setup test data
    const teamManager = new MockTeamManager();
    const actor = new MockCharacter("Hero", "ally", 100, 10, 5, 10);
    const enemy1 = new MockCharacter("Enemy1", "enemy", 100, 10, 5, 10);
    const enemy2 = new MockCharacter("Enemy2", "enemy", 50, 15, 3, 12);
    const ally1 = new MockCharacter("Ally1", "ally", 30, 8, 4, 9);
    
    const potentialTargets = [actor, enemy1, enemy2, ally1];
    
    // Test context
    const context = {
        actor,
        potentialTargets,
        teamManager,
        ability: { name: "Test Ability" }
    };
    
    // Test targeting behaviors
    console.log("targetRandomEnemy:", battleBehaviors.selectTarget('targetRandomEnemy', context)?.name);
    console.log("targetLowestHpEnemy:", battleBehaviors.selectTarget('targetLowestHpEnemy', context)?.name);
    console.log("targetHighestHpEnemy:", battleBehaviors.selectTarget('targetHighestHpEnemy', context)?.name);
    console.log("targetAllEnemies:", battleBehaviors.selectTarget('targetAllEnemies', context)?.map(t => t.name));
    console.log("targetLowestHpAlly:", battleBehaviors.selectTarget('targetLowestHpAlly', context)?.name);
    console.log("targetAllAllies:", battleBehaviors.selectTarget('targetAllAllies', context)?.map(t => t.name));
    console.log("targetSelf:", battleBehaviors.selectTarget('targetSelf', context)?.name);
    
    // Test targetType to behavior mapping
    console.log("Behavior for 'SingleEnemy':", battleBehaviors.getTargetingBehaviorFromType('SingleEnemy'));
    console.log("Behavior for 'AllEnemies':", battleBehaviors.getTargetingBehaviorFromType('AllEnemies'));
    console.log("Behavior for 'LowestHpAlly':", battleBehaviors.getTargetingBehaviorFromType('LowestHpAlly'));
    
    // Test default behavior
    console.log("Default targeting behavior:", battleBehaviors.getDefaultTargetingBehavior());
    console.log("Using default for unknown behavior:", battleBehaviors.selectTarget('nonexistent', context)?.name);
}

/**
 * Run tests for action decision behaviors
 */
function testActionDecisionBehaviors() {
    console.log("=== Testing Action Decision Behaviors ===");
    
    // Setup test data
    const actor = new MockCharacter("Hero", "ally", 100, 10, 5, 10);
    const battleManager = new MockBattleManager();
    const teamManager = new MockTeamManager();
    
    const availableAbilities = [
        {
            id: "ability1",
            name: "Fireball",
            damageType: "spell",
            isHealing: false,
            selectionWeight: 1.0
        },
        {
            id: "ability2",
            name: "Heal",
            damageType: "healing",
            isHealing: true,
            selectionWeight: 1.2
        },
        {
            id: "ability3",
            name: "Shield",
            damageType: "utility",
            isHealing: false,
            selectionWeight: 0.8
        }
    ];
    
    // Test context
    const context = {
        actor,
        availableAbilities,
        battleManager,
        teamManager
    };
    
    // Test multiple times to observe randomness
    console.log("=== decideAction_Random50Percent (multiple runs) ===");
    for (let i = 0; i < 5; i++) {
        const result = battleBehaviors.decideAction('decideAction_Random50Percent', context);
        console.log(`Run ${i + 1}:`, result ? result.name : "Basic Attack");
    }
    
    console.log("=== decideAction_WeightedRandomAbility (multiple runs) ===");
    for (let i = 0; i < 5; i++) {
        const result = battleBehaviors.decideAction('decideAction_WeightedRandomAbility', context);
        console.log(`Run ${i + 1}:`, result ? result.name : "Basic Attack");
    }
    
    console.log("=== decideAction_PrioritizeOffense ===");
    const offensiveResult = battleBehaviors.decideAction('decideAction_PrioritizeOffense', context);
    console.log("Result:", offensiveResult ? offensiveResult.name : "Basic Attack");
    
    console.log("=== decideAction_AlwaysUseAbilities ===");
    const alwaysAbilityResult = battleBehaviors.decideAction('decideAction_AlwaysUseAbilities', context);
    console.log("Result:", alwaysAbilityResult ? alwaysAbilityResult.name : "Basic Attack");
    
    // Test with healing priority when allies are injured
    console.log("=== decideAction_PrioritizeHeal (allies need healing) ===");
    
    // Create injured allies
    const ally1 = new MockCharacter("InjuredAlly", "ally", 100, 10, 5, 10);
    ally1.currentHp = 30; // 30% health
    
    battleManager.addCharacter(actor);
    battleManager.addCharacter(ally1);
    teamManager.addCharacter(actor, "ally");
    teamManager.addCharacter(ally1, "ally");
    
    const healingResult = battleBehaviors.decideAction('decideAction_PrioritizeHeal', context);
    console.log("Result:", healingResult ? healingResult.name : "Basic Attack");
}

/**
 * Run tests for passive behaviors
 */
function testPassiveBehaviors() {
    console.log("=== Testing Passive Behaviors ===");
    
    // Setup test data
    const actor = new MockCharacter("Hero", "ally", 100, 10, 5, 10);
    const enemy = new MockCharacter("Enemy", "enemy", 100, 10, 5, 10);
    const battleManager = new MockBattleManager();
    const teamManager = new MockTeamManager();
    
    // Add characters
    battleManager.addCharacter(actor);
    battleManager.addCharacter(enemy);
    teamManager.addCharacter(actor, "ally");
    teamManager.addCharacter(enemy, "enemy");
    
    // Test passive_ApplyRegenOnTurnStart
    console.log("=== passive_ApplyRegenOnTurnStart ===");
    
    const regenContext = {
        actor,
        ability: { name: "Regeneration", passiveType: "onTurnStart" },
        battleManager,
        teamManager,
        trigger: 'onTurnStart'
    };
    
    const regenResult = battleBehaviors.processPassive('passive_ApplyRegenOnTurnStart', regenContext);
    console.log("Result:", regenResult);
    
    // Test passive_DamageReflectOnHit
    console.log("=== passive_DamageReflectOnHit ===");
    
    const reflectContext = {
        actor,
        ability: { name: "Thorns", passiveType: "onDamageTaken" },
        battleManager,
        teamManager,
        trigger: 'onDamageTaken',
        additionalData: {
            source: enemy,
            damageAmount: 20
        }
    };
    
    const reflectResult = battleBehaviors.processPassive('passive_DamageReflectOnHit', reflectContext);
    console.log("Result:", reflectResult);
    
    // Test passive_TeamBuffOnBattleStart
    console.log("=== passive_TeamBuffOnBattleStart ===");
    
    const buffContext = {
        actor,
        ability: { 
            name: "Team Spirit", 
            passiveType: "onBattleStart",
            passiveData: {
                statusId: "status_atk_up",
                duration: 3
            }
        },
        battleManager,
        teamManager,
        trigger: 'onBattleStart'
    };
    
    const buffResult = battleBehaviors.processPassive('passive_TeamBuffOnBattleStart', buffContext);
    console.log("Result:", buffResult);
}

/**
 * Run all tests
 */
function runAllTests() {
    console.log("======= BEHAVIOR REGISTRY TEST =======");
    
    // List all registered behaviors
    console.log("=== REGISTERED BEHAVIORS ===");
    console.log(battleBehaviors.registry.listAllBehaviors());
    
    // Run individual tests
    testTargetingBehaviors();
    testActionDecisionBehaviors();
    testPassiveBehaviors();
    
    console.log("======= TEST COMPLETE =======");
}

// Export test functions
export {
    runAllTests,
    testTargetingBehaviors,
    testActionDecisionBehaviors,
    testPassiveBehaviors
};

// Automatically run tests when imported directly
if (typeof window !== 'undefined') {
    window.runBehaviorTests = runAllTests;
    console.log("Test utility loaded. Run tests with window.runBehaviorTests()");
}


===== FILE: index.js =====
/**
 * Index file for the battle logic system
 * Provides a central point for importing all battle behavior components
 */

// Export main interface
export { default as battleBehaviors } from './BattleBehaviors.js';

// Export registry and individual behavior collections
export { default as behaviorRegistry } from './BehaviorRegistry.js';
export * as targetingBehaviors from './TargetingBehaviors.js';
export * as actionDecisionBehaviors from './ActionDecisionBehaviors.js';
export * as passiveBehaviors from './PassiveBehaviors.js';

// Export test utilities
export * as behaviorTesting from './BehaviorRegistryTest.js';

// For direct script inclusion, attach to window
if (typeof window !== 'undefined') {
    // Import and set up on window for direct browser usage
    import('./BattleBehaviors.js').then(module => {
        window.battleBehaviors = module.default;
        console.log('Battle Behaviors system loaded and available at window.battleBehaviors');
    });
}


===== FILE: PassiveBehaviors.js =====
/**
 * PassiveBehaviors.js
 * 
 * Collection of passive behavior functions for the battle system.
 * These functions define how passive abilities trigger and what effects they apply.
 */

import behaviorRegistry from './BehaviorRegistry.js';

/**
 * Context object expected for passive behaviors:
 * {
 *   actor: Character,              // The character with the passive ability
 *   ability: Object,               // The passive ability being triggered
 *   battleManager: BattleManager,  // Reference to BattleManager for battle state
 *   teamManager: TeamManager,      // Reference to TeamManager for team data
 *   trigger: String,               // What triggered this passive (onTurnStart, onHit, etc.)
 *   additionalData: Object         // Contextual data based on the trigger (damage amount, source, etc.)
 * }
 */

/**
 * -----------------------------------------------
 * Passive Trigger Types Reference
 * -----------------------------------------------
 * onBattleStart    - When battle begins
 * onBattleEnd      - When battle ends
 * onTurnStart      - At start of a new turn
 * onTurnEnd        - At end of a turn
 * onActionStart    - Before an action is executed
 * onActionEnd      - After an action is executed
 * onDamageDealt    - After dealing damage to a target
 * onDamageTaken    - After taking damage from a source
 * onHealed         - After being healed
 * onHealingDone    - After healing a target
 * onKill           - After defeating an enemy
 * onDefeat         - When character is defeated
 * onRevive         - When character is revived
 * onStatusApplied  - When a status effect is applied to character
 * onStatusRemoved  - When a status effect expires or is removed
 * -----------------------------------------------
 */

/**
 * Applies regeneration status effect at the start of the turn
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_ApplyRegenOnTurnStart(context) {
    const { actor, battleManager, trigger } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onTurnStart') return { executed: false };
    
    // Verify character has valid health before proceeding
    if (!actor || !actor.stats || !actor.stats.hp || isNaN(actor.currentHp)) {
        console.error('Cannot apply regen to character with invalid health state:', actor);
        return { executed: false };
    }
    
    // Apply regeneration status effect
    // v0.5.27.4_StatusEffectParameterFix: Adding sourceId check and ensuring actor is passed as source
    // This function was showing as error source for 'Invalid duration parameter (object)'
    // Updated to use consistent 5-parameter format with explicit stacks
    battleManager.addStatusEffect(actor, 'status_regen', actor, 2, 1);
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability grants Regeneration!`
    };
}

/**
 * Reflects a portion of damage back to the attacker when hit
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_DamageReflectOnHit(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and additional data is provided
    if (trigger !== 'onDamageTaken' || !additionalData) return { executed: false };
    
    const { source, damageAmount, reflectionDepth = 0 } = additionalData;
    
    // Limit reflection depth to prevent infinite chains
    if (reflectionDepth >= 2) { // Maximum of 2 reflection cycles (initial hit + 2 reflections)
        console.debug(`Max reflection depth (${reflectionDepth}) reached, stopping reflection chain`);
        return { executed: false };
    }
    
    // Do nothing if source is not defined or it's self-damage
    if (!source || source === actor) return { executed: false };
    
    // Validate damage amount before calculations
    if (typeof damageAmount !== 'number' || isNaN(damageAmount) || damageAmount <= 0) {
        console.error('Invalid damage amount for reflection:', damageAmount);
        return { executed: false };
    }
    
    // Check if source is valid
    if (!source || !source.currentHp || isNaN(source.currentHp)) {
        console.error('Invalid source for damage reflection');
        return { executed: false };
    }
    
    // Check if source and actor are on different teams (prevent friendly fire)
    if (source.team === actor.team) {
        console.debug(`Skipping damage reflection to ${source.name} as they are on the same team as ${actor.name}`);
        return { executed: false };
    }
    
    // Calculate reflected damage (20% of damage taken)
    const reflectAmount = Math.round(Math.max(1, damageAmount * 0.2));
    
    // Implement a minimum threshold for reflection to prevent endless small reflections
    if (reflectAmount <= 2 && reflectionDepth > 0) {
        console.debug(`Reflection amount (${reflectAmount}) too small for secondary reflection, stopping chain`);
        return { executed: false };
    }
    
    // Apply reflected damage with increased reflection depth
    battleManager.applyDamage(
        source,                 // target (the original attacker)
        reflectAmount,          // damage amount
        actor,                  // source (self)
        null,                   // no ability
        'reflected',            // damage type
        { reflectionDepth: reflectionDepth + 1 } // Track reflection depth
    );
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability reflects ${reflectAmount} damage back to ${source.name}!`
    };
}

/**
 * Has a chance to apply a status effect to the attacker when hit
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_ApplyStatusOnHit(context) {
    const { actor, ability, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and additional data is provided
    if (trigger !== 'onDamageTaken' || !additionalData) return { executed: false };
    
    const { source } = additionalData;
    
    // Do nothing if source is not defined or it's self-damage
    if (!source || source === actor) return { executed: false };
    
    // Check for ability-specific configuration
    const statusId = ability.passiveData?.statusId || 'status_spd_down';
    const chance = ability.passiveData?.chance || 0.25;
    const duration = ability.passiveData?.duration || 2;
    
    // Random chance to apply status
    if (Math.random() < chance) {
        // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
        battleManager.addStatusEffect(source, statusId, actor, duration);
        
        return {
            executed: true,
            message: `${actor.name}'s passive ability applies a status effect to ${source.name}!`
        };
    }
    
    return { executed: false };
}

/**
 * Provides a buff to allies at the start of battle
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_TeamBuffOnBattleStart(context) {
    const { actor, ability, battleManager, teamManager, trigger } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onBattleStart') return { executed: false };
    
    // Get all allies
    const actorTeam = teamManager.getCharacterTeam(actor);
    
    // UPDATED in v0.6.0.4: Use BattleUtilities.getAllCharacters instead of battleManager.getAllCharacters
    // This aligns with Phase 3 refactoring where utility methods were moved out of BattleManager
    let allies = [];
    if (window.BattleUtilities) {
        const allCharacters = BattleUtilities.getAllCharacters(
            battleManager.playerTeam,
            battleManager.enemyTeam
        );
        allies = allCharacters.filter(character => 
            teamManager.getCharacterTeam(character) === actorTeam && !character.defeated
        );
    } else {
        console.warn("[PassiveBehaviors] BattleUtilities not available for getAllCharacters lookup.");
        // Fallback implementation
        allies = [...battleManager.playerTeam, ...battleManager.enemyTeam].filter(character => 
            teamManager.getCharacterTeam(character) === actorTeam && !character.defeated
        );
    }
    
    // Check for ability-specific configuration
    let statusId = 'status_atk_up';
    let duration = 3;
    
    // Safely extract passiveData if it exists
    if (ability && ability.passiveData) {
        statusId = ability.passiveData.statusId || statusId;
        duration = ability.passiveData.duration || duration;
    }
    
    // Apply buff to all allies
    let applied = 0;
    allies.forEach(ally => {
        // Skip if ally has invalid health
        if (!ally || isNaN(ally.currentHp)) {
            console.warn('Skipping buff application to ally with invalid health:', ally);
            return;
        }
        
        // Ensure duration is a number
        let effectDuration = duration;
        if (typeof effectDuration !== 'number') {
            console.warn(`[passive_TeamBuffOnBattleStart] Invalid duration (${typeof duration}) - using default 3`);
            effectDuration = 3;
        }
        
        // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
        // Updated to use consistent 5-parameter format with explicit stacks
        battleManager.addStatusEffect(ally, statusId, actor, effectDuration, 1);
        applied++;
    });
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability buffs the team at the start of battle!`,
        affected: applied
    };
}

/**
 * Increases critical hit chance after landing a critical hit
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_CriticalMomentum(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and was a critical hit
    if (trigger !== 'onDamageDealt' || !additionalData || !additionalData.wasCritical) {
        return { executed: false };
    }
    
    // Apply critical chance buff
    // FIXED (v0.5.27.3_CircularReferenceHotfix): Added actor as source parameter
    // Updated to use consistent 5-parameter format with explicit stacks
    battleManager.addStatusEffect(actor, 'status_crit_up', actor, 2, 1);
    
    return {
        executed: true,
        message: `${actor.name}'s passive ability increases critical chance after landing a critical hit!`
    };
}

/**
 * Applies a damage buff after killing an enemy
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_KillBuff(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onKill') return { executed: false };
    
    // Apply attack up buff after a kill
    // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
    // Updated to use consistent 5-parameter format with explicit stacks
    battleManager.addStatusEffect(actor, 'status_atk_up', actor, 2, 1);
    
    return {
        executed: true,
        message: `${actor.name}'s bloodlust increases attack after defeating an enemy!`
    };
}

/**
 * Applies a healing effect to the character when their HP falls below a threshold
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_LastStand(context) {
    const { actor, ability, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches and has damage data
    if (trigger !== 'onDamageTaken' || !additionalData) return { executed: false };
    
    // Check health threshold (default 30% of max HP)
    const threshold = ability.passiveData?.threshold || 0.3;
    const healthPercent = actor.currentHp / actor.stats.hp;
    
    // Check if we crossed the threshold with this damage
    const previousHealth = actor.currentHp + additionalData.damageAmount;
    const previousPercent = previousHealth / actor.stats.hp;
    
    if (previousPercent >= threshold && healthPercent < threshold) {
        // We just crossed the threshold, trigger the heal
        const healAmount = Math.floor(actor.stats.hp * 0.15); // Heal for 15% of max HP
        
        // Apply healing
        battleManager.applyHealing(actor, healAmount, actor, null, 'passive');
        
        // Apply defense buff
        // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
        // Updated to use consistent 5-parameter format with explicit stacks
        battleManager.addStatusEffect(actor, 'status_def_up', actor, 2, 1);
        
        return {
            executed: true,
            message: `${actor.name}'s last stand activates at low health, granting healing and defense!`
        };
    }
    
    return { executed: false };
}

/**
 * Applies a shield to allies at low health
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_ProtectiveInstinct(context) {
    const { actor, battleManager, teamManager, trigger } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onTurnStart') return { executed: false };
    
    // Get all allies
    const actorTeam = teamManager.getCharacterTeam(actor);
    
    // UPDATED in v0.6.0.4: Use BattleUtilities.getAllCharacters instead of battleManager.getAllCharacters
    // This aligns with Phase 3 refactoring where utility methods were moved out of BattleManager
    let allies = [];
    if (window.BattleUtilities) {
        const allCharacters = BattleUtilities.getAllCharacters(
            battleManager.playerTeam,
            battleManager.enemyTeam
        );
        allies = allCharacters.filter(character => 
            teamManager.getCharacterTeam(character) === actorTeam && 
            character !== actor && // Not self
            !character.defeated && 
            (character.currentHp / character.stats.hp) < 0.4 // Below 40% health
        );
    } else {
        console.warn("[PassiveBehaviors] BattleUtilities not available for getAllCharacters lookup.");
        // Fallback implementation
        allies = [...battleManager.playerTeam, ...battleManager.enemyTeam].filter(character => 
            teamManager.getCharacterTeam(character) === actorTeam && 
            character !== actor && // Not self
            !character.defeated && 
            (character.currentHp / character.stats.hp) < 0.4 // Below 40% health
        );
    }
    
    // If there are low-health allies, protect them
    if (allies.length > 0) {
        let protectedCount = 0;
        
        // Apply shield to up to 2 allies
        for (let i = 0; i < Math.min(2, allies.length); i++) {
            // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
            // Updated to use consistent 5-parameter format with explicit stacks
            battleManager.addStatusEffect(allies[i], 'status_shield', actor, 1, 1);
            protectedCount++;
        }
        
        if (protectedCount > 0) {
            return {
                executed: true,
                message: `${actor.name}'s protective instinct shields ${protectedCount} injured ${protectedCount === 1 ? 'ally' : 'allies'}!`,
                affected: protectedCount
            };
        }
    }
    
    return { executed: false };
}

/**
 * Provides a counter-attack when taking damage
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_Counterattack(context) {
    const { actor, battleManager, trigger, additionalData } = context;
    
    // Only execute if trigger matches
    if (trigger !== 'onDamageTaken' || !additionalData || !additionalData.source) {
        return { executed: false };
    }
    
    // Get the attacker
    const attacker = additionalData.source;
    
    // Check if attacker is valid and still alive
    if (!attacker || attacker.isDead || attacker.currentHp <= 0) {
        return { executed: false };
    }
    
    // Counter with 40% of strength as damage
    const counterDamage = Math.floor(actor.stats.strength * 0.4);
    
    // Apply counter damage
    const result = battleManager.applyDamage(
        attacker,           // target (original attacker)
        counterDamage,      // damage amount
        actor,              // source (self)
        null,               // no ability
        'counter'           // damage type
    );
    
    return {
        executed: true,
        message: `${actor.name} counters the attack, dealing ${counterDamage} damage to ${attacker.name}!`,
        damage: result.damage
    };
}

/**
 * Applies a debuff to enemies when the turn starts
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_Intimidate(context) {
    const { actor, ability, battleManager, teamManager, trigger } = context;
    
    // Only execute on turn start and with 25% chance
    if (trigger !== 'onTurnStart' || Math.random() > 0.25) {
        return { executed: false };
    }
    
    // Get enemies
    const actorTeam = teamManager.getCharacterTeam(actor);
    
    // UPDATED in v0.6.0.4: Use BattleUtilities.getAllCharacters instead of battleManager.getAllCharacters
    // This aligns with Phase 3 refactoring where utility methods were moved out of BattleManager
    let enemies = [];
    if (window.BattleUtilities) {
        const allCharacters = BattleUtilities.getAllCharacters(
            battleManager.playerTeam,
            battleManager.enemyTeam
        );
        enemies = allCharacters.filter(character => 
            teamManager.getCharacterTeam(character) !== actorTeam && 
            !character.defeated
        );
    } else {
        console.warn("[PassiveBehaviors] BattleUtilities not available for getAllCharacters lookup.");
        // Fallback implementation
        enemies = [...battleManager.playerTeam, ...battleManager.enemyTeam].filter(character => 
            teamManager.getCharacterTeam(character) !== actorTeam && 
            !character.defeated
        );
    }
    
    // If there are enemies, intimidate them
    if (enemies.length > 0) {
        // Choose a random enemy
        const target = enemies[Math.floor(Math.random() * enemies.length)];
        
        // Check for ability-specific configuration
        const statusId = ability.passiveData?.statusId || 'status_atk_down';
        const duration = ability.passiveData?.duration || 1;
        
        // Apply status effect
        // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
        // Updated to use consistent 5-parameter format with explicit stacks
        battleManager.addStatusEffect(target, statusId, actor, duration, 1);
        
        return {
            executed: true,
            message: `${actor.name}'s intimidating presence weakens ${target.name}!`
        };
    }
    
    return { executed: false };
}

/**
 * Apply an effect when killing an enemy
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_OnKillEffect(context) {
    const { actor, battleManager, trigger, additionalData, ability } = context;
    
    // Only execute if trigger matches and has defeated data
    if (trigger !== 'onKill' || !additionalData || !additionalData.defeated) {
        return { executed: false };
    }
    
    // Get the defeated enemy
    const defeated = additionalData.defeated;
    
    // Get effect data from passive configuration
    const effectType = ability.passiveData?.effectType || 'heal';
    const effectValue = ability.passiveData?.value || 0.1; // Default to 10% of max HP
    const statusId = ability.passiveData?.statusId || 'status_atk_up';
    const duration = ability.passiveData?.duration || 2;
    
    // Apply different effects based on configuration
    switch (effectType) {
        case 'heal':
            // Heal self based on max HP
            const healAmount = Math.floor(actor.stats.hp * effectValue);
            battleManager.applyHealing(actor, healAmount, actor, null, 'passive');
            
            return {
                executed: true,
                message: `${actor.name} absorbs life essence, healing for ${healAmount} HP!`
            };
            
        case 'buff':
            // Apply a status buff to self
            // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
            // Updated to use consistent 5-parameter format with explicit stacks
            battleManager.addStatusEffect(actor, statusId, actor, duration, 1);
            
            return {
                executed: true,
                message: `${actor.name}'s power grows after defeating ${defeated.name}!`
            };
            
        case 'aoe_damage':
            // Apply AoE damage to all enemies
            const enemyTeam = defeated.team === 'player' ? battleManager.playerTeam : battleManager.enemyTeam;
            const damageAmount = Math.floor(actor.stats.strength * 0.2); // Base on strength
            let damageCount = 0;
            
            enemyTeam.forEach(enemy => {
                if (enemy.currentHp > 0 && enemy !== defeated) {
                    battleManager.applyDamage(enemy, damageAmount, actor, null, 'passive');
                    damageCount++;
                }
            });
            
            if (damageCount > 0) {
                return {
                    executed: true,
                    message: `${actor.name}'s power explodes, dealing ${damageAmount} damage to nearby enemies!`
                };
            }
            break;
    }
    
    return { executed: false };
}

/**
 * Increases critical hit chance after certain triggers
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_CriticalHitBoost(context) {
    const { actor, battleManager, trigger, additionalData, ability } = context;
    
    // Get configuration
    const triggers = ability.passiveData?.triggers || ['onDamageDealt'];
    const duration = ability.passiveData?.duration || 2;
    const bonusAmount = ability.passiveData?.bonusAmount || 0.15; // 15% increased crit chance
    
    // Check if this trigger is in our list of valid triggers
    if (!triggers.includes(trigger)) {
        return { executed: false };
    }
    
    // Add validation for specific trigger conditions
    if (trigger === 'onDamageDealt') {
        // Only trigger on significant damage (more than 15% of target's max HP)
        if (!additionalData || !additionalData.target || !additionalData.damageAmount) {
            return { executed: false };
        }
        
        const target = additionalData.target;
        const damage = additionalData.damageAmount;
        const damagePercent = target.stats.hp > 0 ? damage / target.stats.hp : 0;
        
        if (damagePercent < 0.15) {
            return { executed: false };
        }
    }
    
    // Apply critical hit buff
    // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
    // Fixed: Use consistent 5-parameter format with numeric stacks
    let stackCount = (typeof bonusAmount === 'number' && bonusAmount > 0) ? Math.ceil(bonusAmount) : 1;
    battleManager.addStatusEffect(actor, 'status_crit_up', actor, duration, stackCount);
    
    return {
        executed: true,
        message: `${actor.name}'s critical hit chance increases!`
    };
}

/**
 * Applies a status effect to targets when hitting them
 * @param {object} context - Passive behavior context
 * @returns {object} - Result of the passive ability
 */
function passive_StatusOnHit(context) {
    const { actor, battleManager, trigger, additionalData, ability } = context;
    
    // Only execute on damage dealt
    if (trigger !== 'onDamageDealt' || !additionalData || !additionalData.target) {
        return { executed: false };
    }
    
    const target = additionalData.target;
    
    // Skip if target is already defeated
    if (target.currentHp <= 0 || target.isDead) {
        return { executed: false };
    }
    
    // Get configuration from passive data
    const statusId = ability.passiveData?.statusId || 'status_bleed';
    const chance = ability.passiveData?.chance || 0.25; // 25% chance by default
    const duration = ability.passiveData?.duration || 2;
    
    // Roll for chance
    if (Math.random() < chance) {
        // Apply the status effect
        // FIXED (v0.5.27.2_FixStatusEffectCalls): Added actor as source parameter
        // Updated to use consistent 5-parameter format with explicit stacks
        battleManager.addStatusEffect(target, statusId, actor, duration, 1);
        
        // Get a readable name for the status
        let statusName = statusId;
        if (statusId.startsWith('status_')) {
            statusName = statusId.replace('status_', '').replace('_', ' ');
            // Capitalize first letter
            statusName = statusName.charAt(0).toUpperCase() + statusName.slice(1);
        }
        
        return {
            executed: true,
            message: `${actor.name}'s attack inflicts ${statusName} on ${target.name}!`
        };
    }
    
    return { executed: false };
}

// Register all passive behaviors
behaviorRegistry.registerPassiveBehavior('passive_ApplyRegenOnTurnStart', passive_ApplyRegenOnTurnStart);
behaviorRegistry.registerPassiveBehavior('passive_DamageReflectOnHit', passive_DamageReflectOnHit);
behaviorRegistry.registerPassiveBehavior('passive_ApplyStatusOnHit', passive_ApplyStatusOnHit);
behaviorRegistry.registerPassiveBehavior('passive_TeamBuffOnBattleStart', passive_TeamBuffOnBattleStart);
behaviorRegistry.registerPassiveBehavior('passive_CriticalMomentum', passive_CriticalMomentum);
behaviorRegistry.registerPassiveBehavior('passive_KillBuff', passive_KillBuff);
behaviorRegistry.registerPassiveBehavior('passive_LastStand', passive_LastStand);
behaviorRegistry.registerPassiveBehavior('passive_ProtectiveInstinct', passive_ProtectiveInstinct);
behaviorRegistry.registerPassiveBehavior('passive_Counterattack', passive_Counterattack);
behaviorRegistry.registerPassiveBehavior('passive_Intimidate', passive_Intimidate);
behaviorRegistry.registerPassiveBehavior('passive_OnKillEffect', passive_OnKillEffect);
behaviorRegistry.registerPassiveBehavior('passive_CriticalHitBoost', passive_CriticalHitBoost);
behaviorRegistry.registerPassiveBehavior('passive_StatusOnHit', passive_StatusOnHit);

// Export individual behaviors for direct use if needed
export {
    passive_ApplyRegenOnTurnStart,
    passive_DamageReflectOnHit,
    passive_ApplyStatusOnHit,
    passive_TeamBuffOnBattleStart,
    passive_CriticalMomentum,
    passive_KillBuff,
    passive_LastStand,
    passive_ProtectiveInstinct,
    passive_Counterattack,
    passive_Intimidate,
    passive_OnKillEffect,
    passive_CriticalHitBoost,
    passive_StatusOnHit
};


===== FILE: TargetingBehaviors.js =====
/**
 * TargetingBehaviors.js
 * 
 * Collection of targeting behavior functions for the battle system.
 * These functions determine how characters select targets for their actions.
 */

import behaviorRegistry from './BehaviorRegistry.js';

/**
 * Context object expected for targeting behaviors:
 * {
 *   actor: Character,              // The character taking the action
 *   potentialTargets: Character[], // List of possible targets
 *   teamManager: TeamManager,      // Reference to TeamManager for team data
 *   ability: Object,               // The ability being used (if applicable)
 *   battleManager: BattleManager   // Reference to BattleManager for battle state
 * }
 */

/**
 * Targets a random enemy (default behavior)
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetRandomEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // TEMPORARY DIAGNOSTIC - Remove after bug fix
    console.log(`[TargetingBehavior: targetRandomEnemy] Actor: ${actor.name} (Team: ${actor.team})`);
    console.log(`[TargetingBehavior: targetRandomEnemy] teamManager.getCharacterTeam(actor): ${teamManager.getCharacterTeam(actor)}`);
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        const isEnemy = teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor);
        const isDead = !!target.defeated;
        
        // TEMPORARY DIAGNOSTIC - Remove after bug fix
        console.log(`  Considering: ${target.name} (Team: ${target.team}, TeamManager team: ${teamManager.getCharacterTeam(target)}, HP: ${target.currentHp}, Defeated: ${target.defeated}). Is Enemy?: ${isEnemy}, IsDead: ${isDead}`);
        
        return isEnemy && !isDead;
    });
    
    // TEMPORARY DIAGNOSTIC - Remove after bug fix
    console.log(`[TargetingBehavior: targetRandomEnemy] Valid targets: ${validTargets.length > 0 ? validTargets.map(t => t.name).join(', ') : 'None'}`);    
    
    if (validTargets.length === 0) return null;
    
    // Select random target
    const randomIndex = Math.floor(Math.random() * validTargets.length);
    return validTargets[randomIndex];
}

/**
 * Targets the enemy with the lowest HP
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetLowestHpEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with lowest HP
    return validTargets.reduce((lowestTarget, currentTarget) => {
        return (currentTarget.currentHp < lowestTarget.currentHp) ? currentTarget : lowestTarget;
    }, validTargets[0]);
}

/**
 * Targets the enemy with the highest HP
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetHighestHpEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with highest HP
    return validTargets.reduce((highestTarget, currentTarget) => {
        return (currentTarget.currentHp > highestTarget.currentHp) ? currentTarget : highestTarget;
    }, validTargets[0]);
}

/**
 * Targets all enemies
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAllEnemies(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // TEMPORARY DIAGNOSTIC - Remove after bug fix
    console.log(`[TargetingBehavior: targetAllEnemies] Actor: ${actor.name} (Team: ${actor.team})`);
    console.log(`[TargetingBehavior: targetAllEnemies] teamManager.getCharacterTeam(actor): ${teamManager.getCharacterTeam(actor)}`);
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        const isEnemy = teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor);
        const isDead = !!target.defeated;
        
        // TEMPORARY DIAGNOSTIC - Remove after bug fix
        console.log(`  Considering: ${target.name} (Team: ${target.team}, TeamManager team: ${teamManager.getCharacterTeam(target)}, HP: ${target.currentHp}, Defeated: ${target.defeated}). Is Enemy?: ${isEnemy}, IsDead: ${isDead}`);
        
        return isEnemy && !isDead;
    });
    
    // TEMPORARY DIAGNOSTIC - Remove after bug fix
    console.log(`[TargetingBehavior: targetAllEnemies] Valid targets: ${validTargets.length > 0 ? validTargets.map(t => t.name).join(', ') : 'None'}`);
    
    if (validTargets.length === 0) return null;
    
    return validTargets;
}

/**
 * Targets the ally with the lowest HP
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetLowestHpAlly(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find ally with lowest HP
    return validTargets.reduce((lowestTarget, currentTarget) => {
        return (currentTarget.currentHp < lowestTarget.currentHp) ? currentTarget : lowestTarget;
    }, validTargets[0]);
}

/**
 * Targets all allies
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAllAllies(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    return validTargets;
}

/**
 * Targets self
 * @param {object} context - Targeting context
 * @returns {Character} - The actor
 */
function targetSelf(context) {
    return context.actor;
}

/**
 * Targets the enemy with the highest attack
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetHighestAttackEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with highest attack
    return validTargets.reduce((highestTarget, currentTarget) => {
        return (currentTarget.stats.attack > highestTarget.stats.attack) ? currentTarget : highestTarget;
    }, validTargets[0]);
}

/**
 * Targets the enemy with the highest intellect
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetHighestIntellectEnemy(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find target with highest intellect
    return validTargets.reduce((highestTarget, currentTarget) => {
        return (currentTarget.stats.intellect > highestTarget.stats.intellect) ? currentTarget : highestTarget;
    }, validTargets[0]);
}

/**
 * Targets adjacent enemies (main target plus adjacent ones)
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAdjacentEnemies(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include enemies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) !== teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Get primary target (usually the one with lowest HP or random)
    const primaryTarget = validTargets.reduce((lowestTarget, currentTarget) => {
        return (currentTarget.currentHp < lowestTarget.currentHp) ? currentTarget : lowestTarget;
    }, validTargets[0]);
    
    // Get adjacent targets (implementation depends on how character positions are stored)
    // For this basic implementation, we'll just get up to 2 additional random enemies
    const otherTargets = validTargets.filter(target => target !== primaryTarget);
    const adjacentTargets = [primaryTarget];
    
    // Add up to 2 more random enemies if available
    if (otherTargets.length > 0) {
        // Shuffle other targets
        const shuffled = [...otherTargets].sort(() => 0.5 - Math.random());
        // Add up to 2 more
        for (let i = 0; i < Math.min(2, shuffled.length); i++) {
            adjacentTargets.push(shuffled[i]);
        }
    }
    
    return adjacentTargets;
}

/**
 * Targets a random ally excluding self
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetRandomAlly(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies (excluding self) that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               target !== actor && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Select random ally
    const randomIndex = Math.floor(Math.random() * validTargets.length);
    return validTargets[randomIndex];
}

/**
 * Targets the most injured ally (lowest HP percentage)
 * @param {object} context - Targeting context
 * @returns {Character|null} - Selected target or null if no valid target
 */
function targetMostInjuredAlly(context) {
    const { actor, potentialTargets, teamManager } = context;
    
    // Filter to only include allies that are alive
    const validTargets = potentialTargets.filter(target => {
        return teamManager.getCharacterTeam(target) === teamManager.getCharacterTeam(actor) && 
               !target.defeated;
    });
    
    if (validTargets.length === 0) return null;
    
    // Find ally with lowest HP percentage
    return validTargets.reduce((mostInjured, current) => {
        const currentHpPercent = current.currentHp / current.stats.hp;
        const mostInjuredHpPercent = mostInjured.currentHp / mostInjured.stats.hp;
        return (currentHpPercent < mostInjuredHpPercent) ? current : mostInjured;
    }, validTargets[0]);
}

/**
 * Targets all characters but marks team relationships
 * @param {object} context - Targeting context
 * @returns {Character[]|null} - Array of targets or null if no valid targets
 */
function targetAllCharacters(context) {
    const { actor, potentialTargets, teamManager } = context;
    const actorTeam = actor.team || teamManager.getCharacterTeam(actor);
    
    // Filter living characters and add team relationship info
    const validTargets = potentialTargets.filter(target => !target.defeated).map(target => {
        // Add this crucial property to identify team relationship
        const targetTeam = target.team || teamManager.getCharacterTeam(target);
        target.isAllyOf = targetTeam === actorTeam;
        return target;
    });
    
    if (validTargets.length === 0) return null;
    
    return validTargets;
}

// Register all targeting behaviors
behaviorRegistry.registerTargetingBehavior('targetRandomEnemy', targetRandomEnemy, true);  // Set as default
behaviorRegistry.registerTargetingBehavior('targetLowestHpEnemy', targetLowestHpEnemy);
behaviorRegistry.registerTargetingBehavior('targetHighestHpEnemy', targetHighestHpEnemy);
behaviorRegistry.registerTargetingBehavior('targetAllEnemies', targetAllEnemies);
behaviorRegistry.registerTargetingBehavior('targetLowestHpAlly', targetLowestHpAlly);
behaviorRegistry.registerTargetingBehavior('targetAllAllies', targetAllAllies);
behaviorRegistry.registerTargetingBehavior('targetSelf', targetSelf);
// Register new targeting behaviors
behaviorRegistry.registerTargetingBehavior('targetHighestAttackEnemy', targetHighestAttackEnemy);
behaviorRegistry.registerTargetingBehavior('targetHighestIntellectEnemy', targetHighestIntellectEnemy);
behaviorRegistry.registerTargetingBehavior('targetAdjacentEnemies', targetAdjacentEnemies);
behaviorRegistry.registerTargetingBehavior('targetRandomAlly', targetRandomAlly);
behaviorRegistry.registerTargetingBehavior('targetMostInjuredAlly', targetMostInjuredAlly);
behaviorRegistry.registerTargetingBehavior('targetAllCharacters', targetAllCharacters);

// Export individual behaviors for direct use if needed
export {
    targetRandomEnemy,
    targetLowestHpEnemy,
    targetHighestHpEnemy,
    targetAllEnemies,
    targetLowestHpAlly,
    targetAllAllies,
    targetSelf,
    // Export new targeting behaviors
    targetHighestAttackEnemy,
    targetHighestIntellectEnemy,
    targetAdjacentEnemies,
    targetRandomAlly,
    targetMostInjuredAlly,
    targetAllCharacters
};


===== FILE: Ability.js =====
/**
 * Ability Class
 * Represents special abilities that characters can use in battle
 */

class Ability {
    /**
     * Create a new Ability
     * @param {string} name - The name of the ability
     * @param {number} damage - Base damage or healing amount
     * @param {number} cooldown - Number of turns before ability can be used again
     * @param {boolean} isHealing - Whether ability heals or damages
     * @param {object} effects - Additional effects (status effects, buffs, etc.)
     */
    constructor(name, damage, cooldown, isHealing = false, effects = {}) {
        this.name = name;
        this.damage = damage;
        this.cooldown = cooldown;
        this.currentCooldown = 0;
        this.isHealing = isHealing;
        this.effects = effects;
    }

    // Methods to be implemented
}


===== FILE: Character.js =====
/**
 * Character Class
 * Base class for all battling units in the AutoBattler game
 */

class Character {
    /**
     * Create a new Character
     * @param {string} name - Character name
     * @param {string} type - Element/type (fire, water, etc.)
     * @param {number} hp - Health points
     * @param {number} attack - Attack power
     * @param {number} defense - Defense value
     * @param {number} x - X position on screen
     * @param {number} y - Y position on screen
     * @param {number} color - Color representation (hexadecimal)
     */
    constructor(name, type, hp, attack, defense, x, y, color) {
        this.name = name;
        this.type = type;
        this.maxHp = hp;
        this.currentHp = hp;
        this.attack = attack;
        this.defense = defense;
        this.x = x;
        this.y = y;
        this.color = color;
        this.sprite = null;
        this.text = null;
        this.abilities = [];
        this.abilityCooldowns = {};
    }

    // Methods to be implemented
}


===== FILE: BattleFlowController.js =====
/**
 * BattleFlowController
 * Handles battle flow management separate from BattleManager
 * Part of BattleManager refactoring - Stage 3
 * Version 0.5.9 - 2025-05-20
 */

class BattleFlowController {
    /**
     * Create a new BattleFlowController
     * @param {BattleManager} battleManager - The BattleManager instance
     */
    constructor(battleManager) {
        console.log('[BattleFlowController] Initializing');
        this.battleManager = battleManager;
        
        // Register globally for testing/debugging
        window.battleFlowController = this;
    }
    
    /**
     * Enable the flow controller in the BattleManager
     * @returns {boolean} Success status
     */
    enableFlowController() {
        if (this.battleManager) {
            console.log("[BattleFlowController] Enabling flow controller");
            this.battleManager.useNewFlowController = true;
            return true;
        }
        return false;
    }
    
    /**
     * Disable the flow controller in the BattleManager
     * @returns {boolean} Success status
     */
    disableFlowController() {
        if (this.battleManager) {
            console.log("[BattleFlowController] Disabling flow controller");
            this.battleManager.useNewFlowController = false;
            return true;
        }
        return false;
    }
    
    /**
     * Starts a battle with the provided teams
     * @param {Array} playerTeam - Array of player characters
     * @param {Array} enemyTeam - Array of enemy characters
     * @returns {Promise<boolean>} Promise resolving to battle start success
     */
    async startBattle(playerTeam, enemyTeam) {
        console.log("[BattleFlowController] Starting battle");
        
        try {
            // 1. Preparation phase
            await this.prepareForBattle();
            
            // 2. Team preparation - delegate team preparation to BattleManager
            const preparedPlayerTeam = this.battleManager.prepareTeamForBattle(
                this.deepCopyTeam(playerTeam)
            );
            this.battleManager.playerTeam = preparedPlayerTeam;
            
            const preparedEnemyTeam = this.battleManager.prepareTeamForBattle(
                this.deepCopyTeam(enemyTeam)
            );
            this.battleManager.enemyTeam = preparedEnemyTeam;
            
            // 3. Reset battle state in BattleManager
            this.resetBattleState();
            
            // 4. Render UI (just delegate this operation to BattleManager)
            this.renderUI(preparedPlayerTeam, preparedEnemyTeam);
            
            // 5. Log battle start
            this.battleManager.logMessage('Battle started!');
            this.battleManager.logMessage(
                `${preparedPlayerTeam.length} heroes vs ${preparedEnemyTeam.length} enemies`
            );
            console.log('Battle started with teams:', preparedPlayerTeam, preparedEnemyTeam);
            
            // 6. Process battle start passive abilities
            this.processBattleStartPassives();
            
            // 7. Start first turn
            this.battleManager.startNextTurn();
            
            return true; // Battle started successfully
        } catch (error) {
            console.error("[BattleFlowController] Error starting battle:", error);
            return false; // Battle failed to start
        }
    }
    
    /**
     * Deep copies a team to prevent reference issues
     * @param {Array} team - Team to copy
     * @returns {Array} Deep copy of team
     * @private
     */
    deepCopyTeam(team) {
        if (!team || !Array.isArray(team)) {
            console.warn('[BattleFlowController] Invalid team provided, using empty array');
            return [];
        }
        return team.length > 0 ? JSON.parse(JSON.stringify(team)) : [];
    }
    
    /**
     * Prepares battle systems (status effects, behavior system)
     * @returns {Promise<void>}
     * @private
     */
    async prepareForBattle() {
        console.log("[BattleFlowController] Preparing battle systems");
        
        // Ensure status effect definitions are loaded
        if (!this.battleManager.statusEffectDefinitions) {
            try {
                await this.battleManager.loadStatusEffectDefinitions();
            } catch (error) {
                console.warn('[BattleFlowController] Status effect definitions not available, using fallback behavior:', error);
            }
        }
        
        // Ensure behavior system is initialized
        if (!this.battleManager.battleBehaviors) {
            try {
                await this.battleManager.initializeBehaviorSystem();
            } catch (error) {
                console.warn('[BattleFlowController] Behavior system not available, using legacy behavior:', error);
            }
        }
        
        // Ensure UI is initialized
        this.ensureUIInitialized();
    }
    
    /**
     * Ensures the appropriate UI is initialized based on uiMode
     * @private
     */
    ensureUIInitialized() {
        const uiMode = this.battleManager.uiMode;
        
        if (uiMode === "phaser") {
            console.log('[BattleFlowController] Using Phaser scene for battle visualization');
        } else if (!this.battleManager.battleUI || !this.battleManager.battleUI.isSetup) {
            console.log('[BattleFlowController] Initializing DOM UI for battle');
            try {
                // Create a BattleUI instance if it doesn't exist
                if (!this.battleManager.battleUI) {
                    if (typeof window.BattleUI === 'undefined') {
                        console.error('[BattleFlowController] BattleUI class is not defined! Cannot create BattleUI instance.');
                        throw new Error('BattleUI class is not defined!');
                    }
                    console.log('[BattleFlowController] Creating new DOM BattleUI instance');
                    this.battleManager.battleUI = new window.BattleUI(this.battleManager.scene, this.battleManager);
                }
                
                // Initialize the UI
                this.battleManager.battleUI.initialize();
            } catch (error) {
                console.error('[BattleFlowController] Failed to initialize BattleUI:', error);
                throw error;
            }
        }
    }
    
    /**
     * Resets battle state variables in BattleManager
     * @private
     */
    resetBattleState() {
        console.log("[BattleFlowController] Resetting battle state");
        
        // Reset core battle state variables
        this.battleManager.currentTurn = 0;
        this.battleManager.battleActive = true;
        this.battleManager.isPaused = false;
        this.battleManager.activeCharacterIndex = 0;
        this.battleManager.actionQueue = [];
        this.battleManager.turnActions = [];
        this.battleManager.turnInProgress = false;
        this.battleManager.statusEffects = {};
        
        // Initialize passive trigger tracking at battle level
        this.battleManager.passiveTriggersThisBattle = new Map();
    }
    
    /**
     * Renders characters in the UI
     * @param {Array} playerTeam - Prepared player team
     * @param {Array} enemyTeam - Prepared enemy team
     * @private
     */
    renderUI(playerTeam, enemyTeam) {
        console.log("[BattleFlowController] Rendering characters in UI");
        
        // Delegate to BattleManager's UI for DOM mode
        if (this.battleManager.uiMode !== "phaser" && this.battleManager.battleUI) {
            this.battleManager.battleUI.renderCharacters(playerTeam, enemyTeam);
        }
        
        // For Phaser UI, dispatch event through BattleManager facade if available
        if (this.battleManager.uiMode === "phaser") {
            if (this.battleManager.dispatchBattleEvent) {
                // Use the facade method
                this.battleManager.dispatchBattleEvent(
                    window.battleBridge?.eventTypes.BATTLE_STARTED || 'battle_started', 
                    { playerTeam, enemyTeam }
                );
                console.log('[BattleFlowController] Dispatched BATTLE_STARTED event for Phaser UI');
            } else if (window.battleBridge) {
                // Fallback to direct call
                try {
                    window.battleBridge.dispatchEvent(
                        window.battleBridge.eventTypes.BATTLE_STARTED, 
                        { playerTeam, enemyTeam }
                    );
                    console.log('[BattleFlowController] Dispatched BATTLE_STARTED event for Phaser UI');
                } catch (error) {
                    console.error('[BattleFlowController] Error dispatching BATTLE_STARTED event:', error);
                }
            }
        }
    }
    
    /**
    * Processes battle start passive abilities
    * @private
    */
processBattleStartPassives() {
    console.log("[BattleFlowController] Processing battle start passive abilities");
    
    const allCharacters = [
    ...this.battleManager.playerTeam, 
    ...this.battleManager.enemyTeam
    ];
    
    allCharacters.forEach(character => {
    // Enhanced validation before processing passives
    if (!character) {
    console.warn("[BattleFlowController] Skipping null character reference in battle start passives");
    return;
    }
    
    // Validate character has required properties
    if (!character.name) {
    console.warn(`[BattleFlowController] Character missing name property in battle start passives`);
    return;
    }
    
    // Check character is alive
    if (character.currentHp <= 0 || character.isDead) {
    console.debug(`[BattleFlowController] Skipping passive processing for defeated character: ${character.name}`);
    return;
    }
    
    // Check character has passives to process
    if (!Array.isArray(character.passiveAbilities) || character.passiveAbilities.length === 0) {
    console.debug(`[BattleFlowController] Character has no passive abilities: ${character.name}`);
    return;
    }
    
    // All validation passed, process passive abilities
    this.battleManager.processPassiveAbilities('onBattleStart', character);
    });
}

/**
 * Start the next turn in the battle sequence
 * @returns {boolean} Success status
 */
startNextTurn() {
    console.log("[BattleFlowController] Starting next turn");
    
    try {
        // 1. Increment turn counter
        this.battleManager.currentTurn++;
        
        // 2. Mark turn as in progress
        this.battleManager.turnInProgress = true;
        
        // 3. Process status effects
        this.battleManager.processStatusEffects();
        
        // 4. Process turn start passive abilities
        this.processTurnStartPassives();
        
        // 5. Generate actions for all characters
        this.battleManager.generateTurnActions();
        
        // 6. Start executing actions
        if (this.battleManager.actionQueue && this.battleManager.actionQueue.length > 0) {
            // Log the new turn
            this.battleManager.logMessage(`Turn ${this.battleManager.currentTurn} begins!`, 'info');
            
            // Execute the first action
            setTimeout(() => {
                if (!this.battleManager.isPaused) {
                    this.executeNextAction();
                }
            }, 1000);
            
            return true;
        } else {
            // No actions to execute
            console.warn("[BattleFlowController] No actions to execute in turn");
            this.finishTurn();
            return false;
        }
    } catch (error) {
        console.error("[BattleFlowController] Error starting next turn:", error);
        return false;
    }
}

/**
 * Process turn start passive abilities for all characters
 * @private
 */
processTurnStartPassives() {
    console.log("[BattleFlowController] Processing turn start passive abilities");
    
    const allCharacters = [
        ...this.battleManager.playerTeam, 
        ...this.battleManager.enemyTeam
    ];
    
    allCharacters.forEach(character => {
        // Skip if character is invalid or defeated
        if (!character || character.isDead || character.currentHp <= 0) {
            return;
        }
        
        // Process turn start passives
        this.battleManager.processPassiveAbilities('onTurnStart', character);
    });
}

/**
 * Execute the next action in the queue
 * @returns {boolean} Success status
 */
executeNextAction() {
    console.log("[BattleFlowController] Executing next action");
    
    try {
        // Check if battle is paused
        if (this.battleManager.isPaused) {
            console.log("[BattleFlowController] Battle is paused, not executing action");
            return false;
        }
        
        // Check if there are actions to execute
        if (!this.battleManager.actionQueue || this.battleManager.actionQueue.length === 0) {
            console.log("[BattleFlowController] No more actions in queue, finishing turn");
            this.finishTurn();
            return false;
        }
        
        // Get the next action
        const action = this.battleManager.actionQueue.shift();
        
        // Check if actor is still alive
        if (action.actor.isDead || action.actor.currentHp <= 0) {
            console.log(`[BattleFlowController] Actor ${action.actor.name} is defeated, skipping action`);
            this.executeNextAction();
            return false;
        }
        
        // Apply the action
        this.battleManager.applyActionEffect(action);
        
        // Schedule next action or finish turn
        setTimeout(() => {
            if (!this.battleManager.isPaused) {
                // Check if battle has ended
                if (this.battleManager.checkBattleEnd()) {
                    console.log("[BattleFlowController] Battle has ended during action execution");
                    return;
                }
                
                // Execute next action or finish turn
                if (this.battleManager.actionQueue && this.battleManager.actionQueue.length > 0) {
                    this.executeNextAction();
                } else {
                    this.finishTurn();
                }
            }
        }, this.battleManager.actionDelay);
        
        return true;
    } catch (error) {
        console.error("[BattleFlowController] Error executing action:", error);
        return false;
    }
}

/**
 * Finish the current turn
 * @returns {boolean} Success status
 */
finishTurn() {
    console.log("[BattleFlowController] Finishing turn");
    
    try {
        // Mark turn as not in progress
        this.battleManager.turnInProgress = false;
        
        // Clear action queues
        this.battleManager.actionQueue = [];
        this.battleManager.turnActions = [];
        
        // Display turn summary
        this.battleManager.displayTurnSummary();
        
        // Check if battle has ended
        if (this.checkBattleEnd()) {
            console.log("[BattleFlowController] Battle has ended after turn completion");
            return true;
        }
        
        // Start next turn after delay
        setTimeout(() => {
            if (!this.battleManager.isPaused && this.battleManager.battleActive) {
                this.battleManager.startNextTurn();
            }
        }, this.battleManager.turnDelay);
        
        return true;
    } catch (error) {
        console.error("[BattleFlowController] Error finishing turn:", error);
        return false;
    }
}

/**
 * Check if the battle is over
 * @returns {boolean} True if the battle is over
 */
checkBattleEnd() {
    console.log("[BattleFlowController] Checking if battle has ended");
    
    try {
        // Get team references for readability
        const playerTeam = this.battleManager.playerTeam;
        const enemyTeam = this.battleManager.enemyTeam;
        
        // Count living characters on each team
        const livingPlayerCharacters = playerTeam.filter(character => 
            character && !character.isDead && character.currentHp > 0
        ).length;
        
        const livingEnemyCharacters = enemyTeam.filter(character => 
            character && !character.isDead && character.currentHp > 0
        ).length;
        
        // Check for battle end conditions
        if (livingPlayerCharacters === 0 && livingEnemyCharacters === 0) {
            // Both teams defeated - it's a draw
            console.log("[BattleFlowController] Battle ended in a draw!");
            this.endBattle('draw');
            return true;
        } else if (livingPlayerCharacters === 0) {
            // All player characters defeated
            console.log("[BattleFlowController] Player team defeated! Battle lost.");
            this.endBattle('defeat');
            return true;
        } else if (livingEnemyCharacters === 0) {
            // All enemy characters defeated
            console.log("[BattleFlowController] Enemy team defeated! Battle won.");
            this.endBattle('victory');
            return true;
        }
        
        // Battle continues
        return false;
    } catch (error) {
        console.error("[BattleFlowController] Error checking battle end:", error);
        return false;
    }
}

/**
 * End the battle with the given result
 * @param {string} result - 'victory', 'defeat', or 'draw'
 */
endBattle(result) {
    console.log(`[BattleFlowController] Ending battle with result: ${result}`);
    
    try {
        // Update battle state
        this.battleManager.battleActive = false;
        
        // Clear any pending timers
        if (this.battleManager.turnTimer) {
            clearTimeout(this.battleManager.turnTimer);
            this.battleManager.turnTimer = null;
        }
        
        // Log the result
        let message;
        let messageType;
        
        switch (result) {
            case 'victory':
                message = "Victory! You have won the battle!";
                messageType = 'success';
                break;
            case 'defeat':
                message = "Defeat! Your team has been defeated!";
                messageType = 'error';
                break;
            case 'draw':
                message = "Draw! Both teams have been defeated!";
                messageType = 'info';
                break;
            default:
                message = `Battle ended with result: ${result}`;
                messageType = 'info';
        }
        
        // Log battle end message
        this.battleManager.logMessage(message, messageType);
        
        // Dispatch event for battle end through BattleManager facade if available
        if (this.battleManager.dispatchBattleEndEvent) {
            this.battleManager.dispatchBattleEndEvent(result, 'standard');
        } 
        // Fallback to direct battleBridge call
        else if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_ENDED, {
                    result: result,
                    winner: result, // Add this for standardization
                    playerTeam: this.battleManager.playerTeam,
                    enemyTeam: this.battleManager.enemyTeam
                });
            } catch (error) {
                console.error("[BattleFlowController] Error dispatching battle end event:", error);
            }
        }
        
        return true;
    } catch (error) {
        console.error("[BattleFlowController] Error ending battle:", error);
        return false;
    }
}
}

// Make the class globally available
window.BattleFlowController = BattleFlowController;

// Log that the file has been loaded
console.log('BattleFlowController.js: Loaded and registered globally');


===== FILE: BattleManager.js =====
/**
 * Battle Manager
 * Controls the flow of battle and combat logic
 */

class BattleManager {
    /**
     * Create a new Battle Manager
     * @param {Phaser.Scene} scene - The Phaser scene for the battle
     * @param {string} battleLogId - ID of the HTML element for battle log
     */
    constructor(scene, battleLogId) {
        this.scene = scene;
        this.battleLogId = battleLogId;
        this.playerTeam = [];
        this.enemyTeam = [];
        this.currentTurn = 0;
        this.isAutoBattle = true;
        this.battleActive = false;
        this.isPaused = false;
        this.turnDelay = 6000; // Delay between turns (ms) - doubled from 3000ms for slower pace
        this.actionDelay = 3200; // Delay between actions (ms) - doubled from 1600ms for slower pace
        this.speedMultiplier = 1; // Battle speed (1x, 2x, 4x)
        this.battleUI = null;
        this.turnTimer = null;
        this.activeCharacterIndex = 0;
        this.actionQueue = [];
        this.turnActions = [];
        this.turnInProgress = false;
        this.battleBehaviors = null; // Will hold the behavior system when loaded
        this.uiMode = "dom"; // UI mode: "dom" or "phaser"
        
        // Create a simple teamManager for compatibility with behavior system
        this.teamManager = {
            getCharacterTeam: (character) => character.team
        };

        // REFACTORING: Component manager references

        // REFACTORING: References to component managers
        this.battleFlowController = null;
        this.battleInitializer = null;
        this.statusEffectManager = null;
        this.statusEffectDefinitionLoader = null;
        this.damageCalculator = null;
        this.healingProcessor = null;
        this.typeEffectivenessCalculator = null;
        this.abilityProcessor = null;
        this.actionGenerator = null;
        this.targetingSystem = null;
        this.passiveAbilityManager = null;
        this.passiveTriggerTracker = null;
        this.battleEventDispatcher = null;
        this.battleLogManager = null;
    }
    
    /**
     * Display a summary of all characters' health at the end of a turn
     * @returns {boolean} True if summary was displayed successfully
     */
    displayTurnSummary() {
        // Direct delegation - no toggle mechanism for streamlined implementation
        if (this.battleLogManager) {
            return this.battleLogManager.displayTurnSummary();
        }
        
        // Minimal fallback with warning
        console.warn("[BattleManager] BattleLogManager not available, cannot display turn summary");
        return false;
    }
    

    
    /**
     * Initialize all component managers in proper dependency order
     */
    async initializeComponentManagers() {
        console.log('BattleManager: Initializing component managers...');
        
        // 1. First initialize core dependencies (status effect system)
        if (window.StatusEffectDefinitionLoader) {
            this.statusEffectLoader = new window.StatusEffectDefinitionLoader();
            console.log('BattleManager: StatusEffectDefinitionLoader initialized');
            
            // Only initialize StatusEffectManager if loader is available
            if (window.StatusEffectManager) {
                this.statusEffectManager = new window.StatusEffectManager(this, this.statusEffectLoader);
                console.log('BattleManager: StatusEffectManager initialized');
            }
        }
        
        // 1a. Initialize BattleInitializer (required component)
        if (window.BattleInitializer) {
            this.battleInitializer = new window.BattleInitializer(this);
            console.log('BattleManager: BattleInitializer initialized');
        } else {
            console.error('BattleManager: BattleInitializer not found on global window object. CRITICAL: Battle initialization will fail.');
            throw new Error('BattleInitializer is required but not available');
        }
        
        // 2. Initialize BattleFlowController (required component)
        if (window.BattleFlowController) {
            this.battleFlowController = new window.BattleFlowController(this);
            console.log('BattleManager: BattleFlowController component initialized');
        } else {
            console.error('BattleManager: BattleFlowController not found on global window object');
            throw new Error('BattleFlowController is required but not available');
        }
        
        // 3. Initialize type effectiveness calculator
        if (window.TypeEffectivenessCalculator) {
            this.typeEffectivenessCalculator = new window.TypeEffectivenessCalculator(this);
            console.log('BattleManager: TypeEffectivenessCalculator initialized');
            

        }
        
        // 4. Initialize damage calculator
        // Note: Initialize after TypeEffectivenessCalculator to maintain dependency order
        if (window.DamageCalculator) {
            this.damageCalculator = new window.DamageCalculator(this);
            console.log('BattleManager: DamageCalculator initialized');
            

        }
        
        // 5. Initialize healing processor
        if (window.HealingProcessor) {
            this.healingProcessor = new window.HealingProcessor(this);
            console.log('BattleManager: HealingProcessor initialized');
            

        }
        
        // 6. Initialize ability processor
        if (window.AbilityProcessor) {
            this.abilityProcessor = new window.AbilityProcessor(this);
            console.log('BattleManager: AbilityProcessor initialized');
            

        }
        
        // 7. Initialize passive system components
        if (window.PassiveTriggerTracker) {
            this.passiveTriggerTracker = new window.PassiveTriggerTracker();
            console.log('BattleManager: PassiveTriggerTracker initialized');
            

        }
        
        // Initialize PassiveAbilityManager (after PassiveTriggerTracker)
        if (window.PassiveAbilityManager) {
            this.passiveAbilityManager = new window.PassiveAbilityManager(this, this.passiveTriggerTracker);
            console.log('BattleManager: PassiveAbilityManager initialized');
            

        }
        
        // 7. Initialize targeting system
        if (window.TargetingSystem) {
            this.targetingSystem = new window.TargetingSystem(this);
            console.log('BattleManager: TargetingSystem initialized');
            

        }
        
        // 8. Initialize action generator
        if (window.ActionGenerator) {
            this.actionGenerator = new window.ActionGenerator(this);
            console.log('BattleManager: ActionGenerator initialized');
            

        }
        
        // 9. Initialize event dispatcher (Stage 7)
        if (window.BattleEventDispatcher) {
            this.battleEventDispatcher = new window.BattleEventDispatcher(this);
            console.log('BattleManager: BattleEventDispatcher initialized');
            

        }
        
        // 10. Initialize battle log manager (Stage 7) - must be after event dispatcher
        if (window.BattleLogManager) {
            this.battleLogManager = new window.BattleLogManager(this, this.battleEventDispatcher);
            console.log('BattleManager: BattleLogManager initialized');
            

        }
    }
    
    /**
     * Load status effect definitions from JSON file
     * This method now simply delegates to the StatusEffectDefinitionLoader's primeDefinitions method.
     * @returns {Promise<boolean>} Success status
     */
    async loadStatusEffectDefinitions() {
        // Check if the loader is available
        if (!this.statusEffectLoader) {
            console.error('[BattleManager] StatusEffectDefinitionLoader not available! This is a critical error.');
            return false;
        }
        
        // Check if the loader has the expected method
        if (typeof this.statusEffectLoader.primeDefinitions !== 'function') {
            console.error('[BattleManager] StatusEffectDefinitionLoader is missing primeDefinitions method! This is a critical error.');
            return false;
        }
        
        // Log delegation
        console.log('[BattleManager] Delegating status effect loading to StatusEffectDefinitionLoader');
        
        try {
            // Call the loader's primeDefinitions method which handles both JSON loading and fallbacks
            await this.statusEffectLoader.primeDefinitions();
            return true;
        } catch (error) {
            console.error('[BattleManager] Error during status effect definition loading:', error);
            return false;
        }
    }
    
    // setupFallbackStatusEffects method has been removed - StatusEffectDefinitionLoader now handles all fallbacks internally

    /**
     * Initialize the battle manager
     */
    async initialize() {
        console.log('BattleManager: Initializing...');
        
        // REFACTORING: Initialize component managers
        try {
            // Initialize component managers in dependency order
            await this.initializeComponentManagers();
            
            // Component initialization completed
            console.log('BattleManager: Components initialized successfully');
        } catch (error) {
            console.error('BattleManager: Error initializing component managers:', error);
        }
        
        try {
            // Load status effect definitions via the StatusEffectDefinitionLoader
            await this.loadStatusEffectDefinitions();
            console.log('BattleManager: Status effect definitions loaded');
            
            // Initialize behavior system if available
            try {
                await this.initializeBehaviorSystem();
                console.log('BattleManager: Behavior system initialized');
            } catch (error) {
                console.warn('BattleManager: Behavior system not available, using legacy behavior:', error);
            }
                        
            console.log('BattleManager: Initialized');
        } catch (e) {
            console.error('Error initializing battle UI:', e);
            
            // Try a fallback approach for debugging
            console.log('Checking available UI classes:', {
                'window.BattleUI': typeof window.BattleUI,
                'global BattleUI': typeof BattleUI
            });
        }
    }
    
    /**
     * Force initialization of character stats and properties
     * @param {Array} team - Team of characters to initialize
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} Initialized team
     */
    ensureCompleteCharacterInitialization(team, teamType) {
        // Facade method that delegates to BattleInitializer
        if (this.battleInitializer) {
            return this.battleInitializer.ensureCompleteCharacterInitialization(team, teamType);
        }
        
        // This should not happen since we throw an error during initialization if BattleInitializer is missing
        console.error(`[BattleManager] CRITICAL ERROR: BattleInitializer not available for character initialization (${teamType})`);
        return []; // Return empty array as a last resort
    }

    /**
     * Start a battle with the given teams, with enhanced initialization
     * @param {Array} rawPlayerTeam - Array of player characters
     * @param {Array} rawEnemyTeam - Array of enemy characters
     */
    async startBattle(rawPlayerTeam, rawEnemyTeam) {
        // Use BattleInitializer to initialize teams
        if (this.battleInitializer) {
            const initializedTeams = this.battleInitializer.initializeTeamsAndCharacters(rawPlayerTeam, rawEnemyTeam);
            this.playerTeam = initializedTeams.playerTeam;
            this.enemyTeam = initializedTeams.enemyTeam;
        } else {
            // This should not happen since we throw an error during initialization if BattleInitializer is missing
            console.error("[BattleManager] CRITICAL ERROR: BattleInitializer not available for team initialization");
            throw new Error("BattleInitializer is required for battle initialization");
        }
        
        console.log(`[BattleManager] Starting battle with ${this.playerTeam.length} player characters and ${this.enemyTeam.length} enemy characters`);
        
        // Continue with normal battle flow via BattleFlowController
        return this.battleFlowController.startBattle(this.playerTeam, this.enemyTeam);
    }
    
    /**
     * Start the next turn
     */
    startNextTurn() {
        // Reset passive trigger tracking for the new turn
        if (this.passiveTriggerTracker) {
            this.passiveTriggerTracker.resetTurnTracking();
        } else {
            console.warn("[BattleManager] PassiveTriggerTracker not available for turn reset");
        }
        

        return this.battleFlowController.startNextTurn();
    }
    
    /**
     * Execute the next action in the queue
     */
    executeNextAction() {
        // Delegate to the flow controller
        return this.battleFlowController.executeNextAction();
    }
    
    /**
     * Apply the effect of an action to its target
     * @param {Object} action - The action to apply
     */
    applyActionEffect(action) {
        // Delegate to the ability processor if available
        if (this.abilityProcessor) {
            // Delegate directly to the component for a clean implementation
            return this.abilityProcessor.applyActionEffect(action);
        }


        console.warn("BattleManager using legacy applyActionEffect - AbilityProcessor not available");
        return this.battleFlowController.applyActionEffect(action);
    }
    
    /**
     * Finish the current turn
     */
    finishTurn() {
        // Delegate to the flow controller
        return this.battleFlowController.finishTurn();
    }
    
    /**
     * Apply damage to a character - delegated to DamageCalculator component
     * @param {Object} target - Character receiving damage
     * @param {number} amount - Amount of damage
     * @param {Object} source - Character causing damage (optional)
     * @param {Object} ability - Ability used (optional)
     * @param {string} damageType - Type of damage (default: 'passive')
     * @returns {Object} - Object with actualDamage and killed properties
     */
    applyDamage(target, amount, source = null, ability = null, damageType = 'passive') {
        // Defensive validation (match original method's early returns)
        if (!target || target.isDead || target.currentHp <= 0 || amount <= 0) {
            return { actualDamage: 0, killed: false };
        }
        
        // Ensure DamageCalculator is available
        if (!this.damageCalculator) {
            console.error("DamageCalculator not initialized! Falling back to minimal damage application.");
            
            // Minimal fallback implementation to prevent game crashes
            const previousHp = target.currentHp;
            target.currentHp = Math.max(0, target.currentHp - amount);
            const actualDamage = previousHp - target.currentHp;
            const killed = previousHp > 0 && target.currentHp <= 0;
            
            this.logMessage(`${target.name} takes ${actualDamage} damage! (HP: ${target.currentHp}/${target.stats.hp})`, 'error');
            
            return { actualDamage, killed };
        }
        
        // Delegate to the specialized calculator component
        return this.damageCalculator.applyDamage(target, amount, source, ability, damageType);
    }
    
    /**
     * Check if the battle is over
     * @returns {boolean} True if the battle is over
     */
    checkBattleEnd() {
        // Delegate to the flow controller
        return this.battleFlowController.checkBattleEnd();
    }    
    
    /**
     * Prepare a team for battle by setting initial values
     * @param {Array} team - Array of character objects
     * @returns {Array} - Prepared team for battle
     */
    prepareTeamForBattle(team) {
        console.log('[BattleManager.prepareTeamForBattle] Method invoked.');
        
        if (!team || !Array.isArray(team) || team.length === 0) {
            console.warn('[BattleManager.prepareTeamForBattle] Invalid team provided:', team);
            return [];
        }

        // CORRECTED TEAM TYPE DETERMINATION LOGIC
        // If playerTeam is empty, this is the first call and we're preparing the player team
        // Otherwise, this is the second call and we're preparing the enemy team
        const isPlayerTeamCurrentlyBeingPrepared = !this.playerTeam || this.playerTeam.length === 0;
        const teamTypeToPass = isPlayerTeamCurrentlyBeingPrepared ? 'player' : 'enemy';
        
        // Diagnostic log using the corrected teamTypeToPass variable
        console.log(`[BattleManager.prepareTeamForBattle] Determined teamType: ${teamTypeToPass}. Player team length: ${this.playerTeam?.length || 0}. Preparing to call BattleInitializer.`);
        
        // Delegate to BattleInitializer for team preparation
        if (this.battleInitializer) {
            return this.battleInitializer.prepareTeamForBattle(team, teamTypeToPass);
        } else {
            console.error(`[BattleManager] CRITICAL ERROR: BattleInitializer not available for team preparation (${teamTypeToPass})`);
            return []; // Return empty array as a last resort
        }
    }
    
    /**
     * Generate a unique ID for a character
     * @returns {string} A unique ID
     */
    generateCharacterId() {
        // Facade method that delegates to BattleInitializer
        if (this.battleInitializer) {
            return this.battleInitializer.generateCharacterId();
        }
        
        // Safe fallback implementation that can be used even if BattleInitializer is missing
        console.warn("[BattleManager] BattleInitializer not available for ID generation, using fallback");
        return 'char_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Process status effects for all characters
     * @returns {boolean} - True if status effects were processed successfully
     */
    processStatusEffects() {
        // Defensive check
        if (!this.statusEffectManager) {
            console.error("StatusEffectManager not initialized! Cannot process status effects.");
            return false;
        }
        
        // Process status effects for all characters in both teams
        [...this.playerTeam, ...this.enemyTeam].forEach(character => {
            if (character.currentHp > 0) {
                this.statusEffectManager.processStatusEffects(character);
            }
        });
        
        return true;
    }
    
    /**
     * Add a status effect to a character
     * @param {Object} character - Character to affect
     * @param {string} statusId - ID of the status effect
     * @param {Object|null} source - Character causing the effect (or null if no specific source)
     * @param {number} duration - Number of turns the effect lasts 
     * @param {number} stacks - Number of stacks to apply (default: 1)
     * @returns {boolean} - True if effect was successfully applied
     */
    addStatusEffect(character, statusId, source, duration, stacks = 1) {
        // Defensive check
        if (!this.statusEffectManager) {
            console.error("StatusEffectManager not initialized! Cannot add status effect.");
            return false;
        }
        
        // Ensure duration is a number
        if (typeof duration !== 'number') {
            console.warn(`[BattleManager] Invalid duration parameter (${typeof duration}) in addStatusEffect for '${statusId}' - using default 3`);
            duration = 3; // Default duration
        }
        
        // Ensure stacks is a number
        if (typeof stacks !== 'number') {
            console.warn(`[BattleManager] Invalid stacks parameter (${typeof stacks}) in addStatusEffect for '${statusId}' - using default 1`);
            stacks = 1; // Default stacks
        }
        
        // Direct delegation with validated parameters
        return this.statusEffectManager.addStatusEffect(character, statusId, source, duration, stacks);
    }
    
    /**
     * Update status icons for a character
     * @param {Object} character - Character to update icons for
     * @returns {boolean} - True if icons were successfully updated
     */
    updateStatusIcons(character) {
        // Defensive check
        if (!this.statusEffectManager) {
            console.error("StatusEffectManager not initialized! Cannot update status icons.");
            return false;
        }
        
        // Direct delegation
        return this.statusEffectManager.updateStatusIcons(character);
    }
    
    /**
     * Generate a set of actions for the current turn
     */
    generateTurnActions() {
        // For each living character, generate an action
        // First player team actions
        this.playerTeam.forEach(character => {
            if (character.currentHp > 0) {
                const action = this.generateCharacterAction(character, 'player');
                if (action) this.turnActions.push(action);
            }
        });
        
        // Then enemy team actions
        this.enemyTeam.forEach(character => {
            if (character.currentHp > 0) {
                const action = this.generateCharacterAction(character, 'enemy');
                if (action) this.turnActions.push(action);
            }
        });
        
        // Sort actions by speed (highest speed goes first)
        this.turnActions.sort((a, b) => {
            return b.actor.stats.speed - a.actor.stats.speed;
        });
        
        // Queue up the actions
        this.actionQueue = [...this.turnActions];
    }
    
    /**
     * Import the behavior system if it wasn't already imported
     * This allows backward compatibility with existing code
     */
    async initializeBehaviorSystem() {
        // DIAGNOSTIC: Log the state of behavior systems at startup
        console.log('[BattleManager.initializeBehaviorSystem] Starting behavior system initialization');
        console.log('[BattleManager.initializeBehaviorSystem] Available window behaviors:', {
            'window.battleBehaviors': typeof window.battleBehaviors,
            'window.BattleBehaviors': typeof window.BattleBehaviors,
            'this.battleBehaviors': typeof this.battleBehaviors,
        });
        
        if (!this.battleBehaviors) {
            try {
                // Try dynamic import if ESM is supported
                // Check if the file exists at various potential locations
                console.log('Attempting to load Battle Behaviors system...');
                let module;
                try {
                    module = await import('../battle_logic/BattleBehaviors.js');
                    console.log('Loaded BattleBehaviors from ../battle_logic/BattleBehaviors.js');
                } catch (e) {
                    console.warn('Failed to load from ../battle_logic/', e.message);
                    try {
                        module = await import('/js/battle_logic/BattleBehaviors.js');
                        console.log('Loaded BattleBehaviors from /js/battle_logic/BattleBehaviors.js');
                    } catch (e2) {
                        console.warn('Failed to load from absolute path', e2.message);
                        throw e2;
                    }
                }
                
                this.battleBehaviors = module.default;
                console.log('Battle Behaviors system loaded successfully via ES Module');
            } catch (error) {
                // Fallback to global if already loaded via script tag
                console.log('[BattleManager.initializeBehaviorSystem] ES Module import failed, checking window globals...');
                
                // Try both uppercase and lowercase variants for maximum compatibility
                if (window.BattleBehaviors) {
                    this.battleBehaviors = window.BattleBehaviors;
                    console.log('[BattleManager.initializeBehaviorSystem] Battle Behaviors system loaded from window.BattleBehaviors (uppercase)');
                    
                    // DIAGNOSTIC: Check required methods on the loaded object
                    console.log('[BattleManager.initializeBehaviorSystem] Uppercase BattleBehaviors methods:', {
                        hasBehavior: typeof this.battleBehaviors.hasBehavior === 'function',
                        decideAction: typeof this.battleBehaviors.decideAction === 'function', 
                        selectTarget: typeof this.battleBehaviors.selectTarget === 'function',
                        getDefaultActionDecisionBehavior: typeof this.battleBehaviors.getDefaultActionDecisionBehavior === 'function'
                    });
                } 
                else if (window.battleBehaviors) {
                    this.battleBehaviors = window.battleBehaviors;
                    console.log('[BattleManager.initializeBehaviorSystem] Battle Behaviors system loaded from window.battleBehaviors (lowercase)');
                    
                    // DIAGNOSTIC: Check required methods on the loaded object
                    console.log('[BattleManager.initializeBehaviorSystem] Lowercase battleBehaviors methods:', {
                        hasBehavior: typeof this.battleBehaviors.hasBehavior === 'function',
                        decideAction: typeof this.battleBehaviors.decideAction === 'function', 
                        selectTarget: typeof this.battleBehaviors.selectTarget === 'function',
                        getDefaultActionDecisionBehavior: typeof this.battleBehaviors.getDefaultActionDecisionBehavior === 'function'
                    });
                }
                else {
                    console.warn('[BattleManager.initializeBehaviorSystem] Battle Behaviors system not available:', error);
                    console.log('[BattleManager.initializeBehaviorSystem] Using default behavior when system is not available');
                    // Create a simple default behavior system
                    this.battleBehaviors = {
                        hasBehavior: (name) => false,
                        decideAction: (name, context) => null,
                        selectTarget: (name, context) => {
                            // Simple targeting - find living enemy
                            const targets = context.potentialTargets.filter(t => 
                                t.team !== context.actor.team && t.currentHp > 0
                            );
                            return targets.length > 0 ? targets[0] : null;
                        },
                        getDefaultActionDecisionBehavior: () => 'defaultActionDecision',
                        getDefaultTargetingBehavior: () => 'defaultTargeting',
                        getTargetingBehaviorFromType: (type) => 'defaultTargeting'
                    };
                }
            }
        }
        
        // Final diagnostic check of the initialized system
        console.log('[BattleManager.initializeBehaviorSystem] Final behavior system state:', {
            'this.battleBehaviors defined': !!this.battleBehaviors,
            'decideAction method exists': typeof this.battleBehaviors?.decideAction === 'function'
        });
        
        return this.battleBehaviors;
    }
    
    /**
     * Generate an action for a character
     * @param {Object} character - The character
     * @param {string} team - 'player' or 'enemy'
     * @returns {Object|null} The action or null
     */
    generateCharacterAction(character, team) {
        // Delegate to the action generator if available
        if (this.actionGenerator) {
            return this.actionGenerator.generateCharacterAction(character, team);
        }
        

        console.warn("BattleManager using legacy generateCharacterAction - ActionGenerator not available");
        
        // Safe fallback: return null (no action) if ActionGenerator not available
        return null;
    }
    
    /**
     * Apply a random status effect to a character
     * @param {Object} target - The character to affect
     */
    applyRandomStatusEffect(target) {
        // Delegate to the ability processor if available
        if (this.abilityProcessor) {
            return this.abilityProcessor.applyRandomStatusEffect(target);
        }
        

        console.warn("BattleManager using legacy applyRandomStatusEffect - AbilityProcessor not available");
        return false;
    }
    
    /**
     * Process a single effect from an ability's effects array
     * @param {Object} effect - The effect to process
     * @param {Object} actor - The character using the ability
     * @param {Object} target - The target of the effect
     * @param {Object} ability - The ability being used
     */
    processEffect(effect, actor, target, ability) {
        // Delegate to the ability processor if available
        if (this.abilityProcessor) {
            return this.abilityProcessor.processEffect(effect, actor, target, ability);
        }
        

        console.warn("BattleManager using legacy processEffect - AbilityProcessor not available");
        return false;
    }
    
    /**
     * Calculate damage for an action.
     * Delegates calculation to DamageCalculator component.
     * @param {Object} attacker - The attacking character
     * @param {Object} target - The target character
     * @param {Object|null} ability - The ability used (if any)
     * @param {Object|null} effect - The specific effect from an ability (if any)
     * @returns {Object} - Complete damage calculation result with metadata
     * @see DamageCalculator for implementation details
     */
    calculateDamage(attacker, target, ability, effect = null) {
        // Defensive check - ensure DamageCalculator is available
        if (!this.damageCalculator) {
            console.error("DamageCalculator component not found during delegation in BattleManager!");
            // Return a safe default object matching the expected structure
            return { 
                damage: 0, 
                scalingText: '', 
                scalingStat: 0, 
                scalingStatName: '', 
                damageType: ability ? (ability.damageType || 'physical') : 'physical',
                isCritical: false,
                typeMultiplier: 1
            };
        }
        
        // Direct delegation to DamageCalculator - no adapter wrapper needed now that it returns the full object
        return this.damageCalculator.calculateDamage(attacker, target, ability, effect);
    }
    
   /**
     * Calculate type advantage multiplier.
     * Delegates calculation to the TypeEffectivenessCalculator component.
     * @param {string} attackerType - Attacker's type
     * @param {string} defenderType - Defender's type
     * @returns {number} Damage multiplier (1.5 for advantage, 0.75 for disadvantage, 1.0 otherwise)
     * @see TypeEffectivenessCalculator for implementation details
     */
    calculateTypeMultiplier(attackerType, defenderType) {
        // Delegate directly to the component
        if (this.typeEffectivenessCalculator) {
             // Call the method on the initialized component instance
             return this.typeEffectivenessCalculator.calculateTypeMultiplier(attackerType, defenderType);
        } else {
             // Fallback if the component wasn't properly initialized (should not happen in normal flow)
             console.error("TypeEffectivenessCalculator component not found during delegation in BattleManager!");
             // Return a neutral multiplier as a safe default
             return 1.0;
        }
    }
    
    /**
     * Process passive abilities for a specific trigger event
     * @param {string} trigger - The trigger event (e.g., 'onTurnStart', 'onDamageTaken')
     * @param {Object} character - The character whose passives should be checked
     * @param {Object} additionalData - Additional context data for the passive
     * @returns {Array} Array of executed passive results
     */
    processPassiveAbilities(trigger, character, additionalData = {}) {
        // Delegate to PassiveAbilityManager if available
        if (this.passiveAbilityManager) {
            return this.passiveAbilityManager.processPassiveAbilities(trigger, character, additionalData);
        }
        
        // Fallback with warning if PassiveAbilityManager is not available
        console.warn("[BattleManager] PassiveAbilityManager not available for processing passive abilities");
        return []; // Return empty results as fallback
    }
    
    /**
     * Toggle pause state
     * @returns {boolean} - New pause state
     */
    togglePause() {
        this.isPaused = !this.isPaused;
        
        if (this.isPaused) {
            // Clear any pending turn timer
            if (this.turnTimer) {
                clearTimeout(this.turnTimer);
                this.turnTimer = null;
            }
            this.logMessage('Battle paused', 'info');
        } else {
            // Resume battle
            this.logMessage('Battle resumed', 'info');
            if (!this.turnInProgress) {
                this.startNextTurn();
            } else {
                this.executeNextAction();
            }
        }
        
        return this.isPaused;
    }
    
    /**
     * Pause the battle
     * @returns {boolean} - Current pause state (should be true)
     */
    pauseBattle() {
        if (!this.isPaused) {
            // Only log and clear timer if we're actually changing state
            this.isPaused = true;
            
            // Clear any pending turn timer
            if (this.turnTimer) {
                clearTimeout(this.turnTimer);
                this.turnTimer = null;
            }
            this.logMessage('Battle paused', 'info');
        }
        
        return this.isPaused;
    }
    
    /**
     * Resume the battle
     * @returns {boolean} - Current pause state (should be false)
     */
    resumeBattle() {
        if (this.isPaused) {
            // Only log and restart if we're actually changing state
            this.isPaused = false;
            
            this.logMessage('Battle resumed', 'info');
            if (!this.turnInProgress) {
                this.startNextTurn();
            } else { 
                this.executeNextAction();
            }
        }
        
        return this.isPaused;
    }
    
    /**
     * Set battle speed
     * @param {number} multiplier - Speed multiplier (1, 2, or 3)
     */
    setSpeed(multiplier) {
        const validMultipliers = [1, 2, 3]; // Match UI options
        if (validMultipliers.includes(multiplier)) {
            // Store previous and new value for comparison
            const previousSpeed = this.speedMultiplier;
            this.speedMultiplier = multiplier;
            
            // Base timing values - doubled from original values for slower pace
            const BASE_TURN_DELAY = 6000;
            const BASE_ACTION_DELAY = 3200;
            
            // Update timing values
            this.turnDelay = BASE_TURN_DELAY / multiplier;
            this.actionDelay = BASE_ACTION_DELAY / multiplier;
            
            // Log speed change if it actually changed
            if (previousSpeed !== multiplier) {
                this.logMessage(`Battle speed set to ${multiplier}x`, 'info');
            }
            
            // Notify UI components via bridge
            if (window.battleBridge && this.uiMode === "phaser") {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_UI_INTERACTION, {
                    action: 'speed_change',
                    speed: multiplier,
                    previousSpeed: previousSpeed,
                    turnDelay: this.turnDelay,
                    actionDelay: this.actionDelay
                });
            }
        }
    }
    
    /**
     * Log a message to the battle log
     * @param {string} message - The message to log
     * @param {string} type - The type of message (default, info, success, action, error)
     * @returns {boolean} True if logged successfully
     */
    logMessage(message, type = 'default') {
        // Direct delegation - no toggle mechanism for streamlined implementation
        if (this.battleLogManager) {
            return this.battleLogManager.logMessage(message, type);
        }
        
        // Minimal fallback implementation (no original implementation preserved)
        console.warn(`[BattleManager] BattleLogManager not available, using minimal logging`);
        console.log(`[BattleLog ${type}]: ${message}`);
        
        // Try direct UI or battleBridge communication as last resort
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
                    message: message,
                    type: type
                });
            } catch (error) {
                console.error('[BattleManager] Error dispatching log event:', error);
            }
        }
        
        // Add to DOM battle log if in DOM mode and battleUI is available
        if (this.uiMode === "dom" && this.battleUI && typeof this.battleUI.addLogMessage === 'function') {
            try {
                this.battleUI.addLogMessage(message, type);
            } catch (error) {
                console.error('Error adding message to battle UI:', error);
            }
        }
        
        return false;
    }
    
   /**
     * End the battle
     * @param {string} result - Battle result ('victory', 'defeat', 'draw')
     */
    endBattle(result) {
        // Delegate to the flow controller
        this.battleFlowController.endBattle(result);
    }
    
    /**
     * Check if character was dead but now has HP, and reset death status if needed
     * @param {Object} character - The character to check
     * @returns {boolean} - True if character was revived, false otherwise
     */
    checkAndResetDeathStatus(character) {
        // Delegate to HealingProcessor if available
        if (this.healingProcessor) {
            return this.healingProcessor.checkAndResetDeathStatus(character);
        }
        
        // Original implementation
        // If character was marked as dead but now has HP, reset death status
        if (character.isDead && character.currentHp > 0) {
            character.isDead = false;
            // Add team identifier for clarity
            const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
            this.logMessage(`${character.name}${teamIdentifier} has been revived!`, 'success');
            
            // Update UI if present
            if (this.battleUI) {
                this.battleUI.updateCharacterHealth(character, 0, true);
            }
            
            return true; // Character was revived
        }
        
        return false; // No revival occurred
    }
    
    /**
     * Apply direct healing to a target (for passive abilities, etc.).
     * This method acts as a facade, delegating core logic to HealingProcessor
     * and handling subsequent side effects like logging and passive triggers.
     * @param {Object} target - The character receiving healing
     * @param {number} amount - Amount of healing to apply
     * @param {Object} source - Character causing the healing (optional)
     * @param {Object} ability - Ability associated with the healing (optional)
     * @param {string} healType - Type of healing (e.g., 'passive', 'regen') (optional)
     * @returns {Object} - Result containing { healing: number, revived: boolean }
     */
    applyHealing(target, amount, source = null, ability = null, healType = 'passive') {
        // 1. Ensure HealingProcessor component is available
        if (!this.healingProcessor) {
            console.error('[BattleManager Utility] HealingProcessor component not found! Cannot apply direct healing.');
            // Return default object structure matching original utility method's format
            return { healing: 0, revived: false };
        }

        // 2. Delegate the core healing logic to the HealingProcessor
        // HealingProcessor handles HP capping, CHARACTER_HEALED event dispatch, and returns results.
        const result = this.healingProcessor.applyHealing(target, amount, source, ability, healType);
        const actualHealing = result.actualHealing;
        const wasRevivalPossible = result.revived; // Processor detected conditions for revival

        // 3. Handle Side Effects (Logging & Passives) here in BattleManager based on the result
        if (actualHealing > 0) {
            // Log the healing event
            const targetTeam = target.team;
            const targetInfo = `${target.name}${targetTeam === 'player' ? ' (ally)' : ' (enemy)'}`;
            const sourceInfo = source ? `${source.name}${source.team === 'player' ? ' (ally)' : ' (enemy)'}` : 'Effect';
            const message = source
                ? `${targetInfo} is healed for ${actualHealing} HP from ${sourceInfo}'s ${healType}! (HP: ${target.currentHp}/${target.stats.hp})`
                : `${targetInfo} is healed for ${actualHealing} HP from ${healType}! (HP: ${target.currentHp}/${target.stats.hp})`;
            this.logMessage(message, 'success'); // Use the BattleManager's logMessage

            // Trigger 'onHealed' passive for the target
            this.processPassiveAbilities('onHealed', target, {
                source: source,
                healAmount: actualHealing,
                ability: ability,
                healType: healType
            });

            // Trigger 'onHealingDone' for the source (if not self-healing)
            if (source && source !== target) {
                this.processPassiveAbilities('onHealingDone', source, {
                    target: target,
                    healAmount: actualHealing,
                    ability: ability,
                    healType: healType
                });
            }
        }

        // 4. Check and Reset Death Status (Delegate state change to processor)
        let resurrectionOccurred = false;
        if (wasRevivalPossible) {
             // Check processor exists and has the method before calling
             if (this.healingProcessor.checkAndResetDeathStatus) {
                // Call the processor's method to handle the actual state change (isDefeated = false) and log revival
                resurrectionOccurred = this.healingProcessor.checkAndResetDeathStatus(target);
             } else {
                 console.warn("[BM Utility Heal] HealingProcessor is missing checkAndResetDeathStatus method!");
             }
        }

        // 5. Trigger 'onRevive' passive ONLY if resurrection actually occurred
        if (resurrectionOccurred) {
            this.processPassiveAbilities('onRevive', target, {
                reviver: source,
                ability: ability,
                healType: healType
            });
        }

        // 6. Update UI (If needed for direct calls - evaluate later if purely event-driven is better)
        // Note: This direct UI call might become obsolete if UI relies solely on BattleBridge events.
        if (this.battleUI && actualHealing > 0) {
             if (typeof this.battleUI.updateCharacterHealth === 'function') {
                this.battleUI.updateCharacterHealth(target, actualHealing, true);
             }
        }

        // 7. Return the result, adapting keys for compatibility with original utility method format
        return { healing: actualHealing, revived: resurrectionOccurred };
    }
    
    // Utility methods have been removed and moved to BattleUtilities static class
    // See js/battle_logic/utilities/BattleUtilities.js
    
    /**
     * Dispatch a battle event
     * @param {string} eventType - The type of event
     * @param {Object} eventData - The event data
     * @returns {boolean} True if dispatched successfully
     */
    dispatchBattleEvent(eventType, eventData) {
        // Direct delegation - no toggle mechanism for streamlined implementation
        if (this.battleEventDispatcher) {
            return this.battleEventDispatcher.dispatchEvent(eventType, eventData);
        }
        
        // Minimal fallback implementation (no original implementation preserved)
        console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch ${eventType}`);
        
        // Try direct battleBridge as last resort
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(eventType, eventData);
                return true;
            } catch (error) {
                console.error(`[BattleManager] Error dispatching ${eventType}:`, error);
            }
        }
        
        return false;
    }
    
    /**
     * Dispatch an event when a character takes damage
     * @param {Object} target - The character taking damage
     * @param {number} amount - Amount of damage
     * @param {Object|null} source - Source of the damage (character or null)
     * @param {Object|null} ability - Ability that caused damage (or null)
     * @returns {boolean} - Success status
     */
    dispatchDamageEvent(target, amount, source = null, ability = null) {
        // Direct delegation - no toggle mechanism
        if (this.battleEventDispatcher) {
            return this.battleEventDispatcher.dispatchCharacterDamagedEvent(target, amount, source, ability);
        }
        
        // Minimal fallback
        console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch damage event`);
        
        // Try direct battleBridge as last resort
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
                    character: target,
                    target: target,
                    amount: amount,
                    source: source,
                    ability: ability,
                    newHealth: target.currentHp,
                    maxHealth: target.stats.hp
                });
                return true;
            } catch (error) {
                console.error(`[BattleManager] Error dispatching damage event:`, error);
            }
        }
        
        return false;
    }
    
    /**
     * Dispatch an event when a character is healed
     * @param {Object} target - The character being healed
     * @param {number} amount - Amount of healing
     * @param {Object|null} source - Source of the healing (character or null)
     * @param {Object|null} ability - Ability that caused healing (or null)
     * @returns {boolean} - Success status
     */
    dispatchHealingEvent(target, amount, source = null, ability = null) {
        // Direct delegation - no toggle mechanism
        if (this.battleEventDispatcher) {
            return this.battleEventDispatcher.dispatchCharacterHealedEvent(target, amount, source, ability);
        }
        
        // Minimal fallback
        console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch healing event`);
        
        // Try direct battleBridge as last resort
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_HEALED, {
                    character: target,
                    target: target,
                    amount: amount,
                    source: source,
                    ability: ability,
                    newHealth: target.currentHp,
                    maxHealth: target.stats.hp
                });
                return true;
            } catch (error) {
                console.error(`[BattleManager] Error dispatching healing event:`, error);
            }
        }
        
        return false;
    }
    
    /**
     * Dispatch an event when a character performs an action
     * @param {Object} character - The character performing the action
     * @param {Object} action - The action data
     * @returns {boolean} - Success status
     */
    dispatchActionEvent(character, action) {
        // Direct delegation - no toggle mechanism
        if (this.battleEventDispatcher) {
            return this.battleEventDispatcher.dispatchCharacterActionEvent(character, action);
        }
        
        // Minimal fallback
        console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch action event`);
        
        // Try direct battleBridge as last resort
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_ACTION, {
                    character: character,
                    action: action
                });
                return true;
            } catch (error) {
                console.error(`[BattleManager] Error dispatching action event:`, error);
            }
        }
        
        return false;
    }
    
    /**
     * Dispatch an event when a battle ends
     * @param {string} winner - Winner of the battle ('player', 'enemy', or 'draw')
     * @param {string} reason - Reason for battle end
     * @returns {boolean} - Success status
     */
    dispatchBattleEndEvent(winner, reason = 'standard') {
        // Direct delegation - no toggle mechanism
        if (this.battleEventDispatcher) {
            return this.battleEventDispatcher.dispatchBattleEndedEvent(winner, reason);
        }
        
        // Minimal fallback
        console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch battle end event`);
        
        // Try direct battleBridge as last resort
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_ENDED, {
                    winner: winner,
                    reason: reason
                });
                return true;
            } catch (error) {
                console.error(`[BattleManager] Error dispatching battle end event:`, error);
            }
        }
        
        return false;
    }
}

// Export as ES Module
// Make BattleManager available globally for traditional scripts
if (typeof window !== 'undefined') {
  window.BattleManager = BattleManager;
  console.log("BattleManager class definition loaded and exported to window.BattleManager");
}

// Legacy global assignment for maximum compatibility
window.BattleManager = BattleManager;

// End of BattleManager class


===== FILE: TeamManager.js =====
/**
 * Team Manager
 * Manages team composition and character selection
 */

class TeamManager {
    /**
     * Create a new Team Manager
     */
    constructor() {
        this.availableCharacters = [];
        this.playerTeam = [];
        this.enemyTeam = [];
        this.maxTeamSize = 3;
    }

    /**
     * Set the player's team
     * @param {Array} team - Array of hero objects
     */
    setPlayerTeam(team) {
        this.playerTeam = team;
        console.log('Player team set:', this.playerTeam);
    }

    /**
     * Set a custom enemy team chosen by the player
     * @param {Array} team - Array of enemy characters
     */
    setCustomEnemyTeam(team) {
        // Make deep copies of the characters to avoid modifying original data
        this.enemyTeam = team.map(character => {
            // Create a deep copy
            const characterCopy = JSON.parse(JSON.stringify(character));
            
            // Add a small amount of variance to make battles less predictable
            // This is similar to what we do in generateRandomTeam
            const statVariance = 0.1; // 10% variance - lower than random opponents
            characterCopy.stats.hp = Math.floor(characterCopy.stats.hp * (1 + (Math.random() * statVariance * 2 - statVariance)));
            characterCopy.stats.attack = Math.floor(characterCopy.stats.attack * (1 + (Math.random() * statVariance * 2 - statVariance)));
            characterCopy.stats.defense = Math.floor(characterCopy.stats.defense * (1 + (Math.random() * statVariance * 2 - statVariance)));
            
            return characterCopy;
        });
        
        console.log('Custom enemy team set:', this.enemyTeam);
    }

    /**
     * Generate an enemy team based on battle mode
     * @param {string} mode - Battle mode ('random', 'custom', 'campaign')
     * @returns {Promise} - Promise that resolves when enemy team generation is complete
     */
    async generateEnemyTeam(mode) {
        this.enemyTeam = [];

        let generationPromise;

        switch (mode) {
            case 'random':
                generationPromise = this.generateRandomTeam();
                break;
            case 'custom':
                // Custom teams are now set directly via setCustomEnemyTeam
                // If we reach here, fall back to random (shouldn't happen with UI changes)
                generationPromise = this.generateRandomTeam();
                break;
            case 'campaign':
                // TODO: Implement campaign enemy teams
                generationPromise = this.generateRandomTeam(); // Use random for now
                break;
            default:
                generationPromise = this.generateRandomTeam();
        }

        // Wait for team generation to complete
        await generationPromise;
        
        console.log('Enemy team generation complete:', this.enemyTeam);
        return this.enemyTeam;
    }

    /**
     * Generate a random enemy team
     */
    async generateRandomTeam() {
        try {
            // Always refresh the characters to ensure we have the full pool
            try {
                const response = await fetch('data/characters.json');
                const data = await response.json();
                this.availableCharacters = data.characters;
            } catch (err) {
                console.error('Failed to fetch characters.json:', err);
                // Use hardcoded characters as fallback
                this.availableCharacters = [
                    {
                        id: 4,
                        name: "Vaelgar",
                        type: "dark",
                        role: "Knight",
                        rarity: "Epic",
                        stats: {
                            hp: 120,
                            attack: 18,
                            defense: 12
                        },
                        abilities: [
                            {
                                name: "Shadow Strike",
                                damage: 28,
                                cooldown: 3,
                                isHealing: false,
                                description: "Attacks from the shadows for heavy damage"
                            },
                            {
                                name: "Void Barrier",
                                damage: 20,
                                cooldown: 4,
                                isHealing: true,
                                description: "Creates a barrier of dark energy that absorbs damage"
                            }
                        ]
                    },
                    {
                        id: 3,
                        name: "Sylvanna",
                        type: "nature",
                        role: "Ranger",
                        rarity: "Uncommon",
                        stats: {
                            hp: 90,
                            attack: 15,
                            defense: 15
                        },
                        abilities: [
                            {
                                name: "Vine Whip",
                                damage: 20,
                                cooldown: 2,
                                isHealing: false,
                                description: "Strikes with vines that can ensnare the target"
                            },
                            {
                                name: "Nature's Blessing",
                                damage: 25,
                                cooldown: 4,
                                isHealing: true,
                                description: "Channels the power of nature to heal wounds"
                            }
                        ]
                    }
                ];
            }

            // Clear enemy team
            this.enemyTeam = [];
            
            // Safety check
            if (!this.availableCharacters || this.availableCharacters.length === 0) {
                console.error('No characters available to generate a team');
                return;
            }

            console.log(`Generating random team from ${this.availableCharacters.length} available characters`);

            // Always use max team size (3) for consistent 3v3 battles
            const teamSize = this.maxTeamSize;

            // Select random heroes, with duplicate prevention if possible
            const availableHeroes = [...this.availableCharacters];
            // If we have fewer heroes than needed for a full team, allow duplicates
            const allowDuplicates = availableHeroes.length < teamSize;
            
            for (let i = 0; i < teamSize; i++) {
                // If we run out of unique heroes but still need more, reset the pool
                if (availableHeroes.length === 0) {
                    if (allowDuplicates) {
                        // Reset the available heroes pool to allow duplicates
                        availableHeroes.push(...this.availableCharacters);
                    } else {
                        break;
                    }
                }

                const randomIndex = Math.floor(Math.random() * availableHeroes.length);
                const selectedHero = availableHeroes.splice(randomIndex, 1)[0];
                
                // Create a copy of the hero to avoid modifying the original
                const heroCopy = JSON.parse(JSON.stringify(selectedHero));
                
                // Add some randomness to stats
                const statVariance = 0.2; // 20% variance
                heroCopy.stats.hp = Math.floor(heroCopy.stats.hp * (1 + (Math.random() * statVariance * 2 - statVariance)));
                heroCopy.stats.attack = Math.floor(heroCopy.stats.attack * (1 + (Math.random() * statVariance * 2 - statVariance)));
                heroCopy.stats.defense = Math.floor(heroCopy.stats.defense * (1 + (Math.random() * statVariance * 2 - statVariance)));
                
                this.enemyTeam.push(heroCopy);
            }
            
            // Fallback if no team was generated
            if (this.enemyTeam.length === 0) {
                console.warn('No enemies were generated, using fallback');
                // Add at least one hero as fallback
                const fallbackHero = JSON.parse(JSON.stringify(this.availableCharacters[0]));
                this.enemyTeam.push(fallbackHero);
            }
        } catch (error) {
            console.error('Error generating random team:', error);
            // Use a fallback enemy
            this.enemyTeam = [
                {
                    id: 4,
                    name: "Vaelgar",
                    type: "dark",
                    role: "Knight",
                    stats: {
                        hp: 120,
                        attack: 18,
                        defense: 12
                    },
                    abilities: [
                        {
                            name: "Shadow Strike",
                            damage: 28,
                            cooldown: 3,
                            isHealing: false,
                            description: "Attacks from the shadows for heavy damage"
                        }
                    ]
                }
            ];
        }
        
        console.log('Generated enemy team:', this.enemyTeam);
    }
}


===== FILE: PhaserSoundManager.js =====
/**
 * PhaserSoundManager.js
 * 
 * Manages audio for the Phaser-based battle system. Handles loading,
 * playing, and configuring sounds based on game events.
 */

class PhaserSoundManager {
    constructor(scene) {
        // Check for existing instance
        if (scene.soundManager) {
            console.warn('A sound manager already exists for this scene. Returning existing instance.');
            return scene.soundManager;
        }

        this.scene = scene;
        this.sounds = {};
        this.categories = {
            attack: [], // slap sounds
            ability: [], // splash sounds
            movement: [], // woosh sounds
            ui: [] // UI sounds
        };
        this.config = {
            masterVolume: 0.8,  // Default at 80%
            muted: false,
            categoryVolumes: {
                attack: 0.9,
                ability: 1.0,
                movement: 0.7,
                ui: 0.6
            }
        };
        
        // Initialize the sound manager
        this.initialize();
    }
    
    /**
     * Initialize the sound manager
     */
    initialize() {
        console.log('Initializing Phaser Sound Manager');
        
        // Load default sounds if not already loaded
        this.loadDefaultSounds();
        
        // Set up event listeners
        this.setupEventListeners();
    }
    
    /**
     * Load default battle sounds
     */
    loadDefaultSounds() {

===== FILE: BattleBridge.js =====
/**
 * BattleBridge.js
 * Handles communication between BattleManager and Phaser Battle Scene
 * 
 * Version 0.5.1.2d - 2025-05-04
 */

class BattleBridge {
    constructor() {
        this.battleManager = null;
        this.battleScene = null;
        
        // Event listeners for all battle events
        this.eventListeners = {};
        
        // Define all event types
        this.eventTypes = {
            BATTLE_INITIALIZED: 'battle_initialized',
            BATTLE_STARTED: 'battle_started',
            BATTLE_ENDED: 'battle_ended',
            TURN_STARTED: 'turn_started',
            TURN_ENDED: 'turn_ended',
            CHARACTER_ACTION: 'character_action',
            CHARACTER_DAMAGED: 'character_damaged',
            CHARACTER_HEALED: 'character_healed',
            CHARACTER_DEFEATED: 'character_defeated',
            STATUS_EFFECT_APPLIED: 'status_effect_applied',
            STATUS_EFFECT_REMOVED: 'status_effect_removed',
            STATUS_EFFECT_UPDATED: 'status_effect_updated',
            STATUS_EFFECTS_CHANGED: 'status_effects_changed', // For bulk status effect updates
            ABILITY_USED: 'ability_used',
            PASSIVE_TRIGGERED: 'passive_triggered',
            BATTLE_UI_INTERACTION: 'battle_ui_interaction',
            BATTLE_LOG: 'battle_log' // Event type for battle log messages
        };
        
        // Track bridge state
        this.battlesStarted = 0;
        
        console.log('BattleBridge: Constructor called, registering global class');
    }
    
    /**
     * Initialize the bridge with necessary references
     * @param {Object} battleManager - The BattleManager instance
     * @param {Object} battleScene - The Phaser BattleScene
     */
    initialize(battleManager, battleScene) {
        console.log('BattleBridge: Initializing...');
        
        this.battleManager = battleManager;
        this.battleScene = battleScene;
        
        // Set UI mode to phaser
        if (this.battleManager) {
            console.log('BattleBridge: Setting battleManager.uiMode to "phaser"');
            this.battleManager.uiMode = "phaser";
        } else {
            console.warn('BattleBridge: battleManager is null, cannot set uiMode');
        }
        
        // Set up listeners
        this.setupEventListeners();
        
        // Patch BattleManager to emit events
        this.patchBattleManager();
        
        console.log('BattleBridge: Initialized successfully');
        
        // Dispatch initialization event
        this.dispatchEvent(this.eventTypes.BATTLE_INITIALIZED, {
            battleManager,
            battleScene
        });
        
        return this;
    }
    
    /**
     * Set up event listeners for the bridge
     */
    setupEventListeners() {
        // Initialize event listeners for all event types
        Object.values(this.eventTypes).forEach(type => {
            this.eventListeners[type] = [];
        });
        
        console.log('BattleBridge: Event listeners initialized');
    }
    
    /**
     * Add an event listener
     * @param {string} eventType - The event type to listen for
     * @param {Function} callback - The callback function
     */
    addEventListener(eventType, callback) {
        // Auto-register unknown event types to prevent errors
        if (!this.eventListeners[eventType]) {
            console.log(`BattleBridge: Auto-registering unknown event type "${eventType}"`);
            this.eventListeners[eventType] = [];
        }
        
        this.eventListeners[eventType].push(callback);
        return this;
    }
    
    /**
     * Remove an event listener
     * @param {string} eventType - The event type
     * @param {Function} callback - The callback function to remove
     */
    removeEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) return this;
        
        const index = this.eventListeners[eventType].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[eventType].splice(index, 1);
        }
        
        return this;
    }
    
    /**
     * Dispatch an event to all listeners
     * @param {string} eventType - The event type to dispatch
     * @param {Object} data - The event data
     */
    dispatchEvent(eventType, data) {
        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
        console.log('[BB dispatchEvent CALLED] EventType:', eventType, 'Data Keys:', data ? Object.keys(data) : 'No data', 'Raw Data (beware circular):', data);
        
        console.log(`BattleBridge: Dispatching event ${eventType}`, data);
        
        if (!this.eventListeners[eventType]) {
            console.warn(`BattleBridge: No listeners for event "${eventType}"`);
            return;
        }
        
        // DIAGNOSTIC: Log all registered event types and their listener counts
        if (eventType === 'character_action' || eventType === 'ability_used') {
            console.log('BattleBridge: Event listeners summary:', Object.entries(this.eventListeners).map(([type, listeners]) => {
                return `${type}: ${listeners.length} listeners`;
            }));
        }
        
        // Log listener count for debugging
        console.log(`BattleBridge: Found ${this.eventListeners[eventType].length} listeners for ${eventType}`);
        
        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
        if (this.eventListeners[eventType] && this.eventListeners[eventType].length > 0) { 
            console.log('[BB dispatchEvent] Registered callbacks for ' + eventType + ':', 
                this.eventListeners[eventType].map(cb => cb.name || 'anonymous_handler')); 
        }
        
        // Add event type to data for reference
        const eventData = {
            ...data,
            type: eventType,
            timestamp: Date.now()
        };
        
        try {
            this.eventListeners[eventType].forEach((callback, index) => {
                try {
                    console.log(`BattleBridge: Calling listener ${index} for ${eventType}`, {
                        listenerFunction: typeof callback,
                        listenerThisContext: callback.hasOwnProperty('this') ? 'has this context' : 'no this context',
                        listenerToString: callback.toString().substring(0, 100) + '...' // First 100 chars of function source
                    });
                    callback(eventData);
                    console.log(`BattleBridge: Listener ${index} completed successfully`);
                } catch (error) {
                    console.error(`BattleBridge: Error in event listener ${index} for "${eventType}":`, error);
                }
            });
        } catch (error) {
            console.error(`BattleBridge: Error dispatching event "${eventType}":`, error);
        }
    }
    
    /**
     * Patch the BattleManager methods to emit events
     */
    patchBattleManager() {
        if (!this.battleManager) {
            console.error('BattleBridge: No BattleManager to patch');
            return this;
        }
        
        try {
            console.log('BattleBridge: Patching BattleManager methods...');
            
            // Store original methods
            const originalStartBattle = this.battleManager.startBattle;
            const originalEndBattle = this.battleManager.endBattle;
            const originalStartNextTurn = this.battleManager.startNextTurn;  // UPDATED: correct method name
            const originalEndTurn = this.battleManager.endTurn;
            const originalGenerateCharacterAction = this.battleManager.generateCharacterAction;
            const originalProcessAbility = this.battleManager.processAbility;
            const originalApplyDamage = this.battleManager.applyDamage;
            const originalApplyHealing = this.battleManager.applyHealing;
            const originalAddStatusEffect = this.battleManager.addStatusEffect;
            const originalRemoveStatusEffect = this.battleManager.removeStatusEffect;
            
            // Store 'this' reference for use in patched methods
            const self = this;
            
            // NOTE: The following methods are now fully handled by BattleFlowController:
            // - startBattle: BattleFlowController directly dispatches BATTLE_STARTED
            // - endBattle: BattleFlowController handles battle end and dispatches BATTLE_ENDED
            // - startNextTurn: BattleFlowController dispatches TURN_STARTED events
            // - executeNextAction: BattleFlowController dispatches CHARACTER_ACTION
            // - finishTurn: BattleFlowController handles turn completion and dispatches TURN_ENDED
            // - checkBattleEnd: BattleFlowController handles victory/defeat conditions
            console.log('[BattleBridge] Core battle flow methods now handled by BattleFlowController');
            
            // Patch endTurn
            if (originalEndTurn) {
                this.battleManager.endTurn = function() {
                    const result = originalEndTurn.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.TURN_ENDED, {
                        currentCharacter: this.currentCharacter,
                        turnNumber: this.turnNumber
                    });
                    return result;
                };
            }
            
            // Patch generateCharacterAction
            if (originalGenerateCharacterAction) {
                this.battleManager.generateCharacterAction = function(character) {
                    const action = originalGenerateCharacterAction.apply(this, arguments);
                    // Removed CHARACTER_ACTION dispatch from here - it should only happen during execution, not generation
                    // This prevents simultaneous auto-attack indicators at battle start
                    return action;
                };
            }
            
            // Patch processAbility
            if (originalProcessAbility) {
                this.battleManager.processAbility = function(character, ability, targets) {
                    // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
                    console.log('[BB processAbility Patch] === ENTERED === Character:', character?.name, 'Ability:', ability?.name);
                    
                    console.log('BattleBridge: processAbility patched method called with:', character?.name, ability?.name);
                    const result = originalProcessAbility.apply(this, arguments);
                    
                    // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
                    console.log('[BB processAbility Patch] >>> DISPATCHING ABILITY_USED. Character:', character.name, 'Ability:', ability.name);
                    
                    self.dispatchEvent(self.eventTypes.ABILITY_USED, {
                        source: character,  // Using 'source' for consistency
                        ability,
                        targets,
                        result
                    });
                    return result;
                };
            }
            
            // Patch applyDamage
            if (originalApplyDamage) {
                this.battleManager.applyDamage = function(target, amount, source) {
                    console.log('BattleBridge: applyDamage patched method called with:', target?.name, amount, source?.name);
                    const result = originalApplyDamage.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.CHARACTER_DAMAGED, {
                        target,
                        amount,
                        source,
                        result,
                        newHealth: target.currentHp
                    });
                    
                    // Check for defeat
                    if (target.currentHp <= 0) {  // Fixed: checking currentHp instead of stats.hp
                        self.dispatchEvent(self.eventTypes.CHARACTER_DEFEATED, {
                            character: target,
                            source
                        });
                    }
                    
                    return result;
                };
            }
            
            // Patch applyHealing
            if (originalApplyHealing) {
                this.battleManager.applyHealing = function(target, amount, source) {
                    console.log('BattleBridge: applyHealing patched method called with:', target?.name, amount, source?.name);
                    const result = originalApplyHealing.apply(this, arguments);
                    self.dispatchEvent(self.eventTypes.CHARACTER_HEALED, {
                        target,
                        amount,
                        source,
                        result,
                        newHealth: target.currentHp
                    });
                    return result;
                };
            }
            
            // Patch addStatusEffect
            if (originalAddStatusEffect) {
                this.battleManager.addStatusEffect = function(character, statusId, sourceOrDuration, durationOrStacks, stacks) {
                    console.log('BattleBridge: addStatusEffect patched method called', character?.name, statusId);
                    
                    let source, duration, stackValue;
                    
                    // Detect old-style parameter format: (character, statusId, duration, value)
                    if (typeof sourceOrDuration === 'number' && arguments.length <= 4) {
                        console.warn(`BattleBridge: Detected old-style addStatusEffect call for ${statusId}.`);
                        console.warn(`BattleBridge: Converting to new format (null source, numeric duration).`);
                        
                        // Convert to new format with null source:
                        source = null; // Use null as source instead of character
                        duration = sourceOrDuration; // Use the number as duration
                        stackValue = durationOrStacks || 1; // Use 4th param as stacks or default to 1
                    } else {
                        // For new style, pass parameters directly
                        source = sourceOrDuration;
                        duration = durationOrStacks;
                        stackValue = stacks;
                    }
                    
                    // Call original with processed parameters - BattleManager handles validation
                    const result = originalAddStatusEffect.call(this, character, statusId, source, duration, stackValue);
                    
                    // Only dispatch event if in phaser UI mode
                    if (this.uiMode === "phaser") {
                        // Get character ID for status effects
                        const characterId = character.uniqueId || character.id;
                        
                        // Get the status effect definition with multiple fallback options
                        let statusDefinition = this.statusEffectDefinitions?.[statusId];
                        
                        // If statusDefinition is undefined, try other sources
                        if (!statusDefinition) {
                            // Try getting from battleManager's statusEffectDefinitions directly
                            if (this.statusEffectDefinitions && this.statusEffectDefinitions[statusId]) {
                                statusDefinition = this.statusEffectDefinitions[statusId];
                            }
                            // Try getting from global battleManager
                            else if (window.battleManager?.statusEffectDefinitions?.[statusId]) {
                                statusDefinition = window.battleManager.statusEffectDefinitions[statusId];
                            }
                            // Try accessing through BattleManager's statusEffects array
                            else if (this.statusEffects && Array.isArray(this.statusEffects) && 
                                    this.statusEffects.find) {
                                const foundEffect = this.statusEffects.find(e => e.id === statusId);
                                if (foundEffect) statusDefinition = foundEffect;
                            }
                            // Try global fallbacks if they exist
                            else if (window.STATUS_EFFECT_FALLBACKS?.[statusId]) {
                                statusDefinition = window.STATUS_EFFECT_FALLBACKS[statusId];
                            }
                            // Create a minimal definition if all else fails
                            else {
                                console.warn(`BattleBridge: Creating minimal fallback for status effect ${statusId}`);
                                statusDefinition = {
                                    id: statusId,
                                    name: statusId.replace('status_', '').replace(/_/g, ' '),
                                    description: `${statusId.replace('status_', '').replace(/_/g, ' ')} effect`,
                                    icon: 'default'
                                };
                            }
                        }
                        
                        // Dispatch event with the parameters as passed to BattleManager
                        self.dispatchEvent(self.eventTypes.STATUS_EFFECT_APPLIED, {
                            character: character,
                            statusId: statusId,
                            duration: duration, // Use the duration that was passed to BattleManager
                            stacks: stackValue, // Use the stacks value that was passed to BattleManager
                            statusDefinition: statusDefinition
                        });
                    }
                    
                    return result;
                };
            }
            
            // Patch removeStatusEffect
            if (originalRemoveStatusEffect) {
                this.battleManager.removeStatusEffect = function(character, statusId) {
                    console.log('BattleBridge: removeStatusEffect patched method called', character?.name, statusId);
                    const result = originalRemoveStatusEffect.apply(this, arguments);
                    
                    // Only dispatch event if in phaser UI mode
                    if (this.uiMode === "phaser") {
                        // Dispatch event with character and status ID
                        self.dispatchEvent(self.eventTypes.STATUS_EFFECT_REMOVED, {
                            character: character,
                            statusId: statusId
                        });
                    }
                    
                    return result;
                };
            }
            
            // Add patch for passive triggers if the method exists
            if (this.battleManager.triggerPassive) {
                const originalTriggerPassive = this.battleManager.triggerPassive;
                this.battleManager.triggerPassive = function(character, triggerType, data) {
                    const result = originalTriggerPassive.apply(this, arguments);
                    if (result && result.triggered) {
                        self.dispatchEvent(self.eventTypes.PASSIVE_TRIGGERED, {
                            character,
                            triggerType,
                            passiveData: data,
                            result
                        });
                    }
                    return result;
                };
            }
            
            // Patch applyActionEffect which is the main function that applies damage/healing
            const originalApplyActionEffect = this.battleManager.applyActionEffect;
            if (originalApplyActionEffect) {
                this.battleManager.applyActionEffect = function(action) {
                    console.log('[BB applyActionEffect Patch] === ENTERED === Action Object:', action ? JSON.parse(JSON.stringify(action)) : 'action is null/undefined', 'Condition (action && action.actor && action.actionType) will be:', !!(action && action.actor && action.actionType));
                    
                    console.log('BattleBridge: applyActionEffect patched method called for:', 
                               action?.actor?.name, 'targeting', action?.target?.name);
                    
                    // Dispatch CHARACTER_ACTION event before applying the effect
                    if (action.actor && action.actionType) {
                        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
                        console.log('[BB applyActionEffect Patch] >>> CONDITION MET - DISPATCHING CHARACTER_ACTION. Actor Name:', 
                          action.actor.name, 'Action Type:', action.actionType);
                        // DIAGNOSTIC: Log exact event structure being dispatched
                        const eventType = self.eventTypes.CHARACTER_ACTION;
                        const eventData = {
                            character: action.actor,
                            action: {
                                type: action.actionType,
                                actionType: action.actionType, // ADDED: Duplicate type as actionType
                                name: action.abilityName || action.actionType,
                                abilityName: action.abilityName, // Include raw ability name
                                target: action.target
                            }
                        };
                        
                        // Log the exact event data we're about to dispatch
                        console.log('[BattleBridge.applyActionEffect Patch] Action object JUST BEFORE dispatching CHARACTER_ACTION:', 
                            JSON.parse(JSON.stringify(eventData.action)));
                        
                        console.log(`BattleBridge: Dispatching CHARACTER_ACTION event for ${action.actor.name} performing ${action.actionType}`, {
                            exactEventType: eventType,
                            eventTypeExists: Object.values(self.eventTypes).includes(eventType),
                            eventDataStructure: Object.keys(eventData),
                            listenerCount: self.eventListeners[eventType]?.length || 0
                        });
                        
                        self.dispatchEvent(eventType, eventData);
                    }
                    
                    // Store pre-action health for calculating actual change
                    const targetPreHealth = action.target ? action.target.currentHp : 0;
                    
                    // Apply the original effect
                    const result = originalApplyActionEffect.apply(this, arguments);
                    
                    // Calculate actual health change for direct targets
                    if (action.target) {
                        const targetPostHealth = action.target.currentHp;
                        const healthChange = targetPostHealth - targetPreHealth;
                        
                        // Dispatch appropriate event based on damage or healing
                        if (healthChange < 0) {
                            // Damage event
                            console.log(`BattleBridge: Dispatching CHARACTER_DAMAGED event for ${action.target.name} with new health ${targetPostHealth}`);
                            self.dispatchEvent(self.eventTypes.CHARACTER_DAMAGED, {
                                character: action.target, // IMPORTANT: Use 'character' instead of 'target' to match event handler
                                target: action.target,    // Keep 'target' for backward compatibility
                                amount: Math.abs(healthChange),
                                source: action.actor,
                                ability: action.ability,
                                newHealth: targetPostHealth
                            });
                        } else if (healthChange > 0) {
                            // Healing event
                            console.log(`BattleBridge: Dispatching CHARACTER_HEALED event for ${action.target.name} with new health ${targetPostHealth}`);
                            self.dispatchEvent(self.eventTypes.CHARACTER_HEALED, {
                                character: action.target, // IMPORTANT: Use 'character' instead of 'target' to match event handler
                                target: action.target,    // Keep 'target' for backward compatibility
                                amount: healthChange,
                                source: action.actor,
                                ability: action.ability,
                                newHealth: targetPostHealth
                            });
                        }
                    }
                    
                    return result;
                };
                console.log('BattleBridge: Successfully patched applyActionEffect method');
            } else {
                console.warn('BattleBridge: Could not patch applyActionEffect, method not found');
            }
            
            console.log('BattleBridge: BattleManager successfully patched');

            // Note: The autoAttack patching has been removed as CHARACTER_ACTION events
            // for both abilities and auto-attacks are now directly dispatched by BattleFlowController
            
            // See note above - All battle flow methods now handled by BattleFlowController
        } catch (error) {
            console.error('BattleBridge: Error patching BattleManager:', error);
        }
        
        return this;
    }
    
    /**
     * Get a reference to the player team
     * @returns {Array} The player team array
     */
    getPlayerTeam() {
        return this.battleManager ? this.battleManager.playerTeam : [];
    }
    
    /**
     * Get a reference to the enemy team
     * @returns {Array} The enemy team array
     */
    getEnemyTeam() {
        return this.battleManager ? this.battleManager.enemyTeam : [];
    }
    
    /**
     * Start the battle
     * This initiates the battle flow in BattleManager
     * @param {Array} playerTeam - Optional player team data
     * @param {Array} enemyTeam - Optional enemy team data
     */
    startBattle(playerTeam, enemyTeam) {
        if (!this.battleManager) {
            console.error('BattleBridge: No BattleManager available to start battle');
            return;
        }
        
        console.log('BattleBridge: Starting battle via BattleManager');
        console.log(`BattleBridge: Using provided teams - Player: ${playerTeam?.length || 0} characters, Enemy: ${enemyTeam?.length || 0} characters`);
        
        try {
            // Track battle state
            this.battlesStarted++;
            
            // Start the battle via BattleManager with team data
            this.battleManager.startBattle(playerTeam, enemyTeam);
            
            // Dispatch UI interaction event
            this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { 
                action: 'start_battle',
                source: 'bridge',
                playerTeamSize: playerTeam?.length || 0,
                enemyTeamSize: enemyTeam?.length || 0
            });
        } catch (error) {
            console.error('BattleBridge: Error starting battle:', error);
        }
    }

    /**
     * Clean up battle state when returning to TeamBuilder
     */
    cleanupBattleState() {
        console.log('BattleBridge: Cleaning up battle state before returning to TeamBuilder');
        
        // Reset battle state properties
        this.battlesStarted = 0;
        
        // Clear event listeners to prevent duplicates in subsequent battles
        Object.values(this.eventTypes).forEach(type => {
            this.eventListeners[type] = [];
        });
        
        console.log('BattleBridge: Battle state cleaned up');
    }

    /**
     * Request a character to take their turn
     * @param {Object} character - The character to act
     */
    requestCharacterAction(character) {
        if (!this.battleManager) return;
        
        this.battleManager.processCharacterTurn(character);
    }
    
    /**
     * Request the battle to pause
     */
    requestPause() {
        if (!this.battleManager) return;
        
        this.battleManager.pauseBattle();
        this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { action: 'pause' });
    }
    
    /**
     * Request the battle to resume
     */
    requestResume() {
        if (!this.battleManager) return;
        
        this.battleManager.resumeBattle();
        this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { action: 'resume' });
    }
    
    /**
     * Set battle speed in the battle manager
     * @param {number} speed - The battle speed multiplier
     * @returns {boolean} - Success status
     */
    setBattleSpeed(speed) {
        if (this.battleManager && this.battleManager.setSpeed) {
            this.battleManager.setSpeed(speed);
            return true;
        } else {
            console.error('BattleBridge: battleManager.setSpeed method not found');
            return false;
        }
    }
    
    /**
     * Request to change battle speed
     * @param {number} speed - The battle speed multiplier
     */
    requestSpeedChange(speed) {
        if (!this.battleManager) return;
        
        // Call the correct method
        const success = this.setBattleSpeed(speed);
        
        // Always dispatch the event, even if method call failed
        this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { 
            action: 'speed_change', 
            speed,
            success
        });
    }
}

// Ensure the class is globally accessible
window.BattleBridge = BattleBridge;

// Log that the class has been defined
console.log('BattleBridge.js: Class definition loaded and exported to window.BattleBridge');

// Create an immediate self-check function that logs whether the class is properly exposed
(function checkBattleBridgeExport() {
    // Delay check slightly to allow for script processing
    setTimeout(function() {
        if (typeof window.BattleBridge === 'function') {
            console.log('BattleBridge.js: Successfully verified global class export');
        } else {
            console.error('BattleBridge.js: Class export failed! window.BattleBridge is not a function');
        }
    }, 0);
})();

===== FILE: BattleBridgeInit.js =====
/**
 * BattleBridgeInit.js
 * Creates and initializes the BattleBridge instance
 * 
 * This script ensures there's a global instance of BattleBridge available
 * for the Battle Scene to use (separate from the BattleBridge class itself).
 * 
 * Version 0.5.1.2d - 2025-05-04
 */

(function() {
    // Create a fallback BattleBridge class if the real one isn't loaded
    function createFallbackBattleBridge() {
        console.warn('BattleBridgeInit: Creating a fallback BattleBridge class because the real one was not found');
        
        // Define a minimal BattleBridge implementation
        class FallbackBattleBridge {
            constructor() {
                this.battleManager = null;
                this.battleScene = null;
                this.eventListeners = {};
                
                // Define all event types to match the real implementation
                this.eventTypes = {
                    BATTLE_INITIALIZED: 'battle_initialized',
                    BATTLE_STARTED: 'battle_started',
                    BATTLE_ENDED: 'battle_ended',
                    TURN_STARTED: 'turn_started',
                    TURN_ENDED: 'turn_ended',
                    CHARACTER_ACTION: 'character_action',
                    CHARACTER_DAMAGED: 'character_damaged',
                    CHARACTER_HEALED: 'character_healed',
                    CHARACTER_DEFEATED: 'character_defeated',
                    STATUS_EFFECT_APPLIED: 'status_effect_applied',
                    STATUS_EFFECT_REMOVED: 'status_effect_removed',
                    ABILITY_USED: 'ability_used',
                    PASSIVE_TRIGGERED: 'passive_triggered',
                    BATTLE_UI_INTERACTION: 'battle_ui_interaction',
                    BATTLE_LOG: 'battle_log'
                };
                
                console.warn('FallbackBattleBridge: Created stub implementation with basic functionality');
            }
            
            initialize(battleManager, battleScene) {
                console.warn('FallbackBattleBridge: initialize called (stub implementation)');
                this.battleManager = battleManager;
                this.battleScene = battleScene;
                this.setupEventListeners();
                return this;
            }
            
            setupEventListeners() {
                Object.values(this.eventTypes).forEach(type => {
                    this.eventListeners[type] = [];
                });
                console.log('FallbackBattleBridge: Event listeners initialized');
            }
            
            addEventListener(eventType, callback) {
                if (!this.eventListeners[eventType]) {
                    this.eventListeners[eventType] = [];
                }
                this.eventListeners[eventType].push(callback);
                return this;
            }
            
            removeEventListener(eventType, callback) {
                if (!this.eventListeners[eventType]) return this;
                
                const index = this.eventListeners[eventType].indexOf(callback);
                if (index !== -1) {
                    this.eventListeners[eventType].splice(index, 1);
                }
                return this;
            }
            
            dispatchEvent(eventType, data) {
                console.log(`FallbackBattleBridge: Dispatching event ${eventType}`, data);
                
                if (!this.eventListeners[eventType]) {
                    return;
                }
                
                const eventData = {
                    ...data,
                    type: eventType,
                    timestamp: Date.now()
                };
                
                try {
                    this.eventListeners[eventType].forEach(callback => {
                        try {
                            callback(eventData);
                        } catch (error) {
                            console.error(`FallbackBattleBridge: Error in event listener for "${eventType}":`, error);
                        }
                    });
                } catch (error) {
                    console.error(`FallbackBattleBridge: Error dispatching event "${eventType}":`, error);
                }
            }
            
            patchBattleManager() {
                console.warn('FallbackBattleBridge: patchBattleManager called (stub implementation)');
                return this;
            }
            
            getPlayerTeam() {
                return this.battleManager ? this.battleManager.playerTeam : [];
            }
            
            getEnemyTeam() {
                return this.battleManager ? this.battleManager.enemyTeam : [];
            }
            
            startBattle(playerTeam, enemyTeam) {
                console.warn('FallbackBattleBridge: startBattle called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.startBattle(playerTeam, enemyTeam);
                }
            }
            
            requestCharacterAction(character) {
                console.warn('FallbackBattleBridge: requestCharacterAction called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.processCharacterTurn(character);
                }
            }
            
            requestPause() {
                console.warn('FallbackBattleBridge: requestPause called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.pauseBattle();
                }
            }
            
            requestResume() {
                console.warn('FallbackBattleBridge: requestResume called (stub implementation)');
                if (this.battleManager) {
                    this.battleManager.resumeBattle();
                }
            }
            
            setBattleSpeed(speed) {
                console.warn('FallbackBattleBridge: setBattleSpeed called (stub implementation)');
                if (this.battleManager && this.battleManager.setSpeed) {
                    this.battleManager.setSpeed(speed);
                    return true;
                }
                return false;
            }
            
            requestSpeedChange(speed) {
                console.warn('FallbackBattleBridge: requestSpeedChange called (stub implementation)');
                const success = this.setBattleSpeed(speed);
                this.dispatchEvent(this.eventTypes.BATTLE_UI_INTERACTION, { 
                    action: 'speed_change', 
                    speed,
                    success
                });
            }
        }
        
        // Register the fallback class globally
        window.BattleBridge = FallbackBattleBridge;
        return FallbackBattleBridge;
    }

    // Create the global accessor function
    window.getBattleBridge = function() {
        // Create instance if it doesn't exist
        if (typeof window.battleBridge === 'undefined' || window.battleBridge === null) {
            initBattleBridge();
        }
        return window.battleBridge;
    };

    // Initialize the battle bridge
    function initBattleBridge() {
        console.log('BattleBridgeInit: Checking for BattleBridge class...');
        
        // Check if the BattleBridge class is available
        let BattleBridgeClass = window.BattleBridge;
        
        // If not, create a fallback implementation
        if (typeof BattleBridgeClass !== 'function') {
            console.warn('BattleBridgeInit: BattleBridge class not found! Creating fallback implementation');
            
            // Try to load the script dynamically if possible
            const scriptElement = document.createElement('script');
            scriptElement.src = 'js/phaser/bridge/BattleBridge.js';
            scriptElement.async = false;
            document.head.appendChild(scriptElement);
            
            // Even if we're loading it, we need a fallback right now
            BattleBridgeClass = createFallbackBattleBridge();
        }
        
        try {
            // Create instance of BattleBridge class
            const battleBridge = new BattleBridgeClass();
            
            // Make it globally available with lowercase 'b' (instance)
            // The class is still available at window.BattleBridge (uppercase 'B')
            window.battleBridge = battleBridge;
            
            // Don't initialize immediately - we'll do this when both BattleManager and BattleScene are available
            // Define function for delayed initialization from BattleScene
            window.initializeBattleBridge = function(battleManager, battleScene) {
                console.log('BattleBridgeInit: Delayed initialization with BattleManager and BattleScene');
            if (typeof window.battleBridge.initialize === 'function') {
                window.battleBridge.initialize(battleManager, battleScene);
                return true;
            }
            return false;
        };
            
            console.log('BattleBridgeInit: BattleBridge instance created and assigned to window.battleBridge');
            
            // Return the instance
            return battleBridge;
        } catch (error) {
            console.error('BattleBridgeInit: Error creating BattleBridge instance:', error);
            
            // Try again with fallback as last resort
            try {
                const fallbackClass = createFallbackBattleBridge();
                const fallbackInstance = new fallbackClass();
                window.battleBridge = fallbackInstance;
                console.warn('BattleBridgeInit: Created fallback instance as emergency recovery');
                return fallbackInstance;
            } catch (fallbackError) {
                console.error('BattleBridgeInit: Even fallback creation failed:', fallbackError);
                return null;
            }
        }
    }

    // Run initialization immediately
    initBattleBridge();
    
    // Create a backup of our key battle bridge globals to prevent overwriting
    // Uses Object.defineProperty to protect our getBattleBridge function
    (function protectBattleBridgeGlobals() {
        // Store backup references
        const battleBridgeClass = window.BattleBridge;
        const battleBridgeInstance = window.battleBridge;
        const battleBridgeAccessor = window.getBattleBridge;
        
        // Make getBattleBridge write-protected
        try {
            Object.defineProperty(window, 'getBattleBridge', {
                enumerable: true,
                configurable: false,  // Cannot be deleted or redefined
                get: function() { return battleBridgeAccessor; }
            });
            console.log('BattleBridgeInit: Protected getBattleBridge function from overwriting');
        } catch(e) {
            console.error('BattleBridgeInit: Could not protect getBattleBridge:', e);
        }
        
        // Create restoration function that can be called later if needed
        window._restoreBattleBridge = function() {
            console.log('BattleBridgeInit: Restoring original BattleBridge components');
            window.BattleBridge = battleBridgeClass;
            window.battleBridge = battleBridgeInstance;
            return true;
        };
    })();
    
    // Also initialize on DOMContentLoaded, as a fallback
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof window.battleBridge === 'undefined' || window.battleBridge === null) {
            console.log('BattleBridgeInit: No bridge found at DOMContentLoaded, initializing now...');
            initBattleBridge();
        }
    });
    
    // Check script loading status and dependencies
    function checkScriptLoadStatus() {
        console.log('BattleBridgeInit: Checking script load status...');
        const scripts = document.querySelectorAll('script');
        const loadedScripts = [];
        
        scripts.forEach(script => {
            if (script.src) {
                const scriptName = script.src.split('/').pop();
                loadedScripts.push(`${scriptName} (${script.async ? 'async' : 'sync'})`);
            }
        });
        
        console.log('Loaded scripts:', loadedScripts.join(', '));
        console.log('BattleBridge class available:', typeof window.BattleBridge === 'function');
        console.log('battleBridge instance available:', typeof window.battleBridge !== 'undefined');
    }
    
    // Run status check after a delay to allow other scripts to load
    setTimeout(checkScriptLoadStatus, 1000);
    
    console.log('BattleBridgeInit: Setup complete. Use window.getBattleBridge() to access the bridge instance.');
})();

===== FILE: BattleLogTester.js =====
/**
 * BattleLogTester.js
 * Utility for testing the Battle Log functionality
 */

// Create a global testing utility
window.testBattleLog = function(message, type = 'info') {
    console.log(`Sending test message to battle log: ${message}`);
    
    if (window.battleBridge) {
        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG, {
            message: message,
            type: type
        });
        return true;
    } else {
        console.error('BattleBridge not available for testing');
        return false;
    }
};

// Create a function to test direct message addition
window.addDirectBattleLogMessage = function(message, type = 'info') {
    console.log(`Adding message directly to battle log: ${message}`);
    
    if (window.battleLogPanel) {
        window.battleLogPanel.addMessage(message, type);
        return true;
    } else {
        console.error('Battle log panel not available for direct message');
        return false;
    }
};

// Create a function to test multiple message types
window.testAllMessageTypes = function() {
    const types = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy'];
    
    types.forEach(type => {
        window.testBattleLog(`Test message with type: ${type}`, type);
    });
    
    return 'All message types tested';
};

console.log('Battle Log testing utilities loaded.');
console.log('Use window.testBattleLog("message", "type") to test via BattleBridge');
console.log('Use window.addDirectBattleLogMessage("message", "type") to test direct addition');
console.log('Use window.testAllMessageTypes() to test all message types');


===== FILE: ActionIndicator.js =====
/**
 * ActionIndicator.js
 * A component for displaying floating action text above characters during battle.
 * Shows what action a character is currently performing (auto attack, abilities, etc.)
 */
class ActionIndicator {
    /**
     * Create a new ActionIndicator
     * @param {Phaser.Scene} scene - The scene this indicator belongs to
     * @param {CharacterSprite} parent - The character sprite this indicator is attached to
     */
    constructor(scene, parent) {
        // DIAGNOSTIC: Check parent character
        console.log(`ActionIndicator constructor called for character: ${parent?.character?.name || 'unknown'}`);

        this.scene = scene;
        this.parent = parent;
        this.text = null;
        this.timeline = null;
        this.isAnimating = false;
        
        this.initialize();
    }
    
    /**
     * Initialize the text object with default styling
     */
    initialize() {
        // Create text with shadow for better readability
        this.text = this.scene.add.text(0, -60, '', {
            fontFamily: 'Arial',
            fontSize: '14px',
            color: '#ffffff',
            align: 'center',
            stroke: '#000000',
            strokeThickness: 3,
            shadow: {
                offsetX: 2,
                offsetY: 2,
                color: '#000000',
                blur: 2,
                stroke: true,
                fill: true
            }
        });
        
        // Set origin to center of text for better positioning
        this.text.setOrigin(0.5, 0.5);
        
        // Start invisible
        this.text.setAlpha(0);
        
        // Add to the parent's container if it exists, otherwise directly to scene
        if (this.parent.container) {
            console.log(`ActionIndicator.initialize: Adding text to parent container for ${this.parent?.character?.name}`);
            this.parent.container.add(this.text);
            
            // Since we're adding to the container, position is relative to container origin (0,0)
            // Default position above the character's head
            this.text.setPosition(0, -60);
        } else {
            console.warn(`ActionIndicator.initialize: No parent container for ${this.parent?.character?.name}`);
            // Position relative to parent manually
            this.updatePosition();
        }
    }
    
    /**
     * Update the indicator position relative to parent
     */
    updatePosition() {
        if (!this.parent || !this.text) return;
        
        // Position above the character's head
        if (this.parent.container) {
            // Position is relative to container
            this.text.setPosition(0, -60);
        } else {
            // Position relative to scene coordinates
            const xPos = this.parent.x || 0;
            const yPos = (this.parent.y || 0) - 60;
            this.text.setPosition(xPos, yPos);
        }
        
        console.log(`ActionIndicator.updatePosition: Updated for ${this.parent?.character?.name}, text position: (${this.text.x}, ${this.text.y}), parent has container: ${this.parent?.container ? 'yes' : 'no'}`);
    }
    
    /**
     * Show action text with animation
     * @param {string} actionText - The text to display
     * @param {object} options - Optional configuration for the animation
     */
    showAction(actionText, options = {}) {
        console.log(`ActionIndicator.showAction: Called with text: '${actionText}' for character: ${this.parent?.character?.name || 'unknown'}. Text position before update: (${this.text?.x}, ${this.text?.y}). Parent container exists: ${this.parent?.container ? 'yes' : 'no'}`);
        
        // Default options
        const config = {
            color: '#ffffff', // default white
            duration: 1500,   // how long to display
            rise: 20,         // how far it rises during animation
            ...options        // override with any provided options
        };
        
        // Cancel any existing animation
        if (this.timeline) {
            this.timeline.stop();
            this.timeline.destroy();
        };
        
        // Update text and color
        this.text.setText(actionText);
        this.text.setColor(config.color);
        
        // Make sure position is correct before animation
        this.updatePosition();
        
        // Log the current position
        console.log(`ActionIndicator.showAction: Text position after update: (${this.text.x}, ${this.text.y}) for character: ${this.parent?.character?.name || 'unknown'}`);
        
        // Store original y position
        const startY = this.text.y;
        
        // Create animation timeline
        this.timeline = this.scene.tweens.createTimeline();
        
        // Add fade in while rising
        this.timeline.add({
            targets: this.text,
            alpha: 1,
            y: startY - (config.rise / 2),
            duration: 300,
            ease: 'Power1'
        });
        
        // Add hold phase
        this.timeline.add({
            targets: this.text,
            alpha: 1,
            duration: config.duration - 600, // Subtract fade in/out time
            hold: config.duration - 600,
            onStart: () => {
                this.isAnimating = true;
            }
        });
        
        // Add fade out while continuing to rise
        this.timeline.add({
            targets: this.text,
            alpha: 0,
            y: startY - config.rise,
            duration: 300,
            ease: 'Power1',
            onComplete: () => {
                this.isAnimating = false;
            }
        });
        
        // Start the animation
        this.timeline.play();
    }
    
    /**
     * Show auto attack action
     */
    showAutoAttack() {
        this.showAction('Auto Attack', {
            color: '#f0f0f0' // Light grey color
        });
    }
    
    /**
     * Show ability action
     * @param {string} abilityName - The name of the ability
     */
    showAbility(abilityName) {
        this.showAction(abilityName, {
            color: '#42f5a7' // Light green color for abilities
        });
    }
    
    /**
     * Show status effect action (like applying a buff/debuff)
     * @param {string} statusName - The name of the status effect
     */
    showStatusEffect(statusName) {
        this.showAction(`Status: ${statusName}`, {
            color: '#f5d142' // Gold color for status effects
        });
    }
    
    /**
     * Hide the action indicator immediately
     */
    hide() {
        if (this.timeline) {
            this.timeline.stop();
            this.timeline.destroy();
            this.timeline = null;
        }
        this.text.setAlpha(0);
        this.isAnimating = false;
    }
    
    /**
     * Cleanup resources
     */
    destroy() {
        this.hide();
        if (this.text) {
            this.text.destroy();
            this.text = null;
        }
        this.parent = null;
        this.scene = null;
    }
}

// Make the class available globally
window.ActionIndicator = ActionIndicator;


===== FILE: BattleControlPanel.js =====
/**
 * BattleControlPanel.js
 * UI component for controlling battle flow in the Phaser Battle Scene
 * 
 * @version 0.5.4.0
 */

class BattleControlPanel extends Phaser.GameObjects.Container {
    constructor(scene, x, y) {
        super(scene, x, y);
        
        // Track panel state
        this.state = {
            battleStarted: false,
            battlePaused: false,
            currentSpeed: 1
        };
        
        // Configuration for tooltip-style panel
        this.config = {
            backgroundColor: 0x111825,  // Dark navy blue background (same as tooltips)
            backgroundAlpha: 0.9,       // Slightly less transparent
            borderColor: 0x3498db,      // Bright blue border (same as tooltips)
            borderWidth: 1,             // Thinner border
            cornerRadius: 6,            // Rounded corners
            textColor: '#ffffff',       // White text
            buttonSpacing: 8,           // Space between buttons
            padding: 10                 // Internal padding
        };
        
        // Create panel components
        this.createPanel();
        
        // Add to scene and make interactive
        scene.add.existing(this);
    }
    
    /**
     * Create the panel background and controls
     */
    createPanel() {
        try {
            // Calculate compact panel size
            const buttonWidth = 60;
            const buttonHeight = 30;
            const width = (buttonWidth * 6) + (this.config.buttonSpacing * 7) + (this.config.padding * 2);
            const height = buttonHeight + (this.config.padding * 2) + 20; // Extra space for title
            
            // Create container for background and border
            this.bgContainer = this.scene.add.container(0, 0);
            this.add(this.bgContainer);
            
            // Create background with gradient fill (like tooltips)
            this.graphics = this.scene.add.graphics();
            
            // Create gradient background
            const bgTopColor = this.config.backgroundColor;
            const bgBottomColor = Phaser.Display.Color.IntegerToRGB(bgTopColor);
            bgBottomColor.r = Math.max(0, bgBottomColor.r - 10);
            bgBottomColor.g = Math.max(0, bgBottomColor.g - 10);
            bgBottomColor.b = Math.max(0, bgBottomColor.b - 10);
            const bgBottomColorInt = Phaser.Display.Color.GetColor(
                bgBottomColor.r, 
                bgBottomColor.g, 
                bgBottomColor.b
            );
            
            // Draw background with subtle gradient
            this.graphics.fillGradientStyle(
                bgTopColor, bgTopColor,  // Top colors
                bgBottomColorInt, bgBottomColorInt,  // Bottom colors
                this.config.backgroundAlpha
            );
            
            // Draw rounded rectangle background (centered at 0,0)
            this.graphics.fillRoundedRect(
                -width/2,
                -height/2,
                width,
                height,
                this.config.cornerRadius
            );
            
            // Draw border
            this.graphics.lineStyle(
                this.config.borderWidth,
                this.config.borderColor,
                1
            );
            this.graphics.strokeRoundedRect(
                -width/2 + this.config.borderWidth/2,
                -height/2 + this.config.borderWidth/2,
                width - this.config.borderWidth,
                height - this.config.borderWidth,
                this.config.cornerRadius
            );
            
            this.bgContainer.add(this.graphics);
            
            // Add panel title (small and at the top)
            this.titleText = this.scene.add.text(
                0, -height/2 + 10, 
                'Battle Controls', 
                { 
                    fontFamily: 'Arial', 
                    fontSize: '12px', 
                    color: this.config.textColor,
                    align: 'center'
                }
            ).setOrigin(0.5, 0.5);
            this.add(this.titleText);
            
            // Calculate button positions
            const startX = -width/2 + this.config.padding + buttonWidth/2;
            const buttonsY = 0;
            
            // Create Start/Pause Battle button as icon button (toggles between states)
            this.startPauseButton = this.createIconButton(
                startX, 
                buttonsY, 
                'â–¶ï¸â¸ï¸', // Play/Pause icons
                () => this.onStartPauseButtonClicked(),
                'Start/Pause Battle'
            );
            
            // Create Speed buttons (1x, 2x, 3x)
            const speeds = [1, 2, 3];
            this.speedButtons = [];
            
            speeds.forEach((speed, index) => {
                const x = startX + (index + 1) * (buttonWidth + this.config.buttonSpacing);
                const button = this.createCompactButton(
                    x,
                    buttonsY,
                    `${speed}x`,
                    () => this.onSpeedButtonClicked(speed)
                );
                
                // Store reference for later use
                this.speedButtons.push(button);
                
                // Highlight 1x speed by default
                if (speed === 1) {
                    this.highlightSpeedButton(button);
                }
            });
            
            // Add a vertical divider after speed controls
            this.addVerticalDivider(startX + 4 * (buttonWidth + this.config.buttonSpacing) - this.config.buttonSpacing/2);
            
            // Add copy log button after divider
            this.copyButton = this.createIconButton(
                startX + 5 * (buttonWidth + this.config.buttonSpacing),
                buttonsY,
                'ðŸ“‹', // Clipboard icon
                () => this.copyBattleLog(),
                'Copy Battle Log'
            );
            
        } catch (error) {
            console.error('Error creating compact battle control panel:', error);
            // Create a minimal fallback panel in case of error
            this.createFallbackPanel();
        }
    }
    
    /**
     * Create a minimal fallback panel in case of error
     */
    createFallbackPanel() {
        // Simple background
        this.graphics = this.scene.add.graphics();
        this.graphics.fillStyle(0x222233, 0.8);
        this.graphics.fillRect(-100, -20, 200, 40);
        this.add(this.graphics);
        
        // Simple start button
        this.startPauseButton = this.scene.add.text(
            0, 0, 
            'Start', 
            { 
                fontFamily: 'Arial', 
                fontSize: '14px', 
                color: '#FFFFFF', 
                backgroundColor: '#225588',
                padding: { x: 8, y: 4 }
            }
        ).setOrigin(0.5, 0.5)
         .setInteractive({ useHandCursor: true })
         .on('pointerdown', () => this.onStartPauseButtonClicked());
        
        this.add(this.startPauseButton);
    }
    
    /**
     * Create a compact button styled like tooltips
     */
    createCompactButton(x, y, text, callback, tooltip = null) {
        // Create a container for the button
        const buttonContainer = this.scene.add.container(x, y);
        
        // Button dimensions
        const buttonWidth = 60;
        const buttonHeight = 30;
        
        // Create button background (rounded rectangle)
        const buttonGraphics = this.scene.add.graphics();
        buttonGraphics.fillStyle(0x225588, 1);
        buttonGraphics.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
        buttonGraphics.lineStyle(1, 0x3498db, 1);
        buttonGraphics.strokeRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
        
        // Create button text
        const buttonText = this.scene.add.text(
            0, 0, 
            text, 
            { 
                fontFamily: 'Arial', 
                fontSize: '12px', 
                color: '#FFFFFF',
                align: 'center'
            }
        ).setOrigin(0.5, 0.5);
        
        // Add components to container
        buttonContainer.add([buttonGraphics, buttonText]);
        
        // Make interactive with hitArea for better touch/click
        const hitArea = new Phaser.Geom.Rectangle(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight);
        buttonGraphics.setInteractive(hitArea, Phaser.Geom.Rectangle.Contains)
            .on('pointerover', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x3daddf, 1);
                buttonGraphics.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonText.setScale(1.05);
            })
            .on('pointerout', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x225588, 1);
                buttonGraphics.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonText.setScale(1);
            })
            .on('pointerdown', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x1a4266, 1);
                buttonGraphics.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonText.setScale(0.95);
                
                // Play button sound if available
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            })
            .on('pointerup', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x3daddf, 1);
                buttonGraphics.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 4);
                buttonText.setScale(1.05);
                callback();
            });
        
        // Add the button container to the panel
        this.add(buttonContainer);
        
        // Store references for highlighting/unhighlighting
        buttonContainer.graphics = buttonGraphics;
        buttonContainer.text = buttonText;
        
        return buttonContainer;
    }
    
    /**
     * Create an icon button with emoji
     */
    createIconButton(x, y, iconText, callback, tooltip = null) {
        // Create a container for the button
        const buttonContainer = this.scene.add.container(x, y);
        
        // Button dimensions - square for icons
        const buttonSize = 36;
        
        // Create button background (rounded rectangle)
        const buttonGraphics = this.scene.add.graphics();
        buttonGraphics.fillStyle(0x225588, 1);
        buttonGraphics.fillRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
        buttonGraphics.lineStyle(1, 0x3498db, 1);
        buttonGraphics.strokeRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
        
        // Create button icon text
        const iconTextObj = this.scene.add.text(
            0, 0, 
            iconText, 
            { 
                fontFamily: 'Arial', 
                fontSize: '20px', 
                color: '#FFFFFF',
                align: 'center'
            }
        ).setOrigin(0.5, 0.5);
        
        // Add components to container
        buttonContainer.add([buttonGraphics, iconTextObj]);
        
        // Add tooltip if provided
        if (tooltip) {
            buttonContainer.tooltip = tooltip;
            
            buttonGraphics.on('pointerover', () => {
                if (this.currentTooltip) {
                    this.currentTooltip.destroy();
                }
                
                this.currentTooltip = this.scene.add.text(
                    buttonContainer.x,
                    buttonContainer.y - 30,
                    tooltip,
                    {
                        fontFamily: 'Arial',
                        fontSize: '12px',
                        color: '#ffffff',
                        backgroundColor: '#000000',
                        padding: { x: 5, y: 3 }
                    }
                ).setOrigin(0.5, 1)
                 .setDepth(1000);
                
                this.scene.add.existing(this.currentTooltip);
            });
            
            buttonGraphics.on('pointerout', () => {
                if (this.currentTooltip) {
                    this.currentTooltip.destroy();
                    this.currentTooltip = null;
                }
            });
        }
        
        // Make interactive with hitArea for better touch/click
        const hitArea = new Phaser.Geom.Rectangle(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize);
        buttonGraphics.setInteractive(hitArea, Phaser.Geom.Rectangle.Contains)
            .on('pointerover', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x3daddf, 1);
                buttonGraphics.fillRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                iconTextObj.setScale(1.05);
            })
            .on('pointerout', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x225588, 1);
                buttonGraphics.fillRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                iconTextObj.setScale(1);
            })
            .on('pointerdown', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x1a4266, 1);
                buttonGraphics.fillRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                iconTextObj.setScale(0.95);
                
                // Play button sound if available
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            })
            .on('pointerup', () => {
                buttonGraphics.clear();
                buttonGraphics.fillStyle(0x3daddf, 1);
                buttonGraphics.fillRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                buttonGraphics.lineStyle(1, 0x3498db, 1);
                buttonGraphics.strokeRoundedRect(-buttonSize/2, -buttonSize/2, buttonSize, buttonSize, 4);
                iconTextObj.setScale(1.05);
                callback();
            });
        
        // Add the button container to the panel
        this.add(buttonContainer);
        
        // Store references for highlighting/unhighlighting
        buttonContainer.graphics = buttonGraphics;
        buttonContainer.icon = iconTextObj;
        
        return buttonContainer;
    }
    
    /**
     * Add a vertical divider line
     */
    addVerticalDivider(x) {
        // Create a subtle vertical line as visual separator
        const divider = this.scene.add.line(x, 0, 0, -15, 0, 15, 0x4dabff, 0.4);
        this.add(divider);
        return divider;
    }
    
    /**
     * Handle Start/Pause button click
     */
    onStartPauseButtonClicked() {
        try {
            // Toggle between start and pause based on current state
            if (!this.state.battleStarted) {
                this.startBattle();
            } else {
                this.togglePause();
            }
        } catch (error) {
            console.error('Error with battle control:', error);
            this.showFloatingMessage('Error controlling battle', 0xff0000);
        }
    }
    
    /**
     * Start the battle
     */
    startBattle() {
        // Use global accessor function to get bridge instance
        const battleBridge = window.getBattleBridge();
        
        // Dispatch appropriate event to bridge
        if (battleBridge) {
            console.log('BattleControlPanel: Start Battle clicked');
            
            // Get the team data from the scene
            const playerTeam = this.scene.playerTeam || [];
            const enemyTeam = this.scene.enemyTeam || [];
            
            console.log(`BattleControlPanel: Using team data from scene - Player: ${playerTeam.length} heroes, Enemy: ${enemyTeam.length} heroes`);
            
            // Send a test message to the battle log to verify working
            battleBridge.dispatchEvent(battleBridge.eventTypes.BATTLE_LOG, {
                message: "Battle starting",
                type: "action"
            });
            
            battleBridge.dispatchEvent(battleBridge.eventTypes.BATTLE_UI_INTERACTION, {
                action: 'start_battle',
                source: 'ui_control',
                playerTeamSize: playerTeam.length,
                enemyTeamSize: enemyTeam.length
            });
            
            // Call start battle method on bridge if it exists, passing team data
            if (typeof battleBridge.startBattle === 'function') {
                // Make deep copies of the team data
                const playerTeamCopy = JSON.parse(JSON.stringify(playerTeam));
                const enemyTeamCopy = JSON.parse(JSON.stringify(enemyTeam));
                
                battleBridge.startBattle(playerTeamCopy, enemyTeamCopy);
            } else {
                // Alternative: call directly on BattleManager
                if (this.scene.battleConfig && this.scene.battleConfig.battleManager) {
                    // Make deep copies of the team data
                    const playerTeamCopy = JSON.parse(JSON.stringify(playerTeam));
                    const enemyTeamCopy = JSON.parse(JSON.stringify(enemyTeam));
                    
                    this.scene.battleConfig.battleManager.startBattle(playerTeamCopy, enemyTeamCopy);
                }
            }
            
            // Update button states
            this.state.battleStarted = true;
            this.startPauseButton.icon.setText('â¸ï¸'); // Pause icon
            
            // Show success message
            this.showFloatingMessage('Battle Started!');
        } else {
            console.error('BattleControlPanel: No battle bridge found');
            this.showFloatingMessage('Error: Battle system not ready', 0xff0000);
        }
    }
    
    /**
     * Toggle battle pause state
     */
    togglePause() {
        // Toggle paused state
        this.state.battlePaused = !this.state.battlePaused;
        
        // Update button icon
        this.startPauseButton.icon.setText(this.state.battlePaused ? 'â–¶ï¸' : 'â¸ï¸'); // Play or Pause icons
        
        // Call appropriate method on bridge
        const battleBridge = window.getBattleBridge();
        if (battleBridge) {
            if (this.state.battlePaused) {
                // Use requestPause method which will call battleManager.pauseBattle()
                battleBridge.requestPause();
                this.showFloatingMessage('Battle Paused');
            } else {
                // Use requestResume method which will call battleManager.resumeBattle()
                battleBridge.requestResume();
                this.showFloatingMessage('Battle Resumed');
            }
        } else if (window.battleManager) {
            // Direct fallback to battleManager if bridge not available
            if (this.state.battlePaused) {
                window.battleManager.pauseBattle();
                this.showFloatingMessage('Battle Paused');
            } else {
                window.battleManager.resumeBattle();
                this.showFloatingMessage('Battle Resumed');
            }
        } else {
            console.warn('No bridge or battleManager available for pause control');
            this.showFloatingMessage('Pause control unavailable', 0xffaa00);
        }
    }
    
    /**
     * Handle Speed button click
     * @param {number} speed - The speed multiplier
     */
    onSpeedButtonClicked(speed) {
        try {
            // Only proceed if battle has started
            if (!this.state.battleStarted) {
                this.showFloatingMessage('Start the battle first!', 0xffff00);
                return;
            }
            
            console.log(`BattleControlPanel: Speed ${speed}x clicked`);
            
            // Update speed state
            this.state.currentSpeed = speed;
            
            // Highlight the selected speed button
            this.speedButtons.forEach(button => {
                if (button.text.text === `${speed}x`) {
                    this.highlightSpeedButton(button);
                } else {
                    this.unhighlightSpeedButton(button);
                }
            });
            
            // Call speed change method on bridge if it exists
            const battleBridge = window.getBattleBridge();
            if (battleBridge) {
                battleBridge.requestSpeedChange(speed);
            }
            
            // Show success message
            this.showFloatingMessage(`Speed: ${speed}x`);
        } catch (error) {
            console.error('Error changing battle speed:', error);
            this.showFloatingMessage('Error changing speed', 0xff0000);
        }
    }
    
    /**
     * Highlight a speed button to show it's active
     * @param {Phaser.GameObjects.Container} button - The button to highlight
     */
    highlightSpeedButton(button) {
        button.graphics.clear();
        button.graphics.fillStyle(0x44aa88, 1);
        button.graphics.fillRoundedRect(-30, -15, 60, 30, 4);
        button.graphics.lineStyle(2, 0x4dffc3, 1);
        button.graphics.strokeRoundedRect(-30, -15, 60, 30, 4);
    }
    
    /**
     * Remove highlight from a speed button
     * @param {Phaser.GameObjects.Container} button - The button to unhighlight
     */
    unhighlightSpeedButton(button) {
        button.graphics.clear();
        button.graphics.fillStyle(0x225588, 1);
        button.graphics.fillRoundedRect(-30, -15, 60, 30, 4);
        button.graphics.lineStyle(1, 0x3498db, 1);
        button.graphics.strokeRoundedRect(-30, -15, 60, 30, 4);
    }
    
    /**
     * Show a floating message above the panel
     * @param {string} message - The message to display
     * @param {number} color - Text color (hex)
     */
    showFloatingMessage(message, color = 0xffffff) {
        const text = this.scene.add.text(
            0, -40, 
            message, 
            { 
                fontFamily: 'Arial', 
                fontSize: '14px', 
                color: `#${color.toString(16).padStart(6, '0')}`,
                stroke: '#000000',
                strokeThickness: 2
            }
        ).setOrigin(0.5, 0.5);
        
        this.add(text);
        
        // Animate the message
        this.scene.tweens.add({
            targets: text,
            y: -60,
            alpha: 0,
            duration: 1200,
            ease: 'Power2',
            onComplete: () => {
                text.destroy();
            }
        });
    }
    
    /**
     * Update the panel state based on battle events
     * @param {object} data - Event data
     */
    onBattleEvent(data) {
        if (!data || !data.type) return;
        
        switch (data.type) {
            case 'battle_started':
                this.state.battleStarted = true;
                this.startPauseButton.icon.setText('â¸ï¸'); // Pause icon
                break;
                
            case 'battle_ended':
                this.state.battleStarted = false;
                this.state.battlePaused = false;
                this.startPauseButton.icon.setText('â–¶ï¸â¸ï¸'); // Play/Pause icons
                // Reset speed to 1x
                this.onSpeedButtonClicked(1);
                break;
        }
    }
    
    /**
     * Copy battle log to clipboard
     */
    copyBattleLog() {
        try {
            // Get the battle log from the scene
            const battleLog = this.scene.battleLog;
            
            if (!battleLog || !battleLog.completeLog || battleLog.completeLog.length === 0) {
                this.showFloatingMessage('No battle log to copy', 0xffaa00);
                return;
            }
            
            // Format log text
            const logText = battleLog.completeLog.map(entry => {
                // Include turn number for context if available
                const turnPrefix = entry.turn > 0 ? `[Turn ${entry.turn}] ` : '';
                return `${turnPrefix}${entry.text}`;
            }).join('\n');
            
            // Copy to clipboard
            this.copyToClipboard(logText);
        } catch (error) {
            console.error('Error copying battle log:', error);
            this.showFloatingMessage('Error copying log', 0xff0000);
        }
    }
    
    /**
     * Copy text to clipboard with fallback
     */
    copyToClipboard(text) {
        // Try using the clipboard API with fallback
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showCopyFeedback(true);
                })
                .catch(err => {
                    console.error('Clipboard API failed:', err);
                    this.fallbackCopy(text);
                });
        } else {
            this.fallbackCopy(text);
        }
    }
    
    /**
     * Fallback copy method using textarea
     */
    fallbackCopy(text) {
        try {
            // Create temporary textarea element
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed'; // Avoid scrolling to bottom
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            // Execute copy command
            const successful = document.execCommand('copy');
            this.showCopyFeedback(successful);
            
            // Clean up
            document.body.removeChild(textArea);
        } catch (err) {
            console.error('Fallback copy failed:', err);
            this.showFloatingMessage('Copy failed', 0xff0000);
        }
    }
    
    /**
     * Show visual feedback when copy succeeds
     */
    showCopyFeedback(success) {
        if (success) {
            // Flash the copy button
            if (this.copyButton && this.copyButton.graphics) {
                // Store original color
                const originalFillColor = this.copyButton.graphics.fillStyle;
                
                // Change to success color
                this.copyButton.graphics.clear();
                this.copyButton.graphics.fillStyle(0x48bb78, 1); // Green success color
                this.copyButton.graphics.fillRoundedRect(-18, -18, 36, 36, 4);
                this.copyButton.graphics.lineStyle(1, 0x3498db, 1);
                this.copyButton.graphics.strokeRoundedRect(-18, -18, 36, 36, 4);
                
                // Show "Copied!" message
                const feedbackText = this.scene.add.text(
                    this.copyButton.x, 
                    this.copyButton.y - 30, 
                    'Copied!', 
                    { 
                        fontFamily: 'Arial', 
                        fontSize: '14px', 
                        color: '#48bb78',
                        stroke: '#000000',
                        strokeThickness: 2,
                    }
                ).setOrigin(0.5, 0.5);
                
                // Add feedback text to the scene directly for proper z-index
                this.scene.add.existing(feedbackText);
                
                // Animate feedback text
                this.scene.tweens.add({
                    targets: feedbackText,
                    y: this.copyButton.y - 40,
                    alpha: 0,
                    duration: 1500,
                    ease: 'Power2',
                    onComplete: () => {
                        feedbackText.destroy();
                    }
                });
                
                // Reset button color after delay
                this.scene.time.delayedCall(1000, () => {
                    this.copyButton.graphics.clear();
                    this.copyButton.graphics.fillStyle(0x225588, 1);
                    this.copyButton.graphics.fillRoundedRect(-18, -18, 36, 36, 4);
                    this.copyButton.graphics.lineStyle(1, 0x3498db, 1);
                    this.copyButton.graphics.strokeRoundedRect(-18, -18, 36, 36, 4);
                });
            }
            
            // Show success message
            this.showFloatingMessage('Battle log copied!', 0x48bb78);
        } else {
            // Show error message
            this.showFloatingMessage('Failed to copy', 0xff0000);
        }
    }
}

// Ensure the class is globally accessible
if (typeof window !== 'undefined') {
    window.BattleControlPanel = BattleControlPanel;
}

===== FILE: BattleLogPanel.js =====
/**
 * BattleLogPanel.js
 * DEPRECATED: This complex panel has been replaced by DirectBattleLog.js
 * @version 0.5.0.10ce
 * @deprecated Use DirectBattleLog instead
 */

// NOTE: This entire file is marked for deletion. It has been replaced by a simpler
// DirectBattleLog implementation that doesn't use the complex panel UI.
// The code is kept for reference but will be removed in a future update.

class BattleLogPanel {
    /**
     * Create a new battle log panel
     * @param {Phaser.Scene} scene - The scene to add this panel to
     * @param {number} x - The x position of the panel
     * @param {number} y - The y position of the panel
     * @param {number} width - The width of the panel
     * @param {number} height - The height of the panel
     * @param {Object} options - Additional options for the panel
     */
    constructor(scene, x, y, width, height, options = {}) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        
        // Default options
        this.options = {
            backgroundColor: 0x222233,
            backgroundAlpha: 0.95, // Further increased opacity
            textColor: '#ffffff',
            fontSize: 16, // Further increased font size
            padding: 12, // Increased padding
            maxMessages: 30, // More messages
            autoScroll: true,
            fontFamily: 'Arial',
            ...options // Override defaults with provided options
        };
        
        // Log options for debugging
        console.log('BattleLogPanel: Initialized with options:', JSON.stringify(this.options));
        
        // Initialize properties
        this.messages = [];
        this.scrollPosition = 0;
        this.isScrolling = false;
        this.isVisible = true;
        this.container = null;
        this.textObjects = [];
        this.messageTypes = {
            default: { color: '#ffffff' },   // White
            info: { color: '#4dabff' },      // Brighter blue
            success: { color: '#5aff5a' },   // Brighter green
            action: { color: '#ffee55' },    // Even brighter yellow
            error: { color: '#ff7777' },     // Even brighter red
            player: { color: '#66bbff' },    // Brighter blue for player
            enemy: { color: '#ff7777' }      // Brighter red for enemy
        };
        
        // Log message types for debugging
        console.log('BattleLogPanel: Message type colors:', JSON.stringify(this.messageTypes));
        
        // Create the UI
        this.create();
        
        // Debug - log panel position and dimensions
        console.log('BattleLogPanel: Created at position:', this.x, this.y, 'with size:', this.width, this.height);
        
        // Set up a connection to BattleBridge if possible
        this.connectToBattleBridge();
    }
    
    /**
     * Create the battle log panel UI
     */
    create() {
        // Create container
        this.container = this.scene.add.container(this.x, this.y);
        
        // Background
        this.background = this.scene.add.rectangle(
            0,
            0,
            this.width,
            this.height,
            this.options.backgroundColor,
            this.options.backgroundAlpha
        ).setOrigin(0.5);
        
        // Add border with more contrast
        this.border = this.scene.add.graphics();
        this.border.lineStyle(3, 0x4488ff, 1); // Thicker, blue border
        this.border.strokeRect(
            -this.width/2,
            -this.height/2,
            this.width, 
            this.height
        );
        
        // Create panel title
        this.titleBar = this.scene.add.rectangle(
            0,
            -this.height/2 + 15,
            this.width - 20,
            30,
            0x3366aa, // Brighter blue
            0.95 // More opaque
        ).setOrigin(0.5);
        
        this.titleText = this.scene.add.text(
            0,
            -this.height/2 + 15,
            'Battle Log',
            {
                fontFamily: this.options.fontFamily,
                fontSize: this.options.fontSize + 3, // Slightly larger
                color: '#ffffff',
                align: 'center',
                fontStyle: 'bold', // Bold text
                stroke: '#000000', // Black stroke
                strokeThickness: 2 // Thicker stroke
            }
        ).setOrigin(0.5);
        
        // Create scroll buttons
        this.createScrollButtons();
        
        // Add mask for text clipping
        const maskGraphics = this.scene.add.graphics();
        maskGraphics.fillStyle(0xffffff);
        maskGraphics.fillRect(
            this.x - this.width/2 + this.options.padding, 
            this.y - this.height/2 + 40, // Below title
            this.width - this.options.padding * 2,
            this.height - 50 // Leave space for title and controls
        );
        
        this.textMask = maskGraphics.createGeometryMask();
        
        // Create text container
        this.textContainer = this.scene.add.container(0, 0);
        this.textContainer.setMask(this.textMask);
        
        // Debug - Add visual marker for the text container origin
        const originMarker = this.scene.add.rectangle(0, 0, 10, 10, 0xff0000);
        this.textContainer.add(originMarker);
        
        // Debug - Log text container info
        console.log('BattleLogPanel: Text container created at:', this.textContainer.x, this.textContainer.y);
        // Safely log mask info without trying to access geometryMask.getBounds
        console.log('BattleLogPanel: Text mask created with parent coordinates:', 
            this.x - this.width/2 + this.options.padding, 
            this.y - this.height/2 + 40);
        
        // Debug - Add border around text area
        const textAreaBorder = this.scene.add.graphics();
        textAreaBorder.lineStyle(3, 0x00ff00, 1); // Bright green border
        textAreaBorder.strokeRect(
            -this.width/2 + this.options.padding,
            -this.height/2 + 40,
            this.width - this.options.padding * 2,
            this.height - 50
        );
        
        // Add all components to main container
        this.container.add([
            this.background,
            this.border,
            this.titleBar,
            this.titleText,
            this.textContainer,
            textAreaBorder, // Add debug border
            this.upButton,
            this.downButton,
            this.scrollTextBackground,
            this.scrollText,
            this.clearButton
        ]);
        
        // Initial state
        this.updateButtonStates();
        this.addMessage('Battle log initialized successfully', 'success');
    }
    
    /**
     * Create scroll buttons and controls
     */
    createScrollButtons() {
        const buttonStyle = {
            fontFamily: this.options.fontFamily,
            fontSize: this.options.fontSize + 4,
            color: '#ffffff',
            backgroundColor: '#444466',
            padding: { x: 10, y: 5 }
        };
        
        // Up button (at the top right)
        this.upButton = this.scene.add.text(
            this.width/2 - 30,
            -this.height/2 + 15,
            'â–²',
            buttonStyle
        ).setOrigin(0.5)
        .setInteractive({ useHandCursor: true })
        .on('pointerdown', () => this.scrollUp())
        .on('pointerover', () => this.upButton.setStyle({ backgroundColor: '#666688' }))
        .on('pointerout', () => this.upButton.setStyle({ backgroundColor: '#444466' }));
        
        // Down button (next to up button)
        this.downButton = this.scene.add.text(
            this.width/2 - 10,
            -this.height/2 + 15,
            'â–¼',
            buttonStyle
        ).setOrigin(0.5)
        .setInteractive({ useHandCursor: true })
        .on('pointerdown', () => this.scrollDown())
        .on('pointerover', () => this.downButton.setStyle({ backgroundColor: '#666688' }))
        .on('pointerout', () => this.downButton.setStyle({ backgroundColor: '#444466' }));
        
        // Scroll status text
        this.scrollTextBackground = this.scene.add.rectangle(
            -this.width/2 + 60,
            -this.height/2 + 15,
            100,
            24,
            0x333344,
            0.7
        ).setOrigin(0.5);
        
        this.scrollText = this.scene.add.text(
            -this.width/2 + 60,
            -this.height/2 + 15,
            'Auto-scroll: On',
            {
                fontFamily: this.options.fontFamily,
                fontSize: this.options.fontSize - 2,
                color: '#ffffff',
                align: 'center'
            }
        ).setOrigin(0.5);
        
        // Clear log button
        this.clearButton = this.scene.add.text(
            -this.width/2 + 140,
            -this.height/2 + 15,
            'Clear',
            buttonStyle
        ).setOrigin(0.5)
        .setInteractive({ useHandCursor: true })
        .on('pointerdown', () => this.clearLog())
        .on('pointerover', () => this.clearButton.setStyle({ backgroundColor: '#666688' }))
        .on('pointerout', () => this.clearButton.setStyle({ backgroundColor: '#444466' }));
    }
    
    /**
     * Connect to BattleBridge to receive events
     */
    connectToBattleBridge() {
        // Check if BattleBridge exists
        if (this.scene.battleBridge) {
            console.log('BattleLogPanel: Connecting to BattleBridge');
            
            // Set up event listeners for battle events
            const bridge = this.scene.battleBridge;
            
            // Listen for turn started
            bridge.addEventListener(bridge.eventTypes.TURN_STARTED, (data) => {
                try {
                    console.log('BattleLogPanel: TURN_STARTED event received', data);
                    this.addMessage(`Turn ${data.turnNumber}: ${data.currentCharacter.name}'s turn`, 'info');
                } catch (error) {
                    console.error('Error handling TURN_STARTED event:', error);
                }
            });
            
            // Listen for abilities
            bridge.addEventListener(bridge.eventTypes.ABILITY_USED, (data) => {
                try {
                    console.log('BattleLogPanel: ABILITY_USED event received', data);
                    const team = data.source.team === 'player' ? 'player' : 'enemy';
                    this.addMessage(`${data.source.name} uses ${data.ability.name}`, team);
                } catch (error) {
                    console.error('Error handling ABILITY_USED event:', error);
                }
            });
            
            // Listen for damage
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DAMAGED, (data) => {
                try {
                    console.log('BattleLogPanel: CHARACTER_DAMAGED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    this.addMessage(`${data.target.name} takes ${data.amount} damage (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                } catch (error) {
                    console.error('Error handling CHARACTER_DAMAGED event:', error);
                }
            });
            
            // Listen for healing
            bridge.addEventListener(bridge.eventTypes.CHARACTER_HEALED, (data) => {
                try {
                    console.log('BattleLogPanel: CHARACTER_HEALED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    this.addMessage(`${data.target.name} is healed for ${data.amount} HP (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                } catch (error) {
                    console.error('Error handling CHARACTER_HEALED event:', error);
                }
            });
            
            // Listen for status effects
            bridge.addEventListener(bridge.eventTypes.STATUS_EFFECT_APPLIED, (data) => {
                try {
                    // Defensive check for data structure
                    if (!data || !data.target) {
                        console.warn('Invalid data for STATUS_EFFECT_APPLIED event', data);
                        return;
                    }
                    
                    // Get team for coloring
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Get effect information - need defensive access
                    let effectName = 'status effect';
                    
                    // Try to get the status effect name from various possible properties
                    if (data.statusEffect && data.statusEffect.name) {
                        effectName = data.statusEffect.name;
                    } else if (data.effect && data.effect.name) {
                        effectName = data.effect.name;
                    } else if (data.effect && data.effect.definitionId) {
                        effectName = data.effect.definitionId;
                    } else if (data.effectId) {
                        effectName = data.effectId;
                    }
                    
                    // Make effect name more readable by removing prefix and capitalizing
                    if (effectName.startsWith('status_')) {
                        effectName = effectName.replace('status_', '');
                    }
                    effectName = effectName.charAt(0).toUpperCase() + effectName.slice(1);
                    
                    this.addMessage(`${data.target.name} is affected by ${effectName}`, team);
                } catch (error) {
                    console.warn('Error handling STATUS_EFFECT_APPLIED event:', error);
                    // Try a more basic message as fallback
                    if (data && data.target) {
                        this.addMessage(`${data.target.name} gained a status effect`, 'info');
                    }
                }
            });
            
            // Listen for defeats
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DEFEATED, (data) => {
                const team = data.character.team === 'player' ? 'player' : 'enemy';
                this.addMessage(`${data.character.name} is defeated!`, team === 'player' ? 'error' : 'success');
            });
            
            // Listen for battle end
            bridge.addEventListener(bridge.eventTypes.BATTLE_ENDED, (data) => {
                let message = '';
                let type = 'info';
                
                switch (data.winner) {
                    case 'player':
                        message = 'Victory! Your team has won the battle!';
                        type = 'success';
                        break;
                    case 'enemy':
                        message = 'Defeat! Your team has lost the battle.';
                        type = 'error';
                        break;
                    default:
                        message = 'The battle ended in a draw.';
                        type = 'info';
                }
                
                this.addMessage(message, type);
            });
            
            // Listen for the battle log events directly from BattleManager
            bridge.addEventListener(bridge.eventTypes.BATTLE_LOG, (data) => {
                try {
                    console.log('BattleLogPanel received BATTLE_LOG event:', data);
                    if (!data || !data.message) {
                        console.warn('BattleLogPanel: BATTLE_LOG event missing message data', data);
                        return;
                    }
                    this.addMessage(data.message, data.type || 'default');
                    console.log('BattleLogPanel: Added message to log:', data.message);
                } catch (error) {
                    console.warn('Error handling BATTLE_LOG event:', error);
                }
            });
            
            // Add a test message to verify panel is working properly
            this.addMessage('Battle log panel connected to battle events', 'success');
            this.addMessage('Ready for battle control input', 'info');
            this.addMessage('Test message from BattleScene via BattleBridge', 'info');
            
            console.log('BattleLogPanel: Connected to BattleBridge successfully');
        } else {
            console.warn('BattleLogPanel: BattleBridge not found, will not receive battle events');
        }
    }
    
    /**
     * Add a message to the battle log
     * @param {string} message - The message to add
     * @param {string} type - The type of message (default, info, success, error, action)
     */
    addMessage(message, type = 'default') {
        // Create timestamp
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Add message to array
        this.messages.push({
            text: message,
            type: type,
            timestamp: timestamp
        });
        
        // Limit message count
        if (this.messages.length > this.options.maxMessages) {
            this.messages.shift(); // Remove oldest message
        }
        
        // Render messages
        this.renderMessages();
        
        // Auto-scroll if enabled
        if (this.options.autoScroll) {
            this.scrollToBottom();
        }
    }
    
    /**
     * Render messages in the panel
     * @version 0.5.0.11 - Fixed text boundary containment
     */
    renderMessages() {
        // Clear existing text objects
        this.textObjects.forEach(obj => obj.destroy());
        this.textObjects = [];
        
        // Clear text container contents
        this.textContainer.removeAll(true);
        
        // Calculate visible range based on scroll position
        const startIndex = Math.max(0, this.messages.length - this.options.maxMessages - this.scrollPosition);
        const visibleMessages = this.messages.slice(startIndex, startIndex + this.options.maxMessages);
        
        // Calculate available width for text (accounting for padding)
        const availableWidth = this.width - (this.options.padding * 2) - 10;
        
        console.log(`Text container available width: ${availableWidth}px`);
        
        // Create text objects for each visible message
        visibleMessages.forEach((message, index) => {
            // Get color for message type
            const color = this.messageTypes[message.type]?.color || this.messageTypes.default.color;
            
            // Calculate relative Y position within container
            const yPos = index * (this.options.fontSize + 6);
            
            const textStyle = {
                fontFamily: this.options.fontFamily,
                fontSize: this.options.fontSize,
                color: color,
                wordWrap: { 
                    width: availableWidth,
                    useAdvancedWrap: true  // More accurate wrapping
                },
                stroke: '#000000',
                strokeThickness: 2,
                shadow: {
                    offsetX: 2,
                    offsetY: 2,
                    color: '#000000',
                    blur: 2,
                    stroke: true,
                    fill: true
                }
            };
            
            // Log text creation for debugging
            console.log(`Creating message ${index} at container position (${this.options.padding}, ${yPos})`);
            
            // Create message text - using CONTAINER-RELATIVE positioning
            const text = this.scene.add.text(
                this.options.padding,  // Relative X position within container
                yPos,                  // Relative Y position within container
                `[${message.timestamp}] ${message.text}`,
                textStyle
            );
            
            // Ensure text uses top-left origin
            text.setOrigin(0, 0);
            
            // Add bold for important messages
            if (message.type === 'action' || message.type === 'error' || message.type === 'success') {
                text.setFontStyle('bold');
                text.setStroke('#000000', 3);
            }
            
            // Add to text container
            this.textContainer.add(text);
            
            // Also track in our array for clean-up
            this.textObjects.push(text);
            
            console.log(`Message ${index} added to container, width=${text.width}px`);
        });
        
        // Position the textContainer appropriately within the panel
        this.textContainer.setPosition(-this.width/2 + this.options.padding, -this.height/2 + 40);
        
        // Update button states
        this.updateButtonStates();
    }
    
    /**
     * Scroll the log up
     */
    scrollUp() {
        if (this.scrollPosition < this.messages.length - this.options.maxMessages) {
            this.scrollPosition++;
            this.options.autoScroll = false; // Disable auto-scroll when manually scrolling
            this.updateScrollText();
            this.renderMessages();
        }
    }
    
    /**
     * Scroll the log down
     */
    scrollDown() {
        if (this.scrollPosition > 0) {
            this.scrollPosition--;
            this.renderMessages();
        } else {
            // If already at bottom, enable auto-scroll
            this.options.autoScroll = true;
            this.updateScrollText();
        }
    }
    
    /**
     * Scroll to the bottom of the log
     */
    scrollToBottom() {
        this.scrollPosition = 0;
        this.renderMessages();
    }
    
    /**
     * Toggle auto-scrolling
     */
    toggleAutoScroll() {
        this.options.autoScroll = !this.options.autoScroll;
        
        if (this.options.autoScroll) {
            this.scrollToBottom();
        }
        
        this.updateScrollText();
    }
    
    /**
     * Update the scroll text
     */
    updateScrollText() {
        this.scrollText.setText(`Auto-scroll: ${this.options.autoScroll ? 'On' : 'Off'}`);
    }
    
    /**
     * Clear the log
     */
    clearLog() {
        this.messages = [{
            text: 'Log cleared',
            type: 'info',
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        }];
        
        this.scrollPosition = 0;
        this.renderMessages();
    }
    
    /**
     * Update button states based on scroll position
     */
    updateButtonStates() {
        // Disable up button when at top
        this.upButton.setAlpha(this.scrollPosition < this.messages.length - this.options.maxMessages ? 1 : 0.5);
        
        // Disable down button when at bottom
        this.downButton.setAlpha(this.scrollPosition > 0 ? 1 : 0.5);
    }
    
    /**
     * Set the visibility of the panel
     * @param {boolean} visible - Whether the panel should be visible
     */
    setVisible(visible) {
        this.isVisible = visible;
        this.container.setVisible(visible);
    }
    
    /**
     * Toggle the visibility of the panel
     * @returns {boolean} The new visibility state
     */
    toggle() {
        this.isVisible = !this.isVisible;
        this.container.setVisible(this.isVisible);
        return this.isVisible;
    }
    
    /**
     * Resize the panel
     * @param {number} width - The new width
     * @param {number} height - The new height
     */
    resize(width, height) {
        this.width = width;
        this.height = height;
        
        // Update background
        this.background.width = width;
        this.background.height = height;
        
        // Update border
        this.border.clear();
        this.border.lineStyle(2, 0x444466, 1);
        this.border.strokeRect(
            -width/2,
            -height/2,
            width,
            height
        );
        
        // Update title bar
        this.titleBar.width = width - 20;
        this.titleBar.setPosition(0, -height/2 + 15);
        this.titleText.setPosition(0, -height/2 + 15);
        
        // Update buttons
        this.upButton.setPosition(width/2 - 30, -height/2 + 15);
        this.downButton.setPosition(width/2 - 10, -height/2 + 15);
        this.scrollTextBackground.setPosition(-width/2 + 60, -height/2 + 15);
        this.scrollText.setPosition(-width/2 + 60, -height/2 + 15);
        this.clearButton.setPosition(-width/2 + 140, -height/2 + 15);
        
        // Update mask
        const maskGraphics = this.scene.add.graphics();
        maskGraphics.fillStyle(0xffffff);
        maskGraphics.fillRect(
            this.x - width/2 + this.options.padding,
            this.y - height/2 + 40,
            width - this.options.padding * 2,
            height - 50
        );
        
        this.textMask.destroy();
        this.textMask = maskGraphics.createGeometryMask();
        this.textContainer.setMask(this.textMask);
        
        // Re-render messages
        this.renderMessages();
    }
    
    /**
     * Update method for animation or dynamic content
     * @param {number} time - The current time
     * @param {number} delta - The time since the last update
     */
    update(time, delta) {
        // Intentionally left empty for now
    }
    
    /**
     * Clean up resources used by this component
     */
    /**
     * Utility method to debug text rendering
     * Creates test text with unmissable styling
     */
    createDebugText() {
        try {
            console.log('Creating debug test text...');
            
            // Create a test text directly in the panel
            const testStyle = { 
                font: '24px Arial', 
                fill: '#FF0000',      // Bright red text
                backgroundColor: '#FFFF00',  // Yellow background
                padding: { x: 5, y: 5 }
            };
            
            // Create central test text
            const testX = this.x;
            const testY = this.y;
            const testText = this.scene.add.text(testX, testY, 'TEST TEXT RENDERING', testStyle);
            testText.setOrigin(0.5); // Center it
            testText.setDepth(100);
            
            console.log('Debug test text created at scene coords:', testX, testY);
            
            // Also create text at top-left of white area
            const cornerText = this.scene.add.text(
                this.x - this.width/2 + 20, // Left edge of panel + padding
                this.y - this.height/2 + 40, // Top of content area
                'CORNER TEXT',
                {
                    font: '20px Arial',
                    fill: '#0000FF',      // Blue text
                    backgroundColor: '#00FF00', // Green background
                    padding: { x: 5, y: 5 }
                }
            );
            cornerText.setOrigin(0, 0);
            cornerText.setDepth(100);
            
            console.log('Corner text created at absolute position:', 
                this.x - this.width/2 + 20, 
                this.y - this.height/2 + 40);
                
            return [testText, cornerText];
        } catch(e) {
            console.error("Error creating debug text:", e);
            return null;
        }
    }
    
    destroy() {
        // Remove any event listeners
        if (this.scene.battleBridge) {
            // Optionally remove specific event listeners if needed
        }
        
        // Destroy text objects directly
        this.textObjects.forEach(obj => obj.destroy());
        
        // Destroy mask if it exists
        if (this.textMask) this.textMask.destroy();
        
        // Destroy container and all children
        if (this.container) this.container.destroy();
    }
}

// Make globally accessible
window.BattleLogPanel = BattleLogPanel;


===== FILE: CharacterSprite.js =====
/**
 * CharacterSprite.js
 * Renders a character in the battle scene with appropriate visual elements
 * (Added try...catch blocks for debugging)
 */
class CharacterSprite {
    /**
     * Update the character's health and refresh the health bar
     * @param {number} newHealth - The character's new health value
     * @param {number} maxHealth - The character's maximum health (usually character.stats.hp)
     */
    updateHealth(newHealth, maxHealth) {
        // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
        // TODO: REMOVE or MOVE after bug fix / refactoring
        console.log(`[HEALTH DEBUG] CharacterSprite.updateHealth called for ${this.character?.name}, HP: ${newHealth}/${maxHealth}`);
        // END TEMPORARY DIAGNOSTIC CODE

        console.log(`CharacterSprite.updateHealth: ${this.character?.name} health to ${newHealth}/${maxHealth}`);
        
        try {
            // Update the internal health tracking
            this.currentHealth = newHealth;
            
            // Update the character data's health tracking
            if (this.character) {
                this.character.currentHp = newHealth;
            }
            
            // Show a health change animation
            const healthChange = (this.previousHealth || newHealth) - newHealth;
            const isHealing = healthChange < 0;
            
            // Store current health for future reference
            this.previousHealth = newHealth;
            
            // Show floating text for significant health changes
            if (Math.abs(healthChange) > 0) {
                const textColor = isHealing ? '#00ff00' : '#ff0000';
                const prefix = isHealing ? '+' : '-';
                const text = `${prefix}${Math.abs(healthChange)}`;
                this.showFloatingText(text, { color: textColor, fontSize: 20 });
            }
            
            // Update the visual health bar
            // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
            // TODO: REMOVE or MOVE after bug fix / refactoring
            console.log(`[HEALTH DEBUG] CharacterSprite.updateHealth calling updateHealthBar for ${this.character?.name}`);
            // END TEMPORARY DIAGNOSTIC CODE
            
            this.updateHealthBar(newHealth, maxHealth);
            
            // Play a flash effect for damage on the character image instead of the circle
            if (healthChange > 0 && this.characterImage) {
                this.scene.tweens.add({
                    targets: this.characterImage,
                    alpha: { from: 1.0, to: 0.3 },
                    yoyo: true,
                    duration: 100,
                    repeat: 1,
                    ease: 'Sine.easeOut'
                });
            }
            
            // Play a healing glow effect on the character image
            if (healthChange < 0 && this.characterImage) {
                // Create a temporary glow effect
                const healGlow = this.scene.add.circle(0, 0, 42, 0x00ff00, 0.3);
                this.container.add(healGlow);
                this.container.sendToBack(healGlow);
                
                // Animate and remove the glow
                this.scene.tweens.add({
                    targets: healGlow,
                    alpha: { from: 0.3, to: 0 },
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 400,
                    ease: 'Sine.easeOut',
                    onComplete: () => {
                        healGlow.destroy();
                    }
                });
            }
        } catch (error) {
            console.error(`CharacterSprite.updateHealth: Error updating ${this.character?.name}'s health:`, error);
        }
    }
    
    /**
     * Update the health bar to reflect the current health
     * @param {number} currentHealth - Current health value
     * @param {number} maxHealth - Maximum health value
     */
    updateHealthBar(currentHealth, maxHealth) {
        // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
        // TODO: REMOVE or MOVE after bug fix / refactoring
        console.log(`[HEALTH DEBUG] CharacterSprite.updateHealthBar called for ${this.character?.name}, HP: ${currentHealth}/${maxHealth}`);
        // END TEMPORARY DIAGNOSTIC CODE

        console.log(`CharacterSprite.updateHealthBar: ${this.character?.name} health ${currentHealth}/${maxHealth}`);
        
        try {
            // Skip if health bar components don't exist
            if (!this.healthBar || !this.healthBarBg || !this.hpText) {
                console.warn(`updateHealthBar: Health bar components missing for ${this.character?.name}`);
                return;
            }
            
            // Ensure valid values
            const safeCurrentHealth = Math.max(0, currentHealth || 0);
            const safeMaxHealth = Math.max(1, maxHealth || 1); // Avoid division by zero
            
            // Calculate health percentage (0-1)
            const healthPercent = Math.min(1, safeCurrentHealth / safeMaxHealth);
            
            // Update health bar width
            const healthBarWidth = 80; // Original width
            
            // Use tweens for smooth transition if available
            if (this.scene?.tweens) {
                // Stop any existing health bar tweens to prevent conflicts
                this.scene.tweens.killTweensOf(this.healthBar);
                
                // Create a new tween for smooth transition
                this.scene.tweens.add({
                    targets: this.healthBar,
                    width: healthBarWidth * healthPercent,
                    duration: 300,
                    ease: 'Sine.easeOut',
                    onUpdate: () => {
                        // Update color during tween for smooth color transition
                        const currentWidth = this.healthBar.width;
                        const currentPercent = currentWidth / healthBarWidth;
                        this.healthBar.fillColor = this.getHealthBarColor(currentPercent);
                    }
                });
                
                // Animate health text (shake slightly when taking damage)
                if (this.previousHealthValue && this.previousHealthValue > safeCurrentHealth) {
                    // Character took damage - shake the text
                    this.scene.tweens.add({
                        targets: this.hpText,
                        x: { from: -2, to: 0 },
                        duration: 100,
                        repeat: 1,
                        yoyo: true,
                        ease: 'Sine.easeInOut'
                    });
                } else if (this.previousHealthValue && this.previousHealthValue < safeCurrentHealth) {
                    // Character was healed - subtle bounce
                    this.scene.tweens.add({
                        targets: this.hpText,
                        y: { from: -2, to: 0 },
                        duration: 150,
                        repeat: 0,
                        yoyo: true,
                        ease: 'Bounce'
                    });
                }
            } else {
                // Direct update if tweens not available
                this.healthBar.width = healthBarWidth * healthPercent;
                this.healthBar.fillColor = this.getHealthBarColor(healthPercent);
            }
            
            // Update health text
            this.hpText.setText(`${Math.round(safeCurrentHealth)}/${safeMaxHealth}`);
            
            // Store current health for next comparison
            this.previousHealthValue = safeCurrentHealth;
            
            // Ensure health bar is visible
            if (this.healthBarContainer) {
                this.healthBarContainer.setVisible(true);
            }
            
            console.log(`Health bar updated for ${this.character?.name}: ${healthPercent * 100}% (${safeCurrentHealth}/${safeMaxHealth})`);
            
            // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
            // TODO: REMOVE or MOVE after bug fix / refactoring
            console.log(`[HEALTH DEBUG] CharacterSprite.updateHealthBar finished visual update for ${this.character?.name}: ${healthPercent * 100}% (${safeCurrentHealth}/${safeMaxHealth})`);
            // END TEMPORARY DIAGNOSTIC CODE
        } catch (error) {
            console.error(`Error updating health bar for ${this.character?.name}:`, error);
        }
    }

    /**
     * Create a new character sprite
     * @param {Phaser.Scene} scene - The scene this sprite belongs to
     * @param {Object} character - The character data object
     * @param {Object} config - Configuration options
     */
    constructor(scene, character, config = {}) {
        this.scene = scene;
        this.character = character;
        this.config = Object.assign({
            x: 0,
            y: 0,
            scale: 1,
            showName: true,
            showHealth: true,
            showStatusEffects: true
        }, config);

         // --- Validate Character Data ---
         if (!character) {
              console.error("CharacterSprite Constructor: Invalid character data provided (null or undefined). Cannot create sprite.");
              throw new Error("Invalid character data for CharacterSprite."); // Stop execution here
         }
         if (!character.stats) {
             console.warn(`CharacterSprite Constructor: Character ${character.name || 'Unknown'} missing stats! Using defaults.`);
             character.stats = { hp: 1, // Provide minimal defaults
                                  currentHp: 1 };
         }
         if (typeof character.currentHp === 'undefined') {
            character.currentHp = character.stats.hp;
         }
         if (!character.name) {
             console.warn("CharacterSprite Constructor: Character missing name! Using ID or 'Unknown'.");
             character.name = character.id || 'UnknownCharacter';
         }
         if (!character.type) {
             console.warn(`CharacterSprite Constructor: Character ${character.name} missing type! Using 'neutral'.`);
             character.type = 'neutral';
         }
         // --- End Validation ---

        // Create container for character elements
         try {
             this.container = scene.add.container(this.config.x, this.config.y);
         } catch (error) {
             console.error(`CharacterSprite Constructor (${character.name}): Error creating main container:`, error);
             throw error; // Re-throw critical error
         }


        // --- Create character visual elements with try...catch ---
        try {
             console.log(`CharacterSprite (${character.name}): Creating character image...`);
            this.createCharacterImage();
             console.log(`CharacterSprite (${character.name}): Character image created.`);
        } catch(error) {
            console.error(`CharacterSprite Constructor (${character.name}): Error in createCharacterImage:`, error);
            // Optionally create a fallback visual here if image fails
        }

        if (this.config.showName) {
            try {
                 console.log(`CharacterSprite (${character.name}): Creating name text...`);
                this.createNameText();
                 console.log(`CharacterSprite (${character.name}): Name text created.`);
            } catch(error) {
                console.error(`CharacterSprite Constructor (${character.name}): Error in createNameText:`, error);
            }
        }

        if (this.config.showHealth) {
            try {
                 console.log(`CharacterSprite (${character.name}): Creating health bar...`);
                this.createHealthBar();
                 console.log(`CharacterSprite (${character.name}): Health bar created.`);
            } catch(error) {
                console.error(`CharacterSprite Constructor (${character.name}): Error in createHealthBar:`, error);
            }
        }
        // --- End character elements ---

        // Create action indicator
        try {
            console.log(`CharacterSprite (${character.name}): Creating action indicator...`);
            this.actionIndicator = new ActionIndicator(scene, this);
            console.log(`CharacterSprite (${character.name}): Action indicator created.`);
        } catch(error) {
            console.error(`CharacterSprite Constructor (${character.name}): Error creating action indicator:`, error);
        }
        
        // Create status effect container if enabled
        if (this.config.showStatusEffects) {
            try {
                console.log(`CharacterSprite (${character.name}): Creating status effect container...`);
                this.statusEffectContainer = new StatusEffectContainer(scene, this);
                console.log(`CharacterSprite (${character.name}): Status effect container created.`);
            } catch(error) {
                console.error(`CharacterSprite Constructor (${character.name}): Error creating status effect container:`, error);
            }
        }

        // Make interactive if needed
        if (config.interactive) {
             try {
                 this.makeInteractive();
             } catch(error) {
                  console.error(`CharacterSprite Constructor (${character.name}): Error making sprite interactive:`, error);
             }
        }

        // Store reference for global access (for debugging)
        if (!window.characterSprites) window.characterSprites = {};
        window.characterSprites[character.name] = this; // Note: potential issue if multiple characters have same name
         console.log(`CharacterSprite Constructor (${character.name}): Initialization complete.`);
    }

    /**
     * Show action text above character
     * @param {string} actionText - The action being performed
     */
    showActionText(actionText) {
        console.log(`CS.showActionText: Called for ${this.character?.name} with text: '${actionText}'. this.actionIndicator instance is ${this.actionIndicator ? 'defined' : 'undefined'}.`);
        
        try {
            if (!this.actionIndicator) {
                console.warn(`showActionText (${this.character?.name}): Action indicator not initialized.`);
                return;
            }
            
            if (actionText.toLowerCase().includes('auto attack')) {
                this.actionIndicator.showAutoAttack();
            } else if (actionText.toLowerCase().includes('ability:')) {
                // Extract ability name if in format "Ability: Name"
                const abilityName = actionText.split('Ability:')[1]?.trim() || actionText;
                this.actionIndicator.showAbility(abilityName);
            } else if (actionText.toLowerCase().includes('status:')) {
                // Extract status name if in format "Status: Name"
                const statusName = actionText.split('Status:')[1]?.trim() || actionText;
                this.actionIndicator.showStatusEffect(statusName);
            } else {
                // Display the text directly - likely an ability name without the "Ability:" prefix
                this.actionIndicator.showAbility(actionText);
            }
        } catch (error) {
            console.error(`showActionText (${this.character?.name}): Error showing action text:`, error);
        }
    }

    /**
     * Create the character image using the character art
     */
    createCharacterImage() {
        // Validate character name for path construction
        if (!this.character || !this.character.name) {
            console.error("createCharacterImage: Character name is missing.");
            return; // Cannot proceed without a name
        }

        // Create a type-colored circle as background
        const typeColor = this.getTypeColor(this.character.type);
        try {
            // Create the circle with opacity 0 (invisible) to remove visible background while maintaining functionality
            const circleRadius = 40;
            this.circle = this.scene.add.circle(0, 0, circleRadius, typeColor, 0);
            this.container.add(this.circle);
            // Log that we're using invisible circles per user request
            console.log(`createCharacterImage (${this.character.name}): Using invisible background circle`);
        } catch(error) {
            console.error(`createCharacterImage (${this.character.name}): Error creating background circle:`, error);
            return;
        }
        
        try {
            // Use the texture key that matches how we preloaded it in BattleScene
            const characterKey = `character_${this.character.name}`;
            
            // Check if texture exists (it should if properly preloaded)
            if (this.scene.textures.exists(characterKey)) {
                console.log(`createCharacterImage (${this.character.name}): Using preloaded texture ${characterKey}`);
                
                // Create the image with the proper texture
                this.characterImage = this.scene.add.image(0, 0, characterKey);
                this.container.add(this.characterImage);
                
                // Apply positioning from character data
                this.applyPositioning();
            } else {
                // Fallback if texture wasn't preloaded
                console.warn(`createCharacterImage (${this.character.name}): Texture ${characterKey} not found. Using fallback.`);
                this.createFallbackVisual();
            }
        } catch (error) {
            console.error(`createCharacterImage (${this.character.name}): Error creating image:`, error);
            this.createFallbackVisual();
        }
    }

    /** Helper function to apply positioning to the character image */
    applyPositioning() {
        try {
            if (!this.characterImage || !this.characterImage.scene) {
                console.error(`applyPositioning (${this.character.name}): characterImage or scene missing.`);
                return;
            }

            // Get original texture dimensions
            const textureWidth = this.characterImage.width;
            const textureHeight = this.characterImage.height;
            
            console.log(`applyPositioning (${this.character.name}): Texture dimensions: ${textureWidth}x${textureHeight}`);

            // Apply positioning from character data if available
            if (this.character && this.character.art) {
                const left = parseInt(this.character.art.left) || 0;
                const top = parseInt(this.character.art.top) || 0;
                
                // Apply positioning
                this.characterImage.setPosition(left, top);
                
                // Disable scaling completely for combat-optimized images
                // These are already pre-sized to the optimal dimensions
                console.log(`${this.character.name}: Using combat-optimized image - no scaling needed`);
                this.characterImage.setScale(1.0, 1.0);
                
                // Log final display size
                console.log(`${this.character.name}: Original size maintained at ${textureWidth}x${textureHeight}`);
            } else {
                console.log(`applyPositioning (${this.character.name}): Applying default art positioning.`);
                
                // Apply default positioning
                this.characterImage.setPosition(0, 0);
                
                // Disable scaling completely for combat-optimized images
                // These are already pre-sized to the optimal dimensions
                console.log(`${this.character.name}: Using combat-optimized image (default positioning) - no scaling needed`);
                this.characterImage.setScale(1.0, 1.0);
                
                // Adjust position to center the character art in the circle
                this.characterImage.setPosition(0, -10); // Default vertical offset to center in circle
            }
        } catch(error) {
            console.error(`applyPositioning (${this.character.name}): Error applying position:`, error);
            this.createFallbackVisual();
        }
    }

     /** Helper function to create fallback visual */
     createFallbackVisual() {
          try {
              if (this.characterImage && this.characterImage.active) this.characterImage.destroy(); // Remove potentially broken image
               console.warn(`Creating fallback visual for ${this.character?.name || 'Unknown Character'}`);
               const fallbackText = this.scene.add.text(0, 0, this.character?.name?.charAt(0) || '?', {
                   fontFamily: 'Arial',
                   fontSize: 32,
                   color: '#ffffff'
               }).setOrigin(0.5);
               if(this.container) {
                    this.container.add(fallbackText);
               } else {
                    console.error("Cannot add fallback text, main container missing.");
               }
          } catch (fallbackError) {
               console.error("Error creating fallback visual:", fallbackError);
          }
     }

    /**
     * Create text displaying the character's name
     */
    createNameText() {
         // Validate character data
         if (!this.character || !this.character.name || !this.character.team) {
             console.error("createNameText: Missing character name or team.");
             return;
         }
        // Add team identifier for clarity
        const teamIdentifier = this.character.team === 'player' ? ' (ally)' : ' (enemy)';
        const displayName = this.character.name + teamIdentifier;

         try {
             this.nameText = this.scene.add.text(0, 60, displayName, {
                 fontFamily: 'Arial',
                 fontSize: 14,
                 color: '#ffffff',
                 stroke: '#000000',
                 strokeThickness: 3,
                 align: 'center'
             }).setOrigin(0.5);
             this.container.add(this.nameText);
         } catch(error) {
             console.error(`createNameText (${this.character.name}): Error creating/adding name text:`, error);
         }
    }

    /**
     * Create health bar for the character
     */
    createHealthBar() {
         // Validate character data
         if (!this.character || !this.character.stats || typeof this.character.stats.hp === 'undefined' || typeof this.character.currentHp === 'undefined') {
             console.error(`createHealthBar (${this.character?.name}): Missing required stats (hp, currentHp).`);
             return;
         }
         try {
             // Create health bar container
             this.healthBarContainer = this.scene.add.container(0, 45);

             // Background rectangle
             const healthBarWidth = 80; // Original width
             this.healthBarBg = this.scene.add.rectangle(0, 0, healthBarWidth, 10, 0x000000, 0.7);
             this.healthBarBg.setOrigin(0.5, 0.5);

             // Health bar foreground
              // Ensure maxHP is not zero to avoid division by zero
              const maxHp = Math.max(1, this.character.stats.hp);
             const healthPercent = Math.max(0, Math.min(1, (this.character.currentHp || 0) / maxHp));
             const healthBarColor = this.getHealthBarColor(healthPercent);
             this.healthBar = this.scene.add.rectangle(
                  -healthBarWidth/2, // Start from left edge, adjusted for wider bar
                  0,
                  healthBarWidth * healthPercent,
                  10,
                  healthBarColor,
                  1
             );
              this.healthBar.setOrigin(0, 0.5); // Set origin to left-center for width scaling

             // Add HP text
             this.hpText = this.scene.add.text(0, 0, `${this.character.currentHp || 0}/${maxHp}`, {
                 fontFamily: 'Arial',
                 fontSize: 10,
                 color: '#ffffff',
                 stroke: '#000000',
                 strokeThickness: 2
             }).setOrigin(0.5);

             // Add elements to health bar container
             this.healthBarContainer.add([this.healthBarBg, this.healthBar, this.hpText]);

             // Add health bar container to main container
             this.container.add(this.healthBarContainer);
         } catch(error) {
              console.error(`createHealthBar (${this.character.name}): Error creating/adding health bar elements:`, error);
         }
    }

    /**
     * Make the character sprite interactive
     */
    makeInteractive() {
         // Ensure circle exists before making interactive
         if (!this.circle) {
             console.error(`makeInteractive (${this.character.name}): Background circle does not exist.`);
             return;
         }
         try {
             const hitArea = new Phaser.Geom.Circle(0, 0, 50);
             // Use setSize before setInteractive for non-Graphics objects if needed, but circle should be fine
             this.circle.setInteractive(hitArea, Phaser.Geom.Circle.Contains);

             // Add hover effects
             this.circle.on('pointerover', () => {
                  if (this.container) this.container.setScale(1.1);
                 document.body.style.cursor = 'pointer';
             });

             this.circle.on('pointerout', () => {
                  if (this.container) this.container.setScale(1);
                 document.body.style.cursor = 'default';
             });

             // Add click handler (can be customized later)
             this.circle.on('pointerdown', () => {
                 // Example: Emit a 'character_selected' event
                 this.scene.events.emit('character_selected', this.character);
             });
         } catch (error) {
              console.error(`makeInteractive (${this.character.name}): Error making sprite interactive:`, error);
         }
    }

    /**
     * Get the color for a character based on their type
     * @param {string} type - The character's type
     * @returns {number} - The color as a hex number
     */
    getTypeColor(type) {
        const typeColors = {
            fire: 0xFF4500, water: 0x1E90FF, nature: 0x32CD32,
            electric: 0xFFD700, ice: 0x87CEEB, rock: 0x8B4513,
            air: 0xF0F8FF, light: 0xFFFACD, dark: 0x483D8B,
            metal: 0xC0C0C0, psychic: 0xDA70D6, poison: 0x9370DB,
            physical: 0xBDB76B, arcane: 0x9932CC, mechanical: 0x708090,
            void: 0x191970, crystal: 0xB0E0E6, storm: 0x4682B4,
            ethereal: 0xE6E6FA, blood: 0x8B0000, plague: 0x556B2F,
            gravity: 0x2F4F4F, neutral: 0xAAAAAA // Added neutral for placeholder
        };
        // Fallback for undefined or null type
        const safeType = typeof type === 'string' ? type.toLowerCase() : 'neutral';
        return typeColors[safeType] || 0xCCCCCC; // Gray fallback
    }

    /**
     * Get appropriate color for health bar based on percentage
     * @param {number} percent - Health percentage (0-1)
     * @returns {number} - Color as hex
     */
    getHealthBarColor(percent) {
        if (percent < 0.3) return 0xFF0000; // Red (low health)
        if (percent < 0.6) return 0xFFAA00; // Orange (medium health)
        return 0x00FF00; // Green (high health)
    }

    /**
     * Update the character sprite's state
     */
    update() {
         try { // Added try..catch for safety
             if (this.character && this.character.stats) { // Added check for stats
                 // Update health bar if it exists
                 if (this.healthBar && this.healthBarContainer.visible) { // Check visibility too
                      // Ensure maxHP is valid and non-zero
                      const maxHp = Math.max(1, this.character.stats.hp);
                      // Ensure currentHp is a valid number, default to 0 if not
                      const currentHp = typeof this.character.currentHp === 'number' ? this.character.currentHp : 0;
                     const healthPercent = Math.max(0, Math.min(1, currentHp / maxHp));

                     // Update width smoothly using tweens if available, otherwise set directly
                      const healthBarWidth = 80; // Original width
                      if (this.scene?.tweens) {
                          this.scene.tweens.add({
                              targets: this.healthBar,
                              width: healthBarWidth * healthPercent,
                              duration: 150, // Faster update
                              ease: 'Linear'
                          });
                      } else {
                          this.healthBar.width = healthBarWidth * healthPercent;
                      }

                      // Update position (for left alignment)
                     this.healthBar.x = -healthBarWidth/2; // Adjusted from -40 to match wider bar

                     // Update color based on health percentage
                     this.healthBar.fillColor = this.getHealthBarColor(healthPercent);

                     // Update text
                     if (this.hpText) {
                         this.hpText.setText(`${Math.round(currentHp)}/${maxHp}`);
                     }
                 }
             }
         } catch(error) {
              console.error(`Error updating CharacterSprite (${this.character?.name}):`, error);
         }
    }


    /**
     * Show attack animation
     * @param {CharacterSprite} targetSprite - Target character sprite instance
     * @param {Function} onComplete - Callback when animation completes
     */
    showAttackAnimation(targetSprite, onComplete) {
         // TEMPORARY DIAGNOSTIC - Remove after bug fix
         if (!this.character || !targetSprite || !targetSprite.character) {
             console.error(`[CharacterSprite] showAttackAnimation: Attacker or Target character data missing! Attacker: ${this.character?.name}, TargetSprite valid: ${!!targetSprite}`);
             if (onComplete) onComplete();
             return;
         }
         console.log(`[CharacterSprite.showAttackAnimation] Attacker: ${this.character.name} (Team: ${this.character.team}), Attempting to target: ${targetSprite.character.name} (Team: ${targetSprite.character.team}). Is Ally: ${this.character.team === targetSprite.character.team}`);

         // Prevent friendly fire animation
         if (this.character.team === targetSprite.character.team) {
             console.warn(`[CharacterSprite.showAttackAnimation] FRIENDLY FIRE ATTEMPT HALTED! ${this.character.name} targeting ally ${targetSprite.character.name}.`);
             if (onComplete) onComplete(); // Call onComplete to not stall the battle
             return; // Do not proceed with animation against an ally
         }

         // Validate targetSprite
         if (!targetSprite.container) {
             console.error(`showAttackAnimation (${this.character.name}): Invalid targetSprite container.`);
             if (onComplete) onComplete();
             return;
         }
          // Validate own container and scene
          if (!this.container || !this.scene || !this.scene.tweens) {
               console.error(`showAttackAnimation (${this.character.name}): Missing container or scene/tweens manager.`);
               if (onComplete) onComplete();
               return;
          }

        try { // Added try...catch
            // Show auto attack action indicator
            this.showActionText('Auto Attack');
            
            // --- Get GLOBAL position of the attacker's container ---
            let attackerGlobalPos = new Phaser.Math.Vector2();
            // Ensure 'this.container' is the actual Phaser.GameObjects.Container for this CharacterSprite
            if (!this.container || typeof this.container.getWorldTransformMatrix !== 'function') {
                console.error(`[CS.showAttackAnimation] Attacker ${this.character.name} has no valid .container or getWorldTransformMatrix method!`);
                if (onComplete) onComplete(); return;
            }
            this.container.getWorldTransformMatrix().transformPoint(0, 0, attackerGlobalPos);
            const originalX = attackerGlobalPos.x;
            const originalY = attackerGlobalPos.y;

            // --- Get GLOBAL position of the targetSprite's container ---
            let targetGlobalPos = new Phaser.Math.Vector2();
            // Ensure 'targetSprite.container' is valid
            if (!targetSprite || !targetSprite.container || typeof targetSprite.container.getWorldTransformMatrix !== 'function') {
                console.error(`[CS.showAttackAnimation] Target ${targetSprite?.character?.name || 'Unknown'} has no valid .container or getWorldTransformMatrix method!`);
                if (onComplete) onComplete(); return;
            }
            targetSprite.container.getWorldTransformMatrix().transformPoint(0, 0, targetGlobalPos);
            const targetX_global = targetGlobalPos.x;
            const targetY_global = targetGlobalPos.y;

            console.log(`[CS.showAttackAnimation GLOBAL COORDS] Attacker ${this.character.name}: (${originalX.toFixed(2)}, ${originalY.toFixed(2)})`);
            console.log(`  TargetSprite ${targetSprite.character.name}: (${targetX_global.toFixed(2)}, ${targetY_global.toFixed(2)})`);

            // --- Calculate moveTo using these GLOBAL coordinates ---
            const moveToX = originalX + (targetX_global - originalX) * 0.7;
            const moveToY = originalY + (targetY_global - originalY) * 0.7;

            console.log(`[CS.showAttackAnimation MOVEMENT] Attacker: ${this.character.name} (Start: ${originalX.toFixed(2)}, ${originalY.toFixed(2)}) to TargetSprite: ${targetSprite.character.name} (At: ${targetX_global.toFixed(2)}, ${targetY_global.toFixed(2)}) Calculated Global moveTo: (${moveToX.toFixed(2)}, ${moveToY.toFixed(2)})`);
            
            // Check for any nearby characters that might cause confusion using GLOBAL coordinates
            if (window.characterSprites) {
                let allSpritePositions = [];
                for (const charName in window.characterSprites) {
                    const charSprite = window.characterSprites[charName];
                    if (charSprite && charSprite.container && typeof charSprite.container.getWorldTransformMatrix === 'function') {
                        // Get global position for this character
                        let charGlobalPos = new Phaser.Math.Vector2();
                        charSprite.container.getWorldTransformMatrix().transformPoint(0, 0, charGlobalPos);
                        
                        allSpritePositions.push({
                            name: charName,
                            team: charSprite.character?.team || 'unknown',
                            x: charGlobalPos.x,  // Global X
                            y: charGlobalPos.y,   // Global Y
                            distance: Math.sqrt(
                                Math.pow(moveToX - charGlobalPos.x, 2) +
                                Math.pow(moveToY - charGlobalPos.y, 2)
                            )
                        });
                    }
                }
                
                // Sort by distance to the calculated moveToX/Y coordinates
                allSpritePositions.sort((a, b) => a.distance - b.distance);
                
                // Log the 3 closest characters to where the animation is heading
                console.log(`  Three closest characters to the moveToX/Y point:`);
                for (let i = 0; i < Math.min(3, allSpritePositions.length); i++) {
                    console.log(`    ${allSpritePositions[i].name} (${allSpritePositions[i].team}): (${allSpritePositions[i].x}, ${allSpritePositions[i].y}), distance: ${allSpritePositions[i].distance.toFixed(2)}`);
                }
                
                // Check if closest character might not be the intended target
                if (allSpritePositions.length > 0 && allSpritePositions[0].name !== targetSprite.character.name) {
                    console.warn(`  WARNING: Closest character to moveToX/Y is NOT the intended target!`);
                    console.warn(`  Intended target: ${targetSprite.character.name}, but closest is: ${allSpritePositions[0].name}`);
                    
                    // Also check for characters that might be on the same team as the attacker
                    const sameTeamChars = allSpritePositions.filter(char => char.team === this.character.team);
                    if (sameTeamChars.length > 0 && sameTeamChars[0].distance < 50) { // If an ally is nearby
                        console.warn(`  POTENTIAL FRIENDLY FIRE RISK: Ally ${sameTeamChars[0].name} is very close to attack path!`);
                        console.warn(`  Ally distance: ${sameTeamChars[0].distance.toFixed(2)} (vs target distance: ${allSpritePositions.find(c => c.name === targetSprite.character.name)?.distance.toFixed(2) || 'unknown'})`);
                    }
                }
            }

            // Now, we need to convert our global moveToX/Y coordinates back to the container's local space
            // for the tween to work correctly (since tweens operate in the object's local space)
            let moveToLocal = { x: 0, y: 0 };
            
            // Convert global coordinates to container's local space
            // Note: We need the container's parent to do this properly
            if (this.container.parentContainer) {
                // If the container has a parent, we need to transform the global coordinates to local
                let inverse = this.container.parentContainer.getWorldTransformMatrix().invert();
                moveToLocal = inverse.transformPoint(moveToX, moveToY);
                console.log(`  Converting global moveTo (${moveToX.toFixed(2)}, ${moveToY.toFixed(2)}) to local: (${moveToLocal.x.toFixed(2)}, ${moveToLocal.y.toFixed(2)})`);
            } else {
                // No parent container - coordinates are already in the right space
                moveToLocal.x = moveToX;
                moveToLocal.y = moveToY;
                console.log(`  No parent container - using global coordinates directly: (${moveToLocal.x.toFixed(2)}, ${moveToLocal.y.toFixed(2)})`);
            }
            
            // Get the original local coordinates (current position in container's local space)
            const originalLocalX = this.container.x;
            const originalLocalY = this.container.y;
            console.log(`  Original local position: (${originalLocalX.toFixed(2)}, ${originalLocalY.toFixed(2)})`);

            // Create animation timeline
            const timeline = this.scene.tweens.createTimeline();

            // Add move to target (using calculated local coordinates)
            timeline.add({
                targets: this.container,
                x: moveToLocal.x,
                y: moveToLocal.y,
                duration: 300,
                ease: 'Power2'
            });

            // Add return to original position (using original local coordinates)
            timeline.add({
                targets: this.container,
                x: originalLocalX,
                y: originalLocalY,
                duration: 300,
                ease: 'Power2'
            });

            // Play timeline
            timeline.play();

            // Call complete callback
            if (onComplete) {
                timeline.once('complete', onComplete);
            }
        } catch (error) {
             console.error(`showAttackAnimation (${this.character.name}): Error creating/playing tween:`, error);
             // Ensure callback is still called on error
             if (onComplete) {
                  try { onComplete(); } catch (cbError){ console.error("Error in onComplete callback:", cbError); }
             }
        }
    }


    /**
     * Show a floating text effect above the character
     * @param {string} text - Text to display
     * @param {Object} style - Text style options
     */
    showFloatingText(text, style = {}) {
          // Validate container and scene
          if (!this.container || !this.scene || !this.scene.tweens || !this.scene.add) {
               console.error(`showFloatingText (${this.character.name}): Missing container or scene functionality (tweens/add).`);
               return;
          }
         try { // Added try...catch
            const defaultStyle = {
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3
            };
            const mergedStyle = {...defaultStyle, ...style};

            // Create text
            const floatingText = this.scene.add.text(
                this.container.x,
                this.container.y - 50, // Initial position slightly higher
                text,
                mergedStyle
            ).setOrigin(0.5);

             // Ensure text is added to the correct display list / depth if necessary
             // floatingText.setDepth(100); // Example: Set depth if needed

            // Animate text
            this.scene.tweens.add({
                targets: floatingText,
                y: floatingText.y - 50, // Move further up
                alpha: { from: 1, to: 0 }, // Fade out
                duration: 1500,
                ease: 'Power2',
                onComplete: () => {
                     // Safely destroy text only if it hasn't been destroyed already
                     if (floatingText && floatingText.scene) {
                          floatingText.destroy();
                     }
                }
            });
        } catch (error) {
             console.error(`showFloatingText (${this.character.name}): Error creating/animating floating text:`, error);
        }
    }


    /**
 * Highlight this character as active - MOVED TO TurnIndicator.js
 */
highlight() {
    // Functionality moved to TurnIndicator.js
    console.log(`CharacterSprite highlight for ${this.character?.name} - delegating to TurnIndicator`);
    // TeamContainer will handle the actual highlighting via TurnIndicator
}

    /**
     * Remove highlight effect - MOVED TO TurnIndicator.js
     */
    unhighlight() {
        // Functionality moved to TurnIndicator.js
        // TeamContainer will handle unhighlighting via TurnIndicator
    }

    /**
     * Clean up sprite resources
     */
    destroy() {
         console.log(`CharacterSprite destroy: Cleaning up sprite for ${this.character?.name || 'Unknown'}`);
        // Remove from global reference
        if (window.characterSprites && this.character && this.character.name) {
            // Only delete if it's the same instance (less critical now but good practice)
            if(window.characterSprites[this.character.name] === this) {
                 delete window.characterSprites[this.character.name];
            }
        }

        // Clean up action indicator
        if (this.actionIndicator) {
            try {
                this.actionIndicator.destroy();
                console.log(`CharacterSprite destroy: Action indicator destroyed for ${this.character?.name || 'Unknown'}`);
            } catch (error) {
                console.error(`CharacterSprite destroy: Error destroying action indicator for ${this.character?.name || 'Unknown'}:`, error);
            }
            this.actionIndicator = null;
        }
        
        // Clean up status effect container
        if (this.statusEffectContainer) {
            try {
                this.statusEffectContainer.destroy();
                console.log(`CharacterSprite destroy: Status effect container destroyed for ${this.character?.name || 'Unknown'}`);
            } catch (error) {
                console.error(`CharacterSprite destroy: Error destroying status effect container for ${this.character?.name || 'Unknown'}:`, error);
            }
            this.statusEffectContainer = null;
        }
        
        // Stop any active tweens (highlight tweens moved to TurnIndicator)

        // Clean up and destroy container and its children
         if (this.container) {
             try {
                 this.container.destroy(true); // Pass true to destroy children
                 console.log(`CharacterSprite destroy: Container destroyed for ${this.character?.name || 'Unknown'}`);
             } catch (error) {
                  console.error(`CharacterSprite destroy: Error destroying container for ${this.character?.name || 'Unknown'}:`, error);
             }
             this.container = null; // Nullify reference
         }

         // Nullify other references
         this.scene = null;
         this.character = null;
         this.config = null;
         this.circle = null;
         this.characterImage = null;
         this.nameText = null;
         this.healthBarContainer = null;
         this.healthBar = null;
         this.healthBarBg = null;
         this.hpText = null;
         // Highlight effect references removed (moved to TurnIndicator)
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CharacterSprite;
}

// Make available globally
window.CharacterSprite = CharacterSprite;

===== FILE: DirectBattleLog.js =====
/**
 * DirectBattleLog.js
 * A simplified battle log that displays text directly on screen
 * @version 0.5.0.14
 */
class DirectBattleLog {
    constructor(scene, x, y, width, options = {}) {
        try {
            this.scene = scene;
            this.x = x;
            this.y = y;
            this.width = width;
            this.maxHeight = options.maxHeight || scene.cameras.main.height * 0.5; // Default to half screen height
            
            // Default options
            this.options = {
                fontSize: 16,
                fontFamily: 'Arial',
                maxMessages: 30,
                lineSpacing: 2,
                backgroundColor: 0x000000,
                backgroundAlpha: 0.3,
                padding: 10,
                maxHeight: this.maxHeight, // Use the calculated max height
                ...options
            };
            
            // Store the max height
            this.maxHeight = this.options.maxHeight;
            
            // Message storage
            this.messages = [];
            
            // Complete log history (for copying)
            this.completeLog = [];
            
            // Add message queue properties
            this.messageQueue = [];
            this.isProcessingQueue = false;
            this.messageProcessingSpeed = 200; // Base speed in ms (reduced from 800ms for better responsiveness)
            this.messageProcessingPaused = false;
            
            // Create container for all text
            // Position container at the right edge at Y=350 (aligned with teams)
            this.container = this.scene.add.container(this.x, 350);
            
            // Text message colors
            this.messageTypes = {
                default: { color: '#ffffff' },
                info: { color: '#4dabff' },
                success: { color: '#5aff5a' },
                action: { color: '#ffee55' },
                error: { color: '#ff7777' },
                player: { color: '#66bbff' },
                enemy: { color: '#ff7777' },
                critical: { color: '#ff9900' },
                type: { color: '#66ffcc' }
            };
            
            // Create semi-transparent background
            if (this.options.backgroundColor) {
                this.background = this.scene.add.rectangle(
                    0, 0, 
                    this.width, 10, // Height will be dynamically set
                    this.options.backgroundColor,
                    this.options.backgroundAlpha
                ).setOrigin(0, 0);
                this.container.add(this.background);
            }
            
            // Add control button for pausing message flow
            this.addMessagePauseToggle();
            
            // Set up event connection
            this.connectToBattleBridge();
            
            console.log('DirectBattleLog: Initialized at', this.x, this.y);
        } catch (error) {
            console.error('Error initializing DirectBattleLog:', error);
            // Create a minimal fallback
            this.container = this.scene.add.container(x, y);
            this.messages = [];
            this.messageQueue = [];
            
            // Add simple text to indicate error
            const errorText = this.scene.add.text(
                0, 0, 
                'Battle Log Error - Check Console', 
                { fontSize: '14px', fill: '#ff0000' }
            );
            this.container.add(errorText);
        }
    }
    
    /**
     * Add toggle button for pausing/resuming message flow
     */
    addMessagePauseToggle() {
        try {
            // If we already have a toggle button, remove it first
            if (this.pauseToggle && this.pauseToggle.active) {
                this.pauseToggle.destroy();
            }
            
            // Important: Use local coordinates relative to container
            const toggleButton = this.scene.add.text(
                this.width - 30, 
                10,
                'â¸ï¸',  // Pause icon
                { 
                    fontSize: '18px', 
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    padding: { x: 5, y: 5 }
                }
            )
            .setInteractive({ useHandCursor: true })
            .on('pointerdown', () => {
                try {
                    this.messageProcessingPaused = !this.messageProcessingPaused;
                    toggleButton.setText(this.messageProcessingPaused ? 'â–¶ï¸' : 'â¸ï¸');
                    
                    if (!this.messageProcessingPaused && this.messageQueue.length > 0) {
                        this.processMessageQueue(); // Resume processing
                    }
                } catch (error) {
                    console.error('Error handling toggle button click:', error);
                }
            });
            
            // Store reference to the button object
            this.pauseToggle = toggleButton;
            
            // Add to container safely
            try {
                if (this.container && this.container.add) {
                    this.container.add(this.pauseToggle);
                }
            } catch (addError) {
                console.error('Error adding pause button to container:', addError);
            }
            
            return this.pauseToggle;
        } catch (error) {
            console.error('Error creating pause toggle button:', error);
            return null;
        }
    }
    
    /**
     * Connect to BattleBridge to receive events
     */
    connectToBattleBridge() {
        // Use the global accessor function to get the bridge instance
        this.battleBridge = window.getBattleBridge();
        
        if (this.battleBridge) {
            const bridge = this.battleBridge;
            
            // Add listener specifically for speed changes
            bridge.addEventListener(bridge.eventTypes.BATTLE_UI_INTERACTION, (data) => {
                if (data.action === 'speed_change' && data.speed) {
                    this.syncWithBattleSpeed(data.speed);
                }
            });
            
            // Connect to BATTLE_LOG events
            bridge.addEventListener(bridge.eventTypes.BATTLE_LOG, (data) => {
                try {
                    console.log('DirectBattleLog received BATTLE_LOG event:', data);
                    if (!data || !data.message) {
                        console.warn('DirectBattleLog: BATTLE_LOG event missing message data', data);
                        return;
                    }
                    this.addMessage(data.message, data.type || 'default');
                } catch (error) {
                    console.warn('Error handling BATTLE_LOG event:', error);
                }
            });
            
            // Listen for turn started
            bridge.addEventListener(bridge.eventTypes.TURN_STARTED, (data) => {
                try {
                    console.log('DirectBattleLog: TURN_STARTED event received', data);
                    
                    // Check if currentCharacter exists
                    if (data.currentCharacter && data.currentCharacter.name) {
                        this.addMessage(`Turn ${data.turnNumber}: ${data.currentCharacter.name}'s turn`, 'info');
                    } else {
                        // Fallback message without character name
                        this.addMessage(`Turn ${data.turnNumber || '?'} started`, 'info');
                    }
                } catch (error) {
                    console.error('Error handling TURN_STARTED event:', error);
                    // Safe fallback
                    this.addMessage(`New turn started`, 'info');
                }
            });
            
            // Listen for CHARACTER_ACTION events (newly added)
            bridge.addEventListener(bridge.eventTypes.CHARACTER_ACTION, (data) => {
                try {
                    console.log('DirectBattleLog: CHARACTER_ACTION event received', data);
                    
                    // Skip if missing critical data
                    if (!data.character || !data.action) return;
                    
                    const character = data.character;
                    const action = data.action;
                    const team = character.team === 'player' ? 'player' : 'enemy';
                    
                    // Different handling based on action type
                    if (action.type === 'attack') {
                        // Basic attack message
                        if (action.target) {
                            this.addMessage(`${character.name} attacks ${action.target.name}`, team);
                        }
                    } else if (action.name) {
                        // Ability usage
                        const targetText = action.target ? ` on ${action.target.name}` : '';
                        this.addMessage(`${character.name} uses ${action.name}${targetText}`, team);
                    }
                } catch (error) {
                    console.error('Error handling CHARACTER_ACTION event:', error);
                }
            });
            
            // Listen for abilities
            bridge.addEventListener(bridge.eventTypes.ABILITY_USED, (data) => {
                try {
                    console.log('DirectBattleLog: ABILITY_USED event received', data);
                    const team = data.source.team === 'player' ? 'player' : 'enemy';
                    
                    // Create more detailed message if targets are available
                    let targetText = '';
                    if (data.targets && data.targets.length > 0) {
                        if (data.targets.length === 1) {
                            targetText = ` on ${data.targets[0].name}`;
                        } else {
                            targetText = ` on multiple targets`;
                        }
                    }
                    
                    this.addMessage(`${data.source.name} uses ${data.ability.name}${targetText}`, team);
                } catch (error) {
                    console.error('Error handling ABILITY_USED event:', error);
                }
            });
            
            // Listen for damage
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DAMAGED, (data) => {
                try {
                    console.log('DirectBattleLog: CHARACTER_DAMAGED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Special handling for reflected damage
                    const isReflected = data.result?.damageType === 'reflected';
                    const damageSource = isReflected ? 'reflected damage from' : 'damage';
                    const sourceName = data.source ? ` from ${data.source.name}` : '';
                    
                    if (isReflected) {
                        this.addMessage(`${data.target.name} takes ${data.amount} ${damageSource} ${data.source.name} (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                    } else {
                        this.addMessage(`${data.target.name} takes ${data.amount} ${damageSource}${sourceName} (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                    }
                } catch (error) {
                    console.error('Error handling CHARACTER_DAMAGED event:', error);
                }
            });
            
            // Listen for healing
            bridge.addEventListener(bridge.eventTypes.CHARACTER_HEALED, (data) => {
                try {
                    console.log('DirectBattleLog: CHARACTER_HEALED event received', data);
                    const team = data.target.team === 'player' ? 'player' : 'enemy';
                    
                    // Include source if available
                    const sourceName = data.source ? ` by ${data.source.name}` : '';
                    this.addMessage(`${data.target.name} is healed for ${data.amount} HP${sourceName} (HP: ${data.target.currentHp}/${data.target.stats.hp})`, team);
                } catch (error) {
                    console.error('Error handling CHARACTER_HEALED event:', error);
                }
            });
            
            // Listen for passive triggers (newly added)
            bridge.addEventListener(bridge.eventTypes.PASSIVE_TRIGGERED, (data) => {
                try {
                    console.log('DirectBattleLog: PASSIVE_TRIGGERED event received', data);
                    
                    if (!data.character) return;
                    
                    const team = data.character.team === 'player' ? 'player' : 'enemy';
                    const passiveName = data.result?.message || 'passive ability triggered';
                    
                    this.addMessage(`${data.character.name}'s ${passiveName}`, team);
                } catch (error) {
                    console.error('Error handling PASSIVE_TRIGGERED event:', error);
                }
            });
            
            // Listen for status effects - already implemented
            bridge.addEventListener(bridge.eventTypes.STATUS_EFFECT_APPLIED, (data) => {
                try {
                    console.log('DirectBattleLog received STATUS_EFFECT_APPLIED event:', data);
                    
                    // Validate that essential data exists
                    if (!data || (!data.character && !data.target)) {
                        console.warn('Invalid data for STATUS_EFFECT_APPLIED event', data);
                        return;
                    }
                    
                    // Get character from either property (both are used in different contexts)
                    const character = data.character || data.target;
                    const team = character.team === 'player' ? 'player' : 'enemy';
                    
                    // Get the status effect name from various possible properties
                    let effectName = data.statusId || 'status effect';
                    
                    // Try to get the effect name from statusDefinition if available
                    if (data.statusDefinition) {
                        if (data.statusDefinition.name) {
                            effectName = data.statusDefinition.name;
                        } else if (data.statusDefinition.id) {
                            effectName = data.statusDefinition.id;
                        }
                    } 
                    // Try other potential properties if statusDefinition.name isn't available
                    else if (data.statusEffect && data.statusEffect.name) {
                        effectName = data.statusEffect.name;
                    } else if (data.effect && data.effect.name) {
                        effectName = data.effect.name;
                    }
                    
                    // Format the effect name for better readability
                    if (typeof effectName === 'string') {
                        // Remove status_ prefix if present
                        if (effectName.startsWith('status_')) {
                            effectName = effectName.replace('status_', '');
                        }
                        
                        // Replace underscores with spaces
                        effectName = effectName.replace(/_/g, ' ');
                        
                        // Capitalize first letter
                        if (effectName.length > 0) {
                            effectName = effectName.charAt(0).toUpperCase() + effectName.slice(1);
                        }
                    }
                    
                    // Create and add the message
                    const stacks = data.stacks > 1 ? ` (${data.stacks} stacks)` : '';
                    const duration = data.duration ? ` for ${data.duration} turns` : '';
                    this.addMessage(`${character.name} is affected by ${effectName}${stacks}${duration}`, team);
                } catch (error) {
                    console.warn('Error handling STATUS_EFFECT_APPLIED event:', error);
                    // Try a more basic message as fallback
                    if (data && (data.character || data.target)) {
                        const character = data.character || data.target;
                        this.addMessage(`${character.name} gained a status effect`, 'info');
                    }
                }
            });
            
            // Listen for status effects removed (newly added)
            bridge.addEventListener(bridge.eventTypes.STATUS_EFFECT_REMOVED, (data) => {
                try {
                    console.log('DirectBattleLog received STATUS_EFFECT_REMOVED event:', data);
                    
                    // Validate that essential data exists
                    if (!data || (!data.character && !data.target)) {
                        console.warn('Invalid data for STATUS_EFFECT_REMOVED event', data);
                        return;
                    }
                    
                    // Get character from either property (both are used in different contexts)
                    const character = data.character || data.target;
                    const team = character.team === 'player' ? 'player' : 'enemy';
                    
                    // Get the status effect ID from various possible properties
                    let effectName = data.statusId || 'status effect';
                    
                    // Try to get the effect name from statusDefinition if available
                    if (data.statusDefinition) {
                        if (data.statusDefinition.name) {
                            effectName = data.statusDefinition.name;
                        } else if (data.statusDefinition.id) {
                            effectName = data.statusDefinition.id;
                        }
                    }
                    
                    // Format the effect name for better readability
                    if (typeof effectName === 'string') {
                        // Remove status_ prefix if present
                        if (effectName.startsWith('status_')) {
                            effectName = effectName.replace('status_', '');
                        }
                        
                        // Replace underscores with spaces
                        effectName = effectName.replace(/_/g, ' ');
                        
                        // Capitalize first letter
                        if (effectName.length > 0) {
                            effectName = effectName.charAt(0).toUpperCase() + effectName.slice(1);
                        }
                    }
                    
                    // Create and add the message
                    this.addMessage(`${character.name}'s ${effectName} effect expired`, team);
                } catch (error) {
                    console.error('Error handling STATUS_EFFECT_REMOVED event:', error);
                    // Try a more basic message as fallback
                    if (data && (data.character || data.target)) {
                        const character = data.character || data.target;
                        this.addMessage(`${character.name}'s status effect expired`, 'info');
                    }
                }
            });
            
            // Listen for defeats
            bridge.addEventListener(bridge.eventTypes.CHARACTER_DEFEATED, (data) => {
                const team = data.character.team === 'player' ? 'player' : 'enemy';
                this.addMessage(`${data.character.name} is defeated!`, team === 'player' ? 'error' : 'success');
            });
            
            // Listen for battle end
            bridge.addEventListener(bridge.eventTypes.BATTLE_ENDED, (data) => {
                // TEMPORARY DEBUGGING: Log what the event listener received
                console.log("[DEBUG DirectBattleLog] BATTLE_ENDED event received. data.winner:", data.winner, "Full event data:", data);
                console.trace("[DEBUG DirectBattleLog] BATTLE_ENDED listener stack trace");
                
                let message = '';
                let type = 'info';
                
                switch (data.winner) {
                    case 'player':
                    case 'victory': // Added in case 'victory' is being passed
                        message = 'Victory! Your team has won the battle!';
                        type = 'success';
                        break;
                    case 'enemy':
                    case 'defeat': // Added in case 'defeat' is being passed
                        message = 'Defeat! Your team has lost the battle.';
                        type = 'error';
                        break;
                    default:
                        // TEMPORARY DEBUGGING: Log when we're about to use the draw message
                        console.warn("[DEBUG DirectBattleLog] Using DEFAULT CASE (draw) for data.winner:", data.winner);
                        message = 'The battle ended in a draw.';
                        type = 'info';
                }
                
                // TEMPORARY DEBUGGING: Log the final message that will be added
                console.log("[DEBUG DirectBattleLog] Adding final battle end message:", message);
                
                this.addMessage(message, type);
            });
            
            // Setup direct forward from BattleManager messages via battleBridge
            // This creates a "catch-all" for messages that don't have specific event handlers
            this.setupMessageForwarder();
            
            // Add initialization messages
            this.addMessage('Battle log initialized', 'success');
            this.addMessage('Ready for battle', 'info');
            
            console.log('DirectBattleLog: Connected to BattleBridge successfully');
        } else {
            console.warn('DirectBattleLog: BattleBridge not found, will not receive battle events');
        }
    }
    
    /**
     * Setup forwarding from BattleManager messages to the battle log
     * Note: Disabled in v0.5.24.5 to prevent message duplication.
     * The issue was that this created a circular event dispatch:
     * 1. BattleManager.logMessage already dispatches events
     * 2. BattleLogManager.logMessage also dispatches events
     * 3. This method added a third dispatch of the same event
     */
    setupMessageForwarder() {
        // Skip this setup since we're already receiving events via BattleBridge properly
        console.log('DirectBattleLog: Message forwarding disabled to prevent duplication');
        
        // Original implementation commented out to preserve for reference
        /*
        if (this.scene.battleBridge && this.scene.battleBridge.battleManager) {
            const battleManager = this.scene.battleBridge.battleManager;
            
            // Store original logMessage function
            const originalLogMessage = battleManager.logMessage;
            
            // Replace with a version that also sends events to this log
            battleManager.logMessage = (message, type = 'default') => {
                // Call the original function
                originalLogMessage.call(battleManager, message, type);
                
                // Forward the message to our battle log
                this.scene.battleBridge.dispatchEvent(this.scene.battleBridge.eventTypes.BATTLE_LOG, {
                    message: message,
                    type: type
                });
            };
            
            console.log('DirectBattleLog: Setup message forwarding from BattleManager');
        }
        */
    }
    
    /**
     * Synchronize battle log speed with game speed
     * @param {number} speed - Battle speed multiplier
     */
    syncWithBattleSpeed(speed) {
        // Adjust message processing speed based on battle speed
        // Using a logarithmic scale to make higher speeds less extreme
        const scaleFactor = Math.log10(speed + 1) + 0.5;
        this.messageProcessingSpeed = Math.round(200 / scaleFactor); // Reduced base speed from 800ms to 200ms
        
        console.log(`Battle log speed adjusted: ${speed}x battle speed = ${this.messageProcessingSpeed}ms per message`);
        
        // Handle message backlog detection - more aggressive handling
        if (this.messageQueue.length > 3) { // Reduced threshold from 5 to 3
            const backlogFactor = Math.min(5, this.messageQueue.length / 2); // Increased max factor from 3 to 5, more aggressive scaling
            this.messageProcessingSpeed = Math.max(50, this.messageProcessingSpeed / backlogFactor); // Reduced minimum from 150ms to 50ms
            console.log(`Message backlog detected (${this.messageQueue.length}), adjusted to: ${this.messageProcessingSpeed}ms`);
        }
    }
    
    /**
     * Process message queue
     */
    processMessageQueue() {
        if (this.messageQueue.length === 0 || this.messageProcessingPaused) {
            this.isProcessingQueue = false;
            return;
        }
        
        this.isProcessingQueue = true;
        
        // Process one message
        const message = this.messageQueue.shift();
        this.messages.push(message);
        
        // Limit message count
        if (this.messages.length > this.options.maxMessages) {
            this.messages.shift();
        }
        
        // Update display with animation for the newest message
        this.renderMessages(true);
        
        // Schedule next message with current speed
        this.scene.time.delayedCall(
            this.messageProcessingSpeed, 
            this.processMessageQueue, 
            [], 
            this
        );
    }
    
    /**
     * Add a message to the battle log
     */
    addMessage(message, type = 'default') {
        // Create message object
        const messageObj = {
            text: message,
            type: type,
            turn: this.getCurrentTurn()
        };
        
        // Add to message queue (timestamps removed as requested)
        this.messageQueue.push(messageObj);
        
        // Also add to complete log history for copying
        this.completeLog.push(messageObj);
        
        // Start processing if not already running and not paused
        if (!this.isProcessingQueue && !this.messageProcessingPaused && this.messageQueue.length > 0) {
            this.processMessageQueue();
        }
    }
    
    /**
     * Get the current battle turn number
     */
    getCurrentTurn() {
        if (this.battleBridge && this.battleBridge.battleManager) {
            return this.battleBridge.battleManager.currentTurn || 0;
        } else if (window.battleManager) {
            return window.battleManager.currentTurn || 0;
        }
        return 0;
    }
    
    /**
     * Render all messages
     * @param {boolean} animate - Whether to animate the newest message
     */
    renderMessages(animate = false) {
        // Initialize all variables at function scope level so they're available throughout the method
        // This prevents reference errors when variables are accessed outside their declaration blocks
        let totalHeight = this.options.padding;
        let messagesToShow = [];
        let messageHeights = [];
        let totalHeightNeeded = 0;
        
        try {
            // Store current pause button state and position
            const pauseToggleState = this.messageProcessingPaused;
            const hadPauseToggle = !!this.pauseToggle;
            
            // Clear everything except the pause toggle to avoid issues
            if (this.pauseToggle) {
                // Remove the pause toggle from the container temporarily
                this.container.remove(this.pauseToggle, false); // false = don't destroy
            }
            
            // Now safely clear the container
            this.container.removeAll(true);
            
            // Recreate background if needed
            if (this.options.backgroundColor) {
                this.background = this.scene.add.rectangle(
                    0, 0, 
                    this.width, Math.min(this.maxHeight, 10), // Placeholder height, updated below and limited by maxHeight
                    this.options.backgroundColor,
                    this.options.backgroundAlpha
                ).setOrigin(0, 0);
                this.container.add(this.background);
            }
            
            // Readd the pause toggle if it existed, or create a new one
            if (hadPauseToggle && this.pauseToggle && !this.pauseToggle.destroyed) {
                // Re-add the existing toggle
                this.container.add(this.pauseToggle);
                // Ensure correct state is displayed
                this.pauseToggle.setText(pauseToggleState ? '\u25b6\ufe0f' : '\u23f8\ufe0f');
            } else {
                // Create a new toggle if needed
                this.addMessagePauseToggle();
                if (this.pauseToggle && pauseToggleState) {
                    // Restore previous pause state
                    this.messageProcessingPaused = pauseToggleState;
                    this.pauseToggle.setText('\u25b6\ufe0f');
                }
            }
        } catch (error) {
            console.error('Error in renderMessages preparations:', error);
            // If we encounter an error, try to recover by recreating the toggle
            if (!this.pauseToggle || this.pauseToggle.destroyed) {
                this.addMessagePauseToggle();
            }
        }
        
        try {
            // Track total height for background sizing
            totalHeight = this.options.padding;
            
            // Calculate available height for messages (subtracting top and bottom padding)
            const availableHeight = this.maxHeight - (this.options.padding * 2);
            
            // Reset arrays and counters
            messagesToShow = [];
            messageHeights = [];
            totalHeightNeeded = 0;
            
            // Measure all messages (starting from newest/last)
            for (let i = this.messages.length - 1; i >= 0; i--) {
                const message = this.messages[i];
                
                // Create temporary text to measure height (with proper wrapping)
                const tempText = this.scene.add.text(
                    0, 0,
                    `${message.text}`,
                    {
                        fontFamily: this.options.fontFamily,
                        fontSize: this.options.fontSize,
                        wordWrap: {
                            width: this.width - (this.options.padding * 2),
                            useAdvancedWrap: true
                        }
                    }
                );
                
                // Store the height measurement
                const messageHeight = tempText.height + this.options.lineSpacing;
                tempText.destroy(); // Remove temporary text
                
                // Check if adding this message would exceed available height
                if (totalHeightNeeded + messageHeight <= availableHeight) {
                    messagesToShow.unshift(message); // Add to beginning of array
                    messageHeights.unshift(messageHeight);
                    totalHeightNeeded += messageHeight;
                } else {
                    // No more space for messages
                    break;
                }
            }
        } catch (error) {
            console.error('Error measuring messages:', error);
            // Create empty arrays in case of error
            messagesToShow = [];
            messageHeights = [];
            totalHeightNeeded = 0;
        }
        
        try {
            // Defensive check to ensure messagesToShow is defined
            if (!messagesToShow) messagesToShow = [];
            
            // Reset total height for message positioning
            totalHeight = this.options.padding;
            
            // Now create actual text objects for messages that fit
            messagesToShow.forEach((message, index) => {
                try {
                    // Get color for this message type
                    const color = this.messageTypes[message.type]?.color || this.messageTypes.default.color;
                    
                    // Calculate position
                    const yPos = totalHeight;
                    
                    // Create text style
                    const textStyle = {
                        fontFamily: this.options.fontFamily,
                        fontSize: this.options.fontSize,
                        color: color,
                        wordWrap: {
                            width: this.width - (this.options.padding * 2),
                            useAdvancedWrap: true
                        },
                        stroke: '#000000',
                        strokeThickness: 1
                    };
                    
                    // Create text with timestamp
                    const text = this.scene.add.text(
                        this.options.padding,
                        yPos,
                        `${message.text}`,
                        textStyle
                    );
                    
                    // Add bold for important messages
                    if (message.type === 'action' || message.type === 'error' || message.type === 'success' || message.type === 'critical') {
                        text.setFontStyle('bold');
                    }
                    
                    // Add to container
                    this.container.add(text);
                    
                    // Update total height for next message
                    totalHeight += text.height + this.options.lineSpacing;
                } catch (textError) {
                    console.error('Error creating message text:', textError);
                }
            });
            
            // Update background height - capped at maxHeight
            if (this.background) {
                this.background.height = Math.min(totalHeight + this.options.padding, this.maxHeight);
            }
            
            // Add animation for the most recent message if requested
            if (animate && messagesToShow.length > 0 && this.container) {
                try {
                    // Find the most recent text object (it might not be the last one due to pause button)
                    let lastMessageText = null;
                    for (let i = this.container.length - 1; i >= 0; i--) {
                        const obj = this.container.getAt(i);
                        if (obj && obj.type === 'Text' && obj !== this.pauseToggle) {
                            lastMessageText = obj;
                            break;
                        }
                    }
                    
                    if (lastMessageText) {
                        // Start with larger scale and fade in
                        lastMessageText.setAlpha(0.7).setScale(1.05);
                        
                        // Create animation
                        this.scene.tweens.add({
                            targets: lastMessageText,
                            alpha: 1,
                            scale: 1,
                            duration: 300,
                            ease: 'Sine.easeOut'
                        });
                    }
                } catch (animError) {
                    console.error('Error animating latest message:', animError);
                }
            }
            
            // Make sure pause toggle is at the front
            if (this.pauseToggle && this.container) {
                try {
                    this.container.bringToTop(this.pauseToggle);
                } catch (error) {
                    console.error('Error bringing pause toggle to top:', error);
                }
            }
        } catch (renderError) {
            console.error('Error rendering messages:', renderError);
        }
    }
    
    /**
     * Clear all messages
     */
    clear() {
        this.messages = [];
        this.renderMessages();
    }
    
    /**
     * Destroy this battle log
     */
    destroy() {
        if (this.container) {
            this.container.destroy();
        }
    }
}

// Make globally accessible 
window.DirectBattleLog = DirectBattleLog;

===== FILE: StatusEffectContainer.js =====
/**
 * StatusEffectContainer.js
 * A component to display status effect icons for a character in the battle scene
 * 
 * Version 0.5.3.0 - 2025-05-15
 */

class StatusEffectContainer {
    /**
     * Handle bulk status effects changed event
     * @param {Object} data - Event data containing character and effects array
     */
    handleStatusEffectsChanged(data) {
        // Only process for our parent character
        if (!this.parent || !this.parent.character) return;
        if (!data || !data.character) return;
        
        // Compare character identifiers
        const sameCharacter = 
            // First check unique ID
            (data.character.uniqueId && this.parent.character.uniqueId && 
             data.character.uniqueId === this.parent.character.uniqueId) ||
            // Then check regular ID
            (data.character.id && this.parent.character.id && 
             data.character.id === this.parent.character.id) ||
            // Finally check name as fallback
            (data.character.name === this.parent.character.name && 
             data.character.team === this.parent.character.team);
        
        if (!sameCharacter) return;
        
        console.log(`StatusEffectContainer: Bulk status effects update for ${this.parent.character.name}`);
        
        // Get the array of effects
        const effects = data.effects;
        if (!Array.isArray(effects)) return;
        
        // Clear existing status effects and icons
        this.statusEffects = [];
        this.iconContainers.forEach(container => container.destroy());
        this.iconContainers = [];
        
        // Add each effect
        effects.forEach(effect => {
            // Add to our tracking array
            this.statusEffects.push({
                statusId: effect.id,
                definition: {
                    name: effect.name,
                    description: effect.description,
                    type: effect.effectType
                },
                duration: effect.duration,
                stacks: effect.stacks || 1
            });
            
            // Create and add icon
            this.addIconForEffect(this.statusEffects.length - 1);
        });
        
        // Arrange icons
        this.arrangeIcons();
    }
    
    /**
     * Create a new StatusEffectContainer
     * @param {Phaser.Scene} scene - The Phaser scene this container belongs to
     * @param {CharacterSprite} parent - The parent CharacterSprite this container is attached to
     */
    constructor(scene, parent) {
        this.scene = scene;
        this.parent = parent;
        
        // Configuration settings - adjusted for 32px source images
        this.config = {
            iconSize: 24,         // Display size of each status icon in pixels
            spacing: 4,           // Spacing between icons in pixels
            maxIcons: 6,          // Maximum number of icons to display before showing +N
            backgroundAlpha: 0.5, // Alpha value for icon backgrounds
            yOffset: 20,          // Distance below character to position icons
            fadeSpeed: 200,       // Icon fade in/out speed in ms
            originalIconSize: 32  // Original size of AI icons in pixels
        };
        
        // Create a container for all status effect icons
        this.container = this.scene.add.container(0, this.config.yOffset);
        
        // Set depth to ensure it's above character but below potential tooltips
        this.container.setDepth(this.parent.container.depth + 1);
        
        // Arrays to track status effects and their UI elements
        this.statusEffects = [];   // Status effect data
        this.iconContainers = [];  // Icon visual containers
        
        // Create tooltip (shared across all status effects)
        this.tooltip = new StatusEffectTooltip(scene);
        
        // Initialize the container
        this.initialize();
    }
    
    /**
     * Initialize the StatusEffectContainer
     */
    initialize() {
        // Add container to the parent character
        this.parent.container.add(this.container);
        
        // Position the container at the bottom of the character
        this.updatePosition();
        
        // Set up event listeners for status effects
        this.setupEventListeners();
        
        console.log('StatusEffectContainer: Initialized for character:', this.parent.character.name);
    }
    
    /**
     * Set up event listeners for status effect events
     */
    setupEventListeners() {
        // Get the battle bridge instance
        const bridge = window.battleBridge || (window.getBattleBridge ? window.getBattleBridge() : null);
        
        if (!bridge) {
            console.error('StatusEffectContainer: BattleBridge not available');
            return;
        }
        
        // Listen for status effect applied event
        bridge.addEventListener(
            bridge.eventTypes.STATUS_EFFECT_APPLIED, 
            this.handleStatusEffectApplied.bind(this)
        );
        
        // Listen for status effect removed event
        bridge.addEventListener(
            bridge.eventTypes.STATUS_EFFECT_REMOVED, 
            this.handleStatusEffectRemoved.bind(this)
        );
        
        // Listen for status effect updated event
        bridge.addEventListener(
            bridge.eventTypes.STATUS_EFFECT_UPDATED, 
            this.handleStatusEffectUpdated.bind(this)
        );
        
        // Listen for bulk status effects changed event
        bridge.addEventListener(
            bridge.eventTypes.STATUS_EFFECTS_CHANGED,
            this.handleStatusEffectsChanged.bind(this)
        );
        
        console.log('StatusEffectContainer: Event listeners set up for', this.parent.character.name);
    }
    
    /**
     * Handle status effect applied event
     * @param {Object} data - Event data
     */
    handleStatusEffectApplied(data) {
        // Only process for our parent character
        if (!this.parent || !this.parent.character) return;
        if (!data || !data.character) return;
        
        // Compare character identifiers
        const sameCharacter = 
            // First check unique ID
            (data.character.uniqueId && this.parent.character.uniqueId && 
             data.character.uniqueId === this.parent.character.uniqueId) ||
            // Then check regular ID
            (data.character.id && this.parent.character.id && 
             data.character.id === this.parent.character.id) ||
            // Finally check name as fallback
            (data.character.name === this.parent.character.name && 
             data.character.team === this.parent.character.team);
        
        if (!sameCharacter) return;
        
        console.log(`StatusEffectContainer: Status effect applied to ${this.parent.character.name} - ${data.statusId}`);
        
        // Check if effect already exists
        const existingIndex = this.statusEffects.findIndex(e => e.statusId === data.statusId);
        
        if (existingIndex >= 0) {
            // Update existing effect
            this.statusEffects[existingIndex].duration = data.duration;
            this.statusEffects[existingIndex].stacks = data.stacks || 1;
            this.statusEffects[existingIndex].definition = data.statusDefinition;
            this.updateIconDisplay(existingIndex);
        } else {
            // Add new effect
            this.statusEffects.push({
                statusId: data.statusId,
                definition: data.statusDefinition,
                duration: data.duration,
                stacks: data.stacks || 1
            });
            
            // Create and add the icon
            this.addIconForEffect(this.statusEffects.length - 1);
        }
        
        // Update overall display
        this.arrangeIcons();
    }
    
    /**
     * Handle status effect removed event
     * @param {Object} data - Event data
     */
    handleStatusEffectRemoved(data) {
        // Only process for our parent character
        if (!this.parent || !this.parent.character) return;
        if (!data || !data.character) return;
        
        // Compare character identifiers
        const sameCharacter = 
            // First check unique ID
            (data.character.uniqueId && this.parent.character.uniqueId && 
             data.character.uniqueId === this.parent.character.uniqueId) ||
            // Then check regular ID
            (data.character.id && this.parent.character.id && 
             data.character.id === this.parent.character.id) ||
            // Finally check name as fallback
            (data.character.name === this.parent.character.name && 
             data.character.team === this.parent.character.team);
        
        if (!sameCharacter) return;
        
        console.log(`StatusEffectContainer: Status effect removed from ${this.parent.character.name} - ${data.statusId}`);
        
        // Find effect
        const effectIndex = this.statusEffects.findIndex(e => e.statusId === data.statusId);
        if (effectIndex >= 0) {
            // Remove from our list
            this.statusEffects.splice(effectIndex, 1);
            
            // Remove visual icon
            if (this.iconContainers[effectIndex]) {
                // Create fade-out animation
                this.scene.tweens.add({
                    targets: this.iconContainers[effectIndex],
                    alpha: 0,
                    duration: this.config.fadeSpeed,
                    ease: 'Sine.easeOut',
                    onComplete: () => {
                        if (this.iconContainers[effectIndex]) {
                            this.iconContainers[effectIndex].destroy();
                            this.iconContainers.splice(effectIndex, 1);
                            // Re-arrange remaining icons
                            this.arrangeIcons();
                        }
                    }
                });
            }
        }
    }
    
    /**
     * Handle status effect updated event
     * @param {Object} data - Event data
     */
    handleStatusEffectUpdated(data) {
        // Only process for our parent character
        if (!this.parent || !this.parent.character) return;
        if (!data || !data.character) return;
        
        // Compare character identifiers
        const sameCharacter = 
            // First check unique ID
            (data.character.uniqueId && this.parent.character.uniqueId && 
             data.character.uniqueId === this.parent.character.uniqueId) ||
            // Then check regular ID
            (data.character.id && this.parent.character.id && 
             data.character.id === this.parent.character.id) ||
            // Finally check name as fallback
            (data.character.name === this.parent.character.name && 
             data.character.team === this.parent.character.team);
        
        if (!sameCharacter) return;
        
        console.log(`StatusEffectContainer: Status effect updated for ${this.parent.character.name} - ${data.statusId}`);
        
        // Find effect
        const effectIndex = this.statusEffects.findIndex(e => e.statusId === data.statusId);
        if (effectIndex >= 0) {
            // Update data
            if (data.duration !== undefined) {
                this.statusEffects[effectIndex].duration = data.duration;
            }
            if (data.stacks !== undefined) {
                this.statusEffects[effectIndex].stacks = data.stacks;
            }
            if (data.statusDefinition) {
                this.statusEffects[effectIndex].definition = data.statusDefinition;
            }
            
            // Update visual display
            this.updateIconDisplay(effectIndex);
        }
    }
    
    /**
     * Update the container's position relative to the parent character
     */
    updatePosition() {
        // Position below the character's health bar
        const parentHeight = this.parent.characterImage ? this.parent.characterImage.height : 120;
        this.container.y = (parentHeight / 2) + this.config.yOffset;
    }
    
    /**
     * Get appropriate color for status effect type
     * @param {string} type - The type of status effect (Buff, Debuff, DoT, HoT, Control, Shield)
     * @returns {number} - Phaser color value
     */
    getTypeColor(type) {
        switch (type?.toLowerCase()) {
            case 'buff': return 0x4488ff;     // Blue for buffs
            case 'debuff': return 0xff8844;   // Orange for debuffs
            case 'dot': return 0xff4444;      // Red for damage over time
            case 'hot': return 0x44ff44;      // Green for healing over time
            case 'control': return 0xaa44ff;  // Purple for control effects
            case 'shield': return 0xaaaaaa;   // Gray for shields
            default: return 0xffffff;         // White for unknown types
        }
    }
    
    /**
     * Add an icon for a status effect
     * @param {number} effectIndex - Index of the effect in the statusEffects array
     */
    addIconForEffect(effectIndex) {
        if (effectIndex < 0 || effectIndex >= this.statusEffects.length) return;
        
        const effect = this.statusEffects[effectIndex];
        const icon = this.createStatusIcon(effect.statusId, effect.definition);
        
        // Update counter displays
        this.updateDurationCounter(icon, effect.duration);
        this.updateStackCounter(icon, effect.stacks);
        
        // Make interactive for tooltip
        this.makeIconInteractive(icon, effectIndex);
        
        // Add to our tracking array
        this.iconContainers.push(icon);
        
        // Add to scene container
        this.container.add(icon);
        
        // Create fade-in animation
        icon.setAlpha(0);
        this.scene.tweens.add({
            targets: icon,
            alpha: 1,
            duration: this.config.fadeSpeed,
            ease: 'Sine.easeIn'
        });
    }
    
    /**
     * Update the visual display of an icon
     * @param {number} effectIndex - Index of the effect in the statusEffects array
     */
    updateIconDisplay(effectIndex) {
        if (effectIndex < 0 || effectIndex >= this.statusEffects.length) return;
        if (effectIndex >= this.iconContainers.length) return;
        
        const effect = this.statusEffects[effectIndex];
        const icon = this.iconContainers[effectIndex];
        
        // Update counters
        this.updateDurationCounter(icon, effect.duration);
        this.updateStackCounter(icon, effect.stacks);
    }
    
    /**
     * Create a visual icon for a status effect
     * @param {string} statusId - The ID of the status effect
     * @param {Object} definition - The status effect definition
     * @returns {Phaser.GameObjects.Container} - Container with the status icon
     */
    createStatusIcon(statusId, definition) {
        // Remove "status_" prefix for icon key if present
        const iconKey = statusId.replace('status_', '');
        
        // Create icon container
        const container = this.scene.add.container(0, 0);
        
        // Create background circle with type-based color
        const typeColor = this.getTypeColor(definition?.type || 'buff');
        const bg = this.scene.add.circle(0, 0, this.config.iconSize/2, typeColor, this.config.backgroundAlpha);
        
        // Try to create the icon sprite
        let sprite;
        try {
            // Use the key format expected by preloaded assets
            sprite = this.scene.add.sprite(0, 0, `status_${iconKey}`);
            
            // Scale from 32px original size to our display size
            const isAIIcon = iconKey.includes('AI_');
            if (isAIIcon || iconKey in (window.StatusIconMapper?.getMapping() || {})) {
                // Scale from originalIconSize (32px) to our display size
                const scaleFactor = this.config.iconSize / this.config.originalIconSize;
                sprite.setScale(scaleFactor);
            } else {
                // Handle non-AI icons with direct size setting
                sprite.setDisplaySize(this.config.iconSize - 4, this.config.iconSize - 4);
            }
        } catch (error) {
            console.warn(`StatusEffectContainer: Failed to load icon for ${iconKey}`, error);
            // Create fallback text
            sprite = this.scene.add.text(0, 0, iconKey.charAt(0).toUpperCase(), { 
                fontSize: '16px',
                fontStyle: 'bold',
                fontFamily: 'Arial',
                color: '#FFFFFF'
            });
            sprite.setOrigin(0.5);
        }
        
        // Add elements to the container
        container.add([bg, sprite]);
        
        // Store status data
        container.statusId = statusId;
        container.definition = definition;
        container.duration = definition?.duration || 0;
        container.stacks = 1;
        
        return container;
    }
    
    /**
     * Make an icon interactive for tooltip display
     * @param {Phaser.GameObjects.Container} iconContainer - The icon container
     * @param {number} effectIndex - Index of the effect in the statusEffects array
     */
    makeIconInteractive(iconContainer, effectIndex) {
        // Find the background circle (first child of the container)
        const bg = iconContainer.list[0];
        if (!bg) return;
        
        // Make interactive
        bg.setInteractive({ cursor: 'pointer' });
        
        // Track if icon is clicked (for tooltip persistence)
        iconContainer.isClicked = false;
        
        // Add hover effect
        bg.on('pointerover', () => {
            // Scale up slightly
            this.scene.tweens.add({
                targets: iconContainer,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 100,
                ease: 'Sine.easeOut'
            });
            
            // Show tooltip
            const effect = this.statusEffects[effectIndex];
            if (effect && !iconContainer.isClicked) {
                const worldPos = iconContainer.getWorldTransformMatrix();
                this.tooltip.showTooltip(
                    effect.statusId,
                    effect.definition,
                    { x: worldPos.tx, y: worldPos.ty },
                    effect.duration,
                    effect.stacks
                );
            }
        });
        
        // Remove hover effect
        bg.on('pointerout', () => {
            // Scale back to normal
            this.scene.tweens.add({
                targets: iconContainer,
                scaleX: 1,
                scaleY: 1,
                duration: 100,
                ease: 'Sine.easeIn'
            });
            
            // Hide tooltip only if not clicked
            if (!iconContainer.isClicked) {
                this.tooltip.hideTooltip();
            }
        });
        
        // Add click handler for tooltip persistence
        bg.on('pointerdown', () => {
            // Toggle clicked state
            iconContainer.isClicked = !iconContainer.isClicked;
            
            if (iconContainer.isClicked) {
                // Show tooltip persistently
                const effect = this.statusEffects[effectIndex];
                if (effect) {
                    const worldPos = iconContainer.getWorldTransformMatrix();
                    this.tooltip.showTooltip(
                        effect.statusId,
                        effect.definition,
                        { x: worldPos.tx, y: worldPos.ty },
                        effect.duration,
                        effect.stacks
                    );
                    
                    // Apply pulsing glow to indicate locked state
                    this.scene.tweens.add({
                        targets: bg,
                        alpha: 0.8,
                        yoyo: true,
                        repeat: -1,
                        duration: 600,
                        ease: 'Sine.easeInOut'
                    });
                }
            } else {
                // Hide tooltip
                this.tooltip.hideTooltip();
                
                // Remove pulsing glow
                this.scene.tweens.remove(bg.tween);
                bg.alpha = 1;
            }
        });
    }
    
    /**
     * Add a duration counter to an icon
     * @param {Phaser.GameObjects.Container} iconContainer - The icon container to update
     * @param {number} duration - The duration value to display
     */
    updateDurationCounter(iconContainer, duration) {
        // Remove existing duration text if any
        const existingText = iconContainer.getAll().find(obj => obj.type === 'Text' && obj.durationText);
        if (existingText) {
            existingText.destroy();
        }
        
        // Only add text if duration is > 0
        if (duration > 0) {
            // Create text with duration value
            const text = this.scene.add.text(0, this.config.iconSize/2 - 2, duration.toString(), {
                fontSize: '10px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 2
            });
            text.setOrigin(0.5, 0.5);
            text.durationText = true;
            
            // Add to icon container
            iconContainer.add(text);
        }
    }
    
    /**
     * Add a stack counter to an icon
     * @param {Phaser.GameObjects.Container} iconContainer - The icon container to update
     * @param {number} stacks - The stack count to display
     */
    updateStackCounter(iconContainer, stacks) {
        // Remove existing stack text if any
        const existingText = iconContainer.getAll().find(obj => obj.type === 'Text' && obj.stackText);
        if (existingText) {
            existingText.destroy();
        }
        
        // Only add text if stacks is > 1
        if (stacks > 1) {
            // Create small text with stack count
            const text = this.scene.add.text(this.config.iconSize/2 - 2, -this.config.iconSize/2 + 2, stacks.toString(), {
                fontSize: '10px',
                fontStyle: 'bold',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 2
            });
            text.setOrigin(0.5, 0.5);
            text.stackText = true;
            
            // Add to icon container
            iconContainer.add(text);
        }
    }
    
    /**
     * Arrange all status effect icons in a row
     */
    arrangeIcons() {
        // Position icons in a row
        const { iconSize, spacing } = this.config;
        const totalWidth = Math.min(this.iconContainers.length, this.config.maxIcons) * (iconSize + spacing) - spacing;
        
        // Center the row
        let startX = -totalWidth / 2;
        
        // Position each icon
        this.iconContainers.forEach((icon, index) => {
            // If we have more than max icons, show only the first (max-1) plus a +N indicator
            if (index >= this.config.maxIcons - 1 && this.iconContainers.length > this.config.maxIcons) {
                if (index === this.config.maxIcons - 1) {
                    // Show +N indicator for last visible slot
                    this.showExtraEffectsIndicator(startX + (iconSize + spacing) * index);
                }
                icon.setVisible(false);
            } else {
                icon.setPosition(startX + (iconSize + spacing) * index, 0);
                icon.setVisible(true);
            }
        });
    }
    
    /**
     * Show a +N indicator when there are more effects than can be displayed
     * @param {number} x - X position for the indicator
     */
    showExtraEffectsIndicator(x) {
        // Count extra effects
        const extraCount = this.iconContainers.length - (this.config.maxIcons - 1);
        
        // Remove existing indicator if it exists
        if (this.extraIndicator) {
            this.extraIndicator.destroy();
            this.extraIndicator = null;
        }
        
        // Create indicator container
        this.extraIndicator = this.scene.add.container(x, 0);
        
        // Create background with gradient fill for better appearance
        const bg = this.scene.add.graphics();
        bg.fillStyle(0x222222, 0.8);
        bg.fillCircle(0, 0, this.config.iconSize/2);
        
        // Add subtle border
        bg.lineStyle(1, 0x444444, 0.9);
        bg.strokeCircle(0, 0, this.config.iconSize/2);
        
        // Create text
        const text = this.scene.add.text(0, 0, `+${extraCount}`, {
            fontSize: '12px',
            fontStyle: 'bold',
            fontFamily: 'Arial',
            color: '#FFFFFF'
        });
        text.setOrigin(0.5);
        
        // Add to container
        this.extraIndicator.add([bg, text]);
        
        // Add to main container
        this.container.add(this.extraIndicator);
        
        // Add hitarea for better interaction
        const hitArea = new Phaser.Geom.Circle(0, 0, this.config.iconSize/2);
        bg.setInteractive(hitArea, Phaser.Geom.Circle.Contains, { cursor: 'pointer' });
        
        // Track clicked state
        this.extraIndicator.isClicked = false;
        
        // Add hover effect
        bg.on('pointerover', () => {
            // Scale up slightly
            if (!this.extraIndicator.isClicked) {
                this.scene.tweens.add({
                    targets: this.extraIndicator,
                    scaleX: 1.2,
                    scaleY: 1.2,
                    duration: 100,
                    ease: 'Sine.easeOut'
                });
            }
            
            // Show tooltip with summary of additional effects
            if (!this.extraIndicator.isClicked) {
                // Create tooltip content for multiple effects
                this.showMultiEffectTooltip();
            }
        });
        
        // Remove hover effect
        bg.on('pointerout', () => {
            // Scale back to normal if not clicked
            if (!this.extraIndicator.isClicked) {
                this.scene.tweens.add({
                    targets: this.extraIndicator,
                    scaleX: 1,
                    scaleY: 1,
                    duration: 100,
                    ease: 'Sine.easeIn'
                });
                
                // Hide tooltip
                this.tooltip.hideTooltip();
            }
        });
        
        // Add click handler for tooltip persistence
        bg.on('pointerdown', () => {
            // Toggle clicked state
            this.extraIndicator.isClicked = !this.extraIndicator.isClicked;
            
            if (this.extraIndicator.isClicked) {
                // Scale up and stay
                this.scene.tweens.add({
                    targets: this.extraIndicator,
                    scaleX: 1.2,
                    scaleY: 1.2,
                    duration: 100,
                    ease: 'Sine.easeOut'
                });
                
                // Show detailed tooltip with all extra effects
                this.showMultiEffectTooltip();
                
                // Add pulsing effect to indicate locked state
                this.extraIndicator.pulseTween = this.scene.tweens.add({
                    targets: text,
                    alpha: 0.7,
                    yoyo: true,
                    repeat: -1,
                    duration: 500,
                    ease: 'Sine.easeInOut'
                });
            } else {
                // Scale back to normal
                this.scene.tweens.add({
                    targets: this.extraIndicator,
                    scaleX: 1,
                    scaleY: 1,
                    duration: 100,
                    ease: 'Sine.easeIn'
                });
                
                // Hide tooltip
                this.tooltip.hideTooltip();
                
                // Remove pulsing effect
                if (this.extraIndicator.pulseTween) {
                    this.scene.tweens.remove(this.extraIndicator.pulseTween);
                    text.alpha = 1;
                }
            }
        });
    }
    
    /**
     * Show tooltip with information about multiple effects
     */
    showMultiEffectTooltip() {
        if (!this.extraIndicator) return;
        
        // Get the hidden effects (those beyond max visible)
        const hiddenEffects = this.statusEffects.slice(this.config.maxIcons - 1);
        if (hiddenEffects.length === 0) return;
        
        // Create a title for the tooltip
        const title = `Additional Effects (${hiddenEffects.length})`;
        
        // Create a summary description of hidden effects with formatted names
        const effectNames = hiddenEffects.map(effect => {
            // Get proper formatted name using the tooltip's formatting function
            let name = effect.statusId;
            if (this.tooltip && typeof this.tooltip.formatStatusName === 'function') {
                name = this.tooltip.formatStatusName(effect.statusId);
            } else {
                // Fallback formatting if tooltip formatter is unavailable
                name = effect.definition?.name || 
                       effect.statusId.replace('status_', '')
                       .split('_')
                       .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                       .join(' ');
            }
            
            return `${name} (${effect.duration} turns${effect.stacks > 1 ? `, ${effect.stacks} stacks` : ''})`;
        }).join('\n');
        
        // Get world position for tooltip
        const worldPos = this.extraIndicator.getWorldTransformMatrix();
        
        // Show the tooltip
        this.tooltip.showTooltip(
            'multi_effect', // Using a special ID
            { 
                name: title,
                description: effectNames,
                type: 'info' // Using info type for multi-effect tooltip
            },
            { x: worldPos.tx, y: worldPos.ty },
            0, // No duration
            0  // No stacks
        );
    }
    
    /**
     * Destroy this component and clean up resources
     */
    destroy() {
        // Hide tooltip
        if (this.tooltip) {
            this.tooltip.hideTooltip();
        }
        
        // Clean up all icon containers
        this.iconContainers.forEach(container => container.destroy());
        this.iconContainers = [];
        
        // Clean up extra indicator if exists
        if (this.extraIndicator) {
            this.extraIndicator.destroy();
            this.extraIndicator = null;
        }
        
        // Destroy main container
        this.container.destroy();
        
        console.log('StatusEffectContainer: Destroyed for character:', this.parent.character.name);
    }
}

// Ensure the class is globally accessible
if (typeof window !== 'undefined') {
    window.StatusEffectContainer = StatusEffectContainer;
}

===== FILE: StatusEffectTooltip.js =====
/**
 * StatusEffectTooltip.js
 * A singleton component to display tooltips for status effects
 * Enhanced version with improved visual design and interaction
 * 
 * Version 0.5.3.4 - 2025-05-18
 */

class StatusEffectTooltip {
    /**
     * Create a new StatusEffectTooltip
     * @param {Phaser.Scene} scene - The Phaser scene this tooltip belongs to
     */
    constructor(scene) {
        // Store singleton instance
        if (window.statusEffectTooltip) {
            console.debug('StatusEffectTooltip: Instance already exists, returning existing instance');
            return window.statusEffectTooltip;
        }
        
        this.scene = scene;
        
        // Configuration settings for enhanced tooltip
        this.config = {
            minWidth: 180,       // Minimum width of tooltip
            padding: {
                x: 16,           // Horizontal padding inside tooltip
                y: 12,           // Vertical padding inside tooltip
                inner: 8         // Inner padding between elements
            },
            cornerRadius: 6,     // Rounded corner radius
            backgroundColor: 0x111825,  // Dark navy blue background
            backgroundAlpha: 0.9,  // Slightly less transparent
            borderColor: 0x3498db,  // Bright blue border
            borderWidth: 1,       // Thinner, more elegant border
            textColor: {
                title: '#ffffff',    // White for title
                description: '#cccccc', // Light gray for description
                info: '#99ccff'     // Light blue for additional info
            },
            fontSize: {
                title: 14,        // Title font size
                description: 12,  // Description font size
                info: 10          // Additional info font size
            },
            animationSpeed: {
                show: 120,       // Show animation speed (faster)
                hide: 100        // Hide animation speed (faster)
            },
            offset: {
                icon: 15,        // Offset from icon
                mouse: 10        // Offset from mouse cursor
            }
        };
        
        // Current status details
        this.currentStatus = null;
        
        // Create container
        this.createTooltip();
        
        // Store as singleton
        window.statusEffectTooltip = this;
        
        console.log('StatusEffectTooltip: Created enhanced singleton instance');
    }
    
    /**
     * Show the tooltip at the specified position with status effect details
     * @param {string} statusId - The ID of the status effect
     * @param {Object} definition - The status effect definition
     * @param {Object} position - The position {x, y} to show the tooltip
     * @param {number} duration - Duration of the status effect in turns
     * @param {number} stacks - Number of stacks of the effect
     */
    showTooltip(statusId, definition, position, duration, stacks) {
        // Store current status details
        this.currentStatus = {
            statusId,
            definition,
            position,
            duration,
            stacks
        };
        
        // Clear any existing content
        this.clearContent();
        
        // Get title and description from definition or fallback
        const title = definition?.name || statusId.replace('status_', '').toUpperCase();
        const description = definition?.description || 'Status effect';
        
        // Create text elements
        this.createTooltipContent(title, description, duration, stacks, definition);
        
        // Position tooltip with improved positioning logic
        this.positionTooltip(position);
        
        // Show with animation
        this.container.setVisible(true);
        this.container.setAlpha(0);
        
        // Clear any existing tweens
        if (this.currentTween) {
            this.scene.tweens.remove(this.currentTween);
        }
        
        // Create fade-in animation
        this.currentTween = this.scene.tweens.add({
            targets: this.container,
            alpha: 1,
            duration: this.config.animationSpeed.show,
            ease: 'Cubic.easeOut'
        });
    }
    
    /**
     * Create the tooltip container and base elements
     */
    createTooltip() {
        // Create container at depth 1000 to ensure it's above other elements
        this.container = this.scene.add.container(0, 0);
        this.container.setDepth(1000);
        
        // Create graphics for background and border
        this.graphics = this.scene.add.graphics();
        this.container.add(this.graphics);
        
        // Create text elements with centered alignment
        this.titleText = this.scene.add.text(
            0, 0, '',
            {
                fontFamily: 'Arial',
                fontSize: this.config.fontSize.title,
                color: this.config.textColor.title,
                fontStyle: 'bold',
                align: 'center'  // Center-align title text
            }
        ).setOrigin(0.5, 0.5);  // Set origin to center for centered positioning
        
        this.descText = this.scene.add.text(
            0, 0, '',
            {
                fontFamily: 'Arial',
                fontSize: this.config.fontSize.description,
                color: this.config.textColor.description,
                wordWrap: { width: 0 }, // Will be set dynamically
                align: 'center'  // Center-align description text
            }
        ).setOrigin(0.5, 0.5);  // Set origin to center for centered positioning
        
        this.infoText = this.scene.add.text(
            0, 0, '',
            {
                fontFamily: 'Arial',
                fontSize: this.config.fontSize.info,
                color: this.config.textColor.info,
                align: 'center'  // Center-align info text
            }
        ).setOrigin(0.5, 0.5);  // Set origin to center for centered positioning
        
        // Add text elements to container
        this.container.add([this.titleText, this.descText, this.infoText]);
        
        // Hide initially
        this.container.setVisible(false);
        
        // Add to scene
        this.scene.add.existing(this.container);
    }
    
    /**
     * Format a status effect ID or name to be more user-friendly
     * @param {string} statusName - Status effect name or ID to format
     * @returns {string} - Formatted user-friendly name
     */
    formatStatusName(statusName) {
        if (!statusName) return 'Unknown Effect';
        
        // If name is already provided in a user-friendly format from definition, use it
        // But ensure it's not all uppercase (like 'SHIELD')
        if (statusName && !statusName.includes('_') && !statusName.includes('status_')) {
            // Check if it's all uppercase (like 'SHIELD', 'IMMUNE', etc.)
            if (statusName === statusName.toUpperCase()) {
                // Convert all-caps to Title Case
                return statusName.charAt(0).toUpperCase() + statusName.slice(1).toLowerCase();
            }
            // Just capitalize first letter if it's already in a good format (mixed case)
            return statusName.charAt(0).toUpperCase() + statusName.slice(1);
        }
        
        // Remove 'status_' prefix if present
        let name = statusName.replace('status_', '');
        
        // Handle common abbreviations
        const abbreviations = {
            'atk_up': 'Attack Up',
            'atk_down': 'Attack Down',
            'def_up': 'Defense Up',
            'def_down': 'Defense Down', 
            'spd_up': 'Speed Up',
            'spd_down': 'Speed Down',
            'str_up': 'Strength Up',
            'str_down': 'Strength Down',
            'int_up': 'Intellect Up',
            'int_down': 'Intellect Down',
            'spi_up': 'Spirit Up',
            'spi_down': 'Spirit Down',
            'regen': 'Regeneration',
            'dot': 'Damage Over Time',
            'hot': 'Healing Over Time',
            'shield': 'Shield',
            'immune': 'Immunity',
            'taunt': 'Taunt',
            'burn': 'Burn',
            'stun': 'Stun',
            'freeze': 'Freeze',
            'bleed': 'Bleeding',
            'poison': 'Poison',
            'evade': 'Evasion',
            'reflect': 'Damage Reflect',
            'vulnerable': 'Vulnerability',
            'crit_up': 'Critical Chance Up'
        };
        
        // Check if this is a known abbreviation (case insensitive)
        if (abbreviations[name.toLowerCase()]) {
            return abbreviations[name.toLowerCase()];
        }
        
        // Handle if the name is all uppercase (like 'SHIELD', 'IMMUNE', etc.)
        if (name === name.toUpperCase()) {
            name = name.toLowerCase();
        }
        
        // Format by replacing underscores with spaces and capitalizing each word
        return name.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
    }
    
    /**
     * Create and layout the tooltip content based on status effect details
     * @param {string} title - Status effect name
     * @param {string} description - Status effect description
     * @param {number} duration - Status effect duration in turns
     * @param {number} stacks - Number of stacks of the effect
     * @param {Object} definition - Status effect definition
     */
    createTooltipContent(title, description, duration, stacks, definition) {
        // Format the title to be more user-friendly
        const formattedTitle = this.formatStatusName(title);
        
        // Set text content with center alignment
        this.titleText.setText(formattedTitle);
        this.descText.setText(description);
        
        // Create info text with proper formatting
        let infoLines = [];
        
        // Add duration
        if (duration > 0) {
            infoLines.push(`Duration: ${duration} turn${duration !== 1 ? 's' : ''}`);
        }
        
        // Add stacks
        if (stacks > 1) {
            infoLines.push(`Stacks: ${stacks}`);
        }
        
        // Add type
        if (definition?.type) {
            infoLines.push(`Type: ${definition.type.charAt(0).toUpperCase() + definition.type.slice(1)}`);
        }
        
        // Set info text
        this.infoText.setText(infoLines.join('\n'));
        
        // Calculate optimal width based on content
        const textWidth = Math.max(
            this.titleText.width,
            this.descText.width,
            this.infoText.width
        );
        
        // Calculate tooltip width with padding
        const tooltipWidth = Math.max(
            this.config.minWidth,
            textWidth + (this.config.padding.x * 2)
        );
        
        // Update word wrap width
        this.descText.setWordWrapWidth(tooltipWidth - (this.config.padding.x * 2));
        
        // Position elements with proper spacing (centered horizontally)
        const startY = this.config.padding.y;
        const centerX = tooltipWidth / 2;
        
        // Position title at top (centered)
        this.titleText.setPosition(centerX, startY + (this.titleText.height / 2));
        
        // Position description below title with spacing (centered)
        const descY = startY + this.titleText.height + this.config.padding.inner + (this.descText.height / 2);
        this.descText.setPosition(centerX, descY);
        
        // Position info text below description with spacing (centered)
        const infoY = descY + (this.descText.height / 2) + this.config.padding.inner + (this.infoText.height / 2);
        this.infoText.setPosition(centerX, infoY);
        
        // Calculate total height
        const tooltipHeight = infoY + (this.infoText.height / 2) + this.config.padding.y;
        
        // Draw background and border with rounded corners
        this.graphics.clear();
        
        // Set border color based on status effect type
        const borderColor = this.getBorderColorByType(definition?.type);
        
        // Create gradient background
        const bgTopColor = this.config.backgroundColor;
        const bgBottomColor = Phaser.Display.Color.IntegerToRGB(bgTopColor);
        bgBottomColor.r = Math.max(0, bgBottomColor.r - 10);
        bgBottomColor.g = Math.max(0, bgBottomColor.g - 10);
        bgBottomColor.b = Math.max(0, bgBottomColor.b - 10);
        const bgBottomColorInt = Phaser.Display.Color.GetColor(
            bgBottomColor.r, 
            bgBottomColor.g, 
            bgBottomColor.b
        );
        
        // Draw background with subtle gradient
        this.graphics.fillGradientStyle(
            bgTopColor, bgTopColor,  // Top colors
            bgBottomColorInt, bgBottomColorInt,  // Bottom colors
            this.config.backgroundAlpha
        );
        
        // Draw rounded rectangle background
        this.graphics.fillRoundedRect(
            0, 0,
            tooltipWidth,
            tooltipHeight,
            this.config.cornerRadius
        );
        
        // Draw border with slight inset
        this.graphics.lineStyle(
            this.config.borderWidth,
            borderColor,
            1
        );
        this.graphics.strokeRoundedRect(
            this.config.borderWidth / 2,
            this.config.borderWidth / 2,
            tooltipWidth - this.config.borderWidth,
            tooltipHeight - this.config.borderWidth,
            this.config.cornerRadius
        );
        
        // Store dimensions for positioning
        this.tooltipWidth = tooltipWidth;
        this.tooltipHeight = tooltipHeight;
    }
    
    /**
     * Get border color based on status effect type
     * @param {string} type - Type of status effect
     * @returns {number} - Phaser color value
     */
    getBorderColorByType(type) {
        switch (type?.toLowerCase()) {
            case 'buff': return 0x4488ff;     // Blue for buffs
            case 'debuff': return 0xff8844;   // Orange for debuffs
            case 'dot': return 0xff4444;      // Red for damage over time
            case 'hot': return 0x44ff44;      // Green for healing over time
            case 'control': return 0xaa44ff;  // Purple for control effects
            case 'shield': return 0xaaaaaa;   // Gray for shields
            default: return this.config.borderColor; // Default blue
        }
    }
    
    /**
     * Position the tooltip smartly based on available space
     * @param {Object} position - Target position {x, y}
     */
    positionTooltip(position) {
        // Start with default positioning above the target
        let tooltipX = position.x;
        let tooltipY = position.y - this.config.offset.icon;
        
        // Get screen bounds
        const screenWidth = this.scene.cameras.main.width;
        const screenHeight = this.scene.cameras.main.height;
        
        // Check if tooltip would go off the right edge
        if (tooltipX + (this.tooltipWidth / 2) > screenWidth) {
            tooltipX = screenWidth - (this.tooltipWidth / 2) - 10;
        }
        
        // Check if tooltip would go off the left edge
        if (tooltipX - (this.tooltipWidth / 2) < 0) {
            tooltipX = (this.tooltipWidth / 2) + 10;
        }
        
        // Check if tooltip would go off the top edge
        let positionBelow = false;
        if (tooltipY - this.tooltipHeight < 0) {
            // Position below target instead
            tooltipY = position.y + this.config.offset.icon;
            positionBelow = true;
        }
        
        // Adjust for bottom edge if positioning below
        if (positionBelow && tooltipY + this.tooltipHeight > screenHeight) {
            // If we can't fit above or below, position to the side
            tooltipY = screenHeight - this.tooltipHeight - 10;
        }
        
        // Center the tooltip horizontally on the provided x position
        this.container.setPosition(tooltipX - (this.tooltipWidth / 2), tooltipY - (positionBelow ? 0 : this.tooltipHeight));
    }
    
    /**
     * Clear the tooltip content
     */
    clearContent() {
        this.titleText.setText('');
        this.descText.setText('');
        this.infoText.setText('');
        this.graphics.clear();
    }
    
    /**
     * Hide the tooltip with a fade-out animation
     */
    hideTooltip() {
        if (!this.container || !this.container.visible) return;
        
        // Clear any existing tweens
        if (this.currentTween) {
            this.scene.tweens.remove(this.currentTween);
        }
        
        // Create fade-out animation
        this.currentTween = this.scene.tweens.add({
            targets: this.container,
            alpha: 0,
            duration: this.config.animationSpeed.hide,
            ease: 'Cubic.easeIn',
            onComplete: () => {
                this.container.setVisible(false);
                this.currentStatus = null;
            }
        });
    }
    
    /**
     * Update the tooltip position (useful for moving with cursor)
     * @param {Object} position - New position {x, y}
     */
    updatePosition(position) {
        if (!this.container.visible || !this.currentStatus) return;
        
        // Update stored position
        this.currentStatus.position = position;
        
        // Reposition tooltip
        this.positionTooltip(position);
    }
    
    /**
     * Destroy the tooltip instance
     */
    destroy() {
        if (this.currentTween) {
            this.scene.tweens.remove(this.currentTween);
        }
        
        if (this.container) {
            this.container.destroy();
            this.container = null;
        }
        
        // Remove singleton reference
        if (window.statusEffectTooltip === this) {
            window.statusEffectTooltip = null;
        }
    }
}

// Ensure the class is globally accessible
if (typeof window !== 'undefined') {
    window.StatusEffectTooltip = StatusEffectTooltip;
}

===== FILE: TeamContainer.js =====
/**
 * TeamContainer.js
 * Manages a team of character sprites with proper positioning
 * (Added try...catch blocks for debugging)
 */
class TeamContainer {
    /**
     * Update a character's health in this team
     * @param {string|number|Object} characterId - The character ID, name, or object to update
     * @param {number} newHealth - The new health value
     * @param {number} maxHealth - The maximum health value
     * @returns {boolean} - True if a character was found and updated
     */
    updateCharacterHealth(characterId, newHealth, maxHealth) {
        // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
        // TODO: REMOVE or MOVE after bug fix / refactoring
        console.log(`[HEALTH DEBUG] TeamContainer.updateCharacterHealth called for ${typeof characterId === 'object' ? characterId?.name : characterId}, team: ${this.isPlayerTeam ? 'player' : 'enemy'}, characterId: ${typeof characterId === 'object' ? characterId?.uniqueId || characterId?.id : characterId}`);
        // END TEMPORARY DIAGNOSTIC CODE

        console.log(`TeamContainer.updateCharacterHealth: Updating ${typeof characterId === 'object' ? characterId?.name : characterId} to health ${newHealth}/${maxHealth}`);
        
        // Check if characterSprites is valid
        if (!Array.isArray(this.characterSprites) || this.characterSprites.length === 0) {
            console.warn('TeamContainer.updateCharacterHealth: No character sprites available');
            return false;
        }
        
        // Log available characters for debugging
        console.log('Available characters in team:');
        this.characterSprites.forEach(sprite => {
            if (sprite && sprite.character) {
                console.log(`- ${sprite.character.name} (id: ${sprite.character.id}, uniqueId: ${sprite.character.uniqueId}, team: ${sprite.character.team})`);
            }
        });
        
        // Try to find character sprite using enhanced finding logic
        // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
        // TODO: REMOVE or MOVE after bug fix / refactoring
        console.log(`[HEALTH DEBUG] TeamContainer.updateCharacterHealth: About to call findCharacterSprite`);
        // END TEMPORARY DIAGNOSTIC CODE

        const sprite = this.findCharacterSprite(characterId);
        
        if (!sprite) {
            // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
            // TODO: REMOVE or MOVE after bug fix / refactoring
            console.warn(`[HEALTH DEBUG] Character sprite not found for ${typeof characterId === 'object' ? characterId?.name : characterId}, ID: ${typeof characterId === 'object' ? characterId?.uniqueId || characterId?.id : characterId}`);
            // END TEMPORARY DIAGNOSTIC CODE
        } else {
            // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
            // TODO: REMOVE or MOVE after bug fix / refactoring
            console.log(`[HEALTH DEBUG] Found CharacterSprite for ${sprite.character.name}, calling updateHealth`);
            // END TEMPORARY DIAGNOSTIC CODE
            
            console.log(`TeamContainer: Updating ${sprite.character.name}'s health to ${newHealth}/${maxHealth}`);
            sprite.updateHealth(newHealth, maxHealth);
            return true;
        }
        
        console.warn(`Could not find character sprite for ID/name: ${typeof characterId === 'object' ? JSON.stringify(characterId) : characterId}`);
        return false;
    }
    
    /**
     * Enhanced method to find a character sprite with multiple identification strategies
     * @param {string|number|Object} character - Character identifier (id, name, uniqueId) or object
     * @returns {Object|null} - The character sprite or null if not found
     */
    findCharacterSprite(character) {
        // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
        // TODO: REMOVE or MOVE after bug fix / refactoring
        console.log(`[HEALTH DEBUG] TeamContainer.findCharacterSprite entry: character=${typeof character === 'object' ? character?.name : character}`);
        // END TEMPORARY DIAGNOSTIC CODE

        if (!character) return null;
        
        // Try finding by direct reference first
        let sprite = this.characterSprites.find(s => s.character === character);
        if (sprite) {
            // TEMPORARY DIAGNOSTIC CODE - HEALTH BAR BUG
            // TODO: REMOVE or MOVE after bug fix / refactoring
            console.log(`[HEALTH DEBUG] Found by direct reference: ${sprite.character.name}`);
            // END TEMPORARY DIAGNOSTIC CODE
            return sprite;
        }
        
        // If character is an object, try all its properties
        if (typeof character === 'object') {
            // Try finding by id
            if (character.id !== undefined) {
                sprite = this.characterSprites.find(s => s.character?.id === character.id);
                if (sprite) return sprite;
            }
            
            // Try finding by name
            if (character.name) {
                sprite = this.characterSprites.find(s => s.character?.name === character.name);
                if (sprite) return sprite;
            }
            
            // Try finding by uniqueId
            if (character.uniqueId) {
                sprite = this.characterSprites.find(s => s.character?.uniqueId === character.uniqueId);
                if (sprite) return sprite;
            }
            
            // Try with team information if available
            if (character.name && (character.team === 'player' || character.team === 'enemy')) {
                const matchesTeam = this.isPlayerTeam ? (character.team === 'player') : (character.team === 'enemy');
                sprite = this.characterSprites.find(s => 
                    s.character?.name === character.name && 
                    (s.character?.team === character.team || s.isPlayerTeam === matchesTeam)
                );
                if (sprite) return sprite;
            }
        }
        
        // If character is a string, handle different formats
        if (typeof character === 'string') {
            // Try as direct name or id match
            sprite = this.characterSprites.find(s => 
                s.character?.name === character || 
                s.character?.id === character || 
                s.character?.uniqueId === character
            );
            if (sprite) return sprite;
            
            // Handle team-prefixed IDs (e.g., "enemy_Drakarion_1")
            const parts = character.split('_');
            if (parts.length >= 2) {
                const teamPrefix = parts[0]; // "enemy" or "player"
                const charName = parts[1];   // "Drakarion", "Vaelgor", etc.
                
                // Match by name and team type
                const matchesTeam = this.isPlayerTeam ? (teamPrefix === 'player') : (teamPrefix === 'enemy');
                
                sprite = this.characterSprites.find(s => 
                    s.character?.name === charName && 
                    this.isPlayerTeam === matchesTeam
                );
                if (sprite) return sprite;
                
                // If still not found, try just the name
                sprite = this.characterSprites.find(s => s.character?.name === charName);
                if (sprite) return sprite;
            }
        }
        
        // If character is a number, try as index
        if (typeof character === 'number') {
            if (character >= 0 && character < this.characterSprites.length) {
                return this.characterSprites[character];
            }
        }
        
        // Not found with any method
        return null;
    }

    /**
     * Create a new team container
     * @param {Phaser.Scene} scene - The scene this container belongs to
     * @param {Array} team - Array of character objects
     * @param {boolean} isPlayerTeam - Whether this is the player's team
     * @param {Object} config - Configuration options
     */
    constructor(scene, team, isPlayerTeam, config = {}) {
        this.scene = scene;
        this.team = team;
        this.isPlayerTeam = isPlayerTeam;

        // Set up default config
        this.config = Object.assign({
            x: isPlayerTeam ? 300 : 900,
            y: 350,
            spacing: 180, // Original spacing
            characterScale: 1,
            interactive: true
        }, config);

        // The character sprites in this team
        this.characterSprites = [];

        // Create container
        try { // Added try for container creation
            this.container = scene.add.container(this.config.x, this.config.y);
        } catch (error) {
             console.error(`TeamContainer Constructor: Error creating Phaser container for team ${isPlayerTeam ? 'Player' : 'Enemy'} at (${this.config.x}, ${this.config.y}):`, error);
             // Attempt to recover or just log and potentially fail later
             // For now, let's try creating a default container
             if (!this.container) {
                  try { this.container = scene.add.container(0,0); } catch(e){ console.error("Failed fallback container creation too!"); }
             }
             // Propagate the error up if needed, or handle it here
             // throw error; // Optional: re-throw if it's critical
        }

        // Initialize TurnIndicator for this team
        this.turnIndicatorInstance = null; // Initialize to null
        try {
            if (window.TurnIndicator) { // Check if TurnIndicator class is available
                this.turnIndicatorInstance = new TurnIndicator(this.scene);
                // TurnIndicator's constructor handles scene.add.existing(this)
                console.log(`TeamContainer for ${this.isPlayerTeam ? 'Player' : 'Enemy'} team: TurnIndicator instance created successfully.`);
            } else {
                console.error(`TeamContainer for ${this.isPlayerTeam ? 'Player' : 'Enemy'} team: TurnIndicator class not found on window.`);
            }
        } catch (error) {
            console.error(`TeamContainer for ${this.isPlayerTeam ? 'Player' : 'Enemy'} team: Error creating TurnIndicator instance:`, error);
        }


        // Initialize character sprites - Wrapped call
        try {
            console.log(`TeamContainer: Initializing characters for team ${isPlayerTeam ? 'Player' : 'Enemy'}. Team size: ${this.team?.length || 0}`);
            this.initializeCharacters();
             console.log(`TeamContainer: Finished initializing characters for team ${isPlayerTeam ? 'Player' : 'Enemy'}. Sprites created: ${this.characterSprites.length}`);
        } catch (error) {
            console.error(`TeamContainer Constructor: Error calling initializeCharacters for team ${isPlayerTeam ? 'Player' : 'Enemy'}:`, error);
             // Depending on how critical this is, you might want to stop or show an error message
             // For now, we log the error. The team might be partially rendered or empty.
        }

        // Make available globally for debugging
        if (!window.teamContainers) window.teamContainers = {player: null, enemy: null};
        window.teamContainers[isPlayerTeam ? 'player' : 'enemy'] = this;
    }

    /**
     * Initialize characters within the team
     */
    initializeCharacters() {
        // Ensure team is an array
        if (!Array.isArray(this.team)) {
            console.error('TeamContainer initializeCharacters: this.team is not an array!', this.team);
            this.team = []; // Attempt recovery
        }

        // Calculate positions for each character
        const positions = this.calculatePositions(this.team.length);
        console.log(`TeamContainer initializeCharacters: Calculated ${positions.length} positions.`);


        // Create character sprites
        this.team.forEach((character, index) => {
            // Add team property to character if not set
             if (!character) {
                 console.error(`TeamContainer initializeCharacters: Found null/undefined character at index ${index}. Skipping.`);
                 return; // Skip this iteration
             }

             if (!character.team) {
                character.team = this.isPlayerTeam ? 'player' : 'enemy';
            }

            // Set initial HP if not set
             if (!character.stats) {
                 console.error(`TeamContainer initializeCharacters: Character ${character.name || 'Unknown'} has no stats! Assigning default HP.`);
                 character.stats = { hp: 1 }; // Minimal default stats
             }
            if (typeof character.currentHp === 'undefined') {
                character.currentHp = character.stats.hp;
            }

            // --- Added try...catch around CharacterSprite instantiation ---
            try {
                 console.log(`TeamContainer initializeCharacters: Creating CharacterSprite for ${character.name || 'Unknown ID ' + character.id} at index ${index}.`);
                const sprite = new CharacterSprite(this.scene, character, {
                    x: positions[index].x,
                    y: positions[index].y,
                    scale: this.config.characterScale,
                    interactive: this.config.interactive
                });
                 console.log(`TeamContainer initializeCharacters: Successfully created sprite for ${character.name || 'Unknown ID ' + character.id}.`);

                // Add to our array ONLY if creation succeeded
                this.characterSprites.push(sprite);
                 // IMPORTANT: Add sprite's container to the TeamContainer's container
                 if (this.container && sprite.container) {
                      this.container.add(sprite.container);
                 } else {
                      console.error(`TeamContainer initializeCharacters: Cannot add sprite container for ${character.name}. Main container or sprite container is missing.`);
                 }

            } catch (error) {
                console.error(`TeamContainer initializeCharacters: Error creating CharacterSprite for character: ${character.name || 'Unknown ID ' + character.id} at index ${index}.`, error);
                 // Continue to next character instead of stopping the whole loop
            }
            // --- End of added try...catch ---
        });
         console.log(`TeamContainer initializeCharacters: Finished loop. Total sprites in array: ${this.characterSprites.length}. Sprites added to Phaser container: ${this.container?.list.length || 0}`);
    }

    /**
     * Calculate positions for characters based on team size
     * @param {number} teamSize - Number of characters in the team
     * @returns {Array} - Array of {x,y} positions
     */
    calculatePositions(teamSize) {
         if (typeof teamSize !== 'number' || teamSize < 0) {
             console.warn(`TeamContainer calculatePositions: Invalid teamSize (${teamSize}). Defaulting to 0.`);
             teamSize = 0;
         }
        const positions = [];
        const spacing = this.config.spacing;

        // For 3 character teams, use a special positioning
        if (teamSize === 3) {
            // Position first character higher
            positions.push({
                x: 0,
                y: -spacing - 40 // Move first character 40px higher
            });
            
            // Keep middle character in center
            positions.push({
                x: 0,
                y: 0
            });
            
            // Position last character lower
            positions.push({
                x: 0,
                y: spacing + 40 // Move last character 40px lower
            });
            
            return positions;
        }
        
        // Default positioning for other team sizes
        // Vertical positioning with team centered
        const startY = -(spacing * (teamSize - 1)) / 2;

        for (let i = 0; i < teamSize; i++) {
            positions.push({
                x: 0,
                y: startY + (i * spacing)
            });
        }

        return positions;
    }

    /**
     * Get a character sprite by name
     * @param {string} name - Character name
     * @returns {CharacterSprite|null} - The character sprite or null
     */
    getCharacterSpriteByName(name) {
        // Add safety check
        if (!Array.isArray(this.characterSprites)) {
            console.warn(`[TeamContainer] getCharacterSpriteByName: characterSprites is not an array, cannot look up "${name}"`);
            return null;
        }

        const foundSprite = this.characterSprites.find(sprite => sprite && sprite.character && sprite.character.name === name);
        
        return foundSprite;
    }

    /**
     * Get a character sprite by index
     * @param {number} index - Index in the team
     * @returns {CharacterSprite|null} - The character sprite or null
     */
    getCharacterSpriteByIndex(index) {
         // Add safety check
         if (!Array.isArray(this.characterSprites)) return null;
        return index >= 0 && index < this.characterSprites.length
            ? this.characterSprites[index]
            : null;
    }

    /**
     * Update all character sprites in the team
     */
    update() {
         // Add safety check
         if (!Array.isArray(this.characterSprites)) return;
        this.characterSprites.forEach(sprite => {
             // Check if sprite exists and has an update method
             if (sprite && typeof sprite.update === 'function') {
                  sprite.update();
             }
        });
    }

    /**
     * Show turn indicator for a specific character
     * @param {string|number} identifier - Character name or index
     */
    showTurnIndicator(identifier) {
        console.log(`TC.showTurnIndicator: Called for Turn Highlighting with ID [${identifier}]. Attempting to find CharacterSprite.`);
        let sprite;

        if (typeof identifier === 'number') {
            sprite = this.getCharacterSpriteByIndex(identifier);
        } else {
            sprite = this.getCharacterSpriteByName(identifier);
        }
        
        console.log(`TC.showTurnIndicator: Found CharacterSprite: ${sprite ? `sprite for ${sprite.character?.name}` : 'null'}. Attempting to call sprite.highlight().`);

        if (sprite) {
            if (this.turnIndicatorInstance) {
                // Hide any currently shown indicator for this team instance immediately
                this.turnIndicatorInstance.hide(0); // Hide with 0 duration

                // Calculate position at character's feet
                let bottomOffset = 20; // Default offset
                if (sprite.characterImage && sprite.characterImage.height) {
                    // Position it roughly below the character image's vertical center
                    bottomOffset = (sprite.characterImage.height / 2) - 26; 
                }

                const indicatorX = sprite.container.x;
                const indicatorY = sprite.container.y + bottomOffset;
                const teamColor = this.isPlayerTeam ? 0x4488ff : 0xff4444; // Blue for player, Red for enemy

                console.log(`TC.showTurnIndicator: Calling turnIndicatorInstance.showAt for ${sprite.character?.name} at (${indicatorX}, ${indicatorY}) with color ${teamColor.toString(16)}`);
                const fadeInTime = 250; // ms - for smooth fade-in
                this.turnIndicatorInstance.showAt(indicatorX, indicatorY, teamColor, fadeInTime);
            } else {
                console.warn(`TC.showTurnIndicator: turnIndicatorInstance is null for ${this.isPlayerTeam ? 'Player' : 'Enemy'} team. Cannot show indicator.`);
            }
        }
    }

    /**
     * Clear all highlight effects from all characters in the team
     */
    clearAllHighlights() {
        // Add safety check
        if (!Array.isArray(this.characterSprites)) {
            console.warn(`[TeamContainer] clearAllHighlights: characterSprites is not an array, skipping clear operation.`);
            return; 
        }
        
        console.log(`TC.clearAllHighlights: Called for ${this.isPlayerTeam ? 'player' : 'enemy'} team, clearing highlights for ${this.characterSprites.length} sprites.`);
        
        // Unhighlight all characters in this team
        this.characterSprites.forEach((sprite, index) => {
            if (sprite && typeof sprite.unhighlight === 'function') {
                sprite.unhighlight();
            }
        });
    }
    
    /**
     * Clear turn indicators from all characters in the team
     */
    clearTurnIndicators() {
        // Add safety check
        if (!Array.isArray(this.characterSprites)) {
            console.warn(`[TeamContainer] clearTurnIndicators: characterSprites is not an array, skipping clear operation.`);
            return; 
        }
        
        if (this.turnIndicatorInstance) {
            console.log(`TC.clearTurnIndicators: Hiding turnIndicatorInstance for ${this.isPlayerTeam ? 'Player' : 'Enemy'} team.`);
            const fadeOutTime = 250; // ms - for smooth fade-out
            this.turnIndicatorInstance.hide(fadeOutTime); 
        } else {
            console.warn(`TC.clearTurnIndicators: turnIndicatorInstance is null for ${this.isPlayerTeam ? 'Player' : 'Enemy'} team. Cannot hide indicator.`);
        }
        
        console.log(`TC.clearTurnIndicators: Clearing turn indicators for ${this.isPlayerTeam ? 'player' : 'enemy'} team with ${this.characterSprites.length} sprites.`);
        
        // The following code is commented out as turnIndicatorInstance.hide() now handles the primary visual effect
        // Keeping as a reference for now
        /*
        this.characterSprites.forEach((sprite, index) => {
            if (sprite && typeof sprite.unhighlight === 'function') {
                sprite.unhighlight();
            }
        });
        */
    }

    /**
     * Debug method to log all character sprite ID mappings
     * @returns {Object} Debug information about all character mappings
     */
    debugCharacterIdMapping() {
        console.group(`TeamContainer Debug - ${this.isPlayerTeam ? 'Player' : 'Enemy'} Team Character Mappings:`);
        console.log(`Team Type: ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
        console.log(`Total Characters: ${this.characterSprites?.length || 0}`);
        
        const mappings = [];
        
        if (Array.isArray(this.characterSprites)) {
            this.characterSprites.forEach((sprite, index) => {
                if (!sprite || !sprite.character) {
                    console.log(`Character ${index}: Invalid sprite or character data`);
                    return;
                }
                
                const mapping = {
                    index,
                    name: sprite.character.name,
                    id: sprite.character.id,
                    uniqueId: sprite.character.uniqueId,
                    team: sprite.character.team || (this.isPlayerTeam ? 'player' : 'enemy'),
                    teamPrefix: this.isPlayerTeam ? 'player' : 'enemy',
                    prefixedIds: [
                        `${this.isPlayerTeam ? 'player' : 'enemy'}_${sprite.character.name}`,
                        `${this.isPlayerTeam ? 'player' : 'enemy'}_${sprite.character.name}_${sprite.character.id || index}`
                    ]
                };
                
                console.log(`Character ${index}:`, mapping);
                mappings.push(mapping);
            });
        } else {
            console.warn('No character sprites array available');
        }
        
        console.groupEnd();
        return mappings;
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        console.log(`TeamContainer destroy: Cleaning up team ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
        // Remove from global reference
        if (window.teamContainers) {
            window.teamContainers[this.isPlayerTeam ? 'player' : 'enemy'] = null;
        }

        // Destroy all character sprites
         if (Array.isArray(this.characterSprites)) {
             this.characterSprites.forEach(sprite => {
                  if (sprite && typeof sprite.destroy === 'function') sprite.destroy()
             });
             this.characterSprites = []; // Clear the array
         }
        
        // Destroy the TurnIndicator instance
        if (this.turnIndicatorInstance) {
            if (typeof this.turnIndicatorInstance.destroy === 'function') {
                this.turnIndicatorInstance.destroy();
                console.log(`TeamContainer destroy: TurnIndicator instance destroyed for team ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
            }
            this.turnIndicatorInstance = null;
        }

        // Destroy container
        if (this.container) {
             try {
                 this.container.destroy();
                 console.log(`TeamContainer destroy: Container destroyed for team ${this.isPlayerTeam ? 'Player' : 'Enemy'}`);
             } catch(error) {
                  console.error(`TeamContainer destroy: Error destroying container for team ${this.isPlayerTeam ? 'Player' : 'Enemy'}:`, error);
             }
             this.container = null; // Nullify reference
        }
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TeamContainer;
}

// Make available globally
window.TeamContainer = TeamContainer;

===== FILE: TurnIndicator.js =====
/**
 * TurnIndicator.js
 * A floor marker component that highlights the active character's position during battle
 * 
 * @version 0.6.3.5
 * @updated Improved fade-in/fade-out animations with sequential tweening
 */

class TurnIndicator extends Phaser.GameObjects.Graphics {
    /**
     * Constructor for TurnIndicator
     * @param {Phaser.Scene} scene - The scene this indicator belongs to
     */
    constructor(scene) {
        super(scene);
        scene.add.existing(this);
        this.setAlpha(0);
        this.scene = scene;
        this.fadeTween = null;
    }

    /**
     * Show the indicator at specified position with given color
     * @param {number} x - X position for the indicator
     * @param {number} y - Y position for the indicator
     * @param {number} color - Color of the indicator (hexadecimal)
     * @param {number} fadeInDuration - Duration of fade-in animation in milliseconds
     * @param {number} offsetY - Optional vertical offset for fine-tuning position
     */
    showAt(x, y, color, fadeInDuration = 300, offsetY = -8) {
        if (this.fadeTween) {
            this.fadeTween.stop();
            this.fadeTween = null;
        }

        this.clear();
        this.setPosition(x, y + offsetY);
        
        // Create a flattened ellipse for the floor marker
        // Simplified version without shadow
        // Reduced by 25% while maintaining same proportions
        const radius = 56; // 75 * 0.75 = 56.25 (rounded to 56)
        
        // Draw the highlight ellipse with solid color
        this.fillStyle(color, 0.9); // Keep fill alpha high for visibility during pulse
        this.fillEllipse(0, 0, radius, radius * 0.27); // Flattened ellipse
        
        this.setAlpha(0); // Explicitly set alpha to 0 before fade-in

        // Initial Fade-In Tween
        this.scene.tweens.add({
            targets: this,
            alpha: 0.3, // Target alpha for the start of the pulse
            duration: fadeInDuration, // Use the passed-in duration for fade-in
            ease: 'Linear', // Or 'Sine.easeOut'
            onComplete: () => {
                // Ensure this instance hasn't been destroyed or hidden in the meantime
                if (!this.scene || !this.active) return; 

                // Start Pulsing Tween AFTER fade-in is complete
                if (this.fadeTween) { // Stop any remnants of the fade-in tween just in case
                    this.fadeTween.stop();
                }
                this.fadeTween = this.scene.tweens.add({
                    targets: this,
                    alpha: { from: 0.3, to: 0.7 }, // Pulsing range
                    duration: 800, // Duration of one pulse cycle (e.g., 0.3 -> 0.7 -> 0.3)
                    ease: 'Sine.easeInOut',
                    yoyo: true,
                    repeat: -1 // Infinite repetition
                });
            }
        });
    }

    /**
     * Hide the indicator with a fade out animation
     * @param {number} duration - Duration of fade-out animation in milliseconds
     */
    hide(duration = 300) {
        if (this.fadeTween) {
            this.fadeTween.stop();
            this.fadeTween = null;
        }

        this.fadeTween = this.scene.tweens.add({
            targets: this,
            alpha: 0,
            duration: duration,
            ease: 'Sine.easeOut'
        });
    }

    /**
     * Clean up the indicator resources
     * @param {boolean} fromScene - Whether this is being destroyed by a scene
     */
    destroy(fromScene) {
        if (this.fadeTween) {
            this.fadeTween.stop();
            this.fadeTween = null;
        }
        super.destroy(fromScene);
    }
}

// Make component available globally
if (typeof window !== 'undefined') {
    window.TurnIndicator = TurnIndicator;
    console.log("TurnIndicator loaded and registered globally - enhanced animations with sequential tweening");
}


===== FILE: EffectManager.js =====
/**
 * EffectManager.js
 * Manages and displays visual effects for abilities in the battle scene
 */
class EffectManager {
    /**
     * Create a new EffectManager
     * @param {Phaser.Scene} scene - The scene this effect manager belongs to
     */
    constructor(scene) {
        this.scene = scene;
        this.effects = {};
        this.activeEffects = [];
        
        // Initialize particle emitters and effect definitions
        this.initializeEffects();

        // Track particles for cleanup
        this.particleManagers = [];
    }

    /**
     * Initialize effect definitions and particle emitters
     */
    initializeEffects() {
        // Define effect types
        this.effects = {
            // Fire effects
            fire: {
                color: 0xff4400,
                secondaryColor: 0xff8800,
                particleCount: 40,
                lifespan: 800,
                scale: { start: 0.2, end: 0 },
                speed: { min: 50, max: 100 },
                createEffect: (x, y, targetX, targetY) => this.createFireEffect(x, y, targetX, targetY)
            },
            
            // Water effects
            water: {
                color:

===== FILE: Button.js =====
/**
 * Button Component
 * A reusable button component for Phaser UI
 */
class Button extends Phaser.GameObjects.Container {
    /**
     * Create a new button
     * @param {Phaser.Scene} scene - The scene this button belongs to
     * @param {number} x - The x position
     * @param {number} y - The y position
     * @param {string} text - The button text
     * @param {Object} style - The button style
     * @param {Function} callback - The callback function
     */
    constructor(scene, x, y, text, style = {}, callback = null) {
        super(scene, x, y);
        
        // Default style
        this.style = {
            width: style.width || 200,
            height: style.height || 50,
            color: style.color || 0x3742fa,
            hoverColor: style.hoverColor || 0x2536e0,
            disabledColor: style.disabledColor || 0x596275,
            textColor: style.textColor || '#ffffff',
            fontSize: style.fontSize || '18px',
            fontFamily: style.fontFamily || 'Arial',
            cornerRadius: style.cornerRadius || 8,
            ...style
        };
        
        // Create background
        this.background = scene.add.rectangle(0, 0, this.style.width, this.style.height, this.style.color)
            .setOrigin(0.5)
            .setInteractive({ useHandCursor: true });
        
        // Round corners if specified
        if (this.style.cornerRadius > 0) {
            this.background.setRoundedRectangle(
                this.style.width,
                this.style.height,
                this.style.cornerRadius
            );
        }
        
        // Create text
        this.text = scene.add.text(0, 0, text, {
            fontFamily: this.style.fontFamily,
            fontSize: this.style.fontSize,
            fill: this.style.textColor,
            align: 'center'
        }).setOrigin(0.5);
        
        // Add to container
        this.add([this.background, this.text]);
        
        // Add to scene
        scene.add.existing(this);
        
        // Set up events
        this.setupEvents(callback);
        
        // Set initial state
        this.setEnabled(true);
    }
    
    /**
     * Set up button events
     * @param {Function} callback - The callback function
     */
    setupEvents(callback) {
        // Hover effects
        this.background.on('pointerover', () => {
            if (this.enabled) {
                this.background.fillColor = this.style.hoverColor;
                
                // Scale effect
                this.scene.tweens.add({
                    targets: this,
                    scaleX: 1.05,
                    scaleY: 1.05,
                    duration: 100,
                    ease: 'Power1'
                });
            }
        });
        
        this.background.on('pointerout', () => {
            if (this.enabled) {
                this.background.fillColor = this.style.color;
                
                // Reset scale
                this.scene.tweens.add({
                    targets: this,
                    scaleX: 1,
                    scaleY: 1,
                    duration: 100,
                    ease: 'Power1'
                });
            }
        });
        
        // Click effect
        this.background.on('pointerdown', () => {
            if (this.enabled) {
                // Play sound if available
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
                
                // Scale down effect
                this.scene.tweens.add({
                    targets: this,
                    scaleX: 0.95,
                    scaleY: 0.95,
                    duration: 50,
                    ease: 'Power1',
                    yoyo: true,
                    onComplete: () => {
                        // Execute callback
                        if (callback) {
                            callback();
                        }
                    }
                });
            }
        });
    }
    
    /**
     * Set the button text
     * @param {string} text - The new button text
     */
    setText(text) {
        this.text.setText(text);
        return this;
    }
    
    /**
     * Enable or disable the button
     * @param {boolean} enabled - Whether the button should be enabled
     */
    setEnabled(enabled) {
        this.enabled = enabled;
        
        if (enabled) {
            this.background.fillColor = this.style.color;
            this.text.setAlpha(1);
            this.background.input.cursor = 'pointer';
        } else {
            this.background.fillColor = this.style.disabledColor;
            this.text.setAlpha(0.6);
            this.background.input.cursor = 'default';
        }
        
        return this;
    }
}


===== FILE: Panel.js =====
/**
 * Panel Component
 * A reusable panel/container component for Phaser UI
 */
class Panel extends Phaser.GameObjects.Container {
    /**
     * Create a new panel
     * @param {Phaser.Scene} scene - The scene this panel belongs to
     * @param {number} x - The x position
     * @param {number} y - The y position
     * @param {number} width - The panel width
     * @param {number} height - The panel height
     * @param {Object} style - The panel style
     */
    constructor(scene, x, y, width, height, style = {}) {
        super(scene, x, y);
        
        this.width = width;
        this.height = height;
        
        // Default style
        this.style = {
            backgroundColor: style.backgroundColor || 0x232a40,
            borderColor: style.borderColor || 0x596275,
            borderWidth: style.borderWidth || 0,
            alpha: style.alpha !== undefined ? style.alpha : 1,
            cornerRadius: style.cornerRadius || 8,
            shadow: style.shadow !== undefined ? style.shadow : true,
            shadowColor: style.shadowColor || 0x000000,
            shadowAlpha: style.shadowAlpha || 0.5,
            shadowBlur: style.shadowBlur || 10,
            shadowOffsetX: style.shadowOffsetX || 0,
            shadowOffsetY: style.shadowOffsetY || 5,
            ...style
        };
        
        // Create the panel background
        this.createBackground();
        
        // Add to scene
        scene.add.existing(this);
    }
    
    /**
     * Create the panel background
     */
    createBackground() {
        // Add shadow first if enabled
        if (this.style.shadow) {
            this.shadow = this.scene.add.rectangle(
                this.style.shadowOffsetX,
                this.style.shadowOffsetY,
                this.width,
                this.height,
                this.style.shadowColor,
                this.style.shadowAlpha
            ).setOrigin(0.5);
            
            // Apply corner radius to shadow if needed
            if (this.style.cornerRadius > 0) {
                this.shadow.setRoundedRectangle(
                    this.width,
                    this.height,
                    this.style.cornerRadius
                );
            }
            
            // Add blur effect if supported
            if (this.shadow.postFX) {
                this.shadow.postFX.addBlur(0, 0, this.style.shadowBlur, this.style.shadowBlur, 0x000000, 1);
            }
            
            this.add(this.shadow);
        }
        
        // Create the main background
        this.background = this.scene.add.rectangle(
            0,
            0,
            this.width,
            this.height,
            this.style.backgroundColor,
            this.style.alpha
        ).setOrigin(0.5);
        
        // Apply corner radius if needed
        if (this.style.cornerRadius > 0) {
            this.background.setRoundedRectangle(
                this.width,
                this.height,
                this.style.cornerRadius
            );
        }
        
        this.add(this.background);
        
        // Add border if needed
        if (this.style.borderWidth > 0) {
            this.border = this.scene.add.rectangle(
                0,
                0,
                this.width,
                this.height,
                this.style.borderColor
            ).setOrigin(0.5)
            .setStrokeStyle(this.style.borderWidth, this.style.borderColor);
            
            // Apply corner radius to border
            if (this.style.cornerRadius > 0) {
                this.border.setRoundedRectangle(
                    this.width,
                    this.height,
                    this.style.cornerRadius
                );
            }
            
            this.add(this.border);
        }
    }
    
    /**
     * Add a title to the panel
     * @param {string} text - The title text
     * @param {Object} style - Text style options
     * @returns {Phaser.GameObjects.Text} The created text object
     */
    addTitle(text, style = {}) {
        // Default title style
        const titleStyle = {
            fontFamily: style.fontFamily || 'Arial',
            fontSize: style.fontSize || '24px',
            fill: style.fill || '#ffffff',
            align: style.align || 'center',
            ...style
        };
        
        // Create title text
        this.title = this.scene.add.text(
            0,
            -this.height / 2 + 20,
            text,
            titleStyle
        ).setOrigin(0.5, 0);
        
        this.add(this.title);
        return this.title;
    }
    
    /**
     * Set the background color
     * @param {number} color - The color value
     * @param {number} alpha - The alpha value
     */
    setBackgroundColor(color, alpha = 1) {
        this.background.fillColor = color;
        this.background.fillAlpha = alpha;
        return this;
    }
    
    /**
     * Make the panel interactive
     * @param {Function} callback - Callback function when clicked
     */
    setInteractive(callback = null) {
        this.background.setInteractive({ useHandCursor: true });
        
        if (callback) {
            this.background.on('pointerdown', callback);
        }
        
        return this;
    }
    
    /**
     * Add a fade-in animation to the panel
     * @param {number} duration - The animation duration in milliseconds
     */
    fadeIn(duration = 300) {
        this.alpha = 0;
        this.scene.tweens.add({
            targets: this,
            alpha: 1,
            duration: duration,
            ease: 'Power2'
        });
        return this;
    }
    
    /**
     * Add a slide-in animation to the panel
     * @param {string} direction - The direction to slide from ('up', 'down', 'left', 'right')
     * @param {number} distance - The slide distance in pixels
     * @param {number} duration - The animation duration in milliseconds
     */
    slideIn(direction = 'down', distance = 100, duration = 300) {
        const initialPosition = { x: this.x, y: this.y };
        
        switch (direction) {
            case 'up':
                this.y = initialPosition.y + distance;
                break;
            case 'down':
                this.y = initialPosition.y - distance;
                break;
            case 'left':
                this.x = initialPosition.x + distance;
                break;
            case 'right':
                this.x = initialPosition.x - distance;
                break;
        }
        
        this.scene.tweens.add({
            targets: this,
            x: initialPosition.x,
            y: initialPosition.y,
            duration: duration,
            ease: 'Power2'
        });
        
        return this;
    }
}


===== FILE: BattleEventManager.js =====
/**
 * BattleEventManager.js
 * Manages event listening setup and event handling for the BattleScene
 * Version: 0.6.2.3 (TeamDisplayManager integration)
 */

class BattleEventManager {
    /**
     * Creates a new BattleEventManager
     * @param {Phaser.Scene} scene - Reference to the BattleScene
     * @param {object} battleBridge - Reference to the BattleBridge for event communication
     */
    constructor(scene, battleBridge) {
        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
        console.log('[BEM Constructor] === CONSTRUCTOR FIRST LINE ===');
        
        // Validate dependencies
        if (!scene) {
            console.error("[BattleEventManager] Missing required scene reference");
            return;
        }
        
        if (!battleBridge) {
            console.error("[BattleEventManager] Missing required battleBridge reference");
            return;
        }
        
        this.scene = scene;
        this.battleBridge = battleBridge;
        this.teamManager = null; // Will be set via setTeamManager if available
        this.battleLog = null; // Will be set via setBattleLog if available
        this.boundHandlers = new Map(); // For tracking bound handlers
        
        console.log("[BattleEventManager] Initializing with battleBridge:", {
            hasBattleBridge: !!this.battleBridge,
            eventTypesAvailable: this.battleBridge && this.battleBridge.eventTypes ? Object.keys(this.battleBridge.eventTypes) : 'none',
            hasAddEventListener: this.battleBridge && typeof this.battleBridge.addEventListener === 'function'
        });
        
        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
        console.log('[BEM Constructor] battleBridge TYPEOF addEventListener:', typeof this.battleBridge?.addEventListener, 'CHARACTER_ACTION type value:', this.battleBridge?.eventTypes?.CHARACTER_ACTION);
        
        this.initialize();
    }

    /**
     * Initialize the event manager and set up event listeners
     */
    initialize() {
        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
        console.log('[BEM initialize] === INITIALIZE FIRST LINE ===');
        
        // Bind all event handlers to preserve 'this' context
        this.handleTurnStarted = this.handleTurnStarted.bind(this);
        this.handleStatusEffectApplied = this.handleStatusEffectApplied.bind(this);
        this.handleStatusEffectRemoved = this.handleStatusEffectRemoved.bind(this);
        this.handleStatusEffectUpdated = this.handleStatusEffectUpdated.bind(this);
        this.onCharacterDamaged = this.onCharacterDamaged.bind(this);
        this.onCharacterHealed = this.onCharacterHealed.bind(this);
        this.onCharacterAction = this.onCharacterAction.bind(this);
        this.onAbilityUsed = this.onAbilityUsed.bind(this);
        this.handleBattleEnded = this.handleBattleEnded.bind(this);
        this.handleBattleLog = this.handleBattleLog.bind(this);

        // Setup all event listeners
        this.setupCoreEventListeners();
        this.setupStatusEffectListeners();
        this.setupHealthUpdateListeners();
        this.setupActionIndicatorListeners();

        console.log("[BattleEventManager] Initialization complete");
    }

    /**
     * Set the TeamDisplayManager reference
     * @param {TeamDisplayManager} teamManager - The TeamDisplayManager instance
     */
    setTeamManager(teamManager) {
        if (!teamManager) {
            console.warn("[BattleEventManager] setTeamManager: Missing TeamDisplayManager reference");
            return;
        }
        
        console.log("[BattleEventManager] Setting TeamDisplayManager reference");
        this.teamManager = teamManager;
    }
    
    /**
     * Set the battle log reference
     * @param {DirectBattleLog} battleLog - The DirectBattleLog instance
     */
    setBattleLog(battleLog) {
        if (!battleLog) {
            console.warn("[BattleEventManager] setBattleLog: Missing battle log reference");
            return;
        }
        
        console.log("[BattleEventManager] Setting DirectBattleLog reference");
        this.battleLog = battleLog;
    }

    /**
     * Set up core battle flow event listeners
     */
    setupCoreEventListeners() {
        if (!this.battleBridge) {
            console.warn("[BattleEventManager] Cannot setup core event listeners - battleBridge not available");
            return;
        }
        
        // Store the bound handler and add event listener
        this.registerEventHandler(
            this.battleBridge.eventTypes.TURN_STARTED, 
            this.handleTurnStarted
        );

        // Battle ended event listener
        this.registerEventHandler(
            this.battleBridge.eventTypes.BATTLE_ENDED,
            this.handleBattleEnded
        );
        
        // Battle log event listener
        this.registerEventHandler(
            this.battleBridge.eventTypes.BATTLE_LOG,
            this.handleBattleLog
        );
    }

    /**
     * Set up status effect related event listeners
     */
    setupStatusEffectListeners() {
        if (!this.battleBridge) {
            console.warn("[BattleEventManager] Cannot setup status effect listeners - battleBridge not available");
            return;
        }

        // Status effect listeners
        this.registerEventHandler(
            this.battleBridge.eventTypes.STATUS_EFFECT_APPLIED,
            this.handleStatusEffectApplied
        );

        this.registerEventHandler(
            this.battleBridge.eventTypes.STATUS_EFFECT_REMOVED,
            this.handleStatusEffectRemoved
        );

        this.registerEventHandler(
            this.battleBridge.eventTypes.STATUS_EFFECT_UPDATED,
            this.handleStatusEffectUpdated
        );
    }

    /**
     * Set up health update related event listeners
     */
    setupHealthUpdateListeners() {
        if (!this.battleBridge) {
            console.warn("[BattleEventManager] Cannot setup health update listeners - battleBridge not available");
            return;
        }

        // Health update listeners
        this.registerEventHandler(
            this.battleBridge.eventTypes.CHARACTER_DAMAGED,
            this.onCharacterDamaged
        );

        this.registerEventHandler(
            this.battleBridge.eventTypes.CHARACTER_HEALED,
            this.onCharacterHealed
        );
    }

    /**
     * Set up action indicator related event listeners
     */
    setupActionIndicatorListeners() {
        if (!this.battleBridge) {
            console.warn("[BattleEventManager] Cannot setup action indicator listeners - battleBridge not available");
            return;
        }

        // DIAGNOSTIC: Log the specific event types we're about to register for
        console.log('[BattleEventManager] Setting up action indicator listeners with event types:', {
            CHARACTER_ACTION: this.battleBridge.eventTypes.CHARACTER_ACTION,
            ABILITY_USED: this.battleBridge.eventTypes.ABILITY_USED
        });

        // Action indicator listeners
        this.registerEventHandler(
            this.battleBridge.eventTypes.CHARACTER_ACTION,
            this.onCharacterAction
        );

        this.registerEventHandler(
            this.battleBridge.eventTypes.ABILITY_USED,
            this.onAbilityUsed
        );
        
        // DIAGNOSTIC: Verify registration worked by checking boundHandlers map
        console.log('[BattleEventManager] Action indicators registered:', {
            characterActionBound: this.boundHandlers.has(this.battleBridge.eventTypes.CHARACTER_ACTION),
            abilityUsedBound: this.boundHandlers.has(this.battleBridge.eventTypes.ABILITY_USED)
        });
    }

    /**
     * Helper method to register an event handler and track it for cleanup
     * @param {string} eventType - The event type to listen for
     * @param {function} handler - The bound handler function
     */
    registerEventHandler(eventType, handler) {
        // TEMP DIAGNOSTIC - DELETE AFTER TROUBLESHOOTING
        console.log('[BEM registerEventHandler] Attempting for event:', eventType, 'Handler name:', handler.name || 'anonymous_BEM_handler');
        
        if (!this.battleBridge || !eventType || !handler) {
            console.warn("[BattleEventManager] Cannot register event handler - missing required parameters");
            return;
        }

        // DIAGNOSTIC: Check handler binding
        console.log(`[BattleEventManager] Registering handler for ${eventType}:`, {
            handlerType: typeof handler,
            handlerToString: handler.toString().substring(0, 100) + '...',
            boundThis: handler.hasOwnProperty('this') ? 'has this context' : 'no this context',
        });

        // Store the handler for later cleanup
        this.boundHandlers.set(eventType, handler);
        
        // Register with battleBridge
        this.battleBridge.addEventListener(eventType, handler);
        
        // DIAGNOSTIC: Verify registration
        console.log(`[BattleEventManager] Handler registered for ${eventType}. Now checking battleBridge event listeners:`);
        
        // Try to access the listeners array to verify registration (defensive approach)
        try {
            if (this.battleBridge.eventListeners && this.battleBridge.eventListeners[eventType]) {
                const listenerCount = this.battleBridge.eventListeners[eventType].length;
                console.log(`[BattleEventManager] BattleBridge reports ${listenerCount} listeners for ${eventType}`);
            } else {
                console.warn(`[BattleEventManager] Could not verify listener count in battleBridge for ${eventType}`);
            }
        } catch (error) {
            console.error(`[BattleEventManager] Error verifying listener registration:`, error);
        }
    }

    /**
     * Handle turn started event
     * @param {Object} data - Event data
     */
    handleTurnStarted(data) {
        if (!data || !this.scene) return;

        try {
            // Update turn number display
            if (this.scene.updateTurnNumberDisplay) {
                this.scene.updateTurnNumberDisplay(data.turnNumber);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling turn started:", error);
        }
    }

    /**
     * Handle status effect applied event
     * @param {Object} data - Event data
     */
    handleStatusEffectApplied(data) {
        if (!data || !data.target || !this.scene) return;

        try {
            // Find the target character sprite
            const characterSprite = this.getCharacterSprite(data.target);
            if (!characterSprite) return;

            // Update status effect display
            characterSprite.addStatusEffect(data.effect);

            // Show floating text for status application
            const floatingTextConfig = {
                text: `${data.effect.name} applied!`,
                style: { fontSize: '16px', fill: '#FF00FF' }
            };

            if (this.scene.showFloatingText) {
                this.scene.showFloatingText(data.target, floatingTextConfig.text, floatingTextConfig.style);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling status effect applied:", error);
        }
    }

    /**
     * Handle status effect removed event
     * @param {Object} data - Event data
     */
    handleStatusEffectRemoved(data) {
        if (!data || !data.target || !this.scene) return;

        try {
            // Find the target character sprite
            const characterSprite = this.getCharacterSprite(data.target);
            if (!characterSprite) return;

            // Update status effect display
            characterSprite.removeStatusEffect(data.effectId);

            // Show floating text for status removal
            const floatingTextConfig = {
                text: `${data.effectName} faded!`,
                style: { fontSize: '16px', fill: '#8F8FFF' }
            };

            if (this.scene.showFloatingText) {
                this.scene.showFloatingText(data.target, floatingTextConfig.text, floatingTextConfig.style);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling status effect removed:", error);
        }
    }

    /**
     * Handle status effect updated event
     * @param {Object} data - Event data
     */
    handleStatusEffectUpdated(data) {
        // Currently empty in original code, keeping as placeholder for future implementation
        if (!data) return;
        
        // Will implement when needed in future versions
    }

    /**
     * Handle character damaged event
     * @param {Object} data - Event data
     */
    onCharacterDamaged(data) {
        if (!data || !data.character || !this.scene) return;

        try {
            // Find the character sprite
            const characterSprite = this.getCharacterSprite(data.character);
            if (!characterSprite) return;

            // Update health display
            characterSprite.updateHealth(data.newHealth, data.maxHealth);

            // Display floating damage text
            const amount = data.amount || 0;
            const isCritical = data.isCritical || false;
            
            const floatingTextConfig = {
                text: `-${amount}`,
                style: { 
                    fontSize: isCritical ? '24px' : '20px', 
                    fill: isCritical ? '#FF0000' : '#FF4444',
                    fontStyle: isCritical ? 'bold' : 'normal'
                }
            };

            if (this.scene.showFloatingText) {
                this.scene.showFloatingText(data.character, floatingTextConfig.text, floatingTextConfig.style);
            }

            // Show attack animation if source is available
            if (data.source && this.scene.showAttackAnimation) {
                this.scene.showAttackAnimation(data.source, data.character);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling character damaged:", error);
        }
    }

    /**
     * Handle character healed event
     * @param {Object} data - Event data
     */
    onCharacterHealed(data) {
        if (!data || !data.character || !this.scene) return;

        try {
            // Find the character sprite
            const characterSprite = this.getCharacterSprite(data.character);
            if (!characterSprite) return;

            // Update health display
            characterSprite.updateHealth(data.newHealth, data.maxHealth);

            // Display floating healing text
            const amount = data.amount || 0;
            
            const floatingTextConfig = {
                text: `+${amount}`,
                style: { fontSize: '20px', fill: '#00FF00' }
            };

            if (this.scene.showFloatingText) {
                this.scene.showFloatingText(data.character, floatingTextConfig.text, floatingTextConfig.style);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling character healed:", error);
        }
    }

    /**
    * Handle character action event
    * @param {Object} data - Event data
    */
    onCharacterAction(data) {
    console.log(`BEM.onCharacterAction (for Turn Highlighting): Called for CHARACTER_ACTION. Character: ${data?.character?.name}, Event Data:`, data);
    
    if (!data || !data.character || !this.scene) return;

    try {
    // Log the entire event data for diagnosis
    console.log(`[BattleEventManager.onCharacterAction] EVENT DATA RECEIVED:`, data);
    console.log(`[BattleEventManager.onCharacterAction] data.action object:`, data.action);
    
    console.log(`BEM.onCharacterAction (for Turn Highlighting): this.teamManager is ${this.teamManager ? 'defined' : 'undefined'}. Attempting to call updateActiveCharacterVisuals.`);
    // Update active character visuals using TeamDisplayManager if available
    if (this.teamManager && typeof this.teamManager.updateActiveCharacterVisuals === 'function') {
    this.teamManager.updateActiveCharacterVisuals(data.character);
    } else if (this.scene.updateActiveCharacterVisuals) {
    this.scene.updateActiveCharacterVisuals(data.character);
    }

    // Update action text in UI manager
    if (this.scene.uiManager && typeof this.scene.uiManager.updateActionTextDisplay === 'function') {
    this.scene.uiManager.updateActionTextDisplay(this.scene.battleState.currentTurn, data.character);
    }

    // DIAGNOSTIC: Log action object properties for UI
    console.log(`[BattleEventManager.onCharacterAction] Received action for UI: actionType='${data.action?.actionType}', abilityName='${data.action?.abilityName}'. Preparing to call showActionText.`);

    // Show action indicator on character
    console.log(`BEM.onCharacterAction (for Action Indicator): Character: ${data.character?.name}. Attempting to find CharacterSprite via TeamDisplayManager for showActionText.`);
    const characterSprite = this.getCharacterSprite(data.character);
    console.log(`BEM.onCharacterAction: CharacterSprite found: ${characterSprite ? 'yes' : 'null'}`);
        
    // Get the text to display based on the action type
        let actionText = "Auto Attack"; // Default
            
            // If we have an action with an actionType and abilityName, use them
            if (data.action && data.action.actionType === 'ability' && data.action.abilityName) {
                actionText = `${data.action.abilityName}`;
                console.log(`[BattleEventManager] Using ability name for action indicator: ${actionText}`);
            } else {
                console.log(`[BattleEventManager] Using default 'Auto Attack' for action indicator due to missing action data`);
                // Debug more information about why we're not seeing the right action type
                if (data.action) {
                    console.log(`[BattleEventManager] Action object exists but didn't match criteria:`, {
                        actionType: data.action.actionType,
                        actionTypeIsAbility: data.action.actionType === 'ability',
                        hasAbilityName: !!data.action.abilityName,
                        abilityName: data.action.abilityName
                    });
                }
            }
            
            console.log(`[BattleEventManager.onCharacterAction] Determined actionText for CharacterSprite: '${actionText}' based on type: '${data.action?.actionType}' and name: '${data.action?.abilityName}'`);
            
            if (characterSprite && characterSprite.showActionText) {
                characterSprite.showActionText(actionText);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling character action:", error);
        }
    }

    /**
     * Handle ability used event
     * @param {Object} data - Event data
     */
    onAbilityUsed(data) {
        console.log(`BEM.onAbilityUsed (for Action Indicator): Character: ${data?.character?.name}, Ability: ${data?.ability?.name}. Event Data:`, data, `Attempting to find CharacterSprite via TeamDisplayManager for showActionText.`);
        
        if (!data || !data.character || !data.ability || !this.scene) return;

        try {
            // Show action indicator on character
            const characterSprite = this.getCharacterSprite(data.character);
            console.log(`BEM.onAbilityUsed: CharacterSprite found: ${characterSprite ? 'yes' : 'null'}`);
            if (characterSprite && characterSprite.showActionText) {
                // DIAGNOSTIC: Log data received about ability
                console.log(`[BattleEventManager.onAbilityUsed] Showing ability: '${data.ability.name}'`);
                
                // Always display the ability name directly, not prefixed with "Ability:"
                characterSprite.showActionText(`${data.ability.name}`);
            }
        } catch (error) {
            console.error("[BattleEventManager] Error handling ability used:", error);
        }
    }

    /**
     * Handle battle ended event
     * @param {Object} data - Event data, including data.winner
     */
    handleBattleEnded(data) {
        if (!data || !this.scene) {
            console.warn("[BattleEventManager] handleBattleEnded: Missing data or scene reference.");
            return;
        }

        if (typeof this.scene.showBattleOutcome === 'function') {
            try {
                console.log(`[BattleEventManager] Battle ended. Result: ${data.winner}. Calling scene.showBattleOutcome.`);
                this.scene.showBattleOutcome(data.winner);
            } catch (error) {
                console.error("[BattleEventManager] Error calling this.scene.showBattleOutcome:", error);
            }
        } else {
            console.error("[BattleEventManager] this.scene.showBattleOutcome is not a function. Cannot display battle outcome.");
        }
    }
    
    /**
     * Handle battle log event
     * @param {Object} data - Event data
     */
    handleBattleLog(data) {
        if (!data || !data.message) {
            console.warn("[BattleEventManager] handleBattleLog: Missing message data");
            return;
        }

        try {
            // Check if we have a direct reference to the battle log
            if (this.battleLog && typeof this.battleLog.addMessage === 'function') {
                this.battleLog.addMessage(data.message, data.type || 'default');
                return;
            }
            
            // Fallback: try to access the battle log through the scene if available
            if (this.scene && this.scene.battleLog && typeof this.scene.battleLog.addMessage === 'function') {
                this.scene.battleLog.addMessage(data.message, data.type || 'default');
                return;
            }
            
            // Second fallback: try to access through window
            if (window.battleLog && typeof window.battleLog.addMessage === 'function') {
                window.battleLog.addMessage(data.message, data.type || 'default');
                return;
            }
            
            // If we get here, we couldn't find any way to log the message
            console.warn(`[BattleEventManager] Could not find battle log to display message: ${data.message}`);
        } catch (error) {
            console.error("[BattleEventManager] Error handling battle log event:", error);
        }
    }

    /**
     * Helper method to find character sprite based on character data
     * @param {Object} characterData - The character data object
     * @returns {CharacterSprite|null} The character sprite or null if not found
     */
    getCharacterSprite(characterData) {
        if (!characterData) {
            console.warn("[BattleEventManager] getCharacterSprite: Missing character data");
            return null;
        }

        // Try TeamDisplayManager first if available
        if (this.teamManager && typeof this.teamManager.getCharacterSprite === 'function') {
            const sprite = this.teamManager.getCharacterSprite(characterData);
            if (sprite) return sprite;
        }

        // Fallback to legacy approach using team containers directly
        if (!this.scene) {
            console.warn("[BattleEventManager] getCharacterSprite: Missing scene reference");
            return null;
        }

        // Determine which team container to use based on character's team property
        let teamContainer = null;
        if (characterData.team === 'player') {
            teamContainer = this.scene.playerTeamContainer;
        } else if (characterData.team === 'enemy') {
            teamContainer = this.scene.enemyTeamContainer;
        }

        // If we couldn't determine team, try both containers
        if (!teamContainer) {
            // Try player team first
            if (this.scene.playerTeamContainer) {
                const sprite = this.scene.playerTeamContainer.findCharacterSprite(characterData);
                if (sprite) return sprite;
            }

            // Then try enemy team
            if (this.scene.enemyTeamContainer) {
                const sprite = this.scene.enemyTeamContainer.findCharacterSprite(characterData);
                if (sprite) return sprite;
            }

            console.warn(`[BattleEventManager] getCharacterSprite: Could not determine team for character ${characterData.name || characterData.uniqueId || 'unknown'}, and search in both teams failed`);
            return null;
        }

        // If we have a specific team container, use it
        if (!teamContainer.findCharacterSprite) {
            console.error(`[BattleEventManager] getCharacterSprite: findCharacterSprite method is missing on ${characterData.team} team container`);
            return null;
        }

        // Use the findCharacterSprite method
        const sprite = teamContainer.findCharacterSprite(characterData);
        if (!sprite) {
            console.warn(`[BattleEventManager] getCharacterSprite: Character sprite not found for ${characterData.name || characterData.uniqueId || 'unknown'} in ${characterData.team} team`);
        }

        return sprite;
    }

    /**
     * Clean up event listeners
     */
    cleanup() {
        console.log("[BattleEventManager] Cleaning up event listeners");
        
        // Remove all registered event listeners
        if (this.battleBridge) {
            // Remove all listeners using the bound handlers we stored
            for (const [eventType, handler] of this.boundHandlers.entries()) {
                try {
                    this.battleBridge.removeEventListener(eventType, handler);
                } catch (error) {
                    console.warn(`[BattleEventManager] Error removing listener for ${eventType}:`, error);
                }
            }
        }
        
        // Clear tracking map
        this.boundHandlers.clear();
        
        console.log("[BattleEventManager] Event listeners cleaned up");
    }

    /**
     * Destroy the event manager and clean up resources
     */
    destroy() {
        console.log("[BattleEventManager] Destroying...");
        this.cleanup();
        
        // Clear references
        this.scene = null;
        this.battleBridge = null;
        this.teamManager = null;
        
        console.log("[BattleEventManager] Destroyed");
    }
}

// Make BattleEventManager available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleEventManager = BattleEventManager;
    console.log("BattleEventManager class definition loaded");
}


===== FILE: CoordinateDisplay.js =====
/**
 * CoordinateDisplay.js
 * Provides a coordinate grid overlay and mouse position tracking for debugging
 */

class CoordinateDisplay {
    /**
     * @param {Phaser.Scene} scene - The scene to attach to
     * @param {Object} config - Configuration options
     */
    constructor(scene, config = {}) {
        this.scene = scene;
        
        // Configuration with defaults
        this.config = {
            gridSpacing: config.gridSpacing || 50,
            showGrid: config.showGrid !== undefined ? config.showGrid : true,
            showCoordinates: config.showCoordinates !== undefined ? config.showCoordinates : true,
            gridColor: config.gridColor || 0x00ff00,
            gridAlpha: config.gridAlpha || 0.3,
            textColor: config.textColor || '#00ff00',
            fontSize: config.fontSize || 12,
            fontFamily: config.fontFamily || 'Arial',
            backgroundColor: config.backgroundColor || '#000000',
            backgroundAlpha: config.backgroundAlpha || 0.7,
            enabled: config.enabled !== undefined ? config.enabled : true
        };
        
        // Graphics objects
        this.gridContainer = null;
        this.grid = null;
        this.coordinateText = null;
        
        // State tracking
        this.enabled = this.config.enabled;
        
        // Create the display elements
        this.create();
        
        // Make available globally for debugging
        window.CoordinateDisplay = this;
    }
    
    /**
     * Create the grid and coordinate display
     */
    create() {
        // Create a container to hold grid graphics and text labels
        this.gridContainer = this.scene.add.container();
        this.gridContainer.setDepth(1000); // Ensure it's above other elements
        
        // Create the grid graphics object
        this.grid = this.scene.add.graphics();
        this.gridContainer.add(this.grid); // Add graphics to container
        
        // Create coordinate text
        this.coordinateText = this.scene.add.text(10, 10, 'X: 0 Y: 0', {
            fontFamily: this.config.fontFamily,
            fontSize: this.config.fontSize,
            color: this.config.textColor,
            backgroundColor: this.config.backgroundColor + Math.floor(this.config.backgroundAlpha * 255).toString(16).padStart(2, '0'),
            padding: { x: 5, y: 2 }
        });
        this.coordinateText.setDepth(1001); // Above grid
        this.coordinateText.setScrollFactor(0); // Fixed to camera
        
        // Set initial visibility
        this.gridContainer.visible = this.config.showGrid && this.enabled;
        this.coordinateText.visible = this.config.showCoordinates && this.enabled;
        
        // Draw the initial grid
        this.drawGrid();
        
        // Add mouse move listener for coordinate tracking
        this.scene.input.on('pointermove', this.updateCoordinates, this);
        
        // Add keyboard shortcut for toggling (Ctrl+G)
        this.scene.input.keyboard.on('keydown-G', (event) => {
            if (this.scene.input.keyboard.checkModifierKey(event, 'ctrl')) {
                this.toggle();
            }
        });
        
        console.log('CoordinateDisplay: Created');
    }
    
    /**
     * Draw the coordinate grid
     */
    drawGrid() {
        // Clear any existing grid
        this.grid.clear();
        
        if (!this.config.showGrid || !this.enabled) return;
        
        // Set line style
        this.grid.lineStyle(1, this.config.gridColor, this.config.gridAlpha);
        
        // Get scene dimensions
        const width = this.scene.cameras.main.width;
        const height = this.scene.cameras.main.height;
        
        // Draw vertical lines
        for (let x = 0; x < width; x += this.config.gridSpacing) {
            this.grid.beginPath();
            this.grid.moveTo(x, 0);
            this.grid.lineTo(x, height);
            this.grid.strokePath();
            
            // Add coordinate label for x
            if (x > 0) {
                const text = this.scene.add.text(x, 0, x.toString(), {
                    fontFamily: this.config.fontFamily,
                    fontSize: 10,
                    color: this.config.textColor
                });
                text.setDepth(1000);
                text.setOrigin(0.5, 0);
                this.gridContainer.add(text); // Add to container so it gets destroyed with grid
            }
        }
        
        // Draw horizontal lines
        for (let y = 0; y < height; y += this.config.gridSpacing) {
            this.grid.beginPath();
            this.grid.moveTo(0, y);
            this.grid.lineTo(width, y);
            this.grid.strokePath();
            
            // Add coordinate label for y
            if (y > 0) {
                const text = this.scene.add.text(0, y, y.toString(), {
                    fontFamily: this.config.fontFamily,
                    fontSize: 10,
                    color: this.config.textColor
                });
                text.setDepth(1000);
                text.setOrigin(0, 0.5);
                this.gridContainer.add(text); // Add to container so it gets destroyed with grid
            }
        }
    }
    
    /**
     * Update the coordinate display based on mouse position
     * @param {Phaser.Input.Pointer} pointer - The mouse/touch pointer
     */
    updateCoordinates(pointer) {
        if (!this.config.showCoordinates || !this.enabled) return;
        
        // Get pointer world position (taking into account camera scroll)
        const x = Math.floor(pointer.worldX);
        const y = Math.floor(pointer.worldY);
        
        // Update the text display
        this.coordinateText.setText(`X: ${x} Y: ${y}`);
    }
    
    /**
     * Toggle the coordinate display on/off
     */
    toggle() {
        this.enabled = !this.enabled;
        
        // Update visibility
        this.gridContainer.visible = this.config.showGrid && this.enabled;
        this.coordinateText.visible = this.config.showCoordinates && this.enabled;
        
        // Redraw grid if turning on
        if (this.enabled && this.config.showGrid) {
            this.drawGrid();
        }
        
        console.log(`CoordinateDisplay: ${this.enabled ? 'Enabled' : 'Disabled'}`);
    }
    
    /**
     * Set grid spacing
     * @param {number} spacing - Grid line spacing in pixels
     */
    setGridSpacing(spacing) {
        this.config.gridSpacing = spacing;
        this.drawGrid();
    }
    
    /**
     * Toggle grid visibility
     * @param {boolean} visible - Whether the grid should be visible
     */
    setGridVisible(visible) {
        this.config.showGrid = visible;
        this.gridContainer.visible = visible && this.enabled;
        if (visible && this.enabled) {
            this.drawGrid();
        }
    }
    
    /**
     * Toggle coordinate display visibility
     * @param {boolean} visible - Whether coordinates should be visible
     */
    setCoordinatesVisible(visible) {
        this.config.showCoordinates = visible;
        this.coordinateText.visible = visible && this.enabled;
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        // Remove event listeners
        this.scene.input.off('pointermove', this.updateCoordinates, this);
        
        // Destroy graphics objects
        if (this.gridContainer) this.gridContainer.destroy();
        if (this.coordinateText) this.coordinateText.destroy();
        
        console.log('CoordinateDisplay: Destroyed');
    }
}

// Make the class globally available
window.CoordinateDisplay = CoordinateDisplay;

===== FILE: DebugManager.js =====
/**
 * DebugManager.js
 * Central manager for debug tools and configuration
 */

class DebugManager {
    /**
     * @param {Phaser.Scene} scene - The scene to attach to
     * @param {Object} config - Configuration options
     */
    constructor(scene, config = {}) {
        this.scene = scene;
        
        // Default configuration with sensible presets
        this.config = {
            enabled: config.enabled !== undefined ? config.enabled : true,
            persistSettings: config.persistSettings !== undefined ? config.persistSettings : true,
            storageKey: config.storageKey || 'autobattler_debug_settings',
            showPanel: config.showPanel !== undefined ? config.showPanel : true,
            position: config.position || { x: 10, y: 10 },
            tools: config.tools ||

===== FILE: ObjectIdentifier.js =====
/**
 * ObjectIdentifier.js
 * Provides object identification and inspection for debugging
 */

class ObjectIdentifier {
    /**
     * @param {Phaser.Scene} scene - The scene to attach to
     * @param {Object} config - Configuration options
     */
    constructor(scene, config = {}) {
        this.scene = scene;
        
        // Configuration with defaults
        this.config = {
            enabled: config.enabled !== undefined ? config.enabled : true,
            showBounds: config.showBounds !== undefined ? config.showBounds : true,
            highlightColor: config.highlightColor || 0xffff00,
            highlightAlpha: config.highlightAlpha || 0.5,
            textColor: config.textColor || '#ffffff',
            backgroundColor: config.backgroundColor || '#000000',
            backgroundAlpha: config.backgroundAlpha || 0.7,
            fontSize: config.fontSize || 12,
            fontFamily: config.fontFamily || 'Arial',
            margin: config.margin || 5,
            padding: config.padding || { x: 5, y: 3 },
            showDepth: config.showDepth !== undefined ? config.showDepth : true,
            showPosition: config.showPosition !== undefined ? config.showPosition : true,
            showSize: config.showSize !== undefined ? config.showSize : true,
            showType: config.showType !== undefined ? config.showType : true,
            showName: config.showName !== undefined ? config.showName : true,
            onlyInteractive: config.onlyInteractive !== undefined ? config.onlyInteractive : false
        };
        
        // State tracking
        this.enabled = this.config.enabled;
        this.highlight = null;
        this.infoPanel = null;
        this.pinnedObjects = [];
        this.pinnedPanels = [];
        
        // Create the display elements
        this.create();
        
        // Make available globally for debugging
        window.ObjectIdentifier = this;
    }
    
    /**
     * Create the identifier components
     */
    create() {
        // Create a graphics object for highlighting objects
        this.highlight = this.scene.add.graphics();
        this.highlight.setDepth(999); // Ensure it's above most elements
        
        // Create info panel container for hover info
        this.infoPanel = this.scene.add.container(0, 0);
        this.infoPanel.setDepth(1000); // Above highlight
        
        // Background for the panel
        const infoBg = this.scene.add.graphics();
        this.infoPanel.add(infoBg);
        
        // Text for the panel
        const infoText = this.scene.add.text(
            this.config.padding.x,
            this.config.padding.y,
            'Hover over an object',
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize,
                color: this.config.textColor,
                wordWrap: { width: 300 }
            }
        );
        this.infoPanel.add(infoText);
        
        // Set panel properties
        this.infoPanel.bg = infoBg;
        this.infoPanel.text = infoText;
        this.infoPanel.visible = false;
        
        // Add keyboard shortcut for toggling (Ctrl+I)
        this.scene.input.keyboard.on('keydown-I', (event) => {
            if (this.scene.input.keyboard.checkModifierKey(event, 'ctrl')) {
                this.toggle();
            }
        });
        
        // Add mouse events for object identification
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        
        console.log('ObjectIdentifier: Created');
    }
    
    /**
     * Handle pointer movement
     * @param {Phaser.Input.Pointer} pointer - The pointer device
     */
    onPointerMove(pointer) {
        if (!this.enabled) return;
        
        // Hide highlight and info panel initially
        this.highlight.clear();
        this.infoPanel.visible = false;
        
        // Get objects under the pointer
        const objects = this.getObjectsUnderPointer(pointer);
        if (objects.length === 0) return;
        
        // Get the top object
        const object = objects[0];
        
        // Highlight the object
        this.highlightObject(object);
        
        // Show object information
        this.showObjectInfo(object, pointer.x, pointer.y);
    }
    
    /**
     * Handle pointer down (click)
     * @param {Phaser.Input.Pointer} pointer - The pointer device
     */
    onPointerDown(pointer) {
        if (!this.enabled || pointer.button !== 0) return;
        
        // Get objects under the pointer
        const objects = this.getObjectsUnderPointer(pointer);
        if (objects.length === 0) return;
        
        // Get the top object
        const object = objects[0];
        
        // Pin or unpin the object
        const existingIndex = this.pinnedObjects.indexOf(object);
        if (existingIndex !== -1) {
            // Object already pinned, remove it
            this.unpinObject(existingIndex);
        } else {
            // Pin the object
            this.pinObject(object);
        }
    }
    
    /**
     * Get objects under the pointer
     * @param {Phaser.Input.Pointer} pointer - The pointer device
     * @returns {Array} Array of game objects
     */
    getObjectsUnderPointer(pointer) {
        // Get all input-enabled objects under the pointer
        let objects = this.scene.input.hitTestPointer(pointer);
        
        // If we only want interactive objects or no objects were found with hitTest
        if (this.config.onlyInteractive || objects.length === 0) {
            return objects;
        }
        
        // For non-interactive objects, we need to do a custom check
        // Get all game objects in the scene
        const allObjects = this.scene.children.list;
        
        // Filter objects that intersect with the pointer position
        const nonInteractiveObjects = allObjects.filter(obj => {
            // Skip if it's not a game object or already in our list
            if (!obj.getBounds || objects.includes(obj)) return false;
            
            // Get object bounds
            const bounds = obj.getBounds();
            
            // Check if pointer is within bounds
            return bounds.contains(pointer.x, pointer.y);
        });
        
        // Merge and sort by depth (highest depth first)
        objects = [...objects, ...nonInteractiveObjects]
            .sort((a, b) => b.depth - a.depth);
        
        return objects;
    }
    
    /**
     * Highlight a game object
     * @param {Phaser.GameObjects.GameObject} object - The object to highlight
     */
    highlightObject(object) {
        if (!this.config.showBounds || !object.getBounds) return;
        
        // Get object bounds
        const bounds = object.getBounds();
        
        // Draw highlight rectangle
        this.highlight.lineStyle(2, this.config.highlightColor, 1);
        this.highlight.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
        
        // Fill with semi-transparent color
        this.highlight.fillStyle(this.config.highlightColor, this.config.highlightAlpha);
        this.highlight.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
    
    /**
     * Show information about a game object
     * @param {Phaser.GameObjects.GameObject} object - The object to show info for
     * @param {number} x - X position of the pointer
     * @param {number} y - Y position of the pointer
     */
    showObjectInfo(object, x, y) {
        // Build info text
        const infoLines = [];
        
        // Check if pinned
        const isPinned = this.pinnedObjects.includes(object);
        
        // Type
        if (this.config.showType) {
            const type = object.type || object.constructor.name;
            infoLines.push(`Type: ${type}`);
        }
        
        // Name
        if (this.config.showName && object.name) {
            infoLines.push(`Name: ${object.name}`);
        }
        
        // Position
        if (this.config.showPosition) {
            infoLines.push(`Position: (${Math.round(object.x)}, ${Math.round(object.y)})`);
        }
        
        // Size (if available)
        if (this.config.showSize && (object.width !== undefined && object.height !== undefined)) {
            infoLines.push(`Size: ${Math.round(object.width)} Ã— ${Math.round(object.height)}`);
        }
        
        // Depth (z-order)
        if (this.config.showDepth && object.depth !== undefined) {
            infoLines.push(`Depth: ${object.depth}`);
        }
        
        // Alpha (transparency)
        if (object.alpha !== undefined) {
            infoLines.push(`Alpha: ${object.alpha.toFixed(2)}`);
        }
        
        // Origin
        if (object.originX !== undefined && object.originY !== undefined) {
            infoLines.push(`Origin: (${object.originX.toFixed(2)}, ${object.originY.toFixed(2)})`);
        }
        
        // Visibility
        infoLines.push(`Visible: ${object.visible}`);
        
        // Interactive
        infoLines.push(`Interactive: ${object.input ? 'Yes' : 'No'}`);
        
        // Pin status
        infoLines.push(`Status: ${isPinned ? 'ðŸ“Œ Pinned' : 'Click to pin'}`);
        
        // Set info text
        const infoText = infoLines.join('\n');
        this.infoPanel.text.setText(infoText);
        
        // Resize background
        const bounds = this.infoPanel.text.getBounds();
        this.infoPanel.bg.clear();
        this.infoPanel.bg.fillStyle(
            parseInt(this.config.backgroundColor.replace('#', '0x')),
            this.config.backgroundAlpha
        );
        this.infoPanel.bg.fillRect(
            0,
            0,
            bounds.width + (this.config.padding.x * 2),
            bounds.height + (this.config.padding.y * 2)
        );
        
        // Position panel near pointer, but ensure it stays on screen
        let panelX = x + this.config.margin;
        let panelY = y + this.config.margin;
        
        // Adjust if panel would go off right edge
        if (panelX + bounds.width + (this.config.padding.x * 2) > this.scene.cameras.main.width) {
            panelX = x - this.config.margin - bounds.width - (this.config.padding.x * 2);
        }
        
        // Adjust if panel would go off bottom edge
        if (panelY + bounds.height + (this.config.padding.y * 2) > this.scene.cameras.main.height) {
            panelY = y - this.config.margin - bounds.height - (this.config.padding.y * 2);
        }
        
        // Position the panel
        this.infoPanel.setPosition(panelX, panelY);
        this.infoPanel.visible = true;
    }
    
    /**
     * Pin an object for continued display
     * @param {Phaser.GameObjects.GameObject} object - The object to pin
     */
    pinObject(object) {
        // Add to pinned objects
        this.pinnedObjects.push(object);
        
        // Create pinned panel
        const panel = this.scene.add.container(10, 10 + (this.pinnedPanels.length * 150));
        panel.setDepth(1001); // Above other interface elements
        
        // Background for the panel
        const bg = this.scene.add.graphics();
        panel.add(bg);
        
        // Title for the panel
        const title = this.scene.add.text(
            this.config.padding.x,
            this.config.padding.y,
            `ðŸ“Œ ${object.name || object.type || object.constructor.name}`,
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize + 2,
                color: this.config.textColor,
                fontStyle: 'bold'
            }
        );
        panel.add(title);
        
        // Object properties
        const propsText = this.scene.add.text(
            this.config.padding.x,
            title.height + (this.config.padding.y * 2),
            'Loading properties...',
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize,
                color: this.config.textColor,
                wordWrap: { width: 250 }
            }
        );
        panel.add(propsText);
        
        // Close button
        const closeBtn = this.scene.add.text(
            240,
            this.config.padding.y,
            'âœ–',
            {
                fontFamily: this.config.fontFamily,
                fontSize: this.config.fontSize + 2,
                color: '#ff6666'
            }
        );
        closeBtn.setInteractive({ useHandCursor: true });
        closeBtn.on('pointerdown', () => {
            const index = this.pinnedObjects.indexOf(object);
            if (index !== -1) {
                this.unpinObject(index);
            }
        });
        panel.add(closeBtn);
        
        // Store references
        panel.bg = bg;
        panel.title = title;
        panel.propsText = propsText;
        panel.closeBtn = closeBtn;
        panel.object = object;
        
        // Update the panel content
        this.updatePinnedPanel(panel);
        
        // Add to pinned panels
        this.pinnedPanels.push(panel);
        
        // Rearrange panels
        this.arrangePinnedPanels();
    }
    
    /**
     * Unpin an object
     * @param {number} index - The index of the object to unpin
     */
    unpinObject(index) {
        // Remove object and panel
        this.pinnedObjects.splice(index, 1);
        const panel = this.pinnedPanels.splice(index, 1)[0];
        
        // Destroy the panel
        panel.destroy();
        
        // Rearrange remaining panels
        this.arrangePinnedPanels();
    }
    
    /**
     * Update a pinned panel's content
     * @param {Phaser.GameObjects.Container} panel - The panel to update
     */
    updatePinnedPanel(panel) {
        const object = panel.object;
        
        // Build properties text
        let propsLines = [];
        
        try {
            // Extract key properties
            const props = {
                // Position and dimensions
                x: Math.round(object.x),
                y: Math.round(object.y),
                width: object.width !== undefined ? Math.round(object.width) : 'N/A',
                height: object.height !== undefined ? Math.round(object.height) : 'N/A',
                
                // Visual properties
                visible: object.visible,
                alpha: object.alpha !== undefined ? object.alpha.toFixed(2) : 'N/A',
                depth: object.depth,
                
                // Transform
                scaleX: object.scaleX !== undefined ? object.scaleX.toFixed(2) : 'N/A',
                scaleY: object.scaleY !== undefined ? object.scaleY.toFixed(2) : 'N/A',
                rotation: object.rotation !== undefined ? (object.rotation * (180/Math.PI)).toFixed(1) + 'Â°' : 'N/A'
            };
            
            // Format properties
            Object.entries(props).forEach(([key, value]) => {
                propsLines.push(`${key}: ${value}`);
            });
            
            // For text objects, also show text content
            if (object.text !== undefined) {
                propsLines.push('');
                propsLines.push('Text: ' + (object.text.length > 30 ? object.text.substring(0, 30) + '...' : object.text));
            }
            
            // Panel content
            panel.propsText.setText(propsLines.join('\n'));
            
            // Resize background
            const titleBounds = panel.title.getBounds();
            const propsBounds = panel.propsText.getBounds();
            const width = Math.max(titleBounds.width, propsBounds.width) + (this.config.padding.x * 3) + panel.closeBtn.width;
            const height = titleBounds.height + propsBounds.height + (this.config.padding.y * 3);
            
            panel.bg.clear();
            panel.bg.fillStyle(parseInt(this.config.backgroundColor.replace('#', '0x')), this.config.backgroundAlpha);
            panel.bg.lineStyle(1, 0xffffff, 0.5);
            panel.bg.fillRoundedRect(0, 0, width, height, 5);
            panel.bg.strokeRoundedRect(0, 0, width, height, 5);
            
            // Update close button position
            panel.closeBtn.setPosition(width - this.config.padding.x - panel.closeBtn.width, this.config.padding.y);
        } catch (error) {
            console.error('Error updating pinned panel:', error);
            panel.propsText.setText('Error getting properties');
        }
    }
    
    /**
     * Arrange pinned panels vertically
     */
    arrangePinnedPanels() {
        this.pinnedPanels.forEach((panel, index) => {
            panel.setPosition(10, 10 + (index * 160));
        });
    }
    
    /**
     * Update pinned panels with current object properties
     */
    update() {
        if (!this.enabled) return;
        
        this.pinnedPanels.forEach(panel => {
            this.updatePinnedPanel(panel);
        });
    }
    
    /**
     * Toggle the object identifier on/off
     */
    toggle() {
        this.enabled = !this.enabled;
        
        // Update visibility
        this.highlight.visible = this.enabled;
        this.infoPanel.visible = false;
        
        // Update pinned panels
        this.pinnedPanels.forEach(panel => {
            panel.visible = this.enabled;
        });
        
        console.log(`ObjectIdentifier: ${this.enabled ? 'Enabled' : 'Disabled'}`);
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        // Remove event listeners
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.input.off('pointerdown', this.onPointerDown, this);
        
        // Destroy graphics objects
        if (this.highlight) this.highlight.destroy();
        if (this.infoPanel) this.infoPanel.destroy();
        
        // Destroy pinned panels
        this.pinnedPanels.forEach(panel => panel.destroy());
        this.pinnedPanels = [];
        this.pinnedObjects = [];
        
        console.log('ObjectIdentifier: Destroyed');
    }
}

// Make the class globally available
window.ObjectIdentifier = ObjectIdentifier;

===== FILE: BattleUIManager.js =====
/**
 * BattleUIManager.js
 * Manager for all UI components in the Battle Scene
 * 
 * Handles creation and management of:
 * - Background and scene visuals
 * - HUD elements (turn indicators, battle info)
 * - UI panels (battle log, controls)
 * - Battle outcome screens
 * 
 * @version 0.6.2.1
 */

class BattleUIManager {
    /**
     * Constructor for BattleUIManager
     * @param {Phaser.Scene} scene - The scene this manager belongs to
     */
    constructor(scene) {
        // Validate dependencies
        if (!scene) {
            console.error("[BattleUIManager] Missing required scene reference");
            return;
        }
        
        this.scene = scene;
        this.components = {};
        
        console.log("[BattleUIManager] Initialized");
    }
    
    /**
     * Initialize all UI components
     */
    initializeUI() {
        try {
            console.log("[BattleUIManager] Creating UI components...");
            
            // Create background elements
            this.createBackground();
            
            // Create scene titles and header elements
            this.createSceneTitle();
            this.createWelcomeMessage();
            this.createReturnButton();
            
            // Create test pattern (for development only)
            this.createTestPattern();
            
            // Create battle controls and log
            this.createBattleControls();
            this.createBattleLogPanel();
            
            // Initialize text displays
            this.initializeTextDisplays();
            
            console.log("[BattleUIManager] UI components created successfully");
            return true;
        } catch (error) {
            console.error("[BattleUIManager] Error initializing UI:", error);
            this.showErrorMessage("Failed to initialize battle UI: " + error.message);
            return false;
        }
    }
    
    /**
     * Initialize text displays for turn and action information
     * @private
     */
    initializeTextDisplays() {
        // Initialize placeholders for text indicators
        this.turnTextIndicator = null;
        this.actionTextIndicator = null;
    }
    
    /**
     * Create the background for the battle scene
     */
    createBackground() {
        try {
            // Create a gradient background
            const width = this.scene.cameras.main.width;
            const height = this.scene.cameras.main.height;

            // Create background rectangle
            this.scene.add.rectangle(
                width / 2,
                height / 2,
                width,
                height,
                0x333344 // Navy blue color
            );

            // Add some visual interest with diagonal lines
            const graphics = this.scene.add.graphics();
            graphics.lineStyle(2, 0xffffff, 0.1);

            // Draw grid lines
            const spacing = 80;
            for (let i = 0; i < width + height; i += spacing) {
                graphics.moveTo(0, i);
                graphics.lineTo(i, 0);
            }

            graphics.strokePath();
            
            // Store reference for cleanup
            this.components.background = graphics;

            console.log("[BattleUIManager] Background created successfully");
        } catch (error) {
            console.error("[BattleUIManager] Error creating background:", error);
        }
    }
    
    /**
     * Create the scene title
     */
    createSceneTitle() {
        try {
            const sceneTitle = this.scene.add.text(
                this.scene.cameras.main.width / 2,
                50,
                'Battle Scene',
                {
                    fontFamily: 'Arial',
                    fontSize: 36,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }
            ).setOrigin(0.5);

            // Add simple animation
            this.scene.tweens.add({
                targets: sceneTitle,
                y: 40,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            // Store reference for cleanup
            this.components.sceneTitle = sceneTitle;

            console.log("[BattleUIManager] Scene title created successfully");
        } catch (error) {
            console.error("[BattleUIManager] Error creating scene title:", error);
        }
    }
    
    /**
     * Create the return button to go back to the TeamBuilder
     */
    createReturnButton() {
        try {
            const button = this.scene.add.text(
                this.scene.cameras.main.width - 100,
                50,
                'Return',
                {
                    fontFamily: 'Arial',
                    fontSize: '20px',
                    color: '#ffffff',
                    backgroundColor: '#555555',
                    padding: { x: 15, y: 8 }
                }
            ).setOrigin(0.5).setInteractive({ useHandCursor: true });

            button.on('pointerdown', () => {
                console.log("[BattleUIManager] Return button clicked");
                this.returnToTeamBuilder();
            });

            button.on('pointerover', () => {
                button.setBackgroundColor('#777777');
            });

            button.on('pointerout', () => {
                button.setBackgroundColor('#555555');
            });
            
            // Store reference for cleanup
            this.components.returnButton = button;

            console.log("[BattleUIManager] Return button created successfully");
        } catch (error) {
            console.error("[BattleUIManager] Error creating return button:", error);
            this.showErrorMessage('Failed to create return button');
        }
    }
    
    /**
     * Handle returning to the TeamBuilder scene/UI
     */
    returnToTeamBuilder() {
        try {
            console.log("[BattleUIManager] Returning to Team Builder...");
            
            // Clean up battle state
            if (window.battleBridge) {
                window.battleBridge.cleanupBattleState();
            }

            // Stop the current scene properly
            this.scene.scene.stop();

            // Hide Phaser container and show DOM UI
            const phaserContainer = document.getElementById('game-container');
            if (phaserContainer) {
                phaserContainer.style.display = 'none';
            }
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) {
                teamBuilderContainer.style.display = 'block'; // Or 'flex' depending on your CSS
            }

            // Optionally, notify TeamBuilderUI if it exists
            if (window.teamBuilderUI && typeof window.teamBuilderUI.onReturnFromPhaserBattle === 'function') {
                window.teamBuilderUI.onReturnFromPhaserBattle();
            } else {
                console.warn("[BattleUIManager] TeamBuilderUI or onReturnFromPhaserBattle not found.");
            }

        } catch (error) {
            console.error("[BattleUIManager] Error returning to Team Builder:", error);
            // Add fallback in case of error during transition
            alert('Error returning to Team Builder. Please refresh if needed.');
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
        }
    }
    
    /**
     * Create a welcome message showing battle data
     */
    createWelcomeMessage() {
        try {
            // Safely access team data from scene
            const playerTeam = this.scene.playerTeam || [];
            const enemyTeam = this.scene.enemyTeam || [];
            
            // Create player team summary
            const playerTeamNames = playerTeam.map(character => character.name).join(', ');
            const playerTeamText = `Player Team (${playerTeam.length}): ${playerTeamNames || 'None'}`;

            // Create enemy team summary
            const enemyTeamNames = enemyTeam.map(character => character.name).join(', ');
            const enemyTeamText = `Enemy Team (${enemyTeam.length}): ${enemyTeamNames || 'None'}`;

            // Create battle mode text
            const battleModeText = `Battle Mode: ${this.scene.battleConfig?.battleMode || 'Unknown'}`;

            // Create welcome message
            const welcomeText = this.scene.add.text(
                this.scene.cameras.main.width / 2,
                120,
                `Battle Scene Initialized!\n${playerTeamText}\n${enemyTeamText}\n${battleModeText}`,
                {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 2
                }
            ).setOrigin(0.5);
            
            // Store reference for cleanup
            this.components.welcomeMessage = welcomeText;

            console.log("[BattleUIManager] Welcome message created successfully");
        } catch (error) {
            console.error("[BattleUIManager] Error creating welcome message:", error);
        }
    }
    
    /**
     * Create a test pattern to verify the scene is rendering correctly
     * This is a temporary visual element to confirm Phaser is working
     */
    createTestPattern() {
        try {
            // Create a container for test elements
            const testContainer = this.scene.add.container(
                this.scene.cameras.main.width / 2,
                this.scene.cameras.main.height / 2
            );

            // Add colorful circles in different positions
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            const radius = 30;

            for (let i = 0; i < colors.length; i++) {
                const angle = (i / colors.length) * Math.PI * 2;
                const x = Math.cos(angle) * 100;
                const y = Math.sin(angle) * 100;

                const circle = this.scene.add.circle(x, y, radius, colors[i], 0.8);
                testContainer.add(circle);

                // Add pulsing animation
                this.scene.tweens.add({
                    targets: circle,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    duration: 500 + (i * 100),
                    yoyo: true,
                    repeat: -1
                });
            }

            // Add version text
            const versionText = this.scene.add.text(0, 0, 'Battle Scene v0.6.2.1', {
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#ffffff',
                align: 'center'
            }).setOrigin(0.5);

            testContainer.add(versionText);
            
            // Store reference for cleanup
            this.components.testPattern = testContainer;

            console.log("[BattleUIManager] Test pattern created successfully");
        } catch (error) {
            console.error("[BattleUIManager] Error creating test pattern:", error);
        }
    }
    
    /**
     * Create the battle control panel
     * Adds UI controls for starting battle, changing speed, pausing/resuming
     */
    createBattleControls() {
        try {
            // Create the battle control panel at the bottom of the screen
            if (typeof BattleControlPanel === 'function') {
                const battleControlPanel = new BattleControlPanel(
                    this.scene,
                    this.scene.cameras.main.width / 2, // center horizontally
                    this.scene.cameras.main.height - 50 // position near bottom
                );
                
                // Store reference for cleanup
                this.components.battleControlPanel = battleControlPanel;
                
                console.log("[BattleUIManager] Battle control panel created successfully");
            } else {
                console.error("[BattleUIManager] BattleControlPanel class not found");
                this.showErrorMessage('Battle controls not available');
            }
        } catch (error) {
            console.error("[BattleUIManager] Error creating battle control panel:", error);
            this.showErrorMessage('Failed to create battle controls');
        }
    }
    
    /**
     * Create the battle log for displaying battle events
     */
    createBattleLogPanel() {
        try {
            // Check if DirectBattleLog class exists
            if (typeof DirectBattleLog === 'function') {
                // Calculate half screen height for max height constraint
                const halfScreenHeight = this.scene.cameras.main.height * 0.5;
                
                // Create the direct battle log in the right side of the screen
                const battleLog = new DirectBattleLog(
                    this.scene, 
                    this.scene.cameras.main.width - 350, // X position (right side)
                    50,                                  // Y position (top)
                    300,                                 // Width
                    {
                        backgroundColor: 0x000000,
                        backgroundAlpha: 0.5,
                        fontSize: 16,
                        maxMessages: 30,
                        padding: 10,
                        maxHeight: halfScreenHeight // Limit height to half the screen
                    }
                );
                
                // Store reference for cleanup
                this.components.battleLog = battleLog;
                
                // Make the battle log accessible to the scene
                this.scene.battleLog = battleLog;
                
                // Add direct access for testing in console
                window.battleLog = battleLog;
                
                // Register the battle log with the event manager if available
                if (this.scene.eventManager && typeof this.scene.eventManager.setBattleLog === 'function') {
                    this.scene.eventManager.setBattleLog(battleLog);
                    console.log("[BattleUIManager] Registered battle log with BattleEventManager");
                } else {
                    console.warn("[BattleUIManager] BattleEventManager not available or missing setBattleLog method");
                }
                
                console.log("[BattleUIManager] Battle log created successfully");
            } else {
                console.error("[BattleUIManager] DirectBattleLog class not found");
                this.showErrorMessage('Battle log not available');
            }
        } catch (error) {
            console.error("[BattleUIManager] Error creating battle log:", error);
            this.showErrorMessage('Failed to create battle log');
        }
    }
    
    /**
     * Update the turn number display only
     * @param {number} turnNumber - The current turn number
     */
    updateTurnNumberDisplay(turnNumber) {
        try {
            // Define standard text style
            const indicatorStyle = {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3,
                backgroundColor: '#444444',
                padding: { x: 10, y: 5 }
            };
            
            // Position at the top of the screen
            const position = { 
                x: this.scene.cameras.main.width / 2,
                y: 80
            };
            
            // Get character name from current text if available
            let characterName = '';
            if (this.turnTextIndicator && this.turnTextIndicator.text) {
                const characterNameMatch = this.turnTextIndicator.text.match(/: ([^']+)'s Action/i);
                characterName = characterNameMatch ? characterNameMatch[1] : '';
            }
            
            // Format text based on available information
            const text = characterName 
                ? `TURN ${turnNumber}: ${characterName}'s Action`
                : `TURN ${turnNumber}`;
                
            // Get or create text object safely
            const textObj = this.safeGetTextObject(
                'turnTextIndicator', 
                position, 
                text, 
                indicatorStyle
            );
            
            // If we got a valid text object, update it
            if (textObj) {
                try {
                    textObj.setText(text);
                    
                    // Add animation effect if not already animated
                    if (!this.scene.tweens.isTweening(textObj)) {
                        this.scene.tweens.add({
                            targets: textObj,
                            scale: { from: 0.8, to: 1 },
                            duration: 300,
                            ease: 'Back.easeOut'
                        });
                    }
                } catch (textError) {
                    console.error('[BattleUIManager] Error updating turn text:', textError);
                    // Reset for recreation next time
                    this.turnTextIndicator = null;
                }
            }
            
            console.log(`[BattleUIManager] Turn number display updated to ${turnNumber}`);
        } catch (error) {
            console.error('[BattleUIManager] Error updating turn number display:', error);
            // Reset for recreation next time
            this.turnTextIndicator = null;
        }
    }
    
    /**
     * Update the action text display with character information
     * @param {number} turnNumber - The current turn number
     * @param {Object} character - The character performing an action
     */
    updateActionTextDisplay(turnNumber, character) {
        try {
            if (!character) return;
            
            // Background color based on team
            const backgroundColor = character.team === 'player' ? '#225588' : '#882255';
            
            // Create or update the text with character's information
            const text = `TURN ${turnNumber}: ${character.name}'s Action`;
            const indicatorStyle = {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3,
                backgroundColor: backgroundColor,
                padding: { x: 10, y: 5 }
            };
            
            // Position at the top of the screen
            const position = { 
                x: this.scene.cameras.main.width / 2,
                y: 80
            };
            
            // Get or create text object safely
            const textObj = this.safeGetTextObject(
                'turnTextIndicator', 
                position, 
                text, 
                indicatorStyle
            );
            
            // If we got a valid text object, update it
            if (textObj) {
                try {
                    textObj.setText(text);
                    textObj.setBackgroundColor(backgroundColor);
                    
                    // Add or restart animation effect
                    this.scene.tweens.killTweensOf(textObj);
                    this.scene.tweens.add({
                        targets: textObj,
                        scale: { from: 0.9, to: 1 },
                        duration: 300,
                        ease: 'Back.easeOut',
                        onComplete: () => {
                            // Only add bounce if object is still valid
                            if (textObj.active && !textObj.destroyed) {
                                this.scene.tweens.add({
                                    targets: textObj,
                                    y: { from: 80, to: 85 },
                                    duration: 1500,
                                    yoyo: true,
                                    repeat: -1,
                                    ease: 'Sine.easeInOut'
                                });
                            }
                        }
                    });
                } catch (textError) {
                    console.error('[BattleUIManager] Error updating action text:', textError);
                    // Reset for recreation next time
                    this.turnTextIndicator = null;
                }
            }
            
            console.log(`[BattleUIManager] Action text updated for ${character.name} on turn ${turnNumber}`);
        } catch (error) {
            console.error('[BattleUIManager] Error updating action text display:', error);
            // Reset for recreation next time
            this.turnTextIndicator = null;
        }
    }
    
    /**
     * Safely gets or creates a text object
     * @param {string} objectKey - Reference property name ('turnTextIndicator', etc.)
     * @param {Object} position - {x, y} coordinates
     * @param {string} defaultText - Default text to display
     * @param {Object} style - Text style options
     * @returns {Phaser.GameObjects.Text} - Valid text object
     */
    safeGetTextObject(objectKey, position, defaultText, style) {
        try {
            // Check if the text object exists and is valid
            const currentObj = this[objectKey];
            
            if (currentObj && currentObj.active && !currentObj.destroyed) {
                // Object exists and is valid - return it
                return currentObj;
            }
            
            // Create new text object if needed
            console.log(`[BattleUIManager] Recreating ${objectKey} text object`);
            
            // Destroy old object if it exists but is invalid
            if (currentObj) {
                try {
                    currentObj.destroy();
                } catch (e) {
                    console.warn(`[BattleUIManager] Error destroying old ${objectKey}:`, e);
                }
            }
            
            // Create new text object
            const newObj = this.scene.add.text(
                position.x,
                position.y,
                defaultText,
                style
            ).setOrigin(0.5);
            
            // Store for future reference
            this[objectKey] = newObj;
            
            return newObj;
        } catch (error) {
            console.error(`[BattleUIManager] Error in safeGetTextObject for ${objectKey}:`, error);
            return null;
        }
    }
    
    /**
     * Display battle outcome screen
     * @param {string} winner - 'player', 'enemy', or 'draw'
     */
    showBattleOutcome(winner) {
        try {
            console.log(`[BattleUIManager] Showing battle outcome - Winner: ${winner}`);
            
            // Create container for outcome elements
            const container = this.scene.add.container(this.scene.cameras.main.width / 2, this.scene.cameras.main.height / 2);
            container.setDepth(1000); // Ensure it appears above everything else
            
            // Add semi-transparent background
            const background = this.scene.add.rectangle(
                0, 0, 
                this.scene.cameras.main.width, 
                this.scene.cameras.main.height, 
                0x000000, 0.7
            );
            container.add(background);
            
            // Create outcome message
            let message = '';
            let color = 0xffffff;
            
            // Handle different possible winner values
            if (winner === 'player' || winner === 'victory') {
                message = 'VICTORY!';
                color = 0x00ff00; // Green
            } else if (winner === 'enemy' || winner === 'defeat') {
                message = 'DEFEAT';
                color = 0xff0000; // Red
            } else if (winner === 'draw') {
                message = 'DRAW';
                color = 0xffff00; // Yellow
            } else {
                // Fallback for genuinely unexpected winner values
                console.warn(`[BattleUIManager] showBattleOutcome received unexpected winner value: '${winner}'. Defaulting UI to DRAW.`);
                message = 'DRAW';
                color = 0x808080; // Gray
            }
            
            // Add outcome text
            const outcomeText = this.scene.add.text(
                0, -50,
                message,
                {
                    fontFamily: 'Arial',
                    fontSize: '64px',
                    color: `#${color.toString(16).padStart(6, '0')}`,
                    stroke: '#000000',
                    strokeThickness: 6,
                    align: 'center',
                    shadow: { color: '#000000', fill: true, offsetX: 2, offsetY: 2, blur: 8 }
                }
            ).setOrigin(0.5);
            container.add(outcomeText);
            
            // Add return button
            const returnButton = this.scene.add.text(
                0, 50,
                'Return to Team Builder',
                {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    color: '#ffffff',
                    backgroundColor: '#555555',
                    padding: { x: 20, y: 10 }
                }
            ).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            returnButton.on('pointerover', () => returnButton.setBackgroundColor('#777777'));
            returnButton.on('pointerout', () => returnButton.setBackgroundColor('#555555'));
            returnButton.on('pointerdown', () => {
                console.log('[BattleUIManager] Return to Team Builder requested by user after battle');
                this.returnToTeamBuilder();
            });
            
            container.add(returnButton);
            
            // Add animation
            this.scene.tweens.add({
                targets: container,
                scale: { from: 0.5, to: 1 },
                alpha: { from: 0, to: 1 },
                duration: 500,
                ease: 'Back.easeOut'
            });
            
            // Store reference to cleanup later
            this.components.outcomeContainer = container;
            
        } catch (error) {
            console.error('[BattleUIManager] Error showing battle outcome:', error);
        }
    }
    
    /**
     * Display error messages in the UI
     * @param {string} message - The error message to show
     */
    showErrorMessage(message) {
        console.error('[BattleUIManager] UI Error Message:', message); // Log to console

        try {
            // Create or update an error text object on the screen
            if (this.components.errorText) {
                this.components.errorText.setText(`ERROR: ${message}`);
            } else {
                const errorText = this.scene.add.text(
                    this.scene.cameras.main.centerX,
                    30, // Position near top-center
                    `ERROR: ${message}`,
                    {
                        fontFamily: 'Arial',
                        fontSize: '16px',
                        color: '#ff0000', // Red color for errors
                        backgroundColor: 'rgba(0,0,0,0.7)',
                        padding: { x: 10, y: 5 },
                        wordWrap: { width: this.scene.cameras.main.width - 40 }
                    }
                ).setOrigin(0.5, 0).setDepth(1001); // Ensure it's visible
                
                this.components.errorText = errorText;
                
                // Optionally fade out the error after some time
                this.scene.time.delayedCall(5000, () => {
                    if (this.components.errorText) {
                        this.components.errorText.destroy();
                        this.components.errorText = null;
                    }
                }, [], this);
            }
        } catch (error) {
            console.error('[BattleUIManager] Error showing error message:', error);
        }
    }
    
    /**
     * Hide the test pattern when no longer needed
     */
    hideTestPattern() {
        if (this.components.testPattern) {
            this.components.testPattern.setVisible(false);
            console.log("[BattleUIManager] Test pattern hidden");
        }
    }
    
    /**
     * Clean up all UI components
     */
    destroy() {
        try {
            console.log("[BattleUIManager] Cleaning up UI components...");
            
            // Destroy all tracked components
            Object.entries(this.components).forEach(([key, component]) => {
                try {
                    if (component) {
                        if (typeof component.destroy === 'function') {
                            component.destroy();
                        } else if (component.active !== undefined) {
                            // For Phaser game objects that might not have destroy method
                            component.setVisible(false);
                            component.setActive(false);
                        }
                        console.log(`[BattleUIManager] Cleaned up ${key}`);
                    }
                } catch (error) {
                    console.error(`[BattleUIManager] Error destroying component ${key}:`, error);
                }
            });
            
            // Clear component references
            this.components = {};
            
            // Clean up text indicators
            if (this.turnTextIndicator) {
                this.turnTextIndicator.destroy();
                this.turnTextIndicator = null;
            }
            
            console.log("[BattleUIManager] UI components cleaned up successfully");
        } catch (error) {
            console.error("[BattleUIManager] Error during UI cleanup:", error);
        }
    }
}

// Make available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleUIManager = BattleUIManager;
    console.log("BattleUIManager class definition loaded and exported to window.BattleUIManager");
}


===== FILE: TeamDisplayManager.js =====
/**
 * TeamDisplayManager - Manages team display and active character visualization in battle
 * 
 * Responsible for:
 * - Creating and managing team containers
 * - Creating and positioning the turn indicator
 * - Updating active character visuals
 * - Providing access to team data and character sprites
 * 
 * @version 0.6.2.3
 */
class TeamDisplayManager {
    /**
     * Constructor for TeamDisplayManager
     * @param {Phaser.Scene} scene - The scene this manager belongs to
     * @param {Object} teamData - Initial team data with playerTeam and enemyTeam
     */
    constructor(scene, teamData = {}) {
        // Validate dependencies
        if (!scene) {
            console.error("[TeamDisplayManager] Missing required scene reference");
            return;
        }
        
        this.scene = scene;
        this.playerTeam = teamData.playerTeam || [];
        this.enemyTeam = teamData.enemyTeam || [];
        
        // Verify TeamContainer is available
        if (typeof window.TeamContainer !== 'function') {
            console.error("[TeamDisplayManager] TeamContainer class not found");
        }
        
        // Initialize component tracking
        this.components = {};
        this.playerTeamContainer = null;
        this.enemyTeamContainer = null;
        this.turnIndicator = null;
        
        console.log("[TeamDisplayManager] Initialized");
    }
    
    /**
     * Initialize teams and turn indicator
     * @returns {boolean} - Success status
     */
    initialize() {
        try {
            // Create turn indicator first
            this.createTurnIndicator();
            
            // Create team containers
            const success = this.createTeams();
            
            return success;
        } catch (error) {
            console.error("[TeamDisplayManager] Error during initialization:", error);
            return false;
        }
    }
    
    /**
     * Create turn indicator
     */
    createTurnIndicator() {
        try {
            // Check if the indicator already exists and destroy it
            if (this.turnIndicator) {
                this.turnIndicator.destroy();
            }
            
            // Create a new turn indicator using the TurnIndicator class
            console.log("[TeamDisplayManager] Creating turn indicator");
            
            if (typeof window.TurnIndicator === 'function') {
                this.turnIndicator = new window.TurnIndicator(this.scene);
                this.turnIndicator.setDepth(10); // Set above characters but below UI
                
                // Track for cleanup
                this.components.turnIndicator = this.turnIndicator;
                console.log("[TeamDisplayManager] TurnIndicator instance created successfully");
            } else {
                console.error("[TeamDisplayManager] TurnIndicator class not found! Creating fallback.");
                
                // Create a fallback graphics object if TurnIndicator class is not available
                this.turnIndicator = this.scene.add.graphics();
                this.turnIndicator.setDepth(10);
                
                // Add minimal showAt method for compatibility
                this.turnIndicator.showAt = (x, y, color, duration) => {
                    console.warn("[TeamDisplayManager] Using fallback showAt method");
                    this.turnIndicator.clear();
                    this.turnIndicator.setPosition(x, y);
                    this.turnIndicator.fillStyle(color, 0.7);
                    this.turnIndicator.fillEllipse(0, 0, 32, 16);
                    this.turnIndicator.setAlpha(0.7);
                };
                
                // Add hide method for compatibility
                this.turnIndicator.hide = (duration) => {
                    this.turnIndicator.clear();
                    this.turnIndicator.setAlpha(0);
                };
            }
            
            console.log("[TeamDisplayManager] Turn indicator created");
            return true;
        } catch (error) {
            console.error("[TeamDisplayManager] Error creating turn indicator:", error);
            return false;
        }
    }
    
    /**
     * Create team containers for both player and enemy teams
     * @returns {boolean} - Success status
     */
    createTeams() {
        try {
            // --- Player Team Creation ---
            try {
                console.log(`[TeamDisplayManager] Creating player team container with ${this.playerTeam.length || 0} characters.`);
                if (!this.playerTeam || this.playerTeam.length === 0) {
                    console.warn('[TeamDisplayManager] Player team data is empty or missing!');
                    this.playerTeam = []; // Ensure it's an array
                }
                
                this.playerTeamContainer = new window.TeamContainer(
                    this.scene,
                    this.playerTeam,
                    true, // isPlayerTeam
                    { x: 800, y: 600 } // Correct position from original BattleScene
                );
                
                // Track for cleanup
                this.components.playerTeamContainer = this.playerTeamContainer;
                console.log('[TeamDisplayManager] Player team container created successfully.');
            } catch (error) {
                console.error('[TeamDisplayManager] ERROR creating PLAYER TeamContainer:', error);
                this.playerTeamContainer = null;
                return false;
            }

            // --- Enemy Team Creation ---
            try {
                console.log(`[TeamDisplayManager] Creating enemy team container with ${this.enemyTeam.length || 0} characters.`);
                if (!this.enemyTeam || this.enemyTeam.length === 0) {
                    console.warn('[TeamDisplayManager] Enemy team data is empty or missing!');
                    this.enemyTeam = []; // Ensure it's an array
                }
                
                this.enemyTeamContainer = new window.TeamContainer(
                    this.scene,
                    this.enemyTeam,
                    false, // not player team
                    { x: 1200, y: 600 } // Correct position from original BattleScene
                );
                
                // Track for cleanup
                this.components.enemyTeamContainer = this.enemyTeamContainer;
                console.log('[TeamDisplayManager] Enemy team container created successfully.');
            } catch (error) {
                console.error('[TeamDisplayManager] ERROR creating ENEMY TeamContainer:', error);
                this.enemyTeamContainer = null;
                return false;
            }
            
            return true; // Success
        } catch (error) {
            console.error('[TeamDisplayManager] Critical error in createTeams:', error);
            return false;
        }
    }
    
    /**
     * Update active character visuals
     * @param {Object} characterData - Active character data
     * @returns {boolean} - Success status
     */
    updateActiveCharacterVisuals(characterData) {
        if (!characterData) {
            console.warn("[TeamDisplayManager] updateActiveCharacterVisuals: Missing character data");
            return false;
        }
        
        try {
            console.log(`TDM.updateActiveCharacterVisuals: Called for Turn Highlighting. Character: ${characterData.name}`);
            
            // Clear previous highlighting in all teams
            console.log(`TDM.updateActiveCharacterVisuals: Attempting to clear indicators on TeamContainers.`);
            if (this.playerTeamContainer) {
                this.playerTeamContainer.clearAllHighlights();
            }
            
            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.clearAllHighlights();
            }
            
            // Find the correct sprite based on character data
            const sprite = this.getCharacterSprite(characterData);
            
            if (!sprite) {
                console.warn("[TeamDisplayManager] Could not find sprite for active character:", 
                    characterData.name || characterData.id || "unknown");
                return false;
            }
            
            console.log(`TDM.updateActiveCharacterVisuals: Attempting showTurnIndicator on ${characterData.team} TeamContainer for character ${characterData.name || characterData.id}.`);
            
            // Show character highlight
            sprite.highlight();
            
            // Update the turn indicator at sprite position
            this.updateTurnIndicator(sprite);
            
            console.log(`[TeamDisplayManager] Updated visuals for ${characterData.name}`);
            return true;
        } catch (error) {
            console.error("[TeamDisplayManager] Error updating active character visuals:", error);
            return false;
        }
    }
    
    /**
     * Update turn indicator position and visibility
     * @param {CharacterSprite} sprite - The active character sprite
     * @private
     */
    updateTurnIndicator(sprite) {
        if (!this.turnIndicator || !sprite) {
            console.warn("[TeamDisplayManager] updateTurnIndicator: Missing turnIndicator or sprite");
            return;
        }
        
        try {
            console.log(`[TeamDisplayManager] Updating turn indicator for ${sprite.character?.name}`);
            
            // Get global position by combining team container position with sprite position
            let xPos = 0, yPos = 0;
            
            if (sprite.container && sprite.character) {
                // Get the team container
                const teamContainer = sprite.character.team === 'player' 
                    ? this.playerTeamContainer 
                    : this.enemyTeamContainer;
                
                if (teamContainer && teamContainer.container) {
                    // Combine team container position with sprite local position
                    xPos = teamContainer.container.x + sprite.container.x;
                    yPos = teamContainer.container.y + sprite.container.y;
                    
                    console.log(`[TeamDisplayManager] Global position calculated: ${xPos}, ${yPos}`);
                } else {
                    console.warn("[TeamDisplayManager] Team container not found for sprite");
                    
                    // Fallback to local position if team container not found
                    if (sprite.container) {
                        xPos = sprite.container.x;
                        yPos = sprite.container.y;
                    }
                }
            }
            
            // Use getBottomCenterPosition if available - apply on global coords
            if (typeof sprite.getBottomCenterPosition === 'function') {
                try {
                    const pos = sprite.getBottomCenterPosition();
                    if (pos && typeof pos.x === 'number' && typeof pos.y === 'number') {
                        // Get the team container for offset
                        const teamContainer = sprite.character?.team === 'player' 
                            ? this.playerTeamContainer 
                            : this.enemyTeamContainer;
                            
                        if (teamContainer && teamContainer.container) {
                            // Add team container offset to the bottom center position
                            xPos = teamContainer.container.x + pos.x;
                            yPos = teamContainer.container.y + pos.y;
                        }
                    }
                } catch (posError) {
                    console.warn("[TeamDisplayManager] Error getting sprite position:", posError);
                }
            }
            
            // Add offset for better visual placement
            yPos += 40;
            
            // Determine color based on team
            const isPlayerTeam = sprite.character?.team === 'player';
            const color = isPlayerTeam ? 0x3498db : 0xe74c3c; // Blue for player, red for enemy
            
            // Get battle speed multiplier (if available)
            const speedMultiplier = this.scene.battleManager?.speedMultiplier || 1;
            
            // Define base animation duration and adjust for battle speed
            const baseFadeDuration = 250;
            const fadeDuration = baseFadeDuration / speedMultiplier;
            
            // Use the turnIndicator's showAt method
            console.log(`[TeamDisplayManager] Showing turn indicator at position ${xPos},${yPos}`);
            this.turnIndicator.showAt(xPos, yPos, color, fadeDuration);
            
            console.log(`[TeamDisplayManager] Turn indicator updated for ${sprite.character?.name} at position: ${xPos},${yPos}`);
        } catch (error) {
            console.error("[TeamDisplayManager] Error updating turn indicator:", error);
        }
    }
    
    /**
     * Get team data (deep copied)
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} - Copy of team data
     */
    getTeamData(teamType) {
        try {
            let sourceTeam = null;
            
            if (teamType === 'player') {
                sourceTeam = this.playerTeam;
            } else if (teamType === 'enemy') {
                sourceTeam = this.enemyTeam;
            } else {
                console.warn("[TeamDisplayManager] Invalid team type requested:", teamType);
                return [];
            }
            
            // Return a deep copy to prevent unintended modifications
            return JSON.parse(JSON.stringify(sourceTeam || []));
        } catch (error) {
            console.error("[TeamDisplayManager] Error getting team data:", error);
            return [];
        }
    }
    
    /**
     * Get a character sprite by character data
     * @param {Object} character - Character data object
     * @returns {CharacterSprite} - Character sprite or null
     */
    getCharacterSprite(character) {
        if (!character) {
            console.warn("[TeamDisplayManager] getCharacterSprite: Missing character data");
            return null;
        }
        
        try {
            // Determine which team container to use
            let container = null;
            
            // Check if the character has a team property
            if (character.team === 'player') {
                container = this.playerTeamContainer;
            } else if (character.team === 'enemy') {
                container = this.enemyTeamContainer;
            } else {
                // If no team property, try both containers
                if (this.playerTeamContainer && this.playerTeamContainer.findCharacterSprite(character)) {
                    container = this.playerTeamContainer;
                } else if (this.enemyTeamContainer && this.enemyTeamContainer.findCharacterSprite(character)) {
                    container = this.enemyTeamContainer;
                }
            }
            
            // Check if we found a valid container
            if (!container) {
                console.warn("[TeamDisplayManager] Could not determine team container for character:", 
                    character.name || character.id || "unknown");
                return null;
            }
            
            // Make sure the container has the findCharacterSprite method
            if (typeof container.findCharacterSprite !== 'function') {
                console.error("[TeamDisplayManager] TeamContainer missing findCharacterSprite method");
                return null;
            }
            
            // Find the character sprite
            const sprite = container.findCharacterSprite(character);
            
            if (!sprite) {
                console.warn("[TeamDisplayManager] Character sprite not found in team container:", 
                    character.name || character.id || "unknown");
            }
            
            return sprite;
        } catch (error) {
            console.error("[TeamDisplayManager] Error getting character sprite:", error);
            return null;
        }
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        try {
            console.log("[TeamDisplayManager] Cleaning up team components...");
            
            // Clean up turn indicator tween
            if (this.turnIndicatorTween) {
                try {
                    this.turnIndicatorTween.remove();
                    this.turnIndicatorTween = null;
                } catch (error) {
                    console.error("[TeamDisplayManager] Error removing turn indicator tween:", error);
                }
            }
            
            // Clean up turn indicator
            if (this.turnIndicator) {
                try {
                    this.turnIndicator.destroy();
                    this.turnIndicator = null;
                } catch (error) {
                    console.error("[TeamDisplayManager] Error destroying turn indicator:", error);
                }
            }
            
            // Clean up team containers
            if (this.playerTeamContainer) {
                try {
                    this.playerTeamContainer.destroy();
                    this.playerTeamContainer = null;
                } catch (error) {
                    console.error("[TeamDisplayManager] Error destroying player team container:", error);
                }
            }
            
            if (this.enemyTeamContainer) {
                try {
                    this.enemyTeamContainer.destroy();
                    this.enemyTeamContainer = null;
                } catch (error) {
                    console.error("[TeamDisplayManager] Error destroying enemy team container:", error);
                }
            }
            
            // Clear all component references
            this.components = {};
            
            console.log("[TeamDisplayManager] Team components cleaned up successfully");
        } catch (error) {
            console.error("[TeamDisplayManager] Error during team component cleanup:", error);
        }
    }
}

// Make component available globally
if (typeof window !== 'undefined') {
    window.TeamDisplayManager = TeamDisplayManager;
    console.log("TeamDisplayManager loaded and registered globally");
}


===== FILE: BattleScene.js =====
/**
 * BattleScene.js
 * Main scene for battle visualization in Phaser
 * This scene displays the battle between player and enemy teams.
 * It provides the visual representation layer that connects to
 * the BattleManager for game logic processing.
 * @version 0.6.2.3 (TeamDisplayManager implementation)
 */

// TurnIndicator is loaded via traditional script in index.html
// Note: BattleEventManager, BattleUIManager, and TeamDisplayManager are included via traditional script tags in index.html

// Define the BattleScene class
export default class BattleScene extends Phaser.Scene {

    constructor() {
        super({
            key: 'BattleScene'
        });

        // Track initialization
        this.isInitialized = false;

        // Battle state
        this.battleState = {
            isStarted: false,
            isPaused: false,
            currentSpeed: 1,
            currentTurn: 0,
            activeCharacter: null
        };
        
        // Track active character data
        this.activeCharacter = null;
        
        // Track last turn event time for debouncing
        this.lastTurnEventTime = 0;

        // Debug settings
        this.debug = {
            enabled: true,
            showCoordinates: true,
            showObjectInfo: false
        };

        // References to battle components
        this.components = {};
        this.playerTeamContainer = null; // Initialize to null
        this.enemyTeamContainer = null; // Initialize to null

        // Make available globally for debugging
        window.BattleScene = this;
    }

    /**
     * Initialize the scene with battle configuration
     * @param {Object} data - Battle configuration data from TeamBuilder
     */
    init(data) {
        console.log('BattleScene init with data:', data);
        this.battleConfig = data || {};

        // Store references to teams (with enhanced deep copying to prevent reference issues)
        try {
            if (this.battleConfig.playerTeam) {
                // Use deep copy with proper serialization/deserialization
                const serialized = JSON.stringify(this.battleConfig.playerTeam);
                this.playerTeam = JSON.parse(serialized);
                
                console.log(`BattleScene: Stored player team with ${this.playerTeam.length} heroes (deep copy)`);
                
                // Validate team data structure
                this.playerTeam.forEach((char, idx) => {
                    if (!char.stats) {
                        console.warn(`[BattleScene] Player character at index ${idx} (${char.name || 'unnamed'}) missing stats object`);
                        char.stats = { hp: 100, attack: 10, defense: 5, speed: 10 };
                    }
                });
            } else {
                this.playerTeam = [];
                console.warn('BattleScene: No player team provided');
            }
        
            if (this.battleConfig.enemyTeam) {
                // Use deep copy with proper serialization/deserialization
                const serialized = JSON.stringify(this.battleConfig.enemyTeam);
                this.enemyTeam = JSON.parse(serialized);
                
                console.log(`BattleScene: Stored enemy team with ${this.enemyTeam.length} heroes (deep copy)`);
                
                // Validate team data structure
                this.enemyTeam.forEach((char, idx) => {
                    if (!char.stats) {
                        console.warn(`[BattleScene] Enemy character at index ${idx} (${char.name || 'unnamed'}) missing stats object`);
                        char.stats = { hp: 100, attack: 10, defense: 5, speed: 10 };
                    }
                });
            } else {
                this.enemyTeam = [];
                console.warn('BattleScene: No enemy team provided');
            }
        } catch (error) {
            console.error('[BattleScene] Error processing team data:', error);
            // Create fallback empty teams
            this.playerTeam = [];
            this.enemyTeam = [];
        }

        // Track debug mode from URL parameter if present
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('debug')) {
            this.debug.enabled = urlParams.get('debug') !== 'false';
        }
        console.log(`BattleScene Initializing with Player Team Count: ${this.playerTeam.length}, Enemy Team Count: ${this.enemyTeam.length}`);
    }

    /**
     * Preload any assets needed for the battle scene
     */
    preload() {
        console.log('BattleScene preload starting...');

        // Try to set texture filtering to LINEAR (with error handling)
        // Note: Texture filtering is now handled in PhaserConfig.js via render settings instead
        // of trying to use textures.setFilter which isn't available in this version of Phaser
        console.log('BattleScene: Using config-level texture filtering instead of direct method');

        // Preload all character images in a centralized location
        try {
            // Basic placeholder asset
            this.load.image('character-circle', 'assets/images/icons/character-circle.png');
            
            // Preload all combat-optimized character art - this is the proper place to load assets
            const characterArt = [
                'Aqualia', 'Drakarion', 'Zephyr', 'Lumina', 
                'Sylvanna', 'Vaelgor', 'Seraphina' 
            ];
            
            // Special case for Caste due to parentheses in filename
            const casteKey = 'character_Caste';
            const castePath = 'assets/images/Character Art/Combat_Version/Caste.png';
            this.load.image(casteKey, castePath);
            console.log(`BattleScene: Preloading combat-optimized character image ${casteKey} from ${castePath}`);
            
            characterArt.forEach(name => {
                const key = `character_${name}`;
                // Use the combat-optimized versions of character art
                const path = `assets/images/Character Art/Combat_Version/${name}.png`;
                this.load.image(key, path);
                console.log(`BattleScene: Preloading combat-optimized character image ${key} from ${path}`);
            });
            
            console.log('BattleScene: Character art preload complete');
            
            // Preload status effect icons - call our dedicated method instead
            this.preloadStatusEffectIcons();
        } catch (error) {
            console.warn('BattleScene: Could not preload character art:', error);
        }
        
        console.log('BattleScene preload finished.');
    }

    /**
     * Create the battle scene display
     * Sets up the basic scene elements and initializes the debug tools
     */
    create() {
        console.log('BattleScene create starting...');
        
        // Create turn indicator (using global window.TurnIndicator)
        try {
            // Use the globally registered TurnIndicator class
            if (window.TurnIndicator) {
                this.turnIndicator = new window.TurnIndicator(this);
                this.turnIndicator.setDepth(1); // Set depth to render below sprites but above background
                console.log('Turn indicator created successfully:', this.turnIndicator);
                // Verify the turnIndicator has the showAt method
                if (typeof this.turnIndicator.showAt !== 'function') {
                    console.error('WARNING: Created TurnIndicator but showAt method is missing!');
                }
            } else {
                console.error('ERROR: TurnIndicator class not found in window global scope');
                // Fallback: create a simple Graphics object if class not available
                this.turnIndicator = this.add.graphics();
                this.turnIndicator.setAlpha(0);
                // Add a basic showAt method to the graphics object for compatibility
                this.turnIndicator.showAt = (x, y, color, duration) => {
                    console.log('Using fallback showAt method');
                    this.turnIndicator.clear();
                    this.turnIndicator.setPosition(x, y);
                    this.turnIndicator.fillStyle(color, 0.7);
                    this.turnIndicator.fillCircle(0, 0, 30);
                    this.turnIndicator.setAlpha(0.7);
                };
                // Add hide method for compatibility
                this.turnIndicator.hide = (duration) => {
                    this.turnIndicator.clear();
                    this.turnIndicator.setAlpha(0);
                };
            }
        } catch (err) {
            console.error('Error creating TurnIndicator:', err);
            // Create fallback if error occurs
            this.turnIndicator = this.add.graphics();
            this.turnIndicator.setAlpha(0);
            this.turnIndicator.showAt = (x, y, color, duration) => {
                console.log('Using fallback showAt method after error');
                this.turnIndicator.clear();
                this.turnIndicator.setPosition(x, y);
                this.turnIndicator.fillStyle(color, 0.7);
                this.turnIndicator.fillCircle(0, 0, 30);
                this.turnIndicator.setAlpha(0.7);
            };
            this.turnIndicator.hide = (duration) => {
                this.turnIndicator.clear();
                this.turnIndicator.setAlpha(0);
            };
        }

        // Force Canvas smoothing specifically for this scene
        try {
            if (this.sys.game.renderer.type === Phaser.CANVAS) {
                // For Canvas renderer, we need to explicitly enable image smoothing
                const canvasContext = this.sys.canvas.getContext('2d', { willReadFrequently: true });
                canvasContext.imageSmoothingEnabled = true;
                canvasContext.imageSmoothingQuality = 'high';
                console.log('BattleScene: Canvas imageSmoothingEnabled set to true');
            }
        } catch (e) {
            console.warn('Could not configure Canvas smoothing', e);
        }

        try {
            console.log('BattleScene create: Initializing BattleUIManager...');
            // Initialize BattleUIManager for UI components
            this.initializeUIManager();

            console.log('BattleScene create: Initializing debug tools...');
            // Initialize debug tools if available
            this.initializeDebugTools();
            console.log('BattleScene create: Debug tools initialized.');

            console.log('BattleScene create: Initializing battle bridge...');
            // Initialize battle bridge if BattleManager is available
            this.initializeBattleBridge();
            console.log('BattleScene create: Battle bridge initialized.');

            console.log('BattleScene create: Initializing TeamDisplayManager...');
            // Initialize TeamDisplayManager for team and character visualization
            this.initializeTeamManager();
            console.log('BattleScene create: TeamDisplayManager initialized.');

            // If TeamDisplayManager is not available or failed, fall back to legacy method
            if (!this.teamManager || !this.playerTeamContainer) {
                console.log('BattleScene create: Falling back to legacy team creation...');
                // Create character teams for visualization
                this.createCharacterTeams(); // This now has internal try-catch blocks
                console.log('BattleScene create: Legacy character teams creation attempted.');
            }

            // Hide test pattern after teams are created (if UI manager exists)
            if (this.uiManager && (this.playerTeamContainer || this.enemyTeamContainer)) {
                this.uiManager.hideTestPattern();
            } else if (!this.uiManager) {
                console.warn('BattleScene: Cannot hide test pattern - UIManager not available');
            }

            // Mark as initialized
            this.isInitialized = true;
            
            // Make test functions available globally for debugging
            window.testHealthUpdate = this.testHealthUpdate.bind(this);
            window.testActionIndicator = this.testActionIndicator.bind(this);
            
            // DIAGNOSTIC: Add a direct test method for the visual indicators
            window.testTurnHighlightingDirectly = () => {
                console.log('MANUAL TEST: Testing turn highlighting directly (bypassing events)');
                
                // Get the first character from player team as a test subject
                const testCharacter = this.playerTeam && this.playerTeam.length > 0 ? this.playerTeam[0] : null;
                if (!testCharacter) {
                    console.warn('MANUAL TEST: No test character available');
                    return;
                }
                
                console.log(`MANUAL TEST: Using test character ${testCharacter.name}`);
                
                // Direct test: Try to highlight through TeamDisplayManager first
                if (this.teamManager && typeof this.teamManager.updateActiveCharacterVisuals === 'function') {
                    console.log('MANUAL TEST: Using TeamDisplayManager.updateActiveCharacterVisuals directly');
                    this.teamManager.updateActiveCharacterVisuals(testCharacter);
                }
                
                // Direct test: Find the character sprite directly and show an action text
                if (this.teamManager && typeof this.teamManager.getCharacterSprite === 'function') {
                    const sprite = this.teamManager.getCharacterSprite(testCharacter);
                    if (sprite && typeof sprite.showActionText === 'function') {
                        console.log('MANUAL TEST: Using CharacterSprite.showActionText directly');
                        sprite.showActionText('TEST ACTION (Direct)');
                    } else {
                        console.warn('MANUAL TEST: Could not find sprite or sprite.showActionText method');
                    }
                }
            };
            
            // Log the test function availability
            console.log('DIAGNOSTIC: Test functions available in console: testHealthUpdate, testActionIndicator, testTurnHighlightingDirectly');

            console.log('BattleScene created successfully');
        } catch (error) {
            // This outer catch handles errors in the main create flow
            console.error('FATAL Error in BattleScene create method:', error);
            this.showErrorMessage('FATAL: Failed to initialize battle scene: ' + error.message);
        }
    }

    /**
     * Initialize the BattleUIManager
     * @private
     */
    initializeUIManager() {
        try {
            // Check if BattleUIManager is available
            if (window.BattleUIManager) {
                console.log('BattleScene: Creating BattleUIManager instance');
                this.uiManager = new window.BattleUIManager(this);
                
                // Initialize all UI components
                if (this.uiManager.initializeUI()) {
                    console.log('BattleScene: BattleUIManager initialized successfully');
                } else {
                    console.warn('BattleScene: BattleUIManager initialization returned false');
                }
            } else {
                console.warn('BattleScene: BattleUIManager not found, using legacy UI creation');
                this.showErrorMessage('UI Manager not available - using legacy UI');
            }
        } catch (error) {
            console.error('BattleScene: Error initializing UI manager:', error);
            this.showErrorMessage('Failed to initialize UI: ' + error.message);
        }
    }

    /**
     * Initialize the TeamDisplayManager
     * @private
     */
    initializeTeamManager() {
        try {
            // Check if TeamDisplayManager is available
            if (window.TeamDisplayManager) {
                console.log('BattleScene: Creating TeamDisplayManager instance');
                
                // Create team data object with player and enemy teams
                const teamData = {
                    playerTeam: this.playerTeam || [],
                    enemyTeam: this.enemyTeam || []
                };
                
                // Create manager with scene and team data
                this.teamManager = new window.TeamDisplayManager(this, teamData);
                
                // Initialize teams and indicator
                if (this.teamManager.initialize()) {
                    console.log('BattleScene: TeamDisplayManager initialized successfully');
                    
                    // Store references to team containers for backward compatibility
                    this.playerTeamContainer = this.teamManager.playerTeamContainer;
                    this.enemyTeamContainer = this.teamManager.enemyTeamContainer;
                    
                    // Update event manager to use team manager if needed
                    if (this.eventManager && typeof this.eventManager.setTeamManager === 'function') {
                        this.eventManager.setTeamManager(this.teamManager);
                    }
                    
                    return true;
                } else {
                    console.warn('BattleScene: TeamDisplayManager initialization returned false');
                    return false;
                }
            } else {
                console.warn('BattleScene: TeamDisplayManager not found, using legacy team creation');
                return false;
            }
        } catch (error) {
            console.error('BattleScene: Error initializing team manager:', error);
            return false;
        }
    }

    /**
     * Create character teams for visualization
     * Sets up player and enemy teams with CharacterSprite components
     */
    createCharacterTeams() {
        console.log('Attempting to create character teams...'); // Log start

        // --- Player Team Creation ---
        try {
            console.log(`Creating player team container with ${this.playerTeam?.length || 0} characters.`);
            if (!this.playerTeam || this.playerTeam.length === 0) {
                 console.warn('Player team data is empty or missing!');
                 // Optionally create a placeholder if needed for testing, or just proceed
                 this.playerTeam = []; // Ensure it's an array
            }
            this.playerTeamContainer = new TeamContainer(
                this,
                this.playerTeam,
                true, // isPlayerTeam
                { x: 800, y: 600 }  // Correct position to match original implementation
            );
            console.log('Player team container created successfully.');
        } catch (error) {
            console.error('ERROR creating PLAYER TeamContainer:', error);
            this.showErrorMessage('Failed to create player team container: ' + error.message);
            // Optionally set playerTeamContainer to null or handle fallback
            this.playerTeamContainer = null;
        }

        // --- Enemy Team Creation ---
        try {
             console.log(`Checking enemy team with ${this.enemyTeam?.length || 0} characters.`);
            if (this.enemyTeam && this.enemyTeam.length > 0) {
                console.log('Creating enemy team container from provided data.');
                this.enemyTeamContainer = new TeamContainer(
                this,
                this.enemyTeam,
                false, // isPlayerTeam
                { x: 1200, y: 600 }  // Correct position to match original implementation
                );
                console.log('Enemy team container created successfully from data.');
            } else {
                console.warn('No enemy team provided or team is empty. Creating placeholder enemy.');
                const placeholderEnemyTeam = [
                    { name: 'Placeholder Enemy', type: 'neutral', team: 'enemy', stats: { hp: 50 }, id: 'placeholder_0' } // Added an ID
                ];
                this.enemyTeamContainer = new TeamContainer(
                    this,
                    placeholderEnemyTeam,
                    false, // isPlayerTeam
                    { x: 1150, y: 350 }
                );
                console.log('Placeholder enemy team container created successfully.');
                // Optionally update this.enemyTeam if needed elsewhere
                // this.enemyTeam = placeholderEnemyTeam;
            }
        } catch (error) {
            console.error('ERROR creating ENEMY TeamContainer (or placeholder):', error);
            this.showErrorMessage('Failed to create enemy team container: ' + error.message);
            // Optionally set enemyTeamContainer to null or handle fallback
            this.enemyTeamContainer = null;
        }

        console.log('Character teams creation process finished.');
    }

    /**
     * Preload status effect icons with AI-generated versions
     */
    preloadStatusEffectIcons() {
        try {
            console.log('BattleScene: Preloading status effect icons...');
            
            // Initialize status icon mapping
            this.initStatusIconMapping();
            
            // Set the base path for status icons
            this.load.path = 'assets/images/icons/status/status-icons/';
            
            // Status effect icons list
            const statusIconIds = [
                'burn', 'poison', 'regen', 'stun', 'freeze', 'shield',
                'atk_up', 'atk_down', 'def_up', 'def_down', 'spd_up', 'spd_down',
                'str_up', 'str_down', 'int_up', 'int_down', 'spi_up', 'spi_down',
                'taunt', 'evade', 'bleed', 'reflect', 'vulnerable', 'immune', 'crit_up'
            ];
            
            // Load each status icon with the AI version
            statusIconIds.forEach(iconId => {
                const key = `status_${iconId}`;
                const iconPath = this.statusIconMapping[iconId] || `${iconId}.png`;
                this.load.image(key, iconPath);
                console.log(`BattleScene: Preloading status icon ${key} from ${iconPath}`);
            });
            
            // Reset the path after loading status icons
            this.load.path = '';
            
            console.log('BattleScene: Status effect icons preload complete');
        } catch (error) {
            console.warn('BattleScene: Could not preload status effect icons:', error);
        }
    }
    
    /**
     * Initialize the status icon mapping
     */
    initStatusIconMapping() {
        this.statusIconMapping = window.StatusIconMapper ? 
            window.StatusIconMapper.getMapping() : 
            {
                // Fallback mapping if StatusIconMapper isn't available
                'atk_down': 'AI_Icons/32px/Attack Down_AI.png',
                'atk_up': 'AI_Icons/32px/AttackUp.png',
                'bleed': 'AI_Icons/32px/Bleeding_AI.png',
                'burn': 'AI_Icons/32px/Burn_AI.png',
                'crit_up': 'AI_Icons/32px/CritChanceUp_AI.png',
                'def_down': 'AI_Icons/32px/Defense Down_AI.png',
                'def_up': 'AI_Icons/32px/Defense Up_AI.png',
                'evade': 'AI_Icons/32px/Evasion_AI.png',
                'freeze': 'AI_Icons/32px/Freeze_AI.png',
                'immune': 'AI_Icons/32px/Immunity_AI.png',
                'int_down': 'AI_Icons/32px/IntellectDown_AI.png',
                'int_up': 'AI_Icons/32px/Intellect Up_AI.png',
                'poison': 'AI_Icons/32px/Poison_AI.png',
                'reflect': 'AI_Icons/32px/DamageReflect_AI.png',
                'regen': 'AI_Icons/32px/Regeneration_AI.png',
                'shield': 'AI_Icons/32px/Shield_AI.png',
                'spd_down': 'AI_Icons/32px/Speed Down_AI.png',
                'spd_up': 'AI_Icons/32px/Speed Up_AI.png',
                'spi_down': 'AI_Icons/32px/SpiritDown_AI.png',
                'spi_up': 'AI_Icons/32px/SpiritUp_AI.png',
                'str_down': 'AI_Icons/32px/StrengthDown_AI.png',
                'str_up': 'AI_Icons/32px/StrengthUp_AI.png',
                'stun': 'AI_Icons/32px/Stunned_AI.png',
                'taunt': 'AI_Icons/32px/Taunt_AI.png',
                'vulnerable': 'AI_Icons/32px/Vulnerable_AI.png'
            };
    }
    
    /**
     * Clean up character teams
     */
    cleanupCharacterTeams() {
        try {
            if (this.playerTeamContainer) {
                this.playerTeamContainer.destroy();
                this.playerTeamContainer = null;
            }

            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.destroy();
                this.enemyTeamContainer = null;
            }

            console.log('Character teams cleaned up');
        } catch (error) {
            console.error('Error cleaning up character teams:', error);
        }
    }

    /**
     * Update all active character visual indicators
     * Delegates to TeamDisplayManager if available
     * @param {Object} characterData - Character currently taking action
     */
    updateActiveCharacterVisuals(characterData) {
        // REFACTORING: Use TeamDisplayManager if available
        if (this.teamManager) {
            return this.teamManager.updateActiveCharacterVisuals(characterData);
        }
        
        // Original implementation follows
        try {
            if (!characterData) {
                console.warn('updateActiveCharacterVisuals: Missing character data');
                return;
            }
            
            console.log(`Updating active character visuals for ${characterData.name} (${characterData.team})`);
            
            // Clear turn indicators from all teams
            if (this.playerTeamContainer) this.playerTeamContainer.clearTurnIndicators();
            if (this.enemyTeamContainer) this.enemyTeamContainer.clearTurnIndicators();
            
            // Find the correct team container based on the character's team
            const teamContainer = characterData.team === 'player' 
                ? this.playerTeamContainer 
                : this.enemyTeamContainer;
                
            if (!teamContainer) {
                console.warn(`Could not find team container for team: ${characterData.team}`);
                return;
            }
            
            // Find the character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(characterData.name);
            
            if (characterSprite) {
                // Show the turn indicator for this character
                teamContainer.showTurnIndicator(characterData.name);
                
                // Update the UI text for current character's action using the UI manager
                if (this.uiManager) {
                    this.uiManager.updateActionTextDisplay(this.battleState.currentTurn, characterData);
                } else {
                    console.warn('Cannot update action text display - UIManager not available');
                }
                
                // Determine marker color based on team (blue for player, red for enemy)
                const markerColor = characterData.team === 'player' ? 0x4488ff : 0xff4444;
                
                // Calculate position (under the character)
                const targetX = characterSprite.container.x;
                const targetY = characterSprite.container.y + 40; // Adjust this offset for best visual placement
                
                // Get battle speed multiplier
                const speedMultiplier = this.battleManager?.speedMultiplier || 1;
                
                // Define base animation duration and adjust for battle speed
                const baseFadeDuration = 250;
                const fadeDuration = baseFadeDuration / speedMultiplier;
                
                // Show the floor indicator at the calculated position
                if (this.turnIndicator) {
                    this.turnIndicator.showAt(targetX, targetY, markerColor, fadeDuration);
                }
                
                console.log(`Turn indicator updated for ${characterData.name} at position: ${targetX},${targetY}`);
            } else {
                console.warn(`Could not find character sprite for: ${characterData.name}`);
                
                // Hide the floor indicator if we can't find the character
                if (this.turnIndicator) {
                    const baseFadeDuration = 250;
                    const speedMultiplier = this.battleManager?.speedMultiplier || 1;
                    const fadeDuration = baseFadeDuration / speedMultiplier;
                    this.turnIndicator.hide(fadeDuration);
                }
            }
        } catch (error) {
            console.error('Error updating active character visuals:', error);
        }
    }

    /**
     * Show attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Function} onComplete - Callback when animation completes
     */
    showAttackAnimation(attacker, target, onComplete) {
        try {
            if (!attacker || !target) {
                if (onComplete) onComplete();
                return;
            }
            
            console.log(`[BattleScene] showAttackAnimation: ${attacker.name} (${attacker.team}) attacking ${target.name} (${target.team})`);

            // Validate that attacker and target are from different teams
            if (attacker.team === target.team) {
                console.warn(`[BattleScene] showAttackAnimation: Attempted attack on same team! Attacker and target both on team ${attacker.team}`);
                // Don't show animation for same-team attacks
                if (onComplete) onComplete();
                return;
            }

            // Find sprites
            const attackerTeamContainer = attacker.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            const targetTeamContainer = target.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!attackerTeamContainer || !targetTeamContainer) {
                console.warn(`[BattleScene] showAttackAnimation: Missing team container(s)`);
                if (onComplete) onComplete();
                return;
            }

            const attackerSprite = attackerTeamContainer.getCharacterSpriteByName(attacker.name);
            const targetSprite = targetTeamContainer.getCharacterSpriteByName(target.name);

            if (!attackerSprite || !targetSprite) {
                console.warn(`[BattleScene] showAttackAnimation: Could not find sprites for ${!attackerSprite ? 'attacker' : 'target'}`);
                if (onComplete) onComplete();
                return;
            }

            attackerSprite.showAttackAnimation(targetSprite, onComplete);
        } catch (error) {
            console.error('[BattleScene] Error showing attack animation:', error);
            if (onComplete) onComplete();
        }
    }

    /**
     * Show floating text above a character
     * @param {Object} character - Character to show text above
     * @param {string} text - Text to display
     * @param {Object} style - Text style options
     */
    showFloatingText(character, text, style = {}) {
        try {
            if (!character) return;

            const teamContainer = character.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!teamContainer) return;

            const sprite = teamContainer.getCharacterSpriteByName(character.name);

            if (!sprite) return;

            sprite.showFloatingText(text, style);
        } catch (error) {
            console.error('Error showing floating text:', error);
        }
    }

    /**
     * Initialize debug tools like coordinate display and object identifier
     */
    initializeDebugTools() {
        if (!this.debug.enabled) return;

        try {
            if (typeof CoordinateDisplay !== 'undefined' && this.debug.showCoordinates) {
                this.coordinateDisplay = new CoordinateDisplay(this);
                console.log('CoordinateDisplay initialized');
            } else if (this.debug.showCoordinates) {
                console.warn('CoordinateDisplay class not found.');
            }

            if (typeof ObjectIdentifier !== 'undefined' && this.debug.showObjectInfo) {
                this.objectIdentifier = new ObjectIdentifier(this);
                console.log('ObjectIdentifier initialized');
            } else if (this.debug.showObjectInfo) {
                console.warn('ObjectIdentifier class not found.');
            }
        } catch (error) {
            console.error('Error initializing debug tools:', error);
            this.showErrorMessage('Failed to load debug tools');
        }
    }

    /**
     * Cleanup debug tools
     */
    cleanupDebugTools() {
        try {
            if (this.coordinateDisplay && typeof this.coordinateDisplay.destroy === 'function') {
                this.coordinateDisplay.destroy();
                this.coordinateDisplay = null;
                console.log('CoordinateDisplay destroyed.');
            }
            if (this.objectIdentifier && typeof this.objectIdentifier.destroy === 'function') {
                this.objectIdentifier.destroy();
                this.objectIdentifier = null;
                console.log('ObjectIdentifier destroyed.');
            }
        } catch(error) {
            console.error('Error cleaning up debug tools:', error);
        }
    }

    /**
     * Initialize the bridge connection to BattleManager
     */
    initializeBattleBridge() {
        try {
            // Ensure turn indicator exists
            if (!this.turnIndicator) {
                try {
                    if (window.TurnIndicator) {
                        this.turnIndicator = new window.TurnIndicator(this);
                        this.turnIndicator.setDepth(1);
                    } else {
                        console.error('TurnIndicator class not found during bridge init');
                    }
                } catch (err) {
                    console.error('Error creating TurnIndicator during bridge init:', err);
                }
            }
            // Primary approach: Call the dedicated initialization function
            if (typeof window.initializeBattleBridge === 'function' && window.battleManager) {
                console.log('BattleScene: Calling initializeBattleBridge with BattleManager and BattleScene');
                const success = window.initializeBattleBridge(window.battleManager, this);
                if (success) {
                    console.log('BattleScene: Successfully initialized battle bridge');
                    // Get the bridge instance after initialization
                    this.battleBridge = window.getBattleBridge ? window.getBattleBridge() : window.battleBridge;
                    
                    // Initialize the BattleEventManager
                    this.initializeEventManager();
                } else {
                    console.warn('BattleScene: initializeBattleBridge reported failure');
                }
            }
            // Fallback #1: Use getBattleBridge accessor if available
            else if (typeof window.getBattleBridge === 'function') {
                console.log('BattleScene: Getting battleBridge through getBattleBridge()');
                this.battleBridge = window.getBattleBridge();
                
                // Initialize manually if needed
                if (this.battleBridge && window.battleManager && typeof this.battleBridge.initialize === 'function') {
                    console.log('BattleScene: Initializing battleBridge manually');
                    this.battleBridge.initialize(window.battleManager, this);
                    
                    // Initialize the BattleEventManager
                    this.initializeEventManager();
                }
            }
            // Fallback #2: Direct access as last resort
            else if (window.battleBridge && window.battleManager) {
                console.log('BattleScene: Using legacy direct access to battleBridge');
                this.battleBridge = window.battleBridge; // Use existing global INSTANCE
                this.battleBridge.initialize(window.battleManager, this); // Pass references
                
                // Initialize the BattleEventManager
                this.initializeEventManager();

                console.log('BattleBridge initialized and listeners set up.');
            } else {
                console.warn('battleBridge instance or BattleManager not found. Bridge not initialized.');
                // Add fallback to create instance if only the class exists
                if (window.BattleBridge && typeof window.BattleBridge === 'function' && window.battleManager) {
                    try {
                        console.log('Attempting to create battleBridge instance on-demand...');
                        this.battleBridge = new window.BattleBridge();
                        window.battleBridge = this.battleBridge; // Also make globally available
                        this.battleBridge.initialize(window.battleManager, this);
                        
                        // Initialize the BattleEventManager
                        this.initializeEventManager();
                        
                        console.log('Created battleBridge instance on-demand successfully');
                    } catch (instanceError) {
                        console.error('Failed to create battleBridge instance on-demand:', instanceError);
                    }
                }
            }
        } catch(error) {
            console.error('Error initializing BattleBridge:', error);
            this.showErrorMessage('Failed to connect to battle logic.');
        }
    }

    /**
     * Initialize the BattleEventManager
     * @private
     */
    initializeEventManager() {
        console.log('BattleScene.initializeEventManager: Starting with diagnostics:', {
            battleBridgeAvailable: !!this.battleBridge,
            battleEventManagerClassAvailable: typeof window.BattleEventManager === 'function',
            teamManagerAvailable: !!this.teamManager
        });
        
        try {
            if (this.battleBridge) {
                // DIAGNOSTIC: Check battleBridge's event type structure
                console.log('BattleScene.initializeEventManager: BattleBridge event types check:', {
                    hasEventTypes: !!this.battleBridge.eventTypes,
                    eventTypesList: this.battleBridge.eventTypes ? Object.keys(this.battleBridge.eventTypes) : 'none',
                    CHARACTER_ACTION: this.battleBridge.eventTypes?.CHARACTER_ACTION || 'undefined',
                    ABILITY_USED: this.battleBridge.eventTypes?.ABILITY_USED || 'undefined'
                });
                
                // Check if BattleEventManager is available
                if (window.BattleEventManager) {
                    console.log('[BattleScene.initializeEventManager] >>> About to create BattleEventManager instance.');
                    this.eventManager = new window.BattleEventManager(this, this.battleBridge);
                    console.log('[BattleScene.initializeEventManager] <<< BattleEventManager instance supposedly created. this.eventManager is:', this.eventManager);
                    
                    // DIAGNOSTIC: Verify the event manager was created properly
                    console.log('BattleScene.initializeEventManager: BattleEventManager created:', {
                        instanceCreated: !!this.eventManager,
                        hasOnCharacterAction: typeof this.eventManager?.onCharacterAction === 'function',
                        hasOnAbilityUsed: typeof this.eventManager?.onAbilityUsed === 'function'
                    });
                    
                    // Set TeamDisplayManager reference if available
                    if (this.teamManager && typeof this.eventManager.setTeamManager === 'function') {
                        this.eventManager.setTeamManager(this.teamManager);
                        console.log('BattleScene: Set TeamDisplayManager reference in BattleEventManager');
                    }
                    
                    console.log('BattleScene: BattleEventManager initialized successfully');
                } else {
                    console.warn('BattleScene: BattleEventManager not found, battle events will not be handled.');
                }
            } else {
                console.warn('BattleScene: Cannot initialize event manager - battleBridge not available');
            }
        } catch (error) {
            console.error('BattleScene: Error initializing event manager:', error);
            console.error('BattleScene: Error initializing event manager - battle events will not be handled.');
        }
    }

    /**
     * Cleanup the bridge connection
     */
    cleanupBattleBridge() {
        try {
            // Clean up the event manager first
            if (this.eventManager && typeof this.eventManager.destroy === 'function') {
                console.log('BattleScene: Cleaning up BattleEventManager');
                this.eventManager.destroy();
                this.eventManager = null;
            } else if (this.battleBridge) {
                // Legacy cleanup if no event manager is available
                this.battleBridge.removeEventListener(this.battleBridge.eventTypes.TURN_STARTED, this.handleTurnStarted.bind(this));
                console.log('BattleScene: Legacy event listener cleanup performed');
            }
            
            console.log('BattleScene: BattleBridge cleanup complete');
        } catch(error) {
            console.error('Error cleaning up BattleBridge:', error);
        }
    }

    /**
     * Test health bar updates manually (for debugging)
     * @param {string} teamType - 'player' or 'enemy'
     * @param {number} characterIndex - Index of the character in the team
     * @param {number} newHealth - New health value to set
     */
    testHealthUpdate(teamType = 'player', characterIndex = 0, newHealth = 50) {
        try {
            // Get the appropriate team container
            const teamContainer = teamType === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            if (!teamContainer) {
                console.error(`testHealthUpdate: ${teamType} team container not found`);
                return;
            }
            
            // Get the character array for reference values
            const characterArray = teamType === 'player' ? this.playerTeam : this.enemyTeam;
            if (!characterArray || characterArray.length === 0) {
                console.error(`testHealthUpdate: ${teamType} team array is empty`);
                return;
            }
            
            // Validate characterIndex
            if (characterIndex < 0 || characterIndex >= characterArray.length) {
                console.error(`testHealthUpdate: Invalid character index ${characterIndex} for ${teamType} team`);
                return;
            }
            
            // Get character data
            const character = characterArray[characterIndex];
            const maxHealth = character.stats.hp || 100;
            
            // Update character's health in data structure
            character.currentHp = newHealth;
            
            // Create mock event data
            const mockEventData = {
                character: character,
                newHealth: newHealth,
                amount: character.currentHp - newHealth // Simulated damage/healing amount
            };
            
            // If we have an event manager, use it to dispatch the event
            if (this.eventManager) {
                const eventType = newHealth < character.currentHp ? 
                    this.battleBridge.eventTypes.CHARACTER_DAMAGED : 
                    this.battleBridge.eventTypes.CHARACTER_HEALED;
                
                this.battleBridge.dispatchEvent(eventType, mockEventData);
                
                console.log(`testHealthUpdate: Event dispatched for ${character.name}'s health to ${newHealth}/${maxHealth}`);
            } else {
                // Don't attempt to call methods that have been moved to the event manager
                console.warn('testHealthUpdate: BattleEventManager not available, cannot update health visually');
            }
            
            // Make function available in window for console testing
            window.testHealthUpdate = this.testHealthUpdate.bind(this);
        } catch (error) {
            console.error(`testHealthUpdate: Error:`, error);
        }
    }

    /**
     * Test action indicator manually (for debugging)
     * @param {string} teamType - 'player' or 'enemy'
     * @param {number} characterIndex - Index of the character in the team
     * @param {string} actionText - Action text to display
     */
    testActionIndicator(teamType = 'player', characterIndex = 0, actionText = 'Test Action') {
        try {
            // Get the appropriate team container
            const teamContainer = teamType === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            if (!teamContainer) {
                console.error(`testActionIndicator: ${teamType} team container not found`);
                return;
            }
            
            // Get the character array for reference
            const characterArray = teamType === 'player' ? this.playerTeam : this.enemyTeam;
            if (!characterArray || characterArray.length === 0) {
                console.error(`testActionIndicator: ${teamType} team array is empty`);
                return;
            }
            
            // Validate characterIndex
            if (characterIndex < 0 || characterIndex >= characterArray.length) {
                console.error(`testActionIndicator: Invalid character index ${characterIndex} for ${teamType} team`);
                return;
            }
            
            // Get character data
            const character = characterArray[characterIndex];
            
            // Get character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(character.name);
            if (!characterSprite) {
                console.error(`testActionIndicator: Could not find sprite for ${character.name}`);
                return;
            }
            
            // Show action text
            characterSprite.showActionText(actionText);
            
            console.log(`testActionIndicator: Showed '${actionText}' for ${character.name} (${teamType} team)`);
        } catch (error) {
            console.error(`testActionIndicator: Error:`, error);
        }
    }

    /**
     * Get team data from scene
     * Delegates to TeamDisplayManager if available
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} - Deep copy of requested team data
     */
    getTeamData(teamType) {
        // REFACTORING: Use TeamDisplayManager if available
        if (this.teamManager) {
            return this.teamManager.getTeamData(teamType);
        }
        
        // Original implementation follows
        try {
            if (teamType === 'player' && this.playerTeam) {
                console.log(`BattleScene: Providing player team data with ${this.playerTeam.length} heroes`);
                return JSON.parse(JSON.stringify(this.playerTeam));
            } else if (teamType === 'enemy' && this.enemyTeam) {
                console.log(`BattleScene: Providing enemy team data with ${this.enemyTeam.length} heroes`);
                return JSON.parse(JSON.stringify(this.enemyTeam));
            } else {
                console.warn(`BattleScene: Unable to provide ${teamType} team data`);
                return [];
            }
        } catch (error) {
            console.error(`BattleScene: Error getting ${teamType} team data:`, error);
            return [];
        }
    }
    
    /**
     * Display battle outcome screen
     * Delegates to BattleUIManager
     * @param {string} winner - 'player', 'enemy', or 'draw'
     */
    showBattleOutcome(winner) {
        try {
            console.log(`BattleScene: Showing battle outcome - Winner: ${winner}`);
            
            if (this.uiManager) {
                this.uiManager.showBattleOutcome(winner);
            } else {
                console.error('BattleScene: BattleUIManager not available, cannot show battle outcome');
            }
        } catch (error) {
            console.error('Error showing battle outcome:', error);
        }
    }

    /**
     * Display error messages in the UI
     * Delegates to BattleUIManager
     * @param {string} message - The error message to show
     */
    showErrorMessage(message) {
        console.error('UI Error Message:', message); // Log to console

        if (this.uiManager) {
            this.uiManager.showErrorMessage(message);
        } else {
            console.error('BattleScene: BattleUIManager not available, cannot show error message');
        }
    }

    /**
     * Update loop for the battle scene
     * Called by Phaser on every frame to update game state
     * @param {number} time - Current time in ms since game start
     * @param {number} delta - Time in ms since last update
     */
    update(time, delta) {
        try {
            // Update debug tools if enabled
            if (this.debug.enabled) {
                if (this.objectIdentifier && typeof this.objectIdentifier.update === 'function') {
                    this.objectIdentifier.update();
                }
                // No separate update needed for CoordinateDisplay as it uses pointer events
            }

            // Update character teams if present
            if (this.playerTeamContainer) {
                this.playerTeamContainer.update();
            }

            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.update();
            }
        } catch (error) {
            console.error('Error in update loop:', error);
            // Don't show error messages here to avoid spamming the user
            // since this method is called many times per second
        }
    }

    /**
     * Scene shutdown handler
     * Clean up resources and listeners when the scene is stopped
     */
    shutdown() {
        console.log('BattleScene: Shutting down');

        try {
            // Clean up debug tools
            this.cleanupDebugTools();

            // Clean up battle bridge (including event manager)
            this.cleanupBattleBridge();

            // Clean up TeamDisplayManager
            if (this.teamManager && typeof this.teamManager.destroy === 'function') {
                console.log('BattleScene: Cleaning up TeamDisplayManager');
                this.teamManager.destroy();
                this.teamManager = null;
            } else {
                // If TeamDisplayManager doesn't exist, use legacy cleanup
                this.cleanupCharacterTeams();
            }

            // Clean up UI manager
            if (this.uiManager && typeof this.uiManager.destroy === 'function') {
                console.log('BattleScene: Cleaning up BattleUIManager');
                this.uiManager.destroy();
                this.uiManager = null;
            }

            // Clean up keyboard listeners
            if (this.input && this.input.keyboard) {
                this.input.keyboard.off('keydown-D', this.handleDebugKeypress, this);
            }

            // Clean up tweens
            this.tweens.killAll();

            // Clean up local references
            this.battleConfig = null;
            this.playerTeam = null;
            this.enemyTeam = null;
            this.components = {};
            
            // Clean up turn indicator
            if(this.turnIndicator) { 
                this.turnIndicator.destroy(); 
                this.turnIndicator = null; 
            }

            console.log('BattleScene: Shut down successfully');
        } catch (error) {
            console.error('Error during scene shutdown:', error);
        }
    }
}

window.BattleScene = BattleScene;


===== FILE: BattleScene_old.js =====
/**
 * BattleScene.js
 * Main scene for battle visualization in Phaser
 * * This scene displays the battle between player and enemy teams.
 * It provides the visual representation layer that connects to
 * the BattleManager for game logic processing.
 * * @version 0.5.1.4 (with Turn Indicator feature)
 */

import TurnIndicator from '../components/battle/TurnIndicator.js';
// Note: BattleEventManager is included via traditional script tag in index.html

// Define the BattleScene class
export default class BattleScene extends Phaser.Scene {

    constructor() {
        super({
            key: 'BattleScene'
        });

        // Track initialization
        this.isInitialized = false;

        // Battle state
        this.battleState = {
            isStarted: false,
            isPaused: false,
            currentSpeed: 1,
            currentTurn: 0,
            activeCharacter: null
        };
        
        // Track active character data
        this.activeCharacter = null;
        
        // Track last turn event time for debouncing
        this.lastTurnEventTime = 0;

        // Debug settings
        this.debug = {
            enabled: true,
            showCoordinates: true,
            showObjectInfo: false
        };

        // References to battle components
        this.components = {};
        this.playerTeamContainer = null; // Initialize to null
        this.enemyTeamContainer = null; // Initialize to null
        this.testPattern = null; // Initialize to null

        // Make available globally for debugging
        window.BattleScene = this;
    }

    /**
     * Initialize the scene with battle configuration
     * @param {Object} data - Battle configuration data from TeamBuilder
     */
    init(data) {
        console.log('BattleScene init with data:', data);
        this.battleConfig = data || {};

        // Store references to teams (with enhanced deep copying to prevent reference issues)
        try {
            if (this.battleConfig.playerTeam) {
                // Use deep copy with proper serialization/deserialization
                const serialized = JSON.stringify(this.battleConfig.playerTeam);
                this.playerTeam = JSON.parse(serialized);
                
                console.log(`BattleScene: Stored player team with ${this.playerTeam.length} heroes (deep copy)`);
                
                // Validate team data structure
                this.playerTeam.forEach((char, idx) => {
                    if (!char.stats) {
                        console.warn(`[BattleScene] Player character at index ${idx} (${char.name || 'unnamed'}) missing stats object`);
                        char.stats = { hp: 100, attack: 10, defense: 5, speed: 10 };
                    }
                });
            } else {
                this.playerTeam = [];
                console.warn('BattleScene: No player team provided');
            }
        
            if (this.battleConfig.enemyTeam) {
                // Use deep copy with proper serialization/deserialization
                const serialized = JSON.stringify(this.battleConfig.enemyTeam);
                this.enemyTeam = JSON.parse(serialized);
                
                console.log(`BattleScene: Stored enemy team with ${this.enemyTeam.length} heroes (deep copy)`);
                
                // Validate team data structure
                this.enemyTeam.forEach((char, idx) => {
                    if (!char.stats) {
                        console.warn(`[BattleScene] Enemy character at index ${idx} (${char.name || 'unnamed'}) missing stats object`);
                        char.stats = { hp: 100, attack: 10, defense: 5, speed: 10 };
                    }
                });
            } else {
                this.enemyTeam = [];
                console.warn('BattleScene: No enemy team provided');
            }
        } catch (error) {
            console.error('[BattleScene] Error processing team data:', error);
            // Create fallback empty teams
            this.playerTeam = [];
            this.enemyTeam = [];
        }

        // Track debug mode from URL parameter if present
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('debug')) {
            this.debug.enabled = urlParams.get('debug') !== 'false';
        }
        console.log(`BattleScene Initializing with Player Team Count: ${this.playerTeam.length}, Enemy Team Count: ${this.enemyTeam.length}`);
    }

    /**
     * Preload any assets needed for the battle scene
     */
    preload() {
        console.log('BattleScene preload starting...');

        // Try to set texture filtering to LINEAR (with error handling)
        // Note: Texture filtering is now handled in PhaserConfig.js via render settings instead
        // of trying to use textures.setFilter which isn't available in this version of Phaser
        console.log('BattleScene: Using config-level texture filtering instead of direct method');

        // Preload all character images in a centralized location
        try {
            // Basic placeholder asset
            this.load.image('character-circle', 'assets/images/icons/character-circle.png');
            
            // Preload all combat-optimized character art - this is the proper place to load assets
            const characterArt = [
                'Aqualia', 'Drakarion', 'Zephyr', 'Lumina', 
                'Sylvanna', 'Vaelgor', 'Seraphina' 
            ];
            
            // Special case for Caste due to parentheses in filename
            const casteKey = 'character_Caste';
            const castePath = 'assets/images/Character Art/Combat_Version/Caste.png';
            this.load.image(casteKey, castePath);
            console.log(`BattleScene: Preloading combat-optimized character image ${casteKey} from ${castePath}`);
            
            characterArt.forEach(name => {
                const key = `character_${name}`;
                // Use the combat-optimized versions of character art
                const path = `assets/images/Character Art/Combat_Version/${name}.png`;
                this.load.image(key, path);
                console.log(`BattleScene: Preloading combat-optimized character image ${key} from ${path}`);
            });
            
            console.log('BattleScene: Character art preload complete');
            
            // Preload status effect icons - call our dedicated method instead
            this.preloadStatusEffectIcons();
        } catch (error) {
            console.warn('BattleScene: Could not preload character art:', error);
        }
        
        console.log('BattleScene preload finished.');
    }

    /**
     * Create the battle scene display
     * Sets up the basic scene elements and initializes the debug tools
     */
    create() {
        console.log('BattleScene create starting...');
        
        // Create turn indicator (using static import from top of file)
        try {
            this.turnIndicator = new TurnIndicator(this);
            this.turnIndicator.setDepth(1); // Set depth to render below sprites but above background
            console.log('Turn indicator created successfully:', this.turnIndicator);
            // Verify the turnIndicator has the showAt method
            if (typeof this.turnIndicator.showAt !== 'function') {
                console.error('WARNING: Created TurnIndicator but showAt method is missing!');
            }
        } catch (err) {
            console.error('Error creating TurnIndicator:', err);
            // Fallback: create a simple Graphics object if instantiation fails
            this.turnIndicator = this.add.graphics();
            this.turnIndicator.setAlpha(0);
            // Add a basic showAt method to the graphics object for compatibility
            this.turnIndicator.showAt = (x, y, color, duration) => {
                console.log('Using fallback showAt method');
                this.turnIndicator.clear();
                this.turnIndicator.setPosition(x, y);
                this.turnIndicator.fillStyle(color, 0.7);
                this.turnIndicator.fillCircle(0, 0, 30);
                this.turnIndicator.setAlpha(0.7);
            };
        }

        // Force Canvas smoothing specifically for this scene
        try {
            if (this.sys.game.renderer.type === Phaser.CANVAS) {
                // For Canvas renderer, we need to explicitly enable image smoothing
                const canvasContext = this.sys.canvas.getContext('2d', { willReadFrequently: true });
                canvasContext.imageSmoothingEnabled = true;
                canvasContext.imageSmoothingQuality = 'high';
                console.log('BattleScene: Canvas imageSmoothingEnabled set to true');
            }
        } catch (e) {
            console.warn('Could not configure Canvas smoothing', e);
        }

        try {
            console.log('BattleScene create: Creating background...');
            // Create plain background for now
            this.createBackground();
            console.log('BattleScene create: Background created.');

            console.log('BattleScene create: Creating scene title...');
            // Add scene title for testing
            this.createSceneTitle();
            console.log('BattleScene create: Scene title created.');

            console.log('BattleScene create: Creating return button...');
            // Add return button (temporary)
            this.createReturnButton();
            console.log('BattleScene create: Return button created.');

            console.log('BattleScene create: Creating test pattern...');
            // Add test pattern to confirm rendering
            this.createTestPattern();
            console.log('BattleScene create: Test pattern created.');

            console.log('BattleScene create: Creating welcome message...');
            // Add welcome message to confirm battle data
            this.createWelcomeMessage();
            console.log('BattleScene create: Welcome message created.');

            console.log('BattleScene create: Initializing debug tools...');
            // Initialize debug tools if available
            this.initializeDebugTools();
            console.log('BattleScene create: Debug tools initialized.');

            console.log('BattleScene create: Initializing battle bridge...');
            // Initialize battle bridge if BattleManager is available
            this.initializeBattleBridge();
            console.log('BattleScene create: Battle bridge initialized.');

            console.log('BattleScene create: Creating character teams...');
            // Create character teams for visualization
            this.createCharacterTeams(); // This now has internal try-catch blocks
            console.log('BattleScene create: Character teams creation attempted.');

            console.log('BattleScene create: Creating debug panel...');
            // Add debug controls panel
            this.createDebugPanel();
            console.log('BattleScene create: Debug panel created.');
            
            console.log('BattleScene create: Creating battle controls...');
            // Add battle control panel
            this.createBattleControls();
            console.log('BattleScene create: Battle controls created.');
            
            console.log('BattleScene create: Creating battle log panel...');
            // Add battle log panel
            this.createBattleLogPanel();
            console.log('BattleScene create: Battle log panel created.');

            // Mark as initialized
            this.isInitialized = true;
            
            // Make test functions available globally for debugging
            window.testHealthUpdate = this.testHealthUpdate.bind(this);
            window.testActionIndicator = this.testActionIndicator.bind(this);

            console.log('BattleScene created successfully');
        } catch (error) {
            // This outer catch handles errors in the main create flow
            console.error('FATAL Error in BattleScene create method:', error);
            this.showErrorMessage('FATAL: Failed to initialize battle scene: ' + error.message);
        }
    }

    /**
     * Create character teams for visualization
     * Sets up player and enemy teams with CharacterSprite components
     */
    createCharacterTeams() {
        console.log('Attempting to create character teams...'); // Log start

        // --- Player Team Creation ---
        try {
            console.log(`Creating player team container with ${this.playerTeam?.length || 0} characters.`);
            if (!this.playerTeam || this.playerTeam.length === 0) {
                 console.warn('Player team data is empty or missing!');
                 // Optionally create a placeholder if needed for testing, or just proceed
                 this.playerTeam = []; // Ensure it's an array
            }
            this.playerTeamContainer = new TeamContainer(
                this,
                this.playerTeam,
                true, // isPlayerTeam
                { x: 800, y: 600 }  // Changed from 400 to 600
            );
            console.log('Player team container created successfully.');
        } catch (error) {
            console.error('ERROR creating PLAYER TeamContainer:', error);
            this.showErrorMessage('Failed to create player team container: ' + error.message);
            // Optionally set playerTeamContainer to null or handle fallback
            this.playerTeamContainer = null;
        }

        // --- Enemy Team Creation ---
        try {
             console.log(`Checking enemy team with ${this.enemyTeam?.length || 0} characters.`);
            if (this.enemyTeam && this.enemyTeam.length > 0) {
                console.log('Creating enemy team container from provided data.');
                this.enemyTeamContainer = new TeamContainer(
                this,
                this.enemyTeam,
                false, // isPlayerTeam
                { x: 1200, y: 600 }  // Changed from 400 to 600
                );
                console.log('Enemy team container created successfully from data.');
            } else {
                console.warn('No enemy team provided or team is empty. Creating placeholder enemy.');
                const placeholderEnemyTeam = [
                    { name: 'Placeholder Enemy', type: 'neutral', team: 'enemy', stats: { hp: 50 }, id: 'placeholder_0' } // Added an ID
                ];
                this.enemyTeamContainer = new TeamContainer(
                    this,
                    placeholderEnemyTeam,
                    false, // isPlayerTeam
                    { x: 1200, y: 400 }
                );
                console.log('Placeholder enemy team container created successfully.');
                // Optionally update this.enemyTeam if needed elsewhere
                // this.enemyTeam = placeholderEnemyTeam;
            }
        } catch (error) {
            console.error('ERROR creating ENEMY TeamContainer (or placeholder):', error);
            this.showErrorMessage('Failed to create enemy team container: ' + error.message);
            // Optionally set enemyTeamContainer to null or handle fallback
            this.enemyTeamContainer = null;
        }

        console.log('Character teams creation process finished.');

        // Hide test pattern *only if* at least one container was successfully created
        if (this.testPattern && (this.playerTeamContainer || this.enemyTeamContainer)) {
             console.log('Hiding test pattern as character containers seem to exist.');
            this.testPattern.setVisible(false);
        } else if (this.testPattern) {
             console.warn('Not hiding test pattern because character container creation might have failed.');
        }
    }


    /**
     * Preload status effect icons with AI-generated versions
     */
    preloadStatusEffectIcons() {
        try {
            console.log('BattleScene: Preloading status effect icons...');
            
            // Initialize status icon mapping
            this.initStatusIconMapping();
            
            // Set the base path for status icons
            this.load.path = 'assets/images/icons/status/status-icons/';
            
            // Status effect icons list
            const statusIconIds = [
                'burn', 'poison', 'regen', 'stun', 'freeze', 'shield',
                'atk_up', 'atk_down', 'def_up', 'def_down', 'spd_up', 'spd_down',
                'str_up', 'str_down', 'int_up', 'int_down', 'spi_up', 'spi_down',
                'taunt', 'evade', 'bleed', 'reflect', 'vulnerable', 'immune', 'crit_up'
            ];
            
            // Load each status icon with the AI version
            statusIconIds.forEach(iconId => {
                const key = `status_${iconId}`;
                const iconPath = this.statusIconMapping[iconId] || `${iconId}.png`;
                this.load.image(key, iconPath);
                console.log(`BattleScene: Preloading status icon ${key} from ${iconPath}`);
            });
            
            // Reset the path after loading status icons
            this.load.path = '';
            
            console.log('BattleScene: Status effect icons preload complete');
        } catch (error) {
            console.warn('BattleScene: Could not preload status effect icons:', error);
        }
    }
    
    /**
     * Initialize the status icon mapping
     */
    initStatusIconMapping() {
        this.statusIconMapping = window.StatusIconMapper ? 
            window.StatusIconMapper.getMapping() : 
            {
                // Fallback mapping if StatusIconMapper isn't available
                'atk_down': 'AI_Icons/32px/Attack Down_AI.png',
                'atk_up': 'AI_Icons/32px/AttackUp.png',
                'bleed': 'AI_Icons/32px/Bleeding_AI.png',
                'burn': 'AI_Icons/32px/Burn_AI.png',
                'crit_up': 'AI_Icons/32px/CritChanceUp_AI.png',
                'def_down': 'AI_Icons/32px/Defense Down_AI.png',
                'def_up': 'AI_Icons/32px/Defense Up_AI.png',
                'evade': 'AI_Icons/32px/Evasion_AI.png',
                'freeze': 'AI_Icons/32px/Freeze_AI.png',
                'immune': 'AI_Icons/32px/Immunity_AI.png',
                'int_down': 'AI_Icons/32px/IntellectDown_AI.png',
                'int_up': 'AI_Icons/32px/Intellect Up_AI.png',
                'poison': 'AI_Icons/32px/Poison_AI.png',
                'reflect': 'AI_Icons/32px/DamageReflect_AI.png',
                'regen': 'AI_Icons/32px/Regeneration_AI.png',
                'shield': 'AI_Icons/32px/Shield_AI.png',
                'spd_down': 'AI_Icons/32px/Speed Down_AI.png',
                'spd_up': 'AI_Icons/32px/Speed Up_AI.png',
                'spi_down': 'AI_Icons/32px/SpiritDown_AI.png',
                'spi_up': 'AI_Icons/32px/SpiritUp_AI.png',
                'str_down': 'AI_Icons/32px/StrengthDown_AI.png',
                'str_up': 'AI_Icons/32px/StrengthUp_AI.png',
                'stun': 'AI_Icons/32px/Stunned_AI.png',
                'taunt': 'AI_Icons/32px/Taunt_AI.png',
                'vulnerable': 'AI_Icons/32px/Vulnerable_AI.png'
            };
    }


    
    /**
     * Clean up character teams
     */
    cleanupCharacterTeams() {
        try {
            if (this.playerTeamContainer) {
                this.playerTeamContainer.destroy();
                this.playerTeamContainer = null;
            }

            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.destroy();
                this.enemyTeamContainer = null;
            }

            console.log('Character teams cleaned up');
        } catch (error) {
            console.error('Error cleaning up character teams:', error);
        }
    }

    /**
     * Update all active character visual indicators
     * @param {Object} characterData - Character currently taking action
     */
    updateActiveCharacterVisuals(characterData) {
        try {
            if (!characterData) {
                console.warn('updateActiveCharacterVisuals: Missing character data');
                return;
            }
            
            console.log(`Updating active character visuals for ${characterData.name} (${characterData.team})`);
            
            // Clear turn indicators from all teams
            if (this.playerTeamContainer) this.playerTeamContainer.clearTurnIndicators();
            if (this.enemyTeamContainer) this.enemyTeamContainer.clearTurnIndicators();
            
            // Find the correct team container based on the character's team
            const teamContainer = characterData.team === 'player' 
                ? this.playerTeamContainer 
                : this.enemyTeamContainer;
                
            if (!teamContainer) {
                console.warn(`Could not find team container for team: ${characterData.team}`);
                return;
            }
            
            // Find the character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(characterData.name);
            
            if (characterSprite) {
                // Show the turn indicator for this character
                teamContainer.showTurnIndicator(characterData.name);
                
                // Update the UI text for current character's action
                this.updateActionTextDisplay(this.battleState.currentTurn, characterData);
                
                // Determine marker color based on team (blue for player, red for enemy)
                const markerColor = characterData.team === 'player' ? 0x4488ff : 0xff4444;
                
                // Calculate position (under the character)
                const targetX = characterSprite.container.x;
                const targetY = characterSprite.container.y + 40; // Adjust this offset for best visual placement
                
                // Get battle speed multiplier
                const speedMultiplier = this.battleManager?.speedMultiplier || 1;
                
                // Define base animation duration and adjust for battle speed
                const baseFadeDuration = 250;
                const fadeDuration = baseFadeDuration / speedMultiplier;
                
                // Show the floor indicator at the calculated position
                if (this.turnIndicator) {
                    this.turnIndicator.showAt(targetX, targetY, markerColor, fadeDuration);
                }
                
                console.log(`Turn indicator updated for ${characterData.name} at position: ${targetX},${targetY}`);
            } else {
                console.warn(`Could not find character sprite for: ${characterData.name}`);
                
                // Hide the floor indicator if we can't find the character
                if (this.turnIndicator) {
                    const baseFadeDuration = 250;
                    const speedMultiplier = this.battleManager?.speedMultiplier || 1;
                    const fadeDuration = baseFadeDuration / speedMultiplier;
                    this.turnIndicator.hide(fadeDuration);
                }
            }
        } catch (error) {
            console.error('Error updating active character visuals:', error);
        }
    }

    /**
     * Update the turn number display only
     * @param {number} turnNumber - The current turn number
     */
    /**
     * Safely gets or creates a text object
     * @param {string} objectKey - Reference property name ('turnTextIndicator', etc.)
     * @param {Object} position - {x, y} coordinates
     * @param {string} defaultText - Default text to display
     * @param {Object} style - Text style options
     * @returns {Phaser.GameObjects.Text} - Valid text object
     */
    safeGetTextObject(objectKey, position, defaultText, style) {
        try {
            // Check if the text object exists and is valid
            const currentObj = this[objectKey];
            
            if (currentObj && currentObj.active && !currentObj.destroyed) {
                // Object exists and is valid - return it
                return currentObj;
            }
            
            // Create new text object if needed
            console.log(`[BattleScene] Recreating ${objectKey} text object`);
            
            // Destroy old object if it exists but is invalid
            if (currentObj) {
                try {
                    currentObj.destroy();
                } catch (e) {
                    console.warn(`[BattleScene] Error destroying old ${objectKey}:`, e);
                }
            }
            
            // Create new text object
            const newObj = this.add.text(
                position.x,
                position.y,
                defaultText,
                style
            ).setOrigin(0.5);
            
            // Store for future reference
            this[objectKey] = newObj;
            
            return newObj;
        } catch (error) {
            console.error(`[BattleScene] Error in safeGetTextObject for ${objectKey}:`, error);
            return null;
        }
    }

    /**
     * Update the turn number display only
     * @param {number} turnNumber - The current turn number
     */
    updateTurnNumberDisplay(turnNumber) {
        try {
            // Define standard text style
            const indicatorStyle = {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3,
                backgroundColor: '#444444',
                padding: { x: 10, y: 5 }
            };
            
            // Position at the top of the screen
            const position = { 
                x: this.cameras.main.width / 2,
                y: 80
            };
            
            // Get character name from current text if available
            let characterName = '';
            if (this.turnTextIndicator && this.turnTextIndicator.text) {
                const characterNameMatch = this.turnTextIndicator.text.match(/: ([^']+)'s Action/i);
                characterName = characterNameMatch ? characterNameMatch[1] : '';
            }
            
            // Format text based on available information
            const text = characterName 
                ? `TURN ${turnNumber}: ${characterName}'s Action`
                : `TURN ${turnNumber}`;
                
            // Get or create text object safely
            const textObj = this.safeGetTextObject(
                'turnTextIndicator', 
                position, 
                text, 
                indicatorStyle
            );
            
            // If we got a valid text object, update it
            if (textObj) {
                try {
                    textObj.setText(text);
                    
                    // Add animation effect if not already animated
                    if (!this.tweens.isTweening(textObj)) {
                        this.tweens.add({
                            targets: textObj,
                            scale: { from: 0.8, to: 1 },
                            duration: 300,
                            ease: 'Back.easeOut'
                        });
                    }
                } catch (textError) {
                    console.error('[BattleScene] Error updating turn text:', textError);
                    // Reset for recreation next time
                    this.turnTextIndicator = null;
                }
            }
            
            console.log(`Turn number display updated to ${turnNumber}`);
        } catch (error) {
            console.error('Error updating turn number display:', error);
            // Reset for recreation next time
            this.turnTextIndicator = null;
        }
    }
    
    /**
     * Update the action text display with character information
     * @param {number} turnNumber - The current turn number
     * @param {Object} character - The character performing an action
     */
    /**
     * Update the action text display with character information
     * @param {number} turnNumber - The current turn number
     * @param {Object} character - The character performing an action
     */
    updateActionTextDisplay(turnNumber, character) {
        try {
            if (!character) return;
            
            // Background color based on team
            const backgroundColor = character.team === 'player' ? '#225588' : '#882255';
            
            // Create or update the text with character's information
            const text = `TURN ${turnNumber}: ${character.name}'s Action`;
            const indicatorStyle = {
                fontFamily: 'Arial',
                fontSize: '18px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3,
                backgroundColor: backgroundColor,
                padding: { x: 10, y: 5 }
            };
            
            // Position at the top of the screen
            const position = { 
                x: this.cameras.main.width / 2,
                y: 80
            };
            
            // Get or create text object safely
            const textObj = this.safeGetTextObject(
                'turnTextIndicator', 
                position, 
                text, 
                indicatorStyle
            );
            
            // If we got a valid text object, update it
            if (textObj) {
                try {
                    textObj.setText(text);
                    textObj.setBackgroundColor(backgroundColor);
                    
                    // Add or restart animation effect
                    this.tweens.killTweensOf(textObj);
                    this.tweens.add({
                        targets: textObj,
                        scale: { from: 0.9, to: 1 },
                        duration: 300,
                        ease: 'Back.easeOut',
                        onComplete: () => {
                            // Only add bounce if object is still valid
                            if (textObj.active && !textObj.destroyed) {
                                this.tweens.add({
                                    targets: textObj,
                                    y: { from: 80, to: 85 },
                                    duration: 1500,
                                    yoyo: true,
                                    repeat: -1,
                                    ease: 'Sine.easeInOut'
                                });
                            }
                        }
                    });
                } catch (textError) {
                    console.error('[BattleScene] Error updating action text:', textError);
                    // Reset for recreation next time
                    this.turnTextIndicator = null;
                }
            }
            
            console.log(`Action text updated for ${character.name} on turn ${turnNumber}`);
        } catch (error) {
            console.error('Error updating action text display:', error);
            // Reset for recreation next time
            this.turnTextIndicator = null;
        }
    }

    /**
     * Show attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Function} onComplete - Callback when animation completes
     */
    showAttackAnimation(attacker, target, onComplete) {
        try {
            if (!attacker || !target) {
                if (onComplete) onComplete();
                return;
            }

            // Find sprites
            const attackerTeamContainer = attacker.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            const targetTeamContainer = target.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!attackerTeamContainer || !targetTeamContainer) {
                if (onComplete) onComplete();
                return;
            }

            const attackerSprite = attackerTeamContainer.getCharacterSpriteByName(attacker.name);
            const targetSprite = targetTeamContainer.getCharacterSpriteByName(target.name);

            if (!attackerSprite || !targetSprite) {
                if (onComplete) onComplete();
                return;
            }

            attackerSprite.showAttackAnimation(targetSprite, onComplete);
        } catch (error) {
            console.error('Error showing attack animation:', error);
            if (onComplete) onComplete();
        }
    }

    /**
     * Show floating text above a character
     * @param {Object} character - Character to show text above
     * @param {string} text - Text to display
     * @param {Object} style - Text style options
     */
    showFloatingText(character, text, style = {}) {
        try {
            if (!character) return;

            const teamContainer = character.team === 'player'
                ? this.playerTeamContainer
                : this.enemyTeamContainer;

            if (!teamContainer) return;

            const sprite = teamContainer.getCharacterSpriteByName(character.name);

            if (!sprite) return;

            sprite.showFloatingText(text, style);
        } catch (error) {
            console.error('Error showing floating text:', error);
        }
    }

    /**
     * Create a test pattern to verify the scene is rendering correctly
     * This is a temporary visual element to confirm Phaser is working
     */
    createTestPattern() {
        try {
            // Create a container for test elements
            const testContainer = this.add.container(
                this.cameras.main.width / 2,
                this.cameras.main.height / 2
            );

            // Add colorful circles in different positions
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            const radius = 30;

            for (let i = 0; i < colors.length; i++) {
                const angle = (i / colors.length) * Math.PI * 2;
                const x = Math.cos(angle) * 100;
                const y = Math.sin(angle) * 100;

                const circle = this.add.circle(x, y, radius, colors[i], 0.8);
                testContainer.add(circle);

                // Add pulsing animation
                this.tweens.add({
                    targets: circle,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    duration: 500 + (i * 100),
                    yoyo: true,
                    repeat: -1
                });
            }

            // Add version text
            const versionText = this.add.text(0, 0, 'Battle Scene v0.5.0.4b', { // *** UPDATED VERSION ***
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#ffffff',
                align: 'center'
            }).setOrigin(0.5);

            testContainer.add(versionText);

            // Store reference
            this.testPattern = testContainer;

            console.log('Test pattern created successfully');
        } catch (error) {
            console.error('Error creating test pattern:', error);
        }
    }

    /**
     * Create a welcome message showing battle data
     * Displays player team and enemy team information
     */
    createWelcomeMessage() {
        try {
            // Create player team summary
            const playerTeamNames = this.playerTeam.map(character => character.name).join(', ');
            const playerTeamText = `Player Team (${this.playerTeam.length}): ${playerTeamNames || 'None'}`;

            // Create enemy team summary
            // Ensure enemyTeam is an array before mapping
            const safeEnemyTeam = Array.isArray(this.enemyTeam) ? this.enemyTeam : [];
            const enemyTeamNames = safeEnemyTeam.map(character => character.name).join(', ');
            const enemyTeamText = `Enemy Team (${safeEnemyTeam.length}): ${enemyTeamNames || 'None'}`;

            // Create battle mode text
            const battleModeText = `Battle Mode: ${this.battleConfig.battleMode || 'Unknown'}`;

            // Create welcome message
            const welcomeText = this.add.text(
                this.cameras.main.width / 2,
                120,
                `Battle Scene Initialized!\n${playerTeamText}\n${enemyTeamText}\n${battleModeText}`,
                {
                    fontFamily: 'Arial',
                    fontSize: 20,
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 2
                }
            ).setOrigin(0.5);

            // Add to scene
            this.welcomeMessage = welcomeText;

            console.log('Welcome message created successfully');
        } catch (error) {
            console.error('Error creating welcome message:', error);
        }
    }

    /**
     * Create the background for the battle scene
     */
    createBackground() {
        try {
            // Create a gradient background
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;

            // Create background rectangle
            this.add.rectangle(
                width / 2,
                height / 2,
                width,
                height,
                0x333344 // Navy blue color
            );

            // Add some visual interest with diagonal lines
            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0xffffff, 0.1);

            // Draw grid lines
            const spacing = 80;
            for (let i = 0; i < width + height; i += spacing) {
                graphics.moveTo(0, i);
                graphics.lineTo(i, 0);
            }

            graphics.strokePath();

            console.log('Background created successfully');
        } catch (error) {
            console.error('Error creating background:', error);
        }
    }

    /**
     * Create the scene title
     */
    createSceneTitle() {
        try {
            this.sceneTitle = this.add.text(
                this.cameras.main.width / 2,
                50,
                'Battle Scene',
                {
                    fontFamily: 'Arial',
                    fontSize: 36,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }
            ).setOrigin(0.5);

            // Add simple animation
            this.tweens.add({
                targets: this.sceneTitle,
                y: 40,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            console.log('Scene title created successfully');
        } catch (error) {
            console.error('Error creating scene title:', error);
        }
    }

    /**
     * Create the return button to go back to the TeamBuilder
     */
     createReturnButton() {
         // ** Implementation Added for v0.5.0.4b Fix **
         try {
             const button = this.add.text(
                 this.cameras.main.width - 100,
                 50,
                 'Return',
                 {
                     fontFamily: 'Arial',
                     fontSize: '20px',
                     color: '#ffffff',
                     backgroundColor: '#555555',
                     padding: { x: 15, y: 8 }
                 }
             ).setOrigin(0.5).setInteractive({ useHandCursor: true });

             button.on('pointerdown', () => {
                 console.log('Return button clicked');
                 this.returnToTeamBuilder();
             });

             button.on('pointerover', () => {
                 button.setBackgroundColor('#777777');
             });

             button.on('pointerout', () => {
                 button.setBackgroundColor('#555555');
             });

             this.returnButton = button;
             console.log('Return button created successfully');
         } catch (error) {
             console.error('Error creating return button:', error);
             this.showErrorMessage('Failed to create return button');
         }
     }

     /**
     * Handle returning to the TeamBuilder scene/UI
     */
     returnToTeamBuilder() {
         try {
             console.log('Returning to Team Builder...');
             
             // Clean up battle state
             if (window.battleBridge) {
                 window.battleBridge.cleanupBattleState();
             }

             // Stop the current scene properly
             this.scene.stop();

             // Hide Phaser container and show DOM UI
             const phaserContainer = document.getElementById('game-container');
             if (phaserContainer) {
                 phaserContainer.style.display = 'none';
             }
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if (teamBuilderContainer) {
                 teamBuilderContainer.style.display = 'block'; // Or 'flex' depending on your CSS
             }

             // Optionally, notify TeamBuilderUI if it exists
             if (window.teamBuilderUI && typeof window.teamBuilderUI.onReturnFromPhaserBattle === 'function') {
                 window.teamBuilderUI.onReturnFromPhaserBattle();
             } else {
                 console.warn('TeamBuilderUI or onReturnFromPhaserBattle not found.');
             }

         } catch (error) {
             console.error('Error returning to Team Builder:', error);
             // Add fallback in case of error during transition
             alert('Error returning to Team Builder. Please refresh if needed.');
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
         }
     }

    /**
     * Initialize debug tools like coordinate display and object identifier
     */
     initializeDebugTools() {
        // ** Implementation Added for v0.5.0.4b Fix **
         if (!this.debug.enabled) return;

         try {
             if (typeof CoordinateDisplay !== 'undefined' && this.debug.showCoordinates) {
                 this.coordinateDisplay = new CoordinateDisplay(this);
                 console.log('CoordinateDisplay initialized');
             } else if (this.debug.showCoordinates) {
                 console.warn('CoordinateDisplay class not found.');
             }

             if (typeof ObjectIdentifier !== 'undefined' && this.debug.showObjectInfo) {
                 this.objectIdentifier = new ObjectIdentifier(this);
                 console.log('ObjectIdentifier initialized');
             } else if (this.debug.showObjectInfo) {
                 console.warn('ObjectIdentifier class not found.');
             }
         } catch (error) {
             console.error('Error initializing debug tools:', error);
             this.showErrorMessage('Failed to load debug tools');
         }
     }

     /**
      * Cleanup debug tools
      */
      cleanupDebugTools() {
         // ** Implementation Added for v0.5.0.4b Fix **
         try {
             if (this.coordinateDisplay && typeof this.coordinateDisplay.destroy === 'function') {
                 this.coordinateDisplay.destroy();
                 this.coordinateDisplay = null;
                 console.log('CoordinateDisplay destroyed.');
             }
             if (this.objectIdentifier && typeof this.objectIdentifier.destroy === 'function') {
                 this.objectIdentifier.destroy();
                 this.objectIdentifier = null;
                 console.log('ObjectIdentifier destroyed.');
             }
         } catch(error) {
              console.error('Error cleaning up debug tools:', error);
         }
     }

     /**
      * Initialize the bridge connection to BattleManager
      */
      initializeBattleBridge() {
         // ** Refactored for v0.6.1.1 - BattleEventManager implementation **
          try {
              // Ensure turn indicator exists
              if (!this.turnIndicator) {
                  try {
                      this.turnIndicator = new TurnIndicator(this);
                      this.turnIndicator.setDepth(1);
                  } catch (err) {
                      console.error('Error creating TurnIndicator during bridge init:', err);
                  }
              }
              // Primary approach: Call the dedicated initialization function
              if (typeof window.initializeBattleBridge === 'function' && window.battleManager) {
                  console.log('BattleScene: Calling initializeBattleBridge with BattleManager and BattleScene');
                  const success = window.initializeBattleBridge(window.battleManager, this);
                  if (success) {
                      console.log('BattleScene: Successfully initialized battle bridge');
                      // Get the bridge instance after initialization
                      this.battleBridge = window.getBattleBridge ? window.getBattleBridge() : window.battleBridge;
                      
                      // Initialize the BattleEventManager
                      this.initializeEventManager();
                  } else {
                      console.warn('BattleScene: initializeBattleBridge reported failure');
                  }
              }
              // Fallback #1: Use getBattleBridge accessor if available
              else if (typeof window.getBattleBridge === 'function') {
                  console.log('BattleScene: Getting battleBridge through getBattleBridge()');
                  this.battleBridge = window.getBattleBridge();
                  
                  // Initialize manually if needed
                  if (this.battleBridge && window.battleManager && typeof this.battleBridge.initialize === 'function') {
                      console.log('BattleScene: Initializing battleBridge manually');
                      this.battleBridge.initialize(window.battleManager, this);
                      
                      // Initialize the BattleEventManager
                      this.initializeEventManager();
                  }
              }
              // Fallback #2: Direct access as last resort
              else if (window.battleBridge && window.battleManager) {
                  console.log('BattleScene: Using legacy direct access to battleBridge');
                  this.battleBridge = window.battleBridge; // Use existing global INSTANCE
                  this.battleBridge.initialize(window.battleManager, this); // Pass references
                  
                  // Initialize the BattleEventManager
                  this.initializeEventManager();

                  console.log('BattleBridge initialized and listeners set up.');
              } else {
                  console.warn('battleBridge instance or BattleManager not found. Bridge not initialized.');
                  // Add fallback to create instance if only the class exists
                  if (window.BattleBridge && typeof window.BattleBridge === 'function' && window.battleManager) {
                      try {
                          console.log('Attempting to create battleBridge instance on-demand...');
                          this.battleBridge = new window.BattleBridge();
                          window.battleBridge = this.battleBridge; // Also make globally available
                          this.battleBridge.initialize(window.battleManager, this);
                          
                          // Initialize the BattleEventManager
                          this.initializeEventManager();
                          
                          console.log('Created battleBridge instance on-demand successfully');
                      } catch (instanceError) {
                          console.error('Failed to create battleBridge instance on-demand:', instanceError);
                      }
                  }
              }
          } catch(error) {
              console.error('Error initializing BattleBridge:', error);
              this.showErrorMessage('Failed to connect to battle logic.');
          }
      }


     /**
      * Initialize the BattleEventManager
      * @private
      */
     initializeEventManager() {
          try {
              if (this.battleBridge) {
                  // Check if BattleEventManager is available
                  if (window.BattleEventManager) {
                      console.log('BattleScene: Creating BattleEventManager instance');
                      this.eventManager = new window.BattleEventManager(this, this.battleBridge);
                      console.log('BattleScene: BattleEventManager initialized successfully');
                  } else {
                      console.warn('BattleScene: BattleEventManager not found, using legacy event setup');
                      console.warn('BattleScene: BattleEventManager not found, battle events will not be handled.');
                  }
              } else {
                  console.warn('BattleScene: Cannot initialize event manager - battleBridge not available');
              }
          } catch (error) {
              console.error('BattleScene: Error initializing event manager:', error);
              console.error('BattleScene: Error initializing event manager - battle events will not be handled.');
          }
     }

     /**
      * Cleanup the bridge connection
      */
      cleanupBattleBridge() {
         // ** Refactored for v0.6.1.1 - BattleEventManager implementation **
          try {
              // Clean up the event manager first
              if (this.eventManager && typeof this.eventManager.destroy === 'function') {
                  console.log('BattleScene: Cleaning up BattleEventManager');
                  this.eventManager.destroy();
                  this.eventManager = null;
              } else if (this.battleBridge) {
                  // Legacy cleanup if no event manager is available
                  this.battleBridge.removeEventListener(this.battleBridge.eventTypes.TURN_STARTED, this.handleTurnStarted.bind(this));
                  console.log('BattleScene: Legacy event listener cleanup performed');
              }
              
              console.log('BattleScene: BattleBridge cleanup complete');
          } catch(error) {
               console.error('Error cleaning up BattleBridge:', error);
          }
      }

     /**
      * Create the debug controls panel
      */
      createDebugPanel() {
          // Debug panel disabled to avoid UI clutter
          return; // Skip creating debug panel entirely
      }


     /**
     * Create the battle log for displaying battle events
     */
     createBattleLogPanel() {
        try {
            // Check if DirectBattleLog class exists
            if (typeof DirectBattleLog === 'function') {
                // Calculate half screen height for max height constraint
                const halfScreenHeight = this.cameras.main.height * 0.5;
                
                // Create the direct battle log in the right side of the screen
                this.battleLog = new DirectBattleLog(
                    this, 
                    this.cameras.main.width - 350, // X position (right side)
                    50,                            // Y position (top)
                    300,                           // Width
                    {
                        backgroundColor: 0x000000,
                        backgroundAlpha: 0.5,
                        fontSize: 16,
                        maxMessages: 30,
                        padding: 10,
                        maxHeight: halfScreenHeight // Limit height to half the screen
                    }
                );
                
                // For testing only - send a test message through BattleBridge if available
                if (this.battleBridge) {
                    console.log('BattleScene: Sending test message through BattleBridge');
                    this.battleBridge.dispatchEvent(this.battleBridge.eventTypes.BATTLE_LOG, {
                        message: 'Test message from BattleScene via BattleBridge',
                        type: 'info'
                    });
                } else {
                    console.warn('BattleScene: BattleBridge not available for test message');
                }
                
                // Add direct access for testing in console
                window.battleLog = this.battleLog;
                
                console.log('Battle log created successfully');
            } else {
                console.error('DirectBattleLog class not found');
                this.showErrorMessage('Battle log not available');
            }
        } catch (error) {
            console.error('Error creating battle log:', error);
            this.showErrorMessage('Failed to create battle log');
        }
    }
    
    /**
     * Create the battle control panel
     * Adds UI controls for starting battle, changing speed, pausing/resuming
     */
     /**
     * Test health bar updates manually (for debugging)
     * @param {string} teamType - 'player' or 'enemy'
     * @param {number} characterIndex - Index of the character in the team
     * @param {number} newHealth - New health value to set
     */
    testHealthUpdate(teamType = 'player', characterIndex = 0, newHealth = 50) {
        try {
            // Get the appropriate team container
            const teamContainer = teamType === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            if (!teamContainer) {
                console.error(`testHealthUpdate: ${teamType} team container not found`);
                return;
            }
            
            // Get the character array for reference values
            const characterArray = teamType === 'player' ? this.playerTeam : this.enemyTeam;
            if (!characterArray || characterArray.length === 0) {
                console.error(`testHealthUpdate: ${teamType} team array is empty`);
                return;
            }
            
            // Validate characterIndex
            if (characterIndex < 0 || characterIndex >= characterArray.length) {
                console.error(`testHealthUpdate: Invalid character index ${characterIndex} for ${teamType} team`);
                return;
            }
            
            // Get character data
            const character = characterArray[characterIndex];
            const maxHealth = character.stats.hp || 100;
            
            // Update character's health in data structure
            character.currentHp = newHealth;
            
            // Create mock event data
            const mockEventData = {
                character: character,
                newHealth: newHealth,
                amount: character.currentHp - newHealth // Simulated damage/healing amount
            };
            
            // Call the appropriate event handler
            if (newHealth < character.currentHp) {
                console.log(`Testing damage event for ${character.name} (${teamType} team) to ${newHealth}/${maxHealth}`);
                this.onCharacterDamaged(mockEventData);
            } else {
                console.log(`Testing healing event for ${character.name} (${teamType} team) to ${newHealth}/${maxHealth}`);
                this.onCharacterHealed(mockEventData);
            }
            
            console.log(`testHealthUpdate: Updated ${character.name}'s health to ${newHealth}/${maxHealth}`);
            
            // Make function available in window for console testing
            window.testHealthUpdate = this.testHealthUpdate.bind(this);
        } catch (error) {
            console.error(`testHealthUpdate: Error:`, error);
        }
    }


    

    

    
    /**
     * Test action indicator manually (for debugging)
     * @param {string} teamType - 'player' or 'enemy'
     * @param {number} characterIndex - Index of the character in the team
     * @param {string} actionText - Action text to display
     */
    testActionIndicator(teamType = 'player', characterIndex = 0, actionText = 'Test Action') {
        try {
            // Get the appropriate team container
            const teamContainer = teamType === 'player' ? this.playerTeamContainer : this.enemyTeamContainer;
            if (!teamContainer) {
                console.error(`testActionIndicator: ${teamType} team container not found`);
                return;
            }
            
            // Get the character array for reference
            const characterArray = teamType === 'player' ? this.playerTeam : this.enemyTeam;
            if (!characterArray || characterArray.length === 0) {
                console.error(`testActionIndicator: ${teamType} team array is empty`);
                return;
            }
            
            // Validate characterIndex
            if (characterIndex < 0 || characterIndex >= characterArray.length) {
                console.error(`testActionIndicator: Invalid character index ${characterIndex} for ${teamType} team`);
                return;
            }
            
            // Get character data
            const character = characterArray[characterIndex];
            
            // Get character sprite
            const characterSprite = teamContainer.getCharacterSpriteByName(character.name);
            if (!characterSprite) {
                console.error(`testActionIndicator: Could not find sprite for ${character.name}`);
                return;
            }
            
            // Show action text
            characterSprite.showActionText(actionText);
            
            console.log(`testActionIndicator: Showed '${actionText}' for ${character.name} (${teamType} team)`);
        } catch (error) {
            console.error(`testActionIndicator: Error:`, error);
        }
    }
    
     createBattleControls() {
     try {
     // Create debug test buttons (only in development mode)
     if (this.debug.enabled) {
          // Create button for testing action indicators
          const actionTestButton = this.add.text(
              100, 90, 'Test Action', {
                  fontFamily: 'Arial',
                  fontSize: '16px',
                  color: '#ffffff',
                  backgroundColor: '#333333',
                  padding: { x: 10, y: 5 }
              }
          ).setInteractive({ useHandCursor: true });
          
          actionTestButton.on('pointerdown', () => {
              // Test showing action indicator for player team character at index 0
              if (this.playerTeam && this.playerTeam.length > 0) {
                  this.testActionIndicator('player', 0, 'Ability: Fireball');
              }
          });
          
          actionTestButton.on('pointerover', () => actionTestButton.setBackgroundColor('#555555'));
          actionTestButton.on('pointerout', () => actionTestButton.setBackgroundColor('#333333'));
          
          // Create button for testing health bar updates
                  const testButton = this.add.text(
                      100, 50, 'Test Health', {
                          fontFamily: 'Arial',
                          fontSize: '16px',
                          color: '#ffffff',
                          backgroundColor: '#333333',
                          padding: { x: 10, y: 5 }
                      }
                  ).setInteractive({ useHandCursor: true });
                  
                  testButton.on('pointerdown', () => {
                      // Test player team character at index 0 with 50% health
                      if (this.playerTeam && this.playerTeam.length > 0) {
                          const character = this.playerTeam[0];
                          const maxHealth = character.stats.hp;
                          const newHealth = Math.floor(maxHealth * 0.5); // 50% health
                          this.testHealthUpdate('player', 0, newHealth);
                      }
                  });
                  
                  testButton.on('pointerover', () => testButton.setBackgroundColor('#555555'));
                  testButton.on('pointerout', () => testButton.setBackgroundColor('#333333'));
              }
              
              // Create the battle control panel at the bottom of the screen
              if (typeof BattleControlPanel === 'function') {
                 this.battleControlPanel = new BattleControlPanel(
                     this,
                     this.cameras.main.width / 2, // center horizontally
                     this.cameras.main.height - 50 // position near bottom
                 );
                 
                 // Set up event listeners for battle events
                 if (this.battleBridge) {
                     // Listen for battle events to update control panel
                     this.battleBridge.addEventListener(this.battleBridge.eventTypes.BATTLE_STARTED, 
                         (data) => this.battleControlPanel.onBattleEvent(data));
                     this.battleBridge.addEventListener(this.battleBridge.eventTypes.BATTLE_ENDED, 
                         (data) => this.battleControlPanel.onBattleEvent(data));
                     this.battleBridge.addEventListener(this.battleBridge.eventTypes.TURN_STARTED, 
                         (data) => this.onTurnStarted(data));
                 }
                 
                 console.log('Battle control panel created successfully');
             } else {
                 console.error('BattleControlPanel class not found');
                 this.showErrorMessage('Battle controls not available');
             }
         } catch (error) {
             console.error('Error creating battle control panel:', error);
             this.showErrorMessage('Failed to create battle controls');
         }
     }
     
     /**
      * Handle turn started event from BattleManager
      * @param {object} data - Turn data including currentCharacter
      */
     onTurnStarted(data) {
         try {
             console.log(`Turn ${data.turnNumber} started. Character: ${data.currentCharacter?.name}`);
             
             // Update battle state
             this.battleState.currentTurn = data.turnNumber;
             this.battleState.activeCharacter = data.currentCharacter;
             
             // Update the turn number only - don't set active character visuals here
             this.updateTurnNumberDisplay(data.turnNumber);
         } catch (error) {
             console.error('Error handling turn started event:', error);
         }
     }

     /**
     * Handle debug keypress events
     */
     handleDebugKeypress(event) {
        // Removed to clean up UI
        return;
     }
     
    /**
     * Get team data from scene
     * Returns copies of team data to prevent reference issues
     * @param {string} teamType - 'player' or 'enemy'
     * @returns {Array} - Deep copy of requested team data
     */
    getTeamData(teamType) {
        try {
            if (teamType === 'player' && this.playerTeam) {
                console.log(`BattleScene: Providing player team data with ${this.playerTeam.length} heroes`);
                return JSON.parse(JSON.stringify(this.playerTeam));
            } else if (teamType === 'enemy' && this.enemyTeam) {
                console.log(`BattleScene: Providing enemy team data with ${this.enemyTeam.length} heroes`);
                return JSON.parse(JSON.stringify(this.enemyTeam));
            } else {
                console.warn(`BattleScene: Unable to provide ${teamType} team data`);
                return [];
            }
        } catch (error) {
            console.error(`BattleScene: Error getting ${teamType} team data:`, error);
            return [];
        }
    }
    
    /**
     * Display battle outcome screen
     * @param {string} winner - 'player', 'enemy', or 'draw'
     */
    showBattleOutcome(winner) {
        try {
            console.log(`BattleScene: Showing battle outcome - Winner: ${winner}`);
            
            // Create container for outcome elements
            const container = this.add.container(this.cameras.main.width / 2, this.cameras.main.height / 2);
            container.setDepth(1000); // Ensure it appears above everything else
            
            // Add semi-transparent background
            const background = this.add.rectangle(
                0, 0, 
                this.cameras.main.width, 
                this.cameras.main.height, 
                0x000000, 0.7
            );
            container.add(background);
            
            // Create outcome message
            let message = '';
            let color = 0xffffff;
            
            // FIXED: Now properly handles 'victory' and 'defeat' values
            if (winner === 'player' || winner === 'victory') {
                message = 'VICTORY!';
                color = 0x00ff00; // Green
            } else if (winner === 'enemy' || winner === 'defeat') {
                message = 'DEFEAT';
                color = 0xff0000; // Red
            } else if (winner === 'draw') {
                message = 'DRAW';
                color = 0xffff00; // Yellow
            } else {
                // Fallback for genuinely unexpected winner values
                console.warn(`[BattleScene] showBattleOutcome received unexpected winner value: '${winner}'. Defaulting UI to DRAW.`);
                message = 'DRAW';
                color = 0x808080; // Gray
            }
            
            // Add outcome text
            const outcomeText = this.add.text(
                0, -50,
                message,
                {
                    fontFamily: 'Arial',
                    fontSize: '64px',
                    color: `#${color.toString(16).padStart(6, '0')}`,
                    stroke: '#000000',
                    strokeThickness: 6,
                    align: 'center',
                    shadow: { color: '#000000', fill: true, offsetX: 2, offsetY: 2, blur: 8 }
                }
            ).setOrigin(0.5);
            container.add(outcomeText);
            
            // Add return button
            const returnButton = this.add.text(
                0, 50,
                'Return to Team Builder',
                {
                    fontFamily: 'Arial',
                    fontSize: '24px',
                    color: '#ffffff',
                    backgroundColor: '#555555',
                    padding: { x: 20, y: 10 }
                }
            ).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            returnButton.on('pointerover', () => returnButton.setBackgroundColor('#777777'));
            returnButton.on('pointerout', () => returnButton.setBackgroundColor('#555555'));
            returnButton.on('pointerdown', () => {
                console.log('Return to Team Builder requested by user after battle');
                this.returnToTeamBuilder();
            });
            
            container.add(returnButton);
            
            // Add animation
            this.tweens.add({
                targets: container,
                scale: { from: 0.5, to: 1 },
                alpha: { from: 0, to: 1 },
                duration: 500,
                ease: 'Back.easeOut'
            });
            
            // Store reference to cleanup later
            this.outcomeContainer = container;
            
        } catch (error) {
            console.error('Error showing battle outcome:', error);
        }
    }

     /**
      * Display error messages in the UI
      * @param {string} message - The error message to show
      */
      showErrorMessage(message) {
          console.error('UI Error Message:', message); // Log to console

          // Create or update an error text object on the screen
          if (this.errorText) {
              this.errorText.setText(`ERROR: ${message}`);
          } else {
              this.errorText = this.add.text(
                  this.cameras.main.centerX,
                  30, // Position near top-center
                  `ERROR: ${message}`,
                  {
                      fontFamily: 'Arial',
                      fontSize: '16px',
                      color: '#ff0000', // Red color for errors
                      backgroundColor: 'rgba(0,0,0,0.7)',
                      padding: { x: 10, y: 5 },
                      wordWrap: { width: this.cameras.main.width - 40 }
                  }
              ).setOrigin(0.5, 0).setDepth(1001); // Ensure it's visible
          }
          // Optionally fade out the error after some time
           this.time.delayedCall(5000, () => {
               if (this.errorText) {
                   this.errorText.destroy();
                   this.errorText = null;
               }
           }, [], this);
      }

    /**
     * Update loop for the battle scene
     * Called by Phaser on every frame to update game state
     * * @param {number} time - Current time in ms since game start
     * @param {number} delta - Time in ms since last update
     */
    update(time, delta) {
        // Ensure proper try...catch block structure
        try {

            // Update debug tools if enabled
            if (this.debug.enabled) {
                // Update object identifier if it exists and has an update method
                if (this.objectIdentifier && typeof this.objectIdentifier.update === 'function') {
                    this.objectIdentifier.update();
                } // Closing brace for objectIdentifier check

                // Update coordinate display if it exists and has an update method
                // No separate update needed for CoordinateDisplay as it uses pointer events

            } // Closing brace for debug.enabled check

            // Update character teams if present
            if (this.playerTeamContainer) {
                this.playerTeamContainer.update();
            } // Closing brace for playerTeamContainer check

            if (this.enemyTeamContainer) {
                this.enemyTeamContainer.update();
            } // Closing brace for enemyTeamContainer check

        } catch (error) { // Closing brace for try block, starting catch block
            console.error('Error in update loop:', error);
            // Don't show error messages here to avoid spamming the user
            // since this method is called many times per second
        } // Closing brace for catch block
    } // Closing brace for update method

    /**
     * Scene shutdown handler
     * Clean up resources and listeners when the scene is stopped
     */
    shutdown() {
        console.log('BattleScene: Shutting down');

        try {
            // Clean up debug tools
            this.cleanupDebugTools();

            // Clean up battle bridge (including event manager)
            this.cleanupBattleBridge();

            // Clean up character teams
            this.cleanupCharacterTeams();

            // Clean up keyboard listeners
            if (this.input && this.input.keyboard) {
                this.input.keyboard.off('keydown-D', this.handleDebugKeypress, this);
                // Remove other specific key listeners if they were added (e.g., for Ctrl+G, Ctrl+I)
                // This requires knowing exactly which keys were registered
            }

            // Clean up tweens
            this.tweens.killAll();

            // Clean up local references
            this.battleConfig = null;
            this.playerTeam = null;
            this.enemyTeam = null;
            this.components = {};
            
            // Clean up battle control panel if it exists
            if(this.battleControlPanel) { this.battleControlPanel.destroy(); this.battleControlPanel = null; }
            if(this.battleLog) { this.battleLog.destroy(); this.battleLog = null; }

            // Clean up potential UI elements added
            if(this.errorText) { this.errorText.destroy(); this.errorText = null; }
            if(this.sceneTitle) { this.sceneTitle.destroy(); this.sceneTitle = null; }
            if(this.returnButton) { this.returnButton.destroy(); this.returnButton = null; }
            if(this.testPattern) { this.testPattern.destroy(); this.testPattern = null; }
            if(this.welcomeMessage) { this.welcomeMessage.destroy(); this.welcomeMessage = null; }
            if(this.debugPanel) { this.debugPanel.destroy(); this.debugPanel = null; }
            // Clean up both turn indicators
            if(this.turnIndicator) { 
                this.turnIndicator.destroy(); 
                this.turnIndicator = null; 
            }
            if(this.turnTextIndicator) {
                this.turnTextIndicator.destroy();
                this.turnTextIndicator = null;
            }
            if(this.outcomeContainer) { this.outcomeContainer.destroy(); this.outcomeContainer = null; }


            console.log('BattleScene: Shut down successfully');
        } catch (error) {
            console.error('Error during scene shutdown:', error);
        }
    } // Closing brace for shutdown method

} // Closing brace for the BattleScene class

window.BattleScene = BattleScene;

===== FILE: BootScene.js =====
/**
 * Boot Scene
 * The initial scene that loads critical assets and setups the game
 */
class BootScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BootScene' });
    }
    
    /**
     * Preload essential assets for the game
     */
    preload() {
        // Display loading text
        this.add.text(
            this.cameras.main.width / 2,
            this.cameras.main.height / 2, 
            'Loading...', 
            { 
                font: '32px Arial',
                fill: '#ffffff'
            }
        ).setOrigin(0.5);
        
        // Create loading bar
        this.createLoadingBar();
        
        // Load essential UI assets
        this.load.image('button', 'assets/images/ui/button.png');
        this.load.image('panel', 'assets/images/ui/panel.png');
        
        // We'll add more assets here as needed
        
        // Show progress
        this.load.on('progress', (value) => {
            this.updateLoadingBar(value);
        });
        
        // When all assets are loaded
        this.load.on('complete', () => {
            // Clean up loading bar
            if (this.loadingBar) {
                this.loadingBar.destroy();
                this.loadingBarBg.destroy();
            }
        });
    }
    
    /**
     * Create game objects and setup the scene
     */
    create() {
        console.log('BootScene: Starting game initialization');
        
        // Initialize game settings
        this.initializeSettings();
        
        // Start the MainMenuScene (or TeamBuilderScene if we want to go directly there)
        this.scene.start('TeamBuilderScene');
    }
    
    /**
     * Create a visual loading bar
     */
    createLoadingBar() {
        const width = 400;
        const height = 30;
        const x = (this.cameras.main.width - width) / 2;
        const y = (this.cameras.main.height + 100) / 2;
        
        // Background of the loading bar
        this.loadingBarBg = this.add.rectangle(
            x + width / 2,
            y + height / 2,
            width,
            height,
            0x333333
        );
        
        // The actual loading bar that will be scaled
        this.loadingBar = this.add.rectangle(
            x + 2 + (width - 4) / 2, // Account for border
            y + 2 + (height - 4) / 2,
            width - 4, // Account for border
            height - 4,
            0x3742fa
        );
        
        // Start at 0 width
        this.loadingBar.scaleX = 0;
    }
    
    /**
     * Update the loading bar based on progress
     * @param {number} value - Progress value between 0 and 1
     */
    updateLoadingBar(value) {
        if (this.loadingBar) {
            this.loadingBar.scaleX = value;
        }
    }
    
    /**
     * Initialize game settings
     */
    initializeSettings() {
        // Set up any global game settings here
        console.log('BootScene: Game settings initialized');
    }
}


===== FILE: TeamBuilderScene.js =====
/**
 * Team Builder Scene
 * Allows players to select and customize their team
 */
class TeamBuilderScene extends Phaser.Scene {
    constructor() {
        super({ key: 'TeamBuilderScene' });
        
        this.teamManager = null;
        this.selectedHeroes = [null, null, null];
        this.selectedHeroDetails = null;
    }
    
    /**
     * Load assets needed for the team builder
     */
    preload() {
        // Load character images
        // We'll use existing character art initially
        
        // Load UI elements
        this.load.image('grid-bg', 'assets/images/ui/grid-bg.png');
        this.load.image('slot-bg', 'assets/images/ui/slot-bg.png');
        
        // You can add more specific assets later
    }
    
    /**
     * Create the team builder interface
     */
    create() {
        console.log('TeamBuilderScene: Creating Phaser team builder UI');
        
        // Get reference to the existing TeamManager
        this.teamManager = window.teamManager;
        
        // Add "Toggle UI" button that switches between DOM and Phaser
        this.createToggleButton();
        
        // Currently, we'll start with a simple placeholder UI
        // that shows a working Phaser scene with some text
        this.createPlaceholderUI();
        
        // Create events to communicate with DOM UI
        this.setupEvents();
    }
    
    /**
     * Update loop for the scene
     */
    update() {
        // Will be used for animations and interactions
    }
    
    /**
     * Create a button to toggle between DOM and Phaser UI
     */
    createToggleButton() {
        const button = this.add.rectangle(100, 50, 180, 40, 0x3742fa)
            .setInteractive();
        
        const text = this.add.text(100, 50, 'Toggle to DOM UI', { 
            fontSize: '16px',
            fill: '#ffffff' 
        }).setOrigin(0.5);
        
        button.on('pointerdown', () => {
            console.log('Switching to DOM UI');
            // Signal to switch back to DOM UI
            this.toggleToDomUI();
        });
        
        button.on('pointerover', () => {
            button.fillColor = 0x2536e0;
        });
        
        button.on('pointerout', () => {
            button.fillColor = 0x3742fa;
        });
    }
    
    /**
     * Create placeholder UI elements
     */
    createPlaceholderUI() {
        // Add background
        this.add.rectangle(
            this.cameras.main.width / 2,
            this.cameras.main.height / 2,
            this.cameras.main.width,
            this.cameras.main.height,
            0x232a40,
            0.8
        );
        
        // Add title
        this.add.text(
            this.cameras.main.width / 2,
            100,
            'Team Builder (Phaser UI)',
            {
                fontSize: '42px',
                fontFamily: 'Bebas Neue',
                fill: '#ffffff'
            }
        ).setOrigin(0.5);
        
        // Add subtitle
        this.add.text(
            this.cameras.main.width / 2,
            160,
            'This is a placeholder for the Phaser-based team builder',
            {
                fontSize: '18px',
                fontFamily: 'Open Sans',
                fill: '#a4b0be'
            }
        ).setOrigin(0.5);
        
        // Add information
        this.add.text(
            this.cameras.main.width / 2,
            this.cameras.main.height / 2,
            'Phaser UI integration in progress...\nClick "Toggle to DOM UI" to return to the original interface',
            {
                fontSize: '24px',
                fontFamily: 'Arial',
                fill: '#ffffff',
                align: 'center'
            }
        ).setOrigin(0.5);
    }
    
    /**
     * Setup event listeners to communicate with DOM UI
     */
    setupEvents() {
        // Create custom events for communication
        // Will be expanded as we implement more features
    }
    
    /**
     * Toggle back to DOM UI
     */
    toggleToDomUI() {
        // Signal to UIManager to show the DOM UI
        if (window.uiManager) {
            window.uiManager.showDomUI();
        } else {
            // Fallback if uiManager isn't initialized yet
            const phaserContainer = document.getElementById('phaser-container');
            if (phaserContainer) {
                phaserContainer.style.display = 'none';
            }
            
            // Show the team builder container
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) {
                teamBuilderContainer.classList.add('active');
            }
            
            // Hide the game container
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.classList.remove('active');
            }
        }
    }
}


===== FILE: assets.js =====
/**
 * Assets Manager
 * Handles loading and organizing game assets
 */
class AssetsManager {
    constructor() {
        // Will store information about assets
        this.assets = {
            // Character assets
            characters: {},
            
            // UI assets
            ui: {},
            
            // Effect assets
            effects: {},
            
            // Arena backgrounds
            arenas: {}
        };
    }
    
    /**
     * Initialize the assets manager
     */
    initialize() {
        // Catalog arena backgrounds
        this.catalogArenaBackgrounds();
        
        // Catalog UI assets
        this.catalogUIAssets();
        
        // Catalog character assets
        this.catalogCharacterAssets();
        
        console.log('AssetsManager: Initialized');
    }
    
    /**
     * Catalog available arena backgrounds
     */
    catalogArenaBackgrounds() {
        // Get arena backgrounds from existing game
        this.assets.arenas = {
            'default': 'assets/images/Arena Art/default.png',
            'grassyfield': 'assets/images/Arena Art/Grassy Field.png'
            // More will be added as they become available
        };
    }
    
    /**
     * Catalog UI assets
     */
    catalogUIAssets() {
        // Basic UI assets
        this.assets.ui = {
            // Buttons
            'button': 'assets/images/ui/button.png',
            'button-hover': 'assets/images/ui/button-hover.png',
            
            // Panels
            'panel': 'assets/images/ui/panel.png',
            'slot': 'assets/images/ui/slot.png',
            
            // Icons
            'health-icon': 'assets/images/icons/health.png',
            'attack-icon': 'assets/images/icons/attack.png',
            'defense-icon': 'assets/images/icons/defense.png',
            'speed-icon': 'assets/images/icons/speed.png'
            
            // More will be added as needed
        };
    }
    
    /**
     * Catalog character assets
     */
    catalogCharacterAssets() {
        // Use the existing TeamBuilderImageLoader to get character images
        if (window.TeamBuilderImageLoader) {
            const loader = new window.TeamBuilderImageLoader();
            this.assets.characters = loader.characterImages || {};
        } else {
            // Fallback to hard-coded paths
            this.assets.characters = {
                'Aqualia': 'assets/images/Character Art/Aqualia.png',
                'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
                'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
                'Lumina': 'assets/images/Character Art/Lumina.png'
                // More can be added as they become available
            };
        }
    }
    
    /**
     * Get the path to a character image
     * @param {string} characterName - The name of the character
     * @returns {string} The path to the character image
     */
    getCharacterImagePath(characterName) {
        return this.assets.characters[characterName] || '';
    }
    
    /**
     * Get the path to an arena background
     * @param {string} arenaKey - The key of the arena
     * @returns {string} The path to the arena background
     */
    getArenaBackgroundPath(arenaKey) {
        return this.assets.arenas[arenaKey] || this.assets.arenas['default'];
    }
    
    /**
     * Get the path to a UI asset
     * @param {string} assetKey - The key of the UI asset
     * @returns {string} The path to the UI asset
     */
    getUIAssetPath(assetKey) {
        return this.assets.ui[assetKey] || '';
    }
    
    /**
     * Preload assets into a Phaser scene
     * @param {Phaser.Scene} scene - The scene to preload assets into
     * @param {string} type - The type of assets to preload ('characters', 'ui', 'arenas', 'all')
     */
    preloadAssets(scene, type = 'all') {
        if (!scene || !scene.load) {
            console.error('AssetsManager: Invalid scene provided for preloading');
            return;
        }
        
        // Preload character assets
        if (type === 'all' || type === 'characters') {
            for (const [name, path] of Object.entries(this.assets.characters)) {
                if (path) {
                    scene.load.image(`character-${name.toLowerCase()}`, path);
                }
            }
        }
        
        // Preload UI assets
        if (type === 'all' || type === 'ui') {
            for (const [key, path] of Object.entries(this.assets.ui)) {
                if (path) {
                    scene.load.image(`ui-${key}`, path);
                }
            }
        }
        
        // Preload arena backgrounds
        if (type === 'all' || type === 'arenas') {
            for (const [key, path] of Object.entries(this.assets.arenas)) {
                if (path) {
                    scene.load.image(`arena-${key}`, path);
                }
            }
        }
    }
}


===== FILE: bridge.js =====
/**
 * Game Bridge (LEGACY SYSTEM)
 * Provides communication between existing game logic and Phaser UI
 * 
 * NOTE: This is a legacy bridge that is being replaced by BattleBridge.
 * It is kept for compatibility but should not be used for new development.
 */
class GameBridge {
    constructor() {
        // References to key game components
        this.teamManager = null;
        this.battleManager = null;
        
        // Event listeners for game events
        this.eventListeners = {};
        
        // IMPORTANT: Do not overwrite the global BattleBridge class or instance
        console.log('GameBridge: Created legacy bridge - this system is deprecated');
        console.log('GameBridge: Preserving existing BattleBridge if it exists');
    }
    
    /**
     * Initialize the bridge with game managers
     * @param {Object} teamManager - The team manager instance
     * @param {Object} battleManager - The battle manager instance
     */
    initialize(teamManager, battleManager) {
        this.teamManager = teamManager;
        this.battleManager = battleManager;
        
        // Set up event system
        this.setupEvents();
        
        console.log('GameBridge: Initialized');
    }
    
    /**
     * Set up event system for communication
     */
    setupEvents() {
        // Create a custom event system for game events
        this.eventTypes = {
            TEAM_UPDATED: 'team_updated',
            BATTLE_STARTED: 'battle_started',
            BATTLE_ENDED: 'battle_ended',
            CHARACTER_ACTION: 'character_action',
            CHARACTER_DAMAGED: 'character_damaged',
            CHARACTER_HEALED: 'character_healed',
            CHARACTER_DEFEATED: 'character_defeated',
            STATUS_EFFECT_APPLIED: 'status_effect_applied',
            ABILITY_USED: 'ability_used'
        };
        
        // Initialize event listeners
        Object.values(this.eventTypes).forEach(type => {
            this.eventListeners[type] = [];
        });
        
        console.log('GameBridge: Event system set up');
    }
    
    /**
     * Add an event listener for a game event
     * @param {string} eventType - The type of event to listen for
     * @param {Function} callback - The callback function to execute
     */
    addEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) {
            this.eventListeners[eventType] = [];
        }
        
        this.eventListeners[eventType].push(callback);
    }
    
    /**
     * Remove an event listener
     * @param {string} eventType - The type of event
     * @param {Function} callback - The callback function to remove
     */
    removeEventListener(eventType, callback) {
        if (!this.eventListeners[eventType]) return;
        
        const index = this.eventListeners[eventType].indexOf(callback);
        if (index !== -1) {
            this.eventListeners[eventType].splice(index, 1);
        }
    }
    
    /**
     * Dispatch a game event
     * @param {string} eventType - The type of event to dispatch
     * @param {Object} data - The data to pass to event listeners
     */
    dispatchEvent(eventType, data) {
        if (!this.eventListeners[eventType]) return;
        
        this.eventListeners[eventType].forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`GameBridge: Error in event listener for ${eventType}`, error);
            }
        });
    }
    
    /**
     * Patch into BattleManager to receive battle events
     */
    patchBattleManager() {
        if (!this.battleManager) {
            console.error('GameBridge: BattleManager not available for patching');
            return;
        }
        
        // Store original functions
        const originalApplyDamage = this.battleManager.applyDamage;
        const originalApplyHealing = this.battleManager.applyHealing;
        const originalProcessAbility = this.battleManager.processAbility;
        const originalAddStatusEffect = this.battleManager.addStatusEffect;
        const originalStartBattle = this.battleManager.startBattle;
        const originalEndBattle = this.battleManager.endBattle;
        
        // Patch functions to add event dispatching
        const self = this;
        
        // Patch damage function
        this.battleManager.applyDamage = function(target, amount, source) {
            const result = originalApplyDamage.call(this, target, amount, source);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.CHARACTER_DAMAGED, {
                target,
                amount,
                source,
                result
            });
            
            // Check for defeat
            if (target.stats.hp <= 0) {
                self.dispatchEvent(self.eventTypes.CHARACTER_DEFEATED, {
                    character: target,
                    source
                });
            }
            
            return result;
        };
        
        // Patch healing function
        this.battleManager.applyHealing = function(target, amount, source) {
            const result = originalApplyHealing.call(this, target, amount, source);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.CHARACTER_HEALED, {
                target,
                amount,
                source,
                result
            });
            
            return result;
        };
        
        // Patch ability processing
        this.battleManager.processAbility = function(character, ability, targets) {
            const result = originalProcessAbility.call(this, character, ability, targets);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.ABILITY_USED, {
                character,
                ability,
                targets,
                result
            });
            
            return result;
        };
        
        // Patch status effect application
        this.battleManager.addStatusEffect = function(target, effect, source) {
            const result = originalAddStatusEffect.call(this, target, effect, source);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.STATUS_EFFECT_APPLIED, {
                target,
                effect,
                source,
                result
            });
            
            return result;
        };
        
        // Patch battle start
        this.battleManager.startBattle = function(playerTeam, enemyTeam) {
            const result = originalStartBattle.call(this, playerTeam, enemyTeam);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.BATTLE_STARTED, {
                playerTeam,
                enemyTeam
            });
            
            return result;
        };
        
        // Patch battle end
        this.battleManager.endBattle = function(winner) {
            const result = originalEndBattle.call(this, winner);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.BATTLE_ENDED, {
                winner,
                playerTeam: this.playerTeam,
                enemyTeam: this.enemyTeam
            });
            
            return result;
        };
        
        console.log('GameBridge: BattleManager patched for event dispatching');
    }
    
    /**
     * Patch into TeamManager to receive team events
     */
    patchTeamManager() {
        if (!this.teamManager) {
            console.error('GameBridge: TeamManager not available for patching');
            return;
        }
        
        // Store original functions
        const originalSetPlayerTeam = this.teamManager.setPlayerTeam;
        const originalSetCustomEnemyTeam = this.teamManager.setCustomEnemyTeam;
        
        // Patch functions to add event dispatching
        const self = this;
        
        // Patch player team setting
        this.teamManager.setPlayerTeam = function(team) {
            const result = originalSetPlayerTeam.call(this, team);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.TEAM_UPDATED, {
                team: 'player',
                characters: team
            });
            
            return result;
        };
        
        // Patch enemy team setting
        this.teamManager.setCustomEnemyTeam = function(team) {
            const result = originalSetCustomEnemyTeam.call(this, team);
            
            // Dispatch event
            self.dispatchEvent(self.eventTypes.TEAM_UPDATED, {
                team: 'enemy',
                characters: team
            });
            
            return result;
        };
        
        console.log('GameBridge: TeamManager patched for event dispatching');
    }
    
    /**
     * Get player team from TeamManager
     * @returns {Array} The player team
     */
    getPlayerTeam() {
        return this.teamManager ? this.teamManager.playerTeam : [];
    }
    
    /**
     * Get enemy team from TeamManager
     * @returns {Array} The enemy team
     */
    getEnemyTeam() {
        return this.teamManager ? this.teamManager.enemyTeam : [];
    }
    
    /**
     * Start a battle with the current teams
     */
    startBattle() {
        if (!this.battleManager) {
            console.error('GameBridge: BattleManager not available for battle');
            return;
        }
        
        // Start the battle with current teams
        const playerTeam = this.getPlayerTeam();
        const enemyTeam = this.getEnemyTeam();
        
        this.battleManager.startBattle(playerTeam, enemyTeam);
    }
}


===== FILE: config.js =====
/**
 * Phaser Game Configuration
 * This file contains the configuration for the Phaser game instance
 */

class PhaserConfig {
    /**
     * Create a Phaser game configuration
     * @param {Object} gameConfig - The game configuration settings
     * @returns {Object} Phaser game configuration object
     */
    static create(gameConfig) {
        // Default settings if not provided
        const width = gameConfig?.width || 1920;
        const height = gameConfig?.height || 1080;
        
        return {
            type: Phaser.AUTO,
            width: width,
            height: height,
            parent: 'phaser-container',
            backgroundColor: '#141e2e',
            transparent: true,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            // We'll add scenes dynamically after they're loaded
            scene: []
        };
    }
    
    /**
     * Initialize the Phaser container in the DOM
     * @param {string} parentId - The ID of the parent container
     * @returns {HTMLElement} The created Phaser container
     */
    static initContainer(parentId = 'game-container') {
        const gameContainer = document.getElementById(parentId);
        
        // Check if container already exists
        let phaserContainer = document.getElementById('phaser-container');
        if (phaserContainer) {
            return phaserContainer;
        }
        
        // Create container if it doesn't exist
        phaserContainer = document.createElement('div');
        phaserContainer.id = 'phaser-container';
        phaserContainer.style.position = 'absolute';
        phaserContainer.style.top = '0';
        phaserContainer.style.left = '0';
        phaserContainer.style.width = '100%';
        phaserContainer.style.height = '100%';
        phaserContainer.style.zIndex = '0';
        gameContainer.appendChild(phaserContainer);
        
        return phaserContainer;
    }
}


===== FILE: PhaserConfig.js =====
/**
 * PhaserConfig.js
 * Configuration utilities for Phaser game initialization
 * 
 * @version 0.5.0.3
 */

// Create a self-executing function to avoid global namespace pollution
(function() {
    // Create the PhaserConfig object
    const PhaserConfig = {
        /**
         * Initialize and get the container for Phaser game
         * @param {string} containerId - The ID for the container element
         * @returns {HTMLElement} - The container element
         */
        initContainer: function(containerId) {
            try {
                // Check if container exists
                let container = document.getElementById(containerId);
                
                // Create container if it doesn't exist
                if (!container) {
                    console.log(`Creating Phaser container with ID: ${containerId}`);
                    container = document.createElement('div');
                    container.id = containerId;
                    document.body.appendChild(container);
                }
                
                // Make sure it has proper styling
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.position = 'absolute';
                container.style.top = '0';
                container.style.left = '0';
                container.style.zIndex = '1000';  // Make sure it's above the TeamBuilder UI
                
                // Hide initially
                container.style.display = 'none';
                
                return container;
            } catch (error) {
                console.error('Error initializing Phaser container:', error);
                // Create emergency fallback container
                const fallbackContainer = document.createElement('div');
                fallbackContainer.id = containerId + '-fallback';
                document.body.appendChild(fallbackContainer);
                return fallbackContainer;
            }
        },
        
        /**
         * Create the Phaser game configuration
         * @param {Object} gameConfig - Game configuration from game.js
         * @returns {Object} - Phaser game configuration object
         */
        create: function(gameConfig) {
            return {
                type: Phaser.AUTO,
                width: gameConfig.width || 1280,
                height: gameConfig.height || 720,
                parent: 'game-container',
                backgroundColor: '#333344',
                scene: [], // Scenes will be added after initialization
                render: {
                    pixelArt: false,
                    antialias: true,
                    roundPixels: false, // Need false for smoother scaling
                    powerPreference: 'high-performance',
                    crisp: false, // Don't use crisp pixelated rendering
                    batchSize: 8192, // Increased batch size for performance
                    // Note: setFilter was removed as it's not available in this Phaser version
                    // Instead, we use these render settings for the same effect
                },
                scale: {
                    mode: Phaser.Scale.FIT,
                    autoCenter: Phaser.Scale.CENTER_BOTH
                },
                physics: {
                    default: false  // No physics needed for this game
                }
            };
        },
        
        /**
         * Check if Phaser is properly initialized
         * @returns {boolean} - Whether Phaser is ready
         */
        isPhaserReady: function() {
            return (
                typeof Phaser !== 'undefined' && 
                window.game && 
                window.game.scene
            );
        }
    };
    
    // Make PhaserConfig available globally
    window.PhaserConfig = PhaserConfig;
    
    console.log('PhaserConfig initialized successfully');
})();


===== FILE: StatusIconMapper.js =====
/**
 * StatusIconMapper - Maps status effect IDs to icon paths
 * Centralizes the mapping between status effect IDs and their corresponding icon files
 */
class StatusIconMapper {
    /**
     * Get the complete mapping of status IDs to icon paths
     * @returns {Object} Mapping of status IDs to icon paths
     */
    static getMapping() {
        return {
            'atk_down': 'AI_Icons/32px/Attack Down_AI.png',
            'atk_up': 'AI_Icons/32px/AttackUp.png',
            'bleed': 'AI_Icons/32px/Bleeding_AI.png',
            'burn': 'AI_Icons/32px/Burn_AI.png',
            'crit_up': 'AI_Icons/32px/CritChanceUp_AI.png',
            'def_down': 'AI_Icons/32px/Defense Down_AI.png',
            'def_up': 'AI_Icons/32px/Defense Up_AI.png',
            'evade': 'AI_Icons/32px/Evasion_AI.png',
            'freeze': 'AI_Icons/32px/Freeze_AI.png',
            'immune': 'AI_Icons/32px/Immunity_AI.png',
            'int_down': 'AI_Icons/32px/IntellectDown_AI.png',
            'int_up': 'AI_Icons/32px/Intellect Up_AI.png',
            'poison': 'AI_Icons/32px/Poison_AI.png',
            'reflect': 'AI_Icons/32px/DamageReflect_AI.png',
            'regen': 'AI_Icons/32px/Regeneration_AI.png',
            'shield': 'AI_Icons/32px/Shield_AI.png',
            'spd_down': 'AI_Icons/32px/Speed Down_AI.png',
            'spd_up': 'AI_Icons/32px/Speed Up_AI.png',
            'spi_down': 'AI_Icons/32px/SpiritDown_AI.png',
            'spi_up': 'AI_Icons/32px/SpiritUp_AI.png',
            'str_down': 'AI_Icons/32px/StrengthDown_AI.png',
            'str_up': 'AI_Icons/32px/StrengthUp_AI.png',
            'stun': 'AI_Icons/32px/Stunned_AI.png',
            'taunt': 'AI_Icons/32px/Taunt_AI.png',
            'vulnerable': 'AI_Icons/32px/Vulnerable_AI.png'
        };
    }
    
    /**
     * Get the icon path for a specific status ID
     * @param {string} statusId - The status effect ID
     * @returns {string} The path to the icon file
     */
    static getPath(statusId) {
        const mapping = this.getMapping();
        return mapping[statusId] || `${statusId}.png`;
    }
}

// Make available globally for non-module code
window.StatusIconMapper = StatusIconMapper;


===== FILE: uiManager.js =====
/**
 * UI Manager
 * Handles switching between DOM and Phaser UIs
 */
class UIManager {
    constructor() {
        this.currentUI = 'dom'; // 'dom' or 'phaser'
        this.game = null; // Will hold the Phaser game instance
        this.scenes = {}; // Will hold references to scenes
    }
    
    /**
     * Initialize the UI Manager
     * @param {Object} game - Phaser game instance
     */
    initialize(game) {
        this.game = game;
        
        // Store references to DOM elements
        this.domElements = {
            teamBuilder: document.getElementById('team-builder-container'),
            gameContainer: document.getElementById('game-container'),
            phaserContainer: document.getElementById('phaser-container')
        };
        
        // Add UI toggle buttons to DOM
        this.addDomToggleButtons();
        
        console.log('UIManager: Initialized');
    }
    
    /**
     * Add toggle buttons to the DOM UI
     */
    addDomToggleButtons() {
        // Create toggle button for team builder
        const teamBuilderContainer = this.domElements.teamBuilder;
        if (teamBuilderContainer) {
            const toggleButton = document.createElement('button');
            toggleButton.textContent = 'Try Phaser UI';
            toggleButton.className = 'phaser-toggle-btn';
            toggleButton.style.position = 'absolute';
            toggleButton.style.top = '20px';
            toggleButton.style.right = '20px';
            toggleButton.style.zIndex = '1000';
            toggleButton.style.backgroundColor = '#3742fa';
            toggleButton.style.color = 'white';
            toggleButton.style.border = 'none';
            toggleButton.style.padding = '8px 16px';
            toggleButton.style.borderRadius = '4px';
            toggleButton.style.cursor = 'pointer';
            
            toggleButton.addEventListener('click', () => {
                this.showPhaserUI('TeamBuilderScene');
            });
            
            teamBuilderContainer.appendChild(toggleButton);
        }
        
        // The battle UI toggle button will be added when battle starts
    }
    
    /**
     * Register a scene with the UI Manager
     * @param {string} key - The scene key
     * @param {Phaser.Scene} scene - The scene instance
     */
    registerScene(key, scene) {
        this.scenes[key] = scene;
    }
    
    /**
     * Show the DOM UI
     */
    showDomUI() {
        // Hide Phaser container
        if (this.domElements.phaserContainer) {
            this.domElements.phaserContainer.style.display = 'none';
        }
        
        // Show appropriate DOM container based on current context
        if (this.currentUI === 'battle') {
            // Show game container for battle
            if (this.domElements.gameContainer) {
                this.domElements.gameContainer.classList.add('active');
            }
            
            // Hide team builder
            if (this.domElements.teamBuilder) {
                this.domElements.teamBuilder.classList.remove('active');
            }
        } else {
            // Show team builder for team selection
            if (this.domElements.teamBuilder) {
                this.domElements.teamBuilder.classList.add('active');
            }
            
            // Hide game container
            if (this.domElements.gameContainer) {
                this.domElements.gameContainer.classList.remove('active');
            }
        }
        
        this.currentUI = 'dom';
        console.log('UIManager: Switched to DOM UI');
    }
    
    /**
     * Show the Phaser UI with the specified scene
     * @param {string} sceneKey - The scene to show
     */
    showPhaserUI(sceneKey) {
        // Make sure the game is initialized
        if (!this.game) {
            console.error('UIManager: Phaser game not initialized');
            return;
        }
        
        // Show Phaser container
        if (this.domElements.phaserContainer) {
            this.domElements.phaserContainer.style.display = 'block';
        }
        
        // Hide DOM UI containers
        if (this.domElements.teamBuilder) {
            this.domElements.teamBuilder.classList.remove('active');
        }
        
        if (this.domElements.gameContainer) {
            this.domElements.gameContainer.classList.remove('active');
        }
        
        // Start the appropriate scene
        try {
            // Stop all active scenes
            const activeScenes = this.game.scene.getScenes(true);
            activeScenes.forEach(scene => {
                if (scene.scene.key !== sceneKey) {
                    scene.scene.stop();
                }
            });
            
            // Start or resume the requested scene
            if (!this.game.scene.isActive(sceneKey)) {
                this.game.scene.start(sceneKey);
            } else {
                this.game.scene.resume(sceneKey);
            }
            
            // Update current UI state
            this.currentUI = sceneKey === 'BattleScene' ? 'battle' : 'phaser';
            console.log(`UIManager: Switched to Phaser UI (${sceneKey})`);
        } catch (error) {
            console.error(`UIManager: Error starting scene ${sceneKey}`, error);
        }
    }
    
    /**
     * Start a battle with the specified teams in Phaser
     * @param {Array} playerTeam - The player's team
     * @param {Array} enemyTeam - The enemy team
     */
    startBattleInPhaser(playerTeam, enemyTeam) {
        // Show Phaser UI with BattleScene
        this.showPhaserUI('BattleScene');
        
        // Get reference to BattleScene
        const battleScene = this.game.scene.getScene('BattleScene');
        if (battleScene) {
            // Start the battle
            battleScene.startBattle(playerTeam, enemyTeam);
        }
    }
}


===== FILE: BattleUI.js =====
/**
 * Battle UI
 * Manages the user interface during battle
 * Implements a Tailwind CSS-based design
 */

class BattleUI {
    /**
     * Verify that background images are available
     * @param {Array} backgroundKeys - Keys for backgrounds to check
     */
    verifyBackgroundImages(backgroundKeys) {
        console.log('Verifying background images availability...');
        
        backgroundKeys.forEach(key => {
            if (key === 'default') {
                console.log('Default grid pattern background is always available');
                return;
            }
            
            const imageUrl = key === 'grassyfield' ? 
                'assets/images/Arena Art/Grassy Field.png' : 
                `assets/images/Arena Art/${key}.jpg`;
            
            // Create a test image to check if it loads
            const img = new Image();
            img.onload = () => {
                console.log(`âœ… Background image verified: ${imageUrl}`);
            };
            img.onerror = () => {
                console.error(`âŒ Background image not found: ${imageUrl}`);
                // Try an alternative path without leading slash
                const altUrl = key === 'grassyfield' ? 
                    'assets/images/Arena Art/Grassy Field.png' : 
                    `assets/images/Arena Art/${key}.jpg`;
                
                console.log(`Trying alternative path: ${altUrl}`);
                
                const altImg = new Image();
                altImg.onload = () => {
                    console.log(`âœ… Alternative path works: ${altUrl}`);
                    // Update the CSS with the working path
                    this.updateBackgroundImagePath(key, altUrl);
                };
                altImg.onerror = () => {
                    console.error(`âŒ Alternative path also failed: ${altUrl}`);
                    console.log('Checking if directory exists...');
                };
                altImg.src = altUrl;
            };
            img.src = imageUrl;
        });
    }
    
    /**
     * Update background image path in CSS
     * @param {string} key - Background key
     * @param {string} url - Working URL
     */
    updateBackgroundImagePath(key, url) {
        // Find the style element
        const styleEl = document.getElementById('battle-ui-styles');
        if (!styleEl) return;
        
        // Get the current styles
        let css = styleEl.textContent;
        
        // Replace the URL in the CSS
        const regex = new RegExp(`\.arena-${key}\s*{[^}]*background-image:\s*url\(['"]?([^'"\)]+)['"]?\)`, 'g');
        const newCss = css.replace(regex, (match, oldUrl) => {
            return match.replace(oldUrl, url);
        });
        
        // Update the style element
        styleEl.textContent = newCss;
        
        console.log(`Updated CSS with working path for ${key}`);
    }
    /**
     * Create a new Battle UI
     * @param {Phaser.Scene} scene - The Phaser scene for the battle
     * @param {BattleManager} battleManager - Reference to the battle manager
     */
    constructor(scene, battleManager) {
        this.scene = scene;
        this.battleManager = battleManager;
        this.elements = {};
        this.isSetup = false;
        this.playerTeam = [];
        this.enemyTeam = [];
        this.currentTurn = 0;
        this.logMessages = [];
        this.activeCharacter = null;
        this.floatingTexts = [];
        this.typeColors = {
            fire: '#ff4757',
            water: '#1e90ff',
            nature: '#2ed573',
            dark: '#9900cc',
            light: '#ffd700',
            air: '#70a1ff'
        };
        this.arenaBackground = 'grassyfield'; // Use Grassy Field as default background
    }

    /**
     * Initialize the battle UI
     */
    initialize() {
        // Check if already initialized
        if (this.isSetup) {
            console.log('BattleUI: Already initialized, skipping');
            // Even if already initialized, make sure tooltips are cleaned up
            this.cleanupTooltips();
            return;
        }
        
        // Check if battle UI already exists in DOM and remove it if it does
        const existingUI = document.getElementById('battle-ui');
        if (existingUI) {
            console.log('BattleUI: Found existing UI, removing it');
            // Clean up tooltips before removing the UI
            this.cleanupTooltips();
            existingUI.remove();
        }
        
        console.log('BattleUI: Initializing...');
        
        // Clear anything in the game container
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.innerHTML = '';
        } else {
            console.error('Game container not found! Make sure game-container element exists.');
        }
        
        // Add Tailwind CSS if not already present
        this.ensureTailwindCSSIsLoaded();
        
        // Add custom CSS
        this.addCustomStyles();
        
        // Initialize tooltip manager
        this.initializeTooltipManager();
        
        // Create the UI container
        const battleUI = document.createElement('div');
        battleUI.id = 'battle-ui';
        battleUI.className = 'min-h-screen flex flex-col p-4 font-inter';
        battleUI.style.backgroundColor = '#141e2e';
        battleUI.style.color = '#e0e0e0';
        battleUI.style.fontFamily = "'Inter', sans-serif";
        
        // Create header with controls
        const header = this.createHeader();
        battleUI.appendChild(header);
        
        // Create main battle area
        const main = document.createElement('main');
        main.className = 'flex-grow flex gap-4 md:gap-8 items-start justify-center pt-8 relative';
        main.id = 'battle-arena';
        
        // Add arena background
        this.setArenaBackground(main, this.arenaBackground);
        
        // Create player team section
        const playerSection = this.createTeamSection('Your Team', 'text-blue-300');
        
        // Create VS divider
        const vsDiv = document.createElement('div');
        vsDiv.className = 'flex items-center justify-center flex-grow-0 pt-24';
        const vsSpan = document.createElement('span');
        vsSpan.className = 'text-4xl font-bold text-gray-500';
        vsSpan.textContent = 'VS';
        vsDiv.appendChild(vsSpan);
        
        // Create enemy team section
        const enemySection = this.createTeamSection('Enemy Team', 'text-red-300');
        
        // Add team sections to main
        main.appendChild(playerSection);
        main.appendChild(vsDiv);
        main.appendChild(enemySection);
        
        battleUI.appendChild(main);
        
        // Create battle log and add it to the main battle area
        const battleLog = this.createBattleLog();
        main.appendChild(battleLog);
        
        // Add to DOM
        document.body.appendChild(battleUI);
        
        // Store references to key elements
        this.elements = {
            playerTeamContainer: playerSection,
            enemyTeamContainer: enemySection,
            turnDisplay: document.getElementById('turn-display'),
            logContent: document.getElementById('battle-log-content'),
            speedButtons: {
                '1x': document.getElementById('speed-1x'),
                '2x': document.getElementById('speed-2x'),
                '4x': document.getElementById('speed-4x')
            },
            pauseButton: document.getElementById('pause-button'),
            nextTurnButton: document.getElementById('next-turn-button'),
            battleArena: main
        };
        
        this.isSetup = true;
        console.log('BattleUI: Initialized');
        
        // Check available backgrounds
        this.verifyBackgroundImages(['default', 'grassyfield']);
        
        // Check if Tailwind is working correctly and apply fallback styles if needed
        setTimeout(() => {
            if (BattleUIDebug) {
                const snapshot = BattleUIDebug.createSnapshot(this);
                if (!snapshot.tailwindStatus.tailwindWorking) {
                    console.log('BattleUI: Tailwind not working, applying fallback styles');
                    BattleUIDebug.injectFallbackStyles();
                    BattleUIDebug.fixCommonIssues(this);
                }
            }
        }, 500);
    }
    
    /**
     * Ensure Tailwind CSS is loaded
     */
    ensureTailwindCSSIsLoaded() {
        if (!document.getElementById('tailwind-css')) {
            console.log('BattleUI: Adding Tailwind CSS script tag');
            const tailwindScript = document.createElement('script');
            tailwindScript.id = 'tailwind-css';
            tailwindScript.src = 'https://cdn.tailwindcss.com';
            document.head.appendChild(tailwindScript);
            
            // Also add Inter font
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap';
            document.head.appendChild(fontLink);
        }
    }
    
    /**
     * Add custom styles for the battle UI
     */
    addCustomStyles() {
        if (!document.getElementById('battle-ui-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'battle-ui-styles';
            styleEl.textContent = `
                .panel-bg {
                    background-color: #232a40; /* Darker panel color */
                }
                /* Type colors for backgrounds */
                .bg-fire { background-color: #ff4757; }
                .bg-water { background-color: #1e90ff; }
                .bg-nature { background-color: #2ed573; }
                .bg-dark { background-color: #9900cc; }
                .bg-light { background-color: #ffd700; }
                .bg-air { background-color: #70a1ff; }
                
                /* Character Art Styles */
                .character-art-container {
                    background-color: transparent !important;
                    border: none !important;
                    overflow: visible;
                    width: 64px !important;
                    height: 64px !important;
                }
                
                .character-art-wrapper {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 5;
                    pointer-events: none;
                }
                
                .character-art {
                    width: 80px;
                    height: 120px;
                    object-fit: contain;
                    position: absolute;
                    top: -52px;
                    left: -2px; /* Moved more to the right */
                    pointer-events: none;
                    z-index: 10;
                }
                
                /* Special styling for characters with art during active/animation states */
                .active-character .character-art-container {
                    box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.3) !important;
                }
                
                .art-loaded.character-moving img {
                    filter: drop-shadow(0 0 5px rgba(30, 144, 255, 0.8));
                }

                /* Character Circle */
                .character-circle {
                    width: 64px; /* Adjust size as needed */
                    height: 64px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.5rem; /* Size for initial letter */
                    font-weight: bold;
                    margin-bottom: 8px; /* Space between circle and HP bar */
                    border: 2px solid rgba(255, 255, 255, 0.3); /* Subtle border */
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    position: relative; /* Needed for floating text positioning */
                    transition: transform 0.3s ease-in-out;
                }
                /* Character Movement Animations */
                .character-moving {
                    z-index: 100; /* Ensure moving character appears above others */
                }
                /* Text color for light backgrounds */
                .text-dark-on-light { color: #141e2e; }

                /* Simple HP bar style */
                .hp-bar-container {
                    width: 80px; /* Match width roughly to circle */
                    margin: 0 auto; /* Center the bar */
                }
                .hp-bar-background {
                    background-color: #4a5568; /* Gray background for the bar */
                    height: 8px;
                    border-radius: 4px;
                    overflow: hidden;
                    border: 1px solid #2d3748;
                }
                .hp-bar-current {
                    background-color: #48bb78; /* Green for current HP */
                    height: 100%;
                    transition: width 0.3s ease-in-out;
                    border-radius: 4px 0 0 4px; /* Keep left radius */
                }

                /* Highlight for active character */
                .active-character .character-circle { /* Apply glow to the circle */
                    box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6); /* Gold glow */
                    border-color: rgba(255, 215, 0, 0.8);
                }
                .active-character { /* Add scaling to the container */
                     transform: scale(1.05);
                }

                /* Status icons */
                .status-icons-container {
                    margin-top: 4px;
                    display: flex;
                    justify-content: center; /* Center icons below HP bar */
                    gap: 4px; /* Space between icons */
                    min-height: 16px; /* Reserve space even if no icons */
                }
                .status-icon {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    text-align: center;
                    line-height: 16px;
                    font-weight: bold;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
                    cursor: help; /* Show help cursor on hover */
                    transition: transform 0.2s, box-shadow 0.2s;
                    background-color: rgba(0, 0, 0, 0.3); /* Default background color */
                    border: 1px solid rgba(255, 255, 255, 0.3); /* Light border */
                    position: relative;
                    overflow: hidden; /* Make sure icon doesn't overflow the circle */
                    background-size: cover; /* For icon images */
                    background-position: center;
                    background-repeat: no-repeat;
                }
                
                .status-icon:hover {
                    transform: scale(1.3); /* Scale up on hover */
                    box-shadow: 0 0 6px rgba(255, 255, 255, 0.8); /* Glow effect */
                    z-index: 10; /* Ensure it appears above other icons */
                }

                /* Basic button styling */
                .control-button {
                    background-color: #4a5568;
                    padding: 6px 12px;
                    border-radius: 6px;
                    margin-left: 8px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                    font-size: 14px;
                }
                .control-button:hover {
                    background-color: #718096;
                }
                .control-button.active {
                    background-color: #a0aec0;
                    color: #141e2e;
                }

                /* Battle Log Styling */
                .battle-log {
                    height: 180px; /* Increased height */
                    overflow-y: auto;
                    transition: height 0.3s ease-in-out;
                    max-height: 250px;
                    background-color: rgba(28, 33, 48, 0.95) !important; /* More opaque, darker background */
                    /* Hide default scrollbar in different browsers */
                    scrollbar-width: none; /* Firefox */
                    -ms-overflow-style: none; /* IE and Edge */
                }
                
                /* Hide scrollbar for Chrome, Safari and Opera */
                .battle-log::-webkit-scrollbar {
                    display: none;
                }

                /* Simple floating text placeholder */
                .floating-text {
                    position: absolute;
                    top: -25px; /* Position above the circle */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 2px 6px;
                    border-radius: 4px;
                    font-size: 16px;
                    font-weight: bold;
                    white-space: nowrap;
                    z-index: 10; /* Ensure it's above the circle */
                    animation: float-up-fade-out 1.2s forwards;
                }
                
                @keyframes float-up-fade-out {
                    0% {
                        opacity: 0;
                        transform: translate(-50%, 0);
                    }
                    10% {
                        opacity: 1;
                    }
                    80% {
                        opacity: 1;
                    }
                    100% {
                        opacity: 0;
                        transform: translate(-50%, -30px);
                    }
                }
                
                /* Arena backgrounds */
                .arena-default {
                    background-color: #1a1a2e;
                    background-image: linear-gradient(rgba(0,0,0,0.3) 1px, transparent 1px),
                                      linear-gradient(90deg, rgba(0,0,0,0.3) 1px, transparent 1px);
                    background-size: 20px 20px;
                }
                .arena-grassyfield {
                    background-image: url('assets/images/Arena Art/Grassy Field.png');
                    background-size: cover;
                    background-position: center;
                }
                
                /* Victory overlay */
                .victory-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: calc(100% - 200px); /* Leave space for battle log */
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    background-color: rgba(0, 0, 0, 0.7);
                    z-index: 20;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out;
                }
                .victory-text {
                    font-size: 48px;
                    font-weight: bold;
                    margin-bottom: 24px;
                    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
                }
                .victory-button {
                    padding: 12px 24px;
                    background-color: #3742fa;
                    color: white;
                    border-radius: 8px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }
                .victory-button:hover {
                    background-color: #2536e0;
                }
                
                /* Animation for when a character takes damage */
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-5px); }
                    50% { transform: translateX(5px); }
                    75% { transform: translateX(-5px); }
                }
                
                /* Bonk attack animation */
                @keyframes bonk-animation {
                    0% { transform: translateX(-50%) scale(0); opacity: 0; }
                    50% { transform: translateX(-50%) scale(1.5); opacity: 1; }
                    100% { transform: translateX(-50%) scale(1); opacity: 0; }
                }
                
                .attack-bonk {
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 24px;
                    z-index: 110;
                    pointer-events: none;
                }
                
                .animate-bonk {
                    animation: bonk-animation 500ms ease-out forwards;
                }
                
                /* Action Text Animation */
                @keyframes action-text-animation {
                    0% { 
                        opacity: 0;
                        transform: translate(-50%, 10px) scale(0.8);
                    }
                    15% { 
                        opacity: 1;
                        transform: translate(-50%, -5px) scale(1.1);
                    }
                    80% { 
                        opacity: 1;
                        transform: translate(-50%, -5px) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translate(-50%, -15px) scale(0.9);
                    }
                }

                .action-text {
                    position: absolute;
                    top: 10px; /* Adjusted to appear above character container */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.6);
                    color: white;
                    padding: 3px 8px;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: bold;
                    white-space: nowrap;
                    z-index: 50;
                    animation: action-text-animation 1.8s forwards;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                    pointer-events: none;
                }

                /* Action text colors */
                .action-text-attack {
                    color: #f56565; /* Red for attacks */
                }

                .action-text-ability {
                    color: #4299e1; /* Blue for abilities */
                }

                .action-text-heal {
                    color: #48bb78; /* Green for healing */
                }
                
                /* Make sure battle UI properly fills the screen */
                #battle-ui {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    background-color: #141e2e;
                    color: white;
                    overflow: hidden;
                }
            `;
            document.head.appendChild(styleEl);
        }
    }
    
    /**
     * Create the header with turn indicator and controls
     * @returns {HTMLElement} Header element
     */
    createHeader() {
        const header = document.createElement('header');
        header.className = 'panel-bg rounded-lg p-3 mb-4 flex justify-between items-center shadow-md';
        
        // Turn display
        const turnDiv = document.createElement('div');
        const turnSpan = document.createElement('span');
        turnSpan.id = 'turn-display';
        turnSpan.className = 'text-lg font-semibold';
        turnSpan.textContent = 'Turn: 0';
        turnDiv.appendChild(turnSpan);
        
        // Controls
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'flex items-center';
        
        const speedLabel = document.createElement('span');
        speedLabel.className = 'mr-2 text-sm';
        speedLabel.textContent = 'Speed:';
        controlsDiv.appendChild(speedLabel);
        
        // Speed buttons
        const speedButtons = [
            { id: 'speed-1x', text: '1x', active: true, speed: 1 },
            { id: 'speed-2x', text: '2x', active: false, speed: 2 },
            { id: 'speed-4x', text: '4x', active: false, speed: 4 }
        ];
        
        speedButtons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = `control-button ${btn.active ? 'active' : ''}`;
            button.textContent = btn.text;
            button.addEventListener('click', () => this.setSpeed(btn.speed));
            controlsDiv.appendChild(button);
        });
        
        // Pause button
        const pauseButton = document.createElement('button');
        pauseButton.id = 'pause-button';
        pauseButton.className = 'control-button ml-4';
        pauseButton.innerHTML = '&#10074;&#10074;'; // Pause symbol
        pauseButton.addEventListener('click', () => this.togglePause());
        controlsDiv.appendChild(pauseButton);
        
        // Next turn button
        const nextTurnButton = document.createElement('button');
        nextTurnButton.id = 'next-turn-button';
        nextTurnButton.className = 'control-button ml-4';
        nextTurnButton.innerHTML = '&#9654;&#9654;'; // Fast forward symbol
        nextTurnButton.addEventListener('click', () => this.nextTurn());
        controlsDiv.appendChild(nextTurnButton);
        
        // Settings button
        const settingsButton = document.createElement('button');
        settingsButton.id = 'settings-button';
        settingsButton.className = 'control-button ml-1';
        settingsButton.innerHTML = '&#9881;'; // Gear symbol
        settingsButton.addEventListener('click', () => this.showSettings());
        controlsDiv.appendChild(settingsButton);
        
        // Back button
        const backButton = document.createElement('button');
        backButton.id = 'back-button';
        backButton.className = 'control-button ml-4';
        backButton.textContent = 'Back';
        backButton.addEventListener('click', () => this.exitBattle());
        controlsDiv.appendChild(backButton);
        
        header.appendChild(turnDiv);
        header.appendChild(controlsDiv);
        
        return header;
    }
    
    /**
     * Create a team section (either player or enemy)
     * @param {string} title - Section title
     * @param {string} titleColor - Color class for the title
     * @returns {HTMLElement} Team section element
     */
    createTeamSection(title, titleColor) {
        const section = document.createElement('section');
        section.className = 'flex flex-col items-center gap-6 w-1/3 md:w-1/4';
        
        const heading = document.createElement('h2');
        heading.className = `text-xl font-semibold mb-2 ${titleColor}`;
        heading.textContent = title;
        
        section.appendChild(heading);
        
        return section;
    }
    
    /**
     * Create the battle log
     * @returns {HTMLElement} Battle log element
     */
    createBattleLog() {
        const logContainer = document.createElement('div');
        logContainer.className = 'absolute bottom-4 left-4';
        logContainer.style.width = '400px'; // Increased width from 300px to 400px
        logContainer.style.zIndex = '30'; // Higher than victory overlay (which is 20)
        
        const logDiv = document.createElement('div');
        logDiv.className = 'rounded-lg p-4 shadow-md battle-log';
        logDiv.style.backgroundColor = 'rgba(28, 33, 48, 0.95)'; // More opaque, darker background // Increased padding from p-3 to p-4
        
        const logHeading = document.createElement('div');
        logHeading.className = 'flex justify-between items-center text-sm font-semibold mb-2 border-b border-gray-600 pb-1';
        
        const logTitle = document.createElement('h3');
        logTitle.textContent = 'Battle Log';
        
        const copyButton = document.createElement('button');
        copyButton.className = 'text-xs py-0 px-2 bg-blue-600 rounded hover:bg-blue-500';
        copyButton.textContent = 'Copy';
        copyButton.addEventListener('click', () => this.copyBattleLog());
        
        logHeading.appendChild(logTitle);
        logHeading.appendChild(copyButton);
        
        const logContent = document.createElement('div');
        logContent.id = 'battle-log-content';
        logContent.className = 'text-xs space-y-2'; // Increased space between entries from space-y-1 to space-y-2
        
        logDiv.appendChild(logHeading);
        logDiv.appendChild(logContent);
        logContainer.appendChild(logDiv);
        
        return logContainer;
    }
    
    /**
     * Set the arena background
     * @param {HTMLElement} arenaElement - Arena element to apply background to
     * @param {string} backgroundKey - Key for the background to apply ('default', 'forest', etc)
     */
    setArenaBackground(arenaElement, backgroundKey) {
        // Only accept 'default' or 'grassyfield' for now
        if (backgroundKey !== 'default' && backgroundKey !== 'grassyfield') {
            console.log(`Background '${backgroundKey}' not implemented yet, using 'grassyfield' instead`);
            backgroundKey = 'grassyfield';
        }
        
        // Remove any existing arena classes
        arenaElement.classList.remove('arena-default', 'arena-grassyfield');
        
        // Add the requested arena class
        arenaElement.classList.add(`arena-${backgroundKey}`);
        
        // Check if the background is an image and verify it exists
        if (backgroundKey === 'grassyfield') {
            const imageUrl = 'assets/images/Arena Art/Grassy Field.png';
            
            // Apply a custom inline style to be absolutely sure it's applied
            arenaElement.style.backgroundImage = `url("${imageUrl}")`;
            arenaElement.style.backgroundSize = 'cover';
            arenaElement.style.backgroundPosition = 'center';
            
            // Attempt to preload the image to verify it exists
            const img = new Image();
            img.onerror = () => {
                console.error(`Failed to load background image: ${imageUrl}`);
                // Fallback to default background if image fails to load
                arenaElement.classList.remove(`arena-${backgroundKey}`);
                arenaElement.classList.add('arena-default');
                arenaElement.style.backgroundImage = '';
                this.arenaBackground = 'default';
            };
            img.src = imageUrl;
        } else {
            // Remove inline style if using default
            arenaElement.style.backgroundImage = '';
        }
        
        this.arenaBackground = backgroundKey;
    }
    
    /**
     * Render characters in the battle UI
     * @param {Array} playerTeam - Player team characters
     * @param {Array} enemyTeam - Enemy team characters
     */
    renderCharacters(playerTeam, enemyTeam) {
        this.playerTeam = playerTeam;
        this.enemyTeam = enemyTeam;
        
        console.log('BattleUI: Rendering characters', playerTeam, enemyTeam);
        
        // Clear existing characters
        const playerSection = this.elements.playerTeamContainer;
        const enemySection = this.elements.enemyTeamContainer;
        
        // Keep the heading, remove other children
        while (playerSection.childNodes.length > 1) {
            playerSection.removeChild(playerSection.lastChild);
        }
        
        while (enemySection.childNodes.length > 1) {
            enemySection.removeChild(enemySection.lastChild);
        }
        
        // Render player team
        playerTeam.forEach(character => {
            const characterElement = this.createCharacterElement(character, 'player');
            playerSection.appendChild(characterElement);
        });
        
        // Render enemy team
        enemyTeam.forEach(character => {
            const characterElement = this.createCharacterElement(character, 'enemy');
            enemySection.appendChild(characterElement);
        });
        
        // Set the first character as active
        if (playerTeam.length > 0) {
            this.setActiveCharacter(playerTeam[0]);
        }
    }
    
    /**
     * Create a character element
     * @param {Object} character - Character data
     * @param {string} team - 'player' or 'enemy'
     * @returns {HTMLElement} Character element
     */
    createCharacterElement(character, team) {
        const container = document.createElement('div');
        container.className = 'flex flex-col items-center text-center';
        
        // Create a unique ID for this character that includes team information
        // This ensures we correctly identify characters even if they have the same name
        character.uniqueId = `${team}_${character.id}`;
        
        container.id = `character-container-${character.uniqueId}`;
        container.dataset.team = team; // Store team info for attack animations
        
        // Character representation (circle or image)
        const circle = document.createElement('div');
        
        // Check if this is a character with art (Aqualia or any character with art property)
        if (character.name === "Aqualia" || (character.art && character.art.enabled !== false)) {
            // Add a class to identify this as a character with art
            circle.className = 'character-circle character-art-container';
            circle.id = `character-${character.uniqueId}`;
            circle.style.position = 'relative'; // Ensure relative positioning for the movement
            circle.dataset.hasArt = 'true'; // Mark this character as having art
            
            // Log that we're creating a character with art
            console.log(`Creating ${character.name} character with art`);
            
            // Use a direct path to the image based on the web server root
            const artPath = `assets/images/Character Art/${character.name}.png`;
            
            // Create a wrapper div to contain the image and properly position it
            const imageWrapper = document.createElement('div');
            imageWrapper.className = 'character-art-wrapper';
            imageWrapper.style.position = 'absolute';
            imageWrapper.style.top = '0';
            imageWrapper.style.left = '0';
            imageWrapper.style.width = '100%';
            imageWrapper.style.height = '100%';
            imageWrapper.style.zIndex = '5';
            
            // Create and add the image element
            const imgElement = new Image();
            imgElement.className = 'character-art';
            imgElement.alt = character.name;
            
            // Apply character-specific art settings if available
            if (character.art) {
                if (character.art.left) {
                    imgElement.style.left = character.art.left;
                    // Store original left value to maintain position during animations
                    imgElement.dataset.originalLeft = character.art.left;
                }
                if (character.art.top) {
                    imgElement.style.top = character.art.top;
                    // Store original top value to maintain position during animations
                    imgElement.dataset.originalTop = character.art.top;
                }
                if (character.art.width) imgElement.style.width = character.art.width;
                if (character.art.height) imgElement.style.height = character.art.height;
            }
            
            // Log to diagnose image loading issues
            imgElement.onload = function() {
                console.log(`SUCCESS: ${character.name} image loaded successfully`);
                // Remove the background completely once the image loads
                circle.style.backgroundColor = 'transparent';
                circle.style.borderColor = 'transparent';
            };
            
            imgElement.onerror = function(e) {
                console.error(`FAILED: Error loading ${character.name} image:`, e);
                console.log('Image path tried:', imgElement.src);
                // Keep the fallback color/letter if image fails to load
            };
            
            // Set a transparent background by default
            circle.style.backgroundColor = 'transparent';
            circle.style.border = 'none';
            
            // Set the src AFTER setting up event handlers
            imgElement.src = artPath;
            
            // Add the image to the wrapper, then wrapper to circle
            imageWrapper.appendChild(imgElement);
            circle.appendChild(imageWrapper);
        } else {
            // Standard circle for other characters
            circle.className = `character-circle bg-${character.type}`;
            if (character.type === 'light') {
                circle.classList.add('text-dark-on-light');
            }
            circle.id = `character-${character.uniqueId}`;
            circle.textContent = character.name.charAt(0).toUpperCase();
            circle.style.position = 'relative'; // Ensure relative positioning for the movement
        }
        
        // HP bar container
        const hpBarContainer = document.createElement('div');
        hpBarContainer.className = 'hp-bar-container';
        
        const hpBarBackground = document.createElement('div');
        hpBarBackground.className = 'hp-bar-background';
        
        const currentHp = character.currentHp !== undefined ? character.currentHp : character.stats.hp;
        const maxHp = character.stats.hp;
        const healthPercentage = (currentHp / maxHp) * 100;
        
        const hpBarCurrent = document.createElement('div');
        hpBarCurrent.className = 'hp-bar-current';
        hpBarCurrent.style.width = `${healthPercentage}%`;
        hpBarCurrent.id = `hp-bar-${character.uniqueId}`;
        
        hpBarBackground.appendChild(hpBarCurrent);
        hpBarContainer.appendChild(hpBarBackground);
        
        // Character name
        const nameDiv = document.createElement('div');
        nameDiv.className = 'text-sm font-semibold mt-1';
        nameDiv.textContent = character.name;
        
        // HP text
        const hpText = document.createElement('div');
        hpText.className = 'text-xs';
        hpText.textContent = `HP: ${currentHp} / ${maxHp}`;
        hpText.id = `hp-text-${character.uniqueId}`;
        
        // Status icons container
        const statusContainer = document.createElement('div');
        statusContainer.className = 'status-icons-container';
        statusContainer.id = `status-icons-${character.uniqueId}`;
        
        // Add elements to container
        container.appendChild(circle);
        container.appendChild(hpBarContainer);
        container.appendChild(nameDiv);
        container.appendChild(hpText);
        container.appendChild(statusContainer);
        
        return container;
    }
    
    /**
     * Set a character as the active character
     * @param {Object} character - Character data
     */
    setActiveCharacter(character) {
        // Remove active class from all character containers
        document.querySelectorAll('.active-character').forEach(el => {
            el.classList.remove('active-character');
            
            // Restore original position values for any character art if they exist
            const characterId = el.id.replace('character-container-', '');
            const artContainer = document.getElementById(`character-${characterId}`);
            if (artContainer && artContainer.dataset.hasArt === 'true') {
                const img = artContainer.querySelector('.character-art');
                if (img) {
                    // Restore original position values if available
                    if (img.dataset.originalLeft) {
                        img.style.left = img.dataset.originalLeft;
                    }
                    if (img.dataset.originalTop) {
                        img.style.top = img.dataset.originalTop;
                    }
                }
            }
        });
        
        this.activeCharacter = character;
        
        // Add active class to the character container
        // We need the uniqueId which includes team information
        const uniqueId = character.uniqueId || (character.team === 'player' ? `player_${character.id}` : `enemy_${character.id}`);
        const characterContainer = document.getElementById(`character-container-${uniqueId}`);
        if (characterContainer) {
            characterContainer.classList.add('active-character');
            
            // Make sure character art maintains its position when active
            const artContainer = document.getElementById(`character-${uniqueId}`);
            if (artContainer && artContainer.dataset.hasArt === 'true') {
                // If character has art, ensure position is maintained
                const img = artContainer.querySelector('.character-art');
                if (img && img.dataset.originalLeft && img.dataset.originalTop) {
                    // Re-apply the original position values
                    img.style.left = img.dataset.originalLeft;
                    img.style.top = img.dataset.originalTop;
                }
            }
        }
    }
    
    /**
     * Show an attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Object} ability - Ability used
     */
    showAttackAnimation(attacker, target, ability) {
        // DEBUG MESSAGE FOR DEPRECATED DOM ANIMATIONS
        console.warn('âš ï¸ USING DEPRECATED DOM BATTLE ANIMATIONS: Please use Phaser-based battle scene for improved performance');

        // Disable DirectImageLoader during this animation to prevent art switching
        if (typeof window.disableDirectImageLoaderDuringAnimation === 'function') {
            window.disableDirectImageLoaderDuringAnimation();
        } else {
            // Fallback if function doesn't exist
            window.disableDirectImageLoader = true;
            setTimeout(() => { window.disableDirectImageLoader = false; }, 2000);
        }
        
        // Logging for debugging purposes
        console.log(`Animation: ${attacker.name} (${attacker.uniqueId}) attacking ${target.name} (${target.uniqueId})`);
        
        // Get the character elements using uniqueId
        const attackerContainer = document.getElementById(`character-container-${attacker.uniqueId}`);
        const targetContainer = document.getElementById(`character-container-${target.uniqueId}`);
        const attackerCircle = document.getElementById(`character-${attacker.uniqueId}`);
        const targetCircle = document.getElementById(`character-${target.uniqueId}`);
        
        // Add Action Text display above character head (to the container, not the circle)
        const actionType = ability ? (ability.isHealing ? 'heal' : 'ability') : 'attack';
        const actionText = ability ? ability.name : 'Auto-Attack';
        // Use the container instead of circle so text stays in place
        this.showActionText(attackerContainer, actionText, actionType);
        
        if (!attackerCircle || !targetCircle) {
            console.error('Could not find character elements for animation:', 
                        { attacker: attacker.name, target: target.name, 
                          attackerId: attacker.uniqueId, targetId: target.uniqueId });
            return;
        }
        
        // SIMPLIFIED ANIMATION: Just show the action text and update health
        // Store damage info
        const damage = ability ? ability.damage : attacker.stats.attack;
        const isHealing = ability && ability.isHealing;
        
        // Show simplified effect
        this.showBonkEffect(targetCircle, isHealing);
        
        // Show damage numbers
        this.showFloatingText(
            target.id,
            isHealing ? `+${damage}` : `-${damage}`,
            isHealing ? 'text-green-500' : 'text-red-500'
        );
        
        // Update target's health
        this.updateCharacterHealth(target, damage, isHealing);
        
        // Re-enable DirectImageLoader after animation is completely finished
        setTimeout(() => {
            window.disableDirectImageLoader = false;
            console.log('Animation complete, DirectImageLoader re-enabled');
        }, 500);
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Check if this character has artwork
        const hasArt = attackerCircle.dataset.hasArt === 'true';
        
        // Store attacker info in data attribute for secure identification
        // This helps prevent character art mix-ups during animations
        const attackerUniqueId = attacker.uniqueId;
        const attackerName = attacker.name;
        
        // Create a fresh clone of the attacker circle for the animation
        const animatedClone = attackerCircle.cloneNode(false); // Shallow clone first
        animatedClone.id = `clone-${attackerUniqueId}`;
        animatedClone.setAttribute('data-character-id', attacker.id);
        animatedClone.setAttribute('data-character-name', attackerName);
        animatedClone.setAttribute('data-character-unique-id', attackerUniqueId);
        animatedClone.style.position = 'fixed'; // Use fixed positioning for accurate placement
        animatedClone.style.zIndex = '200';
        animatedClone.style.margin = '0'; // Remove any margin
        animatedClone.style.opacity = '1'; 
        animatedClone.style.transition = 'none'; // Disable transitions initially
        animatedClone.classList.add('character-moving');
        
        // Special handling for characters with art
        if (hasArt) {
            // Make sure the container has correct styling
            animatedClone.style.backgroundColor = 'transparent';
            animatedClone.style.border = 'none';
            
            // Create a fresh wrapper instead of cloning to avoid potential reference issues
            const artWrapper = document.createElement('div');
            artWrapper.className = 'character-art-wrapper';
            animatedClone.appendChild(artWrapper);
            
            // Create a fresh image element
            const img = new Image();
            img.className = 'character-art';
            img.alt = attackerName;
            
            // IMPORTANT: Set character-specific data attributes to prevent misidentification
            img.dataset.characterName = attackerName;
            img.dataset.characterId = attacker.id;
            img.dataset.characterUniqueId = attackerUniqueId;
            
            // Ensure the image is set to a working path based on attacker name
            const imagePath = `assets/images/Character Art/${attackerName}.png`;
            img.src = imagePath;
            
            // Use a secure global reference if available
            if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[attackerName]) {
                console.log(`Using cached image for ${attackerName} during animation`);
                // Copy the src from the cache to ensure consistency
                const cachedSrc = window.CHARACTER_IMAGE_CACHE[attackerName].src;
                if (cachedSrc) img.src = cachedSrc;
            }
            
            // Copy over the custom positioning from original image
            const originalImg = attackerCircle.querySelector('.character-art');
            if (originalImg) {
                // Copy exact positioning from original image
                if (originalImg.dataset.originalLeft) {
                    img.style.left = originalImg.dataset.originalLeft;
                    img.dataset.originalLeft = originalImg.dataset.originalLeft;
                }
                if (originalImg.dataset.originalTop) {
                    img.style.top = originalImg.dataset.originalTop;
                    img.dataset.originalTop = originalImg.dataset.originalTop;
                }
                // Copy width/height from original if available
                if (originalImg.style.width) img.style.width = originalImg.style.width;
                if (originalImg.style.height) img.style.height = originalImg.style.height;
            }
            
            // Add the image to the wrapper
            artWrapper.appendChild(img);
            
            // Add a loaded class to the clone
            animatedClone.classList.add('art-loaded');
            
            // Log animation for debugging purposes
            console.log(`Created animation clone for ${attackerName} (${attackerUniqueId})`);
        }
        
        // Hide the original circle during animation
        attackerCircle.style.visibility = 'hidden';
        
        // Clean up any lingering clones before adding a new one
        // This helps prevent potential art mix-ups from earlier animations
        const existingClones = document.querySelectorAll('[id^="clone-"]');
        existingClones.forEach(clone => {
            if (clone.parentNode) {
                clone.parentNode.removeChild(clone);
                console.log('Removed lingering animation clone');
            }
        });
        
        // Add the clone to the battle area
        const battleArena = document.getElementById('battle-arena');
        battleArena.appendChild(animatedClone);
        
        // Calculate positions
        const attackerRect = attackerCircle.getBoundingClientRect();
        const targetRect = targetCircle.getBoundingClientRect();
        
        // Position the clone at the attacker's position
        animatedClone.style.left = `${attackerRect.left}px`;
        animatedClone.style.top = `${attackerRect.top}px`;
        animatedClone.style.width = `${attackerRect.width}px`;
        animatedClone.style.height = `${attackerRect.height}px`;
        
        // Calculate animation timing based on speed
        const speedMultiplier = this.battleManager ? this.battleManager.speedMultiplier || 1 : 1;
        const moveDuration = 400 / speedMultiplier;
        const returnDuration = 300 / speedMultiplier;
        
        // 1. Initial slight scale down
        requestAnimationFrame(() => {
            // Start with a small scale
            animatedClone.style.transform = 'scale(0.9)';
            
            // 2. Move to target with a slight delay
            setTimeout(() => {
                // Apply transition for movement
                animatedClone.style.transition = `left ${moveDuration}ms ease-out, top ${moveDuration}ms ease-out, transform 200ms ease-out`;
                
                // Calculate the target position (stop just short of the target)
                // For player team attacking enemy team, move to the left of the target
                // For enemy team attacking player team, move to the right of the target
                const attackerTeam = attackerContainer.dataset.team;
                const targetTeam = targetContainer.dataset.team;
                
                let moveToX, moveToY;
                if (attackerTeam === 'player' && targetTeam === 'enemy') {
                    // Player attacking enemy - move to the left side of the target
                    moveToX = targetRect.left - (attackerRect.width / 2);
                } else if (attackerTeam === 'enemy' && targetTeam === 'player') {
                    // Enemy attacking player - move to the right side of the target
                    moveToX = targetRect.right - (attackerRect.width / 2);
                } else {
                    // Same team (healing) - go to the center
                    moveToX = targetRect.left + (targetRect.width - attackerRect.width) / 2;
                }
                
                // Vertically align with the target
                moveToY = targetRect.top + (targetRect.height - attackerRect.height) / 2;
                
                // Move toward the target
                animatedClone.style.transform = 'scale(1.1)';
                animatedClone.style.left = `${moveToX}px`;
                animatedClone.style.top = `${moveToY}px`;
                
                // 3. When near target, show impact effect
                setTimeout(() => {
                    // Show bonk effect and shake target
                    this.showBonkEffect(targetCircle, isHealing);
                    targetCircle.style.animation = 'shake 0.5s';
                    
                    // Show damage numbers
                    this.showFloatingText(
                        target.id,
                        isHealing ? `+${damage}` : `-${damage}`,
                        isHealing ? 'text-green-500' : 'text-red-500'
                    );
                    
                    // Update target's health
                    this.updateCharacterHealth(target, damage, isHealing);
                    
                    // 4. Move back to original position
                    setTimeout(() => {
                        animatedClone.style.transition = `left ${returnDuration}ms ease-in, top ${returnDuration}ms ease-in, opacity 200ms ease-out`;
                        animatedClone.style.left = `${attackerRect.left}px`;
                        animatedClone.style.top = `${attackerRect.top}px`;
                        animatedClone.style.transform = 'scale(0.9)';
                        
                        // 5. Fade out clone and remove
                        setTimeout(() => {
                            // Begin fade out
                            animatedClone.style.opacity = '0';
                            
                            setTimeout(() => {
                                // Verify clone is the correct one for this character (safety check)
                                if (animatedClone.dataset.characterUniqueId !== attackerUniqueId) {
                                    console.warn(`Animation clone mismatch detected: ${animatedClone.dataset.characterUniqueId} vs expected ${attackerUniqueId}`);
                                }
                                
                                // Ensure the clone is properly removed
                                if (animatedClone.parentNode) {
                                    console.log(`Removing animation clone for ${attackerName}`);
                                    animatedClone.parentNode.removeChild(animatedClone);
                                }
                                
                                // Double check for any other clones that might be lingering
                                const otherClones = document.querySelectorAll(`[id="clone-${attackerUniqueId}"]`);
                                otherClones.forEach(clone => {
                                    if (clone.parentNode) {
                                        console.warn('Found additional clone to remove');
                                        clone.parentNode.removeChild(clone);
                                    }
                                });
                                
                                // Reset target animation
                                targetCircle.style.animation = '';
                                
                                // Show original attacker circle again
                                attackerCircle.style.visibility = 'visible';
                                
                                // Re-enable DirectImageLoader after animation is completely finished
                                // This ensures no injection happens during the animation
                                window.disableDirectImageLoader = false;
                                console.log('Animation complete, DirectImageLoader re-enabled');
                            }, 200);
                        }, returnDuration - 50);
                    }, 400 / speedMultiplier);
                }, moveDuration);
            }, 50);
        });
        */
    }
    
    /**
     * Show a bonk effect on the target
     * @param {HTMLElement} targetElement - The target element
     * @param {boolean} isHealing - Whether this is a healing effect
     */
    showBonkEffect(targetElement, isHealing = false) {
        // Create bonk element
        const bonk = document.createElement('div');
        bonk.className = 'attack-bonk';
        
        // Use different icon based on whether it's healing or attack
        if (isHealing) {
            bonk.textContent = 'âœ¨'; // Sparkle for healing
            bonk.style.color = '#48bb78'; // Green color
        } else {
            bonk.textContent = 'ðŸ’¥'; // Impact for attack
            bonk.style.color = '#f56565'; // Red color
        }
        
        // Add to target
        targetElement.appendChild(bonk);
        
        // Add animation class
        bonk.classList.add('animate-bonk');
        
        // Remove after animation completes
        setTimeout(() => {
            if (bonk.parentNode === targetElement) {
                targetElement.removeChild(bonk);
            }
        }, 500);
    }
    
    /**
     * Show action text above a character
     * @param {HTMLElement} characterElement - The character element
     * @param {string} actionText - Text to display
     * @param {string} actionType - Type of action ('attack', 'ability', or 'heal')
     */
    showActionText(characterElement, actionText, actionType = 'attack') {
        // Create the action text element
        const actionTextElement = document.createElement('div');
        actionTextElement.className = `action-text action-text-${actionType}`;
        actionTextElement.textContent = actionText;
        
        // Add to character element
        characterElement.appendChild(actionTextElement);
        
        // Remove after animation completes
        const duration = 1800 / (this.battleManager ? this.battleManager.speedMultiplier || 1 : 1);
        setTimeout(() => {
            if (actionTextElement.parentNode === characterElement) {
                characterElement.removeChild(actionTextElement);
            }
        }, duration); // Match the animation duration with battle speed adjustment
    }
    
    /**
     * Show passive effect visual feedback
     * @param {Object} character - Character with the passive ability
     * @param {string} effectName - Name of the passive effect
     */
    showPassiveEffect(character, effectName) {
        // Get character's unique ID
        const uniqueId = character.uniqueId || (character.team === 'player' ? `player_${character.id}` : `enemy_${character.id}`);
        
        // Find the character element
        const characterElement = document.getElementById(`character-${uniqueId}`);
        
        if (!characterElement) {
            console.error(`Could not find character element for ${character.name} (${uniqueId})`);
            return;
        }
        
        // Create passive effect element
        const passiveEffect = document.createElement('div');
        passiveEffect.className = 'passive-effect';
        passiveEffect.textContent = 'âœ¨ ' + effectName;
        
        // Add some custom styling for passive effects
        passiveEffect.style.position = 'absolute';
        passiveEffect.style.top = '-30px';
        passiveEffect.style.left = '50%';
        passiveEffect.style.transform = 'translateX(-50%)';
        passiveEffect.style.backgroundColor = 'rgba(75, 0, 130, 0.8)'; // Purple for passives
        passiveEffect.style.color = 'white';
        passiveEffect.style.padding = '3px 8px';
        passiveEffect.style.borderRadius = '4px';
        passiveEffect.style.fontSize = '12px';
        passiveEffect.style.fontWeight = 'bold';
        passiveEffect.style.whiteSpace = 'nowrap';
        passiveEffect.style.zIndex = '100';
        passiveEffect.style.animation = 'float-up-fade-out 1.5s forwards';
        passiveEffect.style.border = '1px solid rgba(128, 0, 255, 0.5)';
        
        // Add to character element
        characterElement.appendChild(passiveEffect);
        
        // Remove after animation completes
        setTimeout(() => {
            if (passiveEffect.parentNode === characterElement) {
                characterElement.removeChild(passiveEffect);
            }
        }, 1500);
        
        // Also add a glowing effect to the character
        const glowEffect = document.createElement('div');
        glowEffect.className = 'passive-glow';
        glowEffect.style.position = 'absolute';
        glowEffect.style.top = '0';
        glowEffect.style.left = '0';
        glowEffect.style.width = '100%';
        glowEffect.style.height = '100%';
        glowEffect.style.borderRadius = '50%';
        glowEffect.style.boxShadow = '0 0 15px 5px rgba(128, 0, 255, 0.6)';
        glowEffect.style.animation = 'passive-glow 1s ease-out';
        glowEffect.style.zIndex = '5';
        glowEffect.style.pointerEvents = 'none';
        
        // Add glow animation style if it doesn't exist
        if (!document.getElementById('passive-effect-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'passive-effect-styles';
            styleEl.textContent = `
                @keyframes passive-glow {
                    0% { opacity: 0.8; transform: scale(0.9); }
                    50% { opacity: 1; transform: scale(1.1); }
                    100% { opacity: 0; transform: scale(1.2); }
                }
            `;
            document.head.appendChild(styleEl);
        }
        
        // Add the glow element behind other content
        characterElement.insertBefore(glowEffect, characterElement.firstChild);
        
        // Remove glow after animation
        setTimeout(() => {
            if (glowEffect.parentNode === characterElement) {
                characterElement.removeChild(glowEffect);
            }
        }, 1000);
    }
    
    /**
     * Show floating text above a character
     * @param {string} characterId - ID of the character
     * @param {string} text - Text to display
     * @param {string} textColor - Color class for the text
     */
    showFloatingText(characterId, text, textColor) {
        // In case we're passed a regular ID, let's try to find the uniqueId first
        let characterElement = null;
        
        // Try to find the element with uniqueId (player_id or enemy_id)
        const possibleIds = [`player_${characterId}`, `enemy_${characterId}`];
        for (const id of possibleIds) {
            const element = document.getElementById(`character-${id}`);
            if (element) {
                characterElement = element;
                break;
            }
        }
        
        // If not found with uniqueId, fall back to regular id
        if (!characterElement) {
            characterElement = document.getElementById(`character-${characterId}`);
        }
        
        if (!characterElement) {
            console.error(`Could not find character element for ID: ${characterId}`);
            return;
        }
        
        const floatingText = document.createElement('div');
        floatingText.className = `floating-text ${textColor}`;
        floatingText.textContent = text;
        
        characterElement.appendChild(floatingText);
        
        // Remove after animation completes
        setTimeout(() => {
            if (floatingText.parentNode === characterElement) {
                characterElement.removeChild(floatingText);
            }
        }, 1200);
    }
    
    /**
     * Update character health display
     * @param {Object} character - Character data
     * @param {number} amount - Amount to change (damage or healing)
     * @param {boolean} isHealing - Whether this is healing
     */
    updateCharacterHealth(character, amount, isHealing = false) {
        // Update character object
        const newHealth = isHealing 
            ? Math.min(character.currentHp + amount, character.stats.hp)
            : Math.max(0, character.currentHp - amount);
        
        character.currentHp = newHealth;
        
        // Use uniqueId if available
        const uniqueId = character.uniqueId || character.id;
        
        // Update HP bar
        const hpBar = document.getElementById(`hp-bar-${uniqueId}`);
        const hpText = document.getElementById(`hp-text-${uniqueId}`);
        
        if (hpBar && hpText) {
            // Calculate health percentage
            const healthPercentage = (character.currentHp / character.stats.hp) * 100;
            
            // Update HP bar width with animation
            hpBar.style.width = `${healthPercentage}%`;
            
            // Update HP text
            hpText.textContent = `HP: ${character.currentHp} / ${character.stats.hp}`;
            
            // Change color based on health percentage
            if (healthPercentage <= 25) {
                hpBar.style.backgroundColor = '#f56565'; // Red for low health
            } else if (healthPercentage <= 50) {
                hpBar.style.backgroundColor = '#ed8936'; // Orange for medium health
            } else {
                hpBar.style.backgroundColor = '#48bb78'; // Green for good health
            }
        }
    }
    
    /**
     * Update the UI with current state
     */
    update() {
        if (this.battleManager) {
            const turnDisplay = this.elements.turnDisplay;
            if (turnDisplay) {
                turnDisplay.textContent = `Turn: ${this.battleManager.currentTurn}`;
            }
        }
    }
    
    /**
     * Add message to battle log
     * @param {string} message - Message text
     * @param {string} type - Message type
     */
    addLogMessage(message, type = 'default') {
        // Add to our log array
        this.logMessages.push({ message, type });
        
        // No longer limiting to most recent messages so we can copy the entire battle log
        // Previously: if (this.logMessages.length > 30) { this.logMessages.shift(); }
        
        // Update log display
        const logContent = this.elements.logContent;
        if (logContent) {
            const messageElement = document.createElement('p');
            
            // Format the message with colored spans based on content
            let formattedMessage = message;
            
            // Override formatting based on message type
            switch (type) {
                case 'success':
                    messageElement.style.color = '#48bb78'; // Green
                    break;
                case 'error':
                    messageElement.style.color = '#f56565'; // Red
                    break;
                case 'info':
                    messageElement.style.color = '#4299e1'; // Blue
                    break;
                case 'action':
                    messageElement.style.color = '#ed8936'; // Orange
                    break;
            }
            
            messageElement.innerHTML = formattedMessage
                .replace(/\[(.*?)\]/g, '<span style="color: #a0aec0">[$1]</span>') // Abilities in brackets
                .replace(/\+(\d+) HP/g, '<span style="color: #48bb78">+$1 HP</span>') // Healing
                .replace(/Miss!/g, '<span style="color: #a0aec0">Miss!</span>'); // Misses
                
            logContent.appendChild(messageElement);
            
            // Scroll to bottom
            logContent.scrollTop = logContent.scrollHeight;
        }
    }
    
    /**
     * Toggle pause state
     */
    togglePause() {
        if (this.battleManager) {
            const isPaused = this.battleManager.togglePause();
            const pauseButton = this.elements.pauseButton;
            if (pauseButton) {
                pauseButton.innerHTML = isPaused ? '&#9658;' : '&#10074;&#10074;'; // Play or pause symbol
            }
        }
    }
    
    /**
     * Set battle speed
     * @param {number} speed - Speed multiplier
     */
    setSpeed(speed) {
        if (this.battleManager) {
            this.battleManager.setSpeed(speed);
            
            // Update button styles
            Object.entries(this.elements.speedButtons).forEach(([btnSpeed, button]) => {
                if (button) {
                    if (btnSpeed === `${speed}x`) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                }
            });
        }
    }
    
    /**
     * Go to next turn
     */
    nextTurn() {
        if (this.battleManager) {
            this.battleManager.startNextTurn();
        }
    }
    
    /**
     * Show settings dialog
     */
    showSettings() {
        // Only offer backgrounds that actually exist
        const bgOptions = ['default', 'grassyfield'];
        const selectedBg = prompt(`Select arena background (${bgOptions.join(', ')}):`, this.arenaBackground);
        
        if (selectedBg && bgOptions.includes(selectedBg)) {
            this.setArenaBackground(this.elements.battleArena, selectedBg);
            
            // Special handling for grassyfield background
            if (selectedBg === 'grassyfield') {
                // Call our utility method that tries multiple paths
                setTimeout(() => {
                    this.setGrassyFieldDirect();
                }, 100);
            }
            
            // Add a visual notification to confirm the change
            const notification = document.createElement('div');
            notification.textContent = `Background changed to ${selectedBg}`;
            notification.style.position = 'fixed';
            notification.style.top = '60px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            notification.style.color = 'white';
            notification.style.padding = '8px 16px';
            notification.style.borderRadius = '4px';
            notification.style.zIndex = '1000';
            document.body.appendChild(notification);
            
            // Remove notification after 2 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
            
            console.log(`Background changed to ${selectedBg}`);
        }
    }
    
    /**
     * Set Grassy Field as background using direct URL
     * This is a utility method the user can call directly from console
     */
    setGrassyFieldDirect() {
        if (!this.elements || !this.elements.battleArena) {
            console.error('Battle arena element not found');
            return;
        }
        
        const arenaElement = this.elements.battleArena;
        
        // Remove any existing arena classes
        arenaElement.classList.remove('arena-default', 'arena-forest', 'arena-volcano', 'arena-glacier', 'arena-grassyfield');
        
        // Add the grassyfield class
        arenaElement.classList.add('arena-grassyfield');
        
        // Try multiple paths to ensure one works
        const paths = [
            'assets/images/Arena Art/Grassy Field.png',
            './assets/images/Arena Art/Grassy Field.png',
            '../assets/images/Arena Art/Grassy Field.png',
            '../../assets/images/Arena Art/Grassy Field.png',
            '/assets/images/Arena Art/Grassy Field.png',
            'C:/Personal/AutoBattler/assets/images/Arena Art/Grassy Field.png',
            // Try base64 encoded small green rectangle as absolute fallback
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFeQI7Z6j1AwAAAABJRU5ErkJggg=='
        ];
        
        // Try each path
        let currentPath = 0;
        const tryNextPath = () => {
            if (currentPath >= paths.length) {
                console.error('All paths failed, using default background');
                arenaElement.classList.remove('arena-grassyfield');
                arenaElement.classList.add('arena-default');
                arenaElement.style.backgroundImage = '';
                return;
            }
            
            const path = paths[currentPath];
            console.log(`Trying path ${currentPath + 1}/${paths.length}: ${path}`);
            
            // Set the background image
            arenaElement.style.backgroundImage = `url("${path}")`;
            arenaElement.style.backgroundSize = 'cover';
            arenaElement.style.backgroundPosition = 'center';
            
            // If it's the base64 fallback, we're done
            if (path.startsWith('data:')) {
                console.log('Using base64 fallback');
                return;
            }
            
            // Otherwise check if the image loaded
            const img = new Image();
            img.onload = () => {
                console.log(`Success! Path ${currentPath + 1} worked: ${path}`);
            };
            img.onerror = () => {
                console.error(`Path ${currentPath + 1} failed: ${path}`);
                currentPath++;
                tryNextPath();
            };
            img.src = path;
        };
        
        // Start trying paths
        tryNextPath();
        
        // Update background setting
        this.arenaBackground = 'grassyfield';
        
        // Add a notification
        const notification = document.createElement('div');
        notification.textContent = 'Setting Grassy Field background...';
        notification.style.position = 'fixed';
        notification.style.top = '60px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        notification.style.color = 'white';
        notification.style.padding = '8px 16px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '1000';
        document.body.appendChild(notification);
        
        // Remove notification after 3 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
        
        return 'Attempting to set Grassy Field background...';
    }
    
    /**
     * Show victory/defeat screen
     * @param {string} result - 'victory', 'defeat', or 'draw'
     */
    showBattleResult(result) {
        // DEBUG MESSAGE FOR DEPRECATED DOM BATTLE UI
        console.warn('âš ï¸ USING DEPRECATED DOM BATTLE RESULT SCREEN: Please use Phaser-based battle scene for improved performance');

        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'victory-overlay';
        
        const resultText = document.createElement('h2');
        resultText.className = 'victory-text';
        
        switch (result) {
            case 'victory':
                resultText.textContent = 'VICTORY!';
                resultText.style.color = '#48bb78'; // Green
                break;
            case 'defeat':
                resultText.textContent = 'DEFEAT!';
                resultText.style.color = '#f56565'; // Red
                break;
            case 'draw':
                resultText.textContent = 'DRAW!';
                resultText.style.color = '#a0aec0'; // Gray
                break;
        }
        
        const returnButton = document.createElement('button');
        returnButton.className = 'victory-button mb-4';
        returnButton.textContent = 'Return to Team Builder';
        returnButton.addEventListener('click', () => this.exitBattle());
        
        const logNote = document.createElement('div');
        logNote.className = 'text-sm text-gray-300 mt-2';
        logNote.textContent = 'Battle log is still accessible in the bottom-left corner';
        
        overlay.appendChild(resultText);
        overlay.appendChild(returnButton);
        overlay.appendChild(logNote);
        
        // Add to battle UI
        document.getElementById('battle-ui').appendChild(overlay);
        
        // Enhance battle log visibility
        const battleLog = document.querySelector('.battle-log');
        if (battleLog) {
            battleLog.style.backgroundColor = 'rgba(28, 33, 48, 0.98)'; // More opaque
            battleLog.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)'; // Add glow
        }
        
        // Show immediately instead of using animation delay
        overlay.style.opacity = '1';
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Animate in with delay
        setTimeout(() => {
            overlay.style.opacity = '1';
        }, 100);
        */
    }
    
    /**
     * Handle round end events
     * @param {Object} data - Round end data
     */
    handleRoundEnd(data) {
        // DEBUG MESSAGE FOR DEPRECATED DOM ROUND INDICATOR
        console.warn('âš ï¸ USING DEPRECATED DOM ROUND INDICATOR: Please use Phaser-based battle scene for improved performance');

        // Create round end visual indicator
        const roundIndicator = document.createElement('div');
        roundIndicator.className = 'round-end-indicator';
        roundIndicator.textContent = `Round ${data.roundNumber} Complete`;
        
        // Style it directly to make it visible without custom CSS
        roundIndicator.style.position = 'absolute';
        roundIndicator.style.top = '50%';
        roundIndicator.style.left = '50%';
        roundIndicator.style.transform = 'translate(-50%, -50%)';
        roundIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        roundIndicator.style.color = 'white';
        roundIndicator.style.padding = '15px 30px';
        roundIndicator.style.borderRadius = '8px';
        roundIndicator.style.fontWeight = 'bold';
        roundIndicator.style.fontSize = '24px';
        roundIndicator.style.zIndex = '100';
        
        // Add to battle arena if available
        const battleArena = document.getElementById('battle-arena');
        if (battleArena) {
            battleArena.appendChild(roundIndicator);
        } else {
            document.body.appendChild(roundIndicator);
        }
        
        // Remove immediately to avoid delays
        setTimeout(() => {
            if (roundIndicator.parentNode) {
                roundIndicator.parentNode.removeChild(roundIndicator);
            }
        }, 100);
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Show for 2 seconds then fade out
        setTimeout(() => {
            roundIndicator.classList.add('fade-out');
            setTimeout(() => {
                roundIndicator.remove();
            }, 1000); // Fade out duration
        }, 2000); // Display duration
        */
    }

    /**
     * Exit battle
     */
    exitBattle() {
        // Remove our UI
        const battleUI = document.getElementById('battle-ui');
        if (battleUI) {
            document.body.removeChild(battleUI);
        }
        
        // Reset our setup flag
        this.isSetup = false;
        
        // Switch back to team builder
        document.getElementById('game-container').classList.remove('active');
        document.getElementById('team-builder-container').classList.add('active');
    }

    /**
     * Initialize tooltip manager for battle UI
     */
    initializeTooltipManager() {
        // Clean up any existing tooltips first
        this.cleanupTooltips();
        
        // If TooltipManager hasn't been initialized yet
        if (!window.tooltipManager) {
            console.log('BattleUI: Creating new TooltipManager instance');
            // Create a new instance
            window.tooltipManager = new TooltipManager();
        }
        
        // Add battle-specific CSS for tooltips
        this.addBattleTooltipStyles();
    }
    
    /**
     * Clean up all existing tooltips and event listeners
     */
    cleanupTooltips() {
        // Remove all existing tooltip event listeners
        const tooltipElements = document.querySelectorAll('.status-icon');
        tooltipElements.forEach(el => {
            // Clone element to remove all event listeners
            const newEl = el.cloneNode(true);
            if (el.parentNode) {
                el.parentNode.replaceChild(newEl, el);
            }
        });
        
        // Clear any existing tooltip containers
        const tooltipContainers = document.querySelectorAll('.battle-tooltip');
        tooltipContainers.forEach(container => {
            if (container.parentNode) {
                container.parentNode.removeChild(container);
            }
        });
        
        // Reset the battleTooltip property
        this.battleTooltip = null;
        
        console.log('BattleUI: Cleaned up existing tooltips');
    }

    /**
     * Add custom CSS for battle tooltips
     */
    addBattleTooltipStyles() {
        if (!document.getElementById('battle-tooltip-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'battle-tooltip-styles';
            styleEl.textContent = `
                /* Override the info icon for battle status icons */
                .status-icon.has-tooltip::after {
                    content: none; /* Remove the "i" icon */
                }
                
                /* Make status icons more interactive */
                .status-icon {
                    cursor: help;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                    position: relative;
                }
                
                .status-icon:hover {
                    transform: scale(1.2);
                    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
                    z-index: 50;
                }
                
                /* Custom styling for battle tooltips */
                .battle-tooltip {
                    position: fixed; /* Use fixed position */
                    background-color: rgba(20, 30, 46, 0.95); /* Darker blue */
                    color: #e2e8f0;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    max-width: 250px;
                    z-index: 9999; /* Very high z-index */
                    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 5px rgba(66, 153, 225, 0.5); /* Blue glow */
                    pointer-events: none;
                    border: 1px solid rgba(66, 153, 225, 0.3); /* Subtle blue border */
                    display: none; /* Hide initially */
                    transition: opacity 0.2s ease;
                    text-align: left;
                }
                
                .battle-tooltip.visible {
                    display: block;
                }
                
                .tooltip-title {
                    font-weight: bold;
                    margin-bottom: 4px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                    padding-bottom: 4px;
                    color: #90cdf4; /* Light blue for title */
                    font-size: 13px;
                }
                
                .tooltip-content {
                    font-size: 11px;
                    line-height: 1.4;
                }

                .tooltip-content div {
                    margin-bottom: 3px;
                }
            `;
            document.head.appendChild(styleEl);
        }
    }

    /**
     * Add a tooltip to a status icon
     * @param {HTMLElement} icon - The status icon element
     * @param {string} content - HTML content for the tooltip
     */
    addStatusTooltip(icon, content) {
        // Add custom class and cursor style
        icon.classList.add('battle-status-tooltip');
        icon.style.cursor = 'help';
        
        // Create the tooltip element if it doesn't exist
        if (!this.battleTooltip) {
            this.battleTooltip = document.createElement('div');
            this.battleTooltip.className = 'battle-tooltip';
            this.battleTooltip.style.position = 'fixed'; // Use fixed positioning
            this.battleTooltip.style.zIndex = '9999'; // Ensure high z-index
            document.body.appendChild(this.battleTooltip);
        }
        
        // Store content on the icon for easy access
        icon.dataset.tooltipContent = content;
        
        // Add event listeners for both hover and click
        icon.addEventListener('mouseenter', () => {
            this.showStatusTooltip(icon, content);
        });
        
        icon.addEventListener('mouseleave', () => {
            this.hideStatusTooltip();
        });
        
        // Also add click event as a fallback
        icon.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent battle UI click events
            this.showStatusTooltip(icon, content);
            
            // Hide tooltip when clicking elsewhere
            const hideOnOutsideClick = (event) => {
                if (!icon.contains(event.target)) {
                    this.hideStatusTooltip();
                    document.removeEventListener('click', hideOnOutsideClick);
                }
            };
            
            // Add a slight delay to avoid immediate trigger
            setTimeout(() => {
                document.addEventListener('click', hideOnOutsideClick);
            }, 10);
        });
    }

    /**
     * Show a status tooltip for an icon
     * @param {HTMLElement} icon - The status icon element
     * @param {string} content - HTML content for the tooltip
     */
    showStatusTooltip(icon, content) {
        // Get tooltip content from data attribute if not provided
        const tooltipContent = content || icon.dataset.tooltipContent; 
        if (!tooltipContent || !this.battleTooltip) return;

        // Set content first
        this.battleTooltip.innerHTML = tooltipContent;
        
        // Position the tooltip before making it visible
        const rect = icon.getBoundingClientRect();
        
        // First set it to a default position
        this.battleTooltip.style.left = `${rect.left + rect.width / 2 - 125}px`; // Center tooltip
        this.battleTooltip.style.top = `${rect.top - 10}px`; // Temporary position
        
        // Force layout recalculation to ensure offsetHeight is accurate
        this.battleTooltip.style.opacity = '0';
        this.battleTooltip.style.display = 'block';
        
        // Now use the correct height to position properly
        const tooltipHeight = this.battleTooltip.offsetHeight;
        this.battleTooltip.style.top = `${rect.top - tooltipHeight - 10}px`; // Position above icon
        
        // Check if tooltip would go offscreen and adjust if needed
        const tooltipRect = this.battleTooltip.getBoundingClientRect();
        if (tooltipRect.left < 10) {
            this.battleTooltip.style.left = '10px';
        }
        if (tooltipRect.right > window.innerWidth - 10) {
            this.battleTooltip.style.left = `${window.innerWidth - 250 - 10}px`;
        }
        if (tooltipRect.top < 10) {
            // If tooltip would go above the screen, position it below the icon instead
            this.battleTooltip.style.top = `${rect.bottom + 10}px`;
        }
        
        // Make visible
        this.battleTooltip.style.opacity = '1';
        this.battleTooltip.classList.add('visible');
    }
    
    /**
     * Hide the status tooltip
     */
    hideStatusTooltip() {
        if (this.battleTooltip) {
            this.battleTooltip.classList.remove('visible');
            this.battleTooltip.style.display = 'none';
        }
    }
    
    /**
     * Copy battle log to clipboard
     */
    copyBattleLog() {
        // Extract plain text from log messages
        const logText = this.logMessages.map(msg => msg.message).join('\n');
        
        // Copy to clipboard
        navigator.clipboard.writeText(logText)
            .then(() => {
                // Show feedback
                const copyButton = document.querySelector('.battle-log button');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#48bb78'; // Green
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                }, 2000);
            })
            .catch(err => {
                console.error('Failed to copy log:', err);
                alert('Failed to copy battle log to clipboard');
            });
    }
}

// Export for use in other modules
window.BattleUI = BattleUI;
// Also make available as a global variable
if (typeof BattleUI === 'undefined') {
    BattleUI = window.BattleUI;
}

console.log('BattleUI class loaded and available as window.BattleUI');

===== FILE: BattleUIDebug.js =====
/**
 * Battle UI Debug Helper
 * Provides debugging and troubleshooting for the BattleUI
 */

class BattleUIDebug {
    /**
     * Create a debug snapshot of the current state of the UI
     * @param {BattleUI} battleUI - The BattleUI instance to debug
     * @returns {Object} Debug information
     */
    static createSnapshot(battleUI) {
        const snapshot = {
            isSetup: battleUI.isSetup,
            playerTeamCount: battleUI.playerTeam.length,
            enemyTeamCount: battleUI.enemyTeam.length,
            domElements: {},
            tailwindStatus: {}
        };
        
        // Check if key elements exist in the DOM
        snapshot.domElements.battleUI = !!document.getElementById('battle-ui');
        snapshot.domElements.battleArena = !!document.getElementById('battle-arena');
        snapshot.domElements.turnDisplay = !!document.getElementById('turn-display');
        snapshot.domElements.logContent = !!document.getElementById('battle-log-content');
        
        // Check Tailwind CSS status
        snapshot.tailwindStatus.linkExists = !!document.getElementById('tailwind-css');
        snapshot.tailwindStatus.interFontExists = !!document.querySelector('link[href*="fonts.googleapis.com/css2?family=Inter"]');
        
        // Check for any CSS classes that are definitely from Tailwind
        const testElement = document.createElement('div');
        testElement.className = 'text-blue-500';
        document.body.appendChild(testElement);
        const computedStyle = window.getComputedStyle(testElement);
        snapshot.tailwindStatus.tailwindWorking = computedStyle.color !== 'rgb(0, 0, 0)'; // If not black, Tailwind might be working
        document.body.removeChild(testElement);
        
        // Create a log of all used colors
        snapshot.cssColors = {};
        document.querySelectorAll('.character-circle').forEach(el => {
            const style = window.getComputedStyle(el);
            const type = el.classList[1]?.replace('bg-', '') || 'unknown';
            snapshot.cssColors[type] = style.backgroundColor;
        });
        
        console.log('BattleUI Debug Snapshot:', snapshot);
        return snapshot;
    }
    
    /**
     * Fix common UI issues
     * @param {BattleUI} battleUI - The BattleUI instance to fix
     */
    static fixCommonIssues(battleUI) {
        console.log('BattleUIDebug: Attempting to fix common issues...');
        
        // Ensure Tailwind CSS is loaded directly
        if (!document.getElementById('tailwind-css')) {
            console.log('BattleUIDebug: Adding Tailwind CSS...');
            const tailwindScript = document.createElement('script');
            tailwindScript.id = 'tailwind-css';
            tailwindScript.src = 'https://cdn.tailwindcss.com';
            document.head.appendChild(tailwindScript);
            
            // Also add Inter font
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap';
            document.head.appendChild(fontLink);
        }
        
        // Force reinstall custom styles
        console.log('BattleUIDebug: Reinstalling custom styles...');
        const existingStyles = document.getElementById('battle-ui-styles');
        if (existingStyles) {
            document.head.removeChild(existingStyles);
        }
        battleUI.addCustomStyles();
        
        // Force update UI elements
        console.log('BattleUIDebug: Forcing UI update...');
        if (battleUI.isSetup && battleUI.playerTeam.length > 0) {
            battleUI.update();
            
            // Re-render characters
            battleUI.renderCharacters(battleUI.playerTeam, battleUI.enemyTeam);
            
            // Reset active character
            if (battleUI.playerTeam.length > 0) {
                battleUI.setActiveCharacter(battleUI.playerTeam[0]);
            }
        }
        
        console.log('BattleUIDebug: Fix attempts completed');
    }
    
    /**
     * Inject a simple fallback UI style if Tailwind CSS fails to load
     */
    static injectFallbackStyles() {
        console.log('BattleUIDebug: Injecting fallback styles...');
        
        const fallbackStyles = document.createElement('style');
        fallbackStyles.id = 'battle-ui-fallback-styles';
        fallbackStyles.textContent = `
            #battle-ui {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #141e2e;
                color: white;
                font-family: Arial, sans-serif;
                z-index: 9999;
                display: flex;
                flex-direction: column;
                padding: 20px;
            }
            
            header {
                background-color: #232a40;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            main {
                flex: 1;
                display: flex;
                gap: 20px;
                justify-content: center;
                align-items: flex-start;
                padding-top: 30px;
                background-color: #1a1a2e;
            }
            
            section {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 20px;
                width: 30%;
            }
            
            h2 {
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 10px;
            }
            
            footer {
                margin-top: 15px;
            }
            
            .character-circle {
                width: 64px;
                height: 64px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 10px;
                border: 2px solid rgba(255, 255, 255, 0.3);
            }
            
            .bg-fire { background-color: #ff4757; }
            .bg-water { background-color: #1e90ff; }
            .bg-nature { background-color: #2ed573; }
            .bg-dark { background-color: #9900cc; }
            .bg-light { background-color: #ffd700; }
            .bg-air { background-color: #70a1ff; }
            
            .hp-bar-container {
                width: 80px;
                margin: 0 auto;
            }
            
            .hp-bar-background {
                background-color: #4a5568;
                height: 8px;
                border-radius: 4px;
                overflow: hidden;
            }
            
            .hp-bar-current {
                background-color: #48bb78;
                height: 100%;
                border-radius: 4px 0 0 4px;
            }
            
            .battle-log {
                height: 150px;
                overflow-y: auto;
                background-color: #232a40;
                padding: 10px;
                border-radius: 8px;
            }
            
            .active-character .character-circle {
                box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6);
            }
            
            button {
                padding: 8px 15px;
                background-color: #3742fa;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                margin-right: 5px;
            }
            
            .control-button {
                background-color: #4a5568;
            }
            
            .control-button.active {
                background-color: #3742fa;
            }
            
            /* Simple floating text animation */
            .floating-text {
                position: absolute;
                top: -25px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 16px;
                font-weight: bold;
                white-space: nowrap;
                z-index: 10;
                animation: float-up-fade-out 1.2s forwards;
            }
            
            @keyframes float-up-fade-out {
                0% {
                    opacity: 0;
                    transform: translate(-50%, 0);
                }
                10% {
                    opacity: 1;
                }
                80% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                    transform: translate(-50%, -30px);
                }
            }
            
            /* Animation for when a character takes damage */
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-5px); }
            }
        `;
        
        document.head.appendChild(fallbackStyles);
        console.log('BattleUIDebug: Fallback styles injected');
    }
}

// Export for use in other modules
window.BattleUIDebug = BattleUIDebug;


===== FILE: SoundManager.js =====
/**
 * Sound Manager
 * Manages sound effects for the UI
 */

class SoundManager {
    /**
     * Create a new Sound Manager
     */
    constructor() {
        this.sounds = {};
        this.muted = false;
        this.volume = 0.5;
        this.audioContext = null;
        
        try {
            // Try to create audio context for generating sounds
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
            console.log('AudioContext initialized');
        } catch (e) {
            console.warn('Web Audio API not supported', e);
        }
        
        // Create DOM element for controlling sound
        this.createSoundControls();
        this.initialize();
    }

    /**
     * Initialize sound effects
     */
    initialize() {
        // Define sound effects - this will use the generated sounds
        // until actual sound files are available
        this.registerSound('click', 'assets/audio/click.mp3');
        this.registerSound('hover', 'assets/audio/hover.mp3');
        this.registerSound('select', 'assets/audio/select.mp3');
        this.registerSound('add', 'assets/audio/add.mp3');
        this.registerSound('remove', 'assets/audio/remove.mp3');
        this.registerSound('error', 'assets/audio/error.mp3');
        this.registerSound('battle_start', 'assets/audio/battle_start.mp3');
        
        console.log('Sound effects registered');
    }
    
    /**
     * Create sound control UI elements
     */
    createSoundControls() {
        // Create sound controls container
        const soundControls = document.createElement('div');
        soundControls.className = 'sound-controls';
        soundControls.style.position = 'fixed';
        soundControls.style.bottom = '20px';
        soundControls.style.right = '20px';
        soundControls.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        soundControls.style.padding = '10px';
        soundControls.style.borderRadius = '5px';
        soundControls.style.zIndex = '1000';
        
        // Create sound toggle button
        const soundToggle = document.createElement('button');
        soundToggle.textContent = 'ðŸ”Š';
        soundToggle.style.background = 'none';
        soundToggle.style.border = 'none';
        soundToggle.style.color = 'white';
        soundToggle.style.fontSize = '24px';
        soundToggle.style.cursor = 'pointer';
        soundToggle.title = 'Toggle Sound';
        
        // Add click event
        soundToggle.addEventListener('click', () => {
            this.toggleMute();
            soundToggle.textContent = this.muted ? 'ðŸ”‡' : 'ðŸ”Š';
        });
        
        // Add to container
        soundControls.appendChild(soundToggle);
        
        // Add volume slider
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.min = '0';
        volumeSlider.max = '100';
        volumeSlider.value = this.volume * 100;
        volumeSlider.style.width = '100px';
        volumeSlider.style.marginLeft = '10px';
        volumeSlider.title = 'Volume';
        
        // Add change event
        volumeSlider.addEventListener('input', (e) => {
            this.setVolume(e.target.value / 100);
        });
        
        // Add to container
        soundControls.appendChild(volumeSlider);
        
        // Add to document
        document.body.appendChild(soundControls);
    }

    /**
     * Register a sound with both file and generated fallback
     * @param {string} id - Sound identifier
     * @param {string} path - Path to sound file
     */
    registerSound(id, path) {
        this.sounds[id] = {
            path: path,
            loaded: false,
            audio: null
        };
        
        // Try to load the sound file
        this.loadSoundFile(id, path);
    }
    
    /**
     * Try to load an actual sound file
     * @param {string} id - Sound identifier
     * @param {string} path - Path to sound file
     */
    loadSoundFile(id, path) {
        // Create an audio element
        const audio = new Audio();
        
        // Set up event listeners
        audio.oncanplaythrough = () => {
            console.log(`Sound loaded: ${id}`);
            this.sounds[id].loaded = true;
            this.sounds[id].audio = audio;
        };
        
        audio.onerror = () => {
            console.log(`Could not load sound file: ${path}. Will use generated sound instead.`);
        };
        
        // Load the file
        try {
            audio.src = path;
            audio.load();
        } catch (e) {
            console.warn(`Error loading sound file ${path}:`, e);
        }
    }

    /**
     * Play a sound effect
     * @param {string} id - Sound identifier
     */
    play(id) {
        if (this.muted || !this.sounds[id]) return;
        
        try {
            // If the sound file is loaded, play it
            if (this.sounds[id].loaded && this.sounds[id].audio) {
                const soundInstance = this.sounds[id].audio.cloneNode();
                soundInstance.volume = this.volume;
                soundInstance.play();
            } else {
                // Otherwise, generate a sound
                this.generateSound(id);
            }
        } catch (e) {
            console.warn(`Error playing sound ${id}:`, e);
        }
    }
    
    /**
     * Generate a sound using Web Audio API
     * @param {string} id - Sound identifier
     */
    generateSound(id) {
        if (!this.audioContext) return;
        
        try {
            // Create oscillator
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            // Set volume
            gainNode.gain.value = this.volume * 0.3; // Lower volume for generated sounds
            
            // Configure sound based on type
            switch (id) {
                case 'click':
                    oscillator.type = 'square';
                    oscillator.frequency.value = 800;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                    break;
                    
                case 'hover':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 600;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.08);
                    break;
                    
                case 'select':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                    break;
                    
                case 'add':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'remove':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(300, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'error':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(180, this.audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'battle_start':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                    oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.3);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.7);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.7);
                    break;
                    
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            console.log(`Generated sound: ${id}`);
            
        } catch (e) {
            console.warn(`Error generating sound ${id}:`, e);
        }
    }

    /**
     * Set sound volume
     * @param {number} volume - Volume level (0-1)
     */
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        console.log(`Volume set to ${this.volume}`);
    }

    /**
     * Toggle mute state
     * @returns {boolean} - New mute state
     */
    toggleMute() {
        this.muted = !this.muted;
        console.log(`Sound ${this.muted ? 'muted' : 'unmuted'}`);
        return this.muted;
    }

    /**
     * Add hover sound to an element
     * @param {HTMLElement} element - Element to add sound to
     */
    addHoverSound(element) {
        // Hover sounds disabled - too distracting
        // Previously: element.addEventListener('mouseenter', () => this.play('hover'));
    }

    /**
     * Add click sound to an element
     * @param {HTMLElement} element - Element to add sound to
     */
    addClickSound(element) {
        element.addEventListener('click', () => {
            this.play('click');
        });
    }
    
    /**
     * Add sounds to common UI elements
     */
    addSoundsToUI() {
        // Add sounds to all buttons
        document.querySelectorAll('button').forEach(button => {
            this.addHoverSound(button);
            this.addClickSound(button);
        });
        
        // Add sounds to battle mode selectors
        document.querySelectorAll('.battle-mode').forEach(mode => {
            this.addHoverSound(mode);
            mode.addEventListener('click', () => {
                this.play('select');
            });
        });
        
        // Add sounds to hero cards
        document.querySelectorAll('.hero-card').forEach(card => {
            this.addHoverSound(card);
            card.addEventListener('click', () => {
                this.play('select');
            });
        });
        
        // Add sounds to team slots
        document.querySelectorAll('.slot-empty').forEach(slot => {
            this.addHoverSound(slot);
            slot.addEventListener('click', () => {
                this.play('add');
            });
        });
        
        // Add sounds to remove buttons
        document.querySelectorAll('.remove-hero').forEach(button => {
            this.addHoverSound(button);
            button.addEventListener('click', () => {
                this.play('remove');
            });
        });
        
        // Start battle button
        const startButton = document.getElementById('start-battle');
        if (startButton) {
            this.addHoverSound(startButton);
            startButton.addEventListener('click', () => {
                if (!startButton.disabled) {
                    this.play('battle_start');
                } else {
                    this.play('error');
                }
            });
        }
        
        console.log('Added sounds to UI elements');
    }
}

// Create a singleton instance
const soundManager = new SoundManager();

// Make it available globally
window.soundManager = soundManager;

// Add sound effects to UI elements once the page is fully loaded
window.addEventListener('load', () => {
    // Wait a moment for all UI elements to be created
    setTimeout(() => {
        window.soundManager.addSoundsToUI();
    }, 1000);
});


===== FILE: TeamBuilderUI.js =====
/**
 * Team Builder UI
 * Manages the user interface for team selection
 * Based on the React mockup concept
 */

class TeamBuilderUI {
    /**
     * Create a new Team Builder UI
     * @param {TeamManager} teamManager - Reference to the team manager
     */
    constructor(teamManager) {
        this.teamManager = teamManager || null;
        this.availableHeroes = [];
        this.selectedHeroes = [null, null, null];
        this.enemySelectedHeroes = [null, null, null];
        this.selectedHeroDetails = null;
        this.battleMode = 'random';
        this.activeFilters = {
            types: [],
            roles: []
        };
        this.isSelectingEnemyTeam = false; // Flag to track if we're selecting enemy team
        this.imageLoader = null; // Will hold the TeamBuilderImageLoader
        this.typeColors = {
            fire: '#ff4757',
            water: '#1e90ff',
            nature: '#2ed573',
            dark: '#9900cc',
            light: '#ffd700',
            air: '#70a1ff'
        };
        this.rarityColors = {
            Common: '#aaaaaa',
            Uncommon: '#2ed573',
            Rare: '#1e90ff',
            Epic: '#9900cc',
            Legendary: '#ffd700'
        };
    }

    /**
     * Initialize the team builder UI
     */
    async initialize() {
        console.log('TeamBuilderUI: Initializing...');
        // Fetch available heroes from data file
        try {
            // Try both relative and absolute paths
            let response;
            try {
                response = await fetch('data/characters.json');
            } catch (err) {
                console.log('Trying with alternate path...');
                response = await fetch('./data/characters.json');
            }
            const data = await response.json();
            this.availableHeroes = data.characters;
            console.log('TeamBuilderUI: Loaded', this.availableHeroes.length, 'heroes');
            
            // Initialize the image loader
            await this.initializeImageLoader();
            
            this.renderFilters();
            this.renderHeroGrid();
            this.renderTeamSlots();
            this.renderBattleModes();
            this.setupEventListeners();
        } catch (error) {
            console.error('Error loading characters data:', error);
            
            // Display error on the page for debugging
            const heroesGrid = document.getElementById('heroes-grid');
            if (heroesGrid) {
                heroesGrid.innerHTML = `<div style="color: red; padding: 20px;">Error loading heroes data: ${error.message}</div>`;
            }
        }
    }

    /**
     * Render filter options for types and roles
     */
    renderFilters() {
        const heroesSection = document.getElementById('available-heroes');
        
        // Check if filter section already exists
        let filterSection = document.getElementById('hero-filters');
        if (!filterSection) {
            filterSection = document.createElement('div');
            filterSection.id = 'hero-filters';
            
            // Insert filters before the heroes grid
            const heroesGrid = document.getElementById('heroes-grid');
            heroesSection.insertBefore(filterSection, heroesGrid);
        } else {
            filterSection.innerHTML = '';
        }

        // Create type filters
        const typeFilters = document.createElement('div');
        typeFilters.className = 'filter-group';
        
        const typeLabel = document.createElement('div');
        typeLabel.className = 'filter-label';
        typeLabel.textContent = 'Filter by Type:';
        typeFilters.appendChild(typeLabel);
        
        // Get unique types from heroes
        const types = [...new Set(this.availableHeroes.map(hero => hero.type))];
        
        const typeButtonsContainer = document.createElement('div');
        typeButtonsContainer.className = 'filter-buttons';
        
        types.forEach(type => {
            const typeButton = document.createElement('button');
            typeButton.className = `filter-button ${this.activeFilters.types.includes(type) ? 'active' : ''}`;
            typeButton.dataset.type = type;
            typeButton.style.backgroundColor = `${this.typeColors[type]}88`;
            typeButton.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            
            // Add event listener
            typeButton.addEventListener('click', () => {
                const index = this.activeFilters.types.indexOf(type);
                if (index === -1) {
                    // Add filter
                    this.activeFilters.types.push(type);
                    typeButton.classList.add('active');
                } else {
                    // Remove filter
                    this.activeFilters.types.splice(index, 1);
                    typeButton.classList.remove('active');
                }
                
                // Re-render heroes grid
                this.renderHeroGrid();
                
                // Play sound
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            });
            
            // Add hover sound
            if (window.soundManager) {
                window.soundManager.addHoverSound(typeButton);
            }
            
            typeButtonsContainer.appendChild(typeButton);
        });
        
        typeFilters.appendChild(typeButtonsContainer);
        filterSection.appendChild(typeFilters);
        
        // Create role filters
        const roleFilters = document.createElement('div');
        roleFilters.className = 'filter-group';
        
        const roleLabel = document.createElement('div');
        roleLabel.className = 'filter-label';
        roleLabel.textContent = 'Filter by Role:';
        roleFilters.appendChild(roleLabel);
        
        // Get unique roles from heroes
        const roles = [...new Set(this.availableHeroes.map(hero => hero.role))];
        
        const roleButtonsContainer = document.createElement('div');
        roleButtonsContainer.className = 'filter-buttons';
        
        roles.forEach(role => {
            const roleButton = document.createElement('button');
            roleButton.className = `filter-button ${this.activeFilters.roles.includes(role) ? 'active' : ''}`;
            roleButton.dataset.role = role;
            roleButton.textContent = role;
            
            // Add event listener
            roleButton.addEventListener('click', () => {
                const index = this.activeFilters.roles.indexOf(role);
                if (index === -1) {
                    // Add filter
                    this.activeFilters.roles.push(role);
                    roleButton.classList.add('active');
                } else {
                    // Remove filter
                    this.activeFilters.roles.splice(index, 1);
                    roleButton.classList.remove('active');
                }
                
                // Re-render heroes grid
                this.renderHeroGrid();
                
                // Play sound
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            });
            
            // Add hover sound
            if (window.soundManager) {
                window.soundManager.addHoverSound(roleButton);
            }
            
            roleButtonsContainer.appendChild(roleButton);
        });
        
        roleFilters.appendChild(roleButtonsContainer);
        filterSection.appendChild(roleFilters);
        
        // Add clear filters button
        const clearButton = document.createElement('button');
        clearButton.className = 'clear-filters-btn';
        clearButton.textContent = 'Clear Filters';
        clearButton.addEventListener('click', () => {
            this.activeFilters.types = [];
            this.activeFilters.roles = [];
            this.renderFilters();
            this.renderHeroGrid();
            
            // Play sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
        });
        
        // Add hover sound
        if (window.soundManager) {
            window.soundManager.addHoverSound(clearButton);
        }
        
        filterSection.appendChild(clearButton);
    }

    /**
     * Render the available heroes grid
     */
    renderHeroGrid() {
        const heroesGrid = document.getElementById('heroes-grid');
        heroesGrid.innerHTML = '';

        // Filter heroes based on active filters
        let filteredHeroes = [...this.availableHeroes];
        
        // Apply type filters
        if (this.activeFilters.types.length > 0) {
            filteredHeroes = filteredHeroes.filter(hero => 
                this.activeFilters.types.includes(hero.type)
            );
        }
        
        // Apply role filters
        if (this.activeFilters.roles.length > 0) {
            filteredHeroes = filteredHeroes.filter(hero => 
                this.activeFilters.roles.includes(hero.role)
            );
        }

        // Display message if no heroes match filters
        if (filteredHeroes.length === 0) {
            const noHeroes = document.createElement('div');
            noHeroes.className = 'no-heroes-message';
            noHeroes.textContent = 'No heroes match your filters';
            heroesGrid.appendChild(noHeroes);
            return;
        }

        filteredHeroes.forEach(hero => {
            const heroCard = document.createElement('div');
            heroCard.className = 'hero-card';
            heroCard.style.backgroundColor = `${this.typeColors[hero.type]}22`;
            heroCard.dataset.heroId = hero.id;

            if (this.selectedHeroDetails && this.selectedHeroDetails.id === hero.id) {
                heroCard.classList.add('selected');
            }

            const heroContent = document.createElement('div');
            heroContent.className = 'hero-card-content';

            // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
            const heroIconContainer = document.createElement('div');
            heroIconContainer.className = 'hero-avatar-container';
            heroIconContainer.dataset.characterId = hero.id;
            heroIconContainer.dataset.characterName = hero.name;
            heroIconContainer.dataset.artSynced = '0';
            // No background color set - will only be visible if character art exists
            
            // Create art wrapper for character images - this is all we need now
            const artWrapper = document.createElement('div');
            artWrapper.className = 'hero-art-wrapper';
            
            // Assemble the icon structure
            heroIconContainer.appendChild(artWrapper);

            const heroText = document.createElement('div');
            heroText.className = 'hero-card-text';

            const heroName = document.createElement('div');
            heroName.className = 'hero-name';
            heroName.textContent = hero.name;

            const heroType = document.createElement('div');
            heroType.className = 'hero-type';
            
            const typeText = document.createElement('span');
            typeText.style.color = this.typeColors[hero.type];
            typeText.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);
            
            const separator = document.createElement('span');
            separator.textContent = ' â€¢ ';
            
            const roleText = document.createElement('span');
            roleText.textContent = hero.role;

            heroType.appendChild(typeText);
            heroType.appendChild(separator);
            heroType.appendChild(roleText);

            heroText.appendChild(heroName);
            heroText.appendChild(heroType);

            heroContent.appendChild(heroIconContainer);
            heroContent.appendChild(heroText);

            heroCard.appendChild(heroContent);
            heroesGrid.appendChild(heroCard);

            // Add event listener
            heroCard.addEventListener('click', () => this.selectHeroDetails(hero));
        });
        
        // Force image loader to check for new images
        if (this.imageLoader) {
            this.imageLoader.forceCheck();
        }
    }

    /**
     * Render the team slots
     */
    renderTeamSlots() {
        const teamSlots = document.getElementById('team-slots');
        teamSlots.innerHTML = '';
        
        // Add team heading that shows which team we're building
        const teamHeading = document.createElement('div');
        teamHeading.className = 'team-heading team-heading-change';
        teamHeading.id = 'team-heading';
        teamHeading.textContent = this.isSelectingEnemyTeam ? 'Enemy Team' : 'Your Team';
        teamHeading.style.color = this.isSelectingEnemyTeam ? '#ff4757' : '#1e90ff';
        teamSlots.appendChild(teamHeading);
        
        // Add class to container if selecting enemy team
        if (this.isSelectingEnemyTeam) {
            teamSlots.classList.add('is-selecting-enemy');
        } else {
            teamSlots.classList.remove('is-selecting-enemy');
        }
        
        // Get the right array based on what we're selecting
        const currentTeam = this.isSelectingEnemyTeam ? this.enemySelectedHeroes : this.selectedHeroes;

        // Create 3 team slots
        for (let i = 0; i < 3; i++) {
            const slotElement = document.createElement('div');
            slotElement.className = 'team-slot';

            const slotLabel = document.createElement('div');
            slotLabel.className = 'slot-label';
            slotLabel.textContent = `${i + 1}${this.getOrdinalSuffix(i + 1)} Pick`;

            const slotContent = document.createElement('div');
            slotContent.className = 'slot-content';
            
            // Enemy team styling is handled by CSS via the is-selecting-enemy class

            if (currentTeam[i]) {
                // Slot is filled
                slotContent.classList.add('slot-filled');
                slotContent.style.backgroundColor = `${this.typeColors[currentTeam[i].type]}33`;

                const heroDetails = document.createElement('div');
                heroDetails.className = 'hero-details';
                
                // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
                const heroIconContainer = document.createElement('div');
                heroIconContainer.className = 'hero-avatar-container';
                heroIconContainer.dataset.characterId = currentTeam[i].id;
                heroIconContainer.dataset.characterName = currentTeam[i].name;
                heroIconContainer.dataset.artSynced = '0';
                // No background color set - will only be visible if character art exists
                
                // Create art wrapper for character images
                const artWrapper = document.createElement('div');
                artWrapper.className = 'hero-art-wrapper';
                
                // Assemble the icon structure
                heroIconContainer.appendChild(artWrapper);

                const heroInfo = document.createElement('div');
                heroInfo.className = 'hero-info';

                const heroName = document.createElement('div');
                heroName.className = 'hero-name';
                heroName.style.fontWeight = 'bold';
                heroName.textContent = currentTeam[i].name;

                const heroType = document.createElement('div');
                heroType.className = 'hero-type';
                heroType.style.fontSize = '12px';
                heroType.innerHTML = `<span style="color: ${this.typeColors[currentTeam[i].type]}">${currentTeam[i].type.charAt(0).toUpperCase() + currentTeam[i].type.slice(1)}</span> â€¢ ${currentTeam[i].role}`;

                // Basic stats
                const heroStats = document.createElement('div');
                heroStats.className = 'hero-stats';
                heroStats.style.fontSize = '12px';
                heroStats.style.color = '#a4b0be';
                heroStats.textContent = `HP: ${currentTeam[i].stats.hp} | ATK: ${currentTeam[i].stats.attack} | DEF: ${currentTeam[i].stats.defense}`;
                
                // Add advanced stats in condensed format
                const heroAdvStats = document.createElement('div');
                heroAdvStats.className = 'hero-adv-stats';
                heroAdvStats.style.fontSize = '11px';
                heroAdvStats.style.color = '#a4b0be';
                
                // Check if expanded stats exist before displaying them
                if (currentTeam[i].stats.strength && currentTeam[i].stats.intellect && currentTeam[i].stats.spirit) {
                    heroAdvStats.textContent = `STR: ${currentTeam[i].stats.strength} | INT: ${currentTeam[i].stats.intellect} | SPI: ${currentTeam[i].stats.spirit}`;
                    heroInfo.appendChild(heroAdvStats);
                }

                heroInfo.appendChild(heroName);
                heroInfo.appendChild(heroType);
                heroInfo.appendChild(heroStats);

                heroDetails.appendChild(heroIconContainer);
                heroDetails.appendChild(heroInfo);

                const removeButton = document.createElement('button');
                removeButton.className = 'remove-hero';
                removeButton.textContent = 'Ã—';
                removeButton.dataset.slotIndex = i;
                removeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeHeroFromTeam(i);
                });

                slotContent.appendChild(heroDetails);
                slotContent.appendChild(removeButton);
            } else {
                // Slot is empty
                slotContent.classList.add('slot-empty');

                const emptyText = document.createElement('span');
                if (this.selectedHeroDetails) {
                    emptyText.textContent = `Click to place ${this.selectedHeroDetails.name} here`;
                } else {
                    emptyText.textContent = 'Select a hero first';
                    emptyText.style.color = '#a4b0be';
                }

                slotContent.appendChild(emptyText);
                slotContent.dataset.slotIndex = i;
                slotContent.addEventListener('click', () => this.addHeroToTeam(i));
            }

            slotElement.appendChild(slotLabel);
            slotElement.appendChild(slotContent);
            teamSlots.appendChild(slotElement);
        }
        
        // If we're in enemy selection mode, add a Back button to return to player team
        if (this.isSelectingEnemyTeam) {
            const backButton = document.createElement('button');
            backButton.className = 'enemy-team-control-btn';
            backButton.textContent = 'Back to Your Team';
            backButton.addEventListener('click', () => {
                this.isSelectingEnemyTeam = false;
                this.renderTeamSlots();
                this.renderTeamSynergies();
                this.updateStartBattleButton();
            });
            teamSlots.appendChild(backButton);
        }

        // Update synergies - only show for player team
        if (!this.isSelectingEnemyTeam) {
            this.renderTeamSynergies();
        }
        
        // Update the start battle button
        this.updateStartBattleButton();
        
        // Force image loader to check for new images
        if (this.imageLoader) {
            this.imageLoader.forceCheck();
        }
    }

    /**
     * Render the team synergies
     */
    renderTeamSynergies() {
        const synergiesList = document.getElementById('synergies-list');
        synergiesList.innerHTML = '';

        const synergies = this.calculateSynergies();

        if (synergies.length > 0) {
            synergies.forEach(synergy => {
                const synergyItem = document.createElement('li');
                synergyItem.textContent = synergy;
                synergiesList.appendChild(synergyItem);
            });
        } else {
            const noSynergies = document.createElement('li');
            noSynergies.textContent = 'No active synergies yet';
            noSynergies.style.color = '#a4b0be';
            synergiesList.appendChild(noSynergies);
        }
    }

    /**
     * Render the hero details panel
     */
    renderHeroDetails() {
        const detailContent = document.getElementById('detail-content');
        
        // Keep track of previous hero name for intelligent comparison
        const previousHeroId = this.previousHeroId || null;
        this.previousHeroId = this.selectedHeroDetails ? this.selectedHeroDetails.id : null;
        
        // CRITICAL: Disable art observer during detail panel updates
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            // OPTIMIZATION: Instead of clearing all content, preserve the wrapper structure
            const existingDetail = detailContent.querySelector('.detail-hero');
            const existingWrapper = detailContent.querySelector('.hero-avatar-container.detail-icon-container');
            
            // Only clear content if either:
            // 1. No hero is selected (show empty state) OR
            // 2. No existing detail content exists
            if (!this.selectedHeroDetails) {
                // Just emptying content for "no hero selected" state
                detailContent.innerHTML = '';
                
                // No hero selected - show empty state and exit
                const detailEmpty = document.createElement('div');
                detailEmpty.className = 'detail-empty';
                detailEmpty.textContent = 'Select a hero to view details';
                detailContent.appendChild(detailEmpty);
                return;
            }
            
            // If details already exist with a wrapper, update the existing details
            // This preserves the image container for ALL heroes, not just Aqualia
            if (existingDetail && existingWrapper) {
                console.log(`Preserving art wrapper while updating details for ${this.selectedHeroDetails.name}`);
                this.updateExistingHeroDetails(existingDetail);
                return;
            }
        
        // Regular rendering for other heroes or first-time rendering
        const hero = this.selectedHeroDetails;
        const detailHero = document.createElement('div');
        detailHero.className = 'detail-hero';
        detailHero.style.backgroundColor = `${this.typeColors[hero.type]}22`;

        // Header section
        const detailHeader = document.createElement('div');
        detailHeader.className = 'detail-header';

        // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
        const detailIconContainer = document.createElement('div');
        detailIconContainer.className = 'hero-avatar-container detail-icon-container';
        detailIconContainer.dataset.characterId = hero.id;
        detailIconContainer.dataset.characterName = hero.name;
        // No background color set - will only be visible if character art exists
        
        // Create art wrapper for character images
        const artWrapper = document.createElement('div');
        artWrapper.className = 'hero-art-wrapper';
        
        // Assemble the icon structure
        detailIconContainer.appendChild(artWrapper);

        const detailNameType = document.createElement('div');
        detailNameType.className = 'detail-name-type';

        const heroName = document.createElement('h3');
        heroName.textContent = hero.name;

        const detailTags = document.createElement('div');
        detailTags.className = 'detail-tags';

        const typeTag = document.createElement('span');
        typeTag.className = 'detail-tag';
        typeTag.style.backgroundColor = this.typeColors[hero.type];
        typeTag.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);

        const roleTag = document.createElement('span');
        roleTag.className = 'detail-tag';
        roleTag.style.backgroundColor = '#2f3542';
        roleTag.textContent = hero.role;

        const rarityTag = document.createElement('span');
        rarityTag.className = 'detail-tag';
        rarityTag.style.backgroundColor = this.rarityColors[hero.rarity];
        rarityTag.textContent = hero.rarity;

        detailTags.appendChild(typeTag);
        detailTags.appendChild(roleTag);
        detailTags.appendChild(rarityTag);

        detailNameType.appendChild(heroName);
        detailNameType.appendChild(detailTags);

        detailHeader.appendChild(detailIconContainer);
        detailHeader.appendChild(detailNameType);

        // Stats section
        const detailStats = document.createElement('div');
        detailStats.className = 'detail-stats';

        // Add CSS to detail-stats to use flex-column
        detailStats.style.display = 'flex';
        detailStats.style.flexDirection = 'column';
        detailStats.style.gap = '8px';

        // First row of stats (existing)
        const statsRow1 = document.createElement('div');
        statsRow1.className = 'stats-row';
        statsRow1.style.display = 'flex';
        statsRow1.style.justifyContent = 'space-between';
        statsRow1.style.gap = '8px';

        const hpStat = this.createStatBox('HP', hero.stats.hp, 'Health Points - How much damage a character can take before being defeated');
        const atkStat = this.createStatBox('ATK', hero.stats.attack, 'Attack Power - Determines basic attack damage');
        const defStat = this.createStatBox('DEF', hero.stats.defense, 'Defense - Reduces damage taken from attacks');
        const spdStat = this.createStatBox('SPD', hero.stats.speed, 'Speed - Determines turn order in battle (higher goes first)');

        statsRow1.appendChild(hpStat);
        statsRow1.appendChild(atkStat);
        statsRow1.appendChild(defStat);
        statsRow1.appendChild(spdStat);

        // Only add second row if expanded stats exist
        if (hero.stats.strength && hero.stats.intellect && hero.stats.spirit) {
            // Second row of stats (new)
            const statsRow2 = document.createElement('div');
            statsRow2.className = 'stats-row';
            statsRow2.style.display = 'flex';
            statsRow2.style.justifyContent = 'space-between';
            statsRow2.style.gap = '8px';

            const strStat = this.createStatBox('STR', hero.stats.strength, 'Strength - Increases physical ability damage');
            const intStat = this.createStatBox('INT', hero.stats.intellect, 'Intellect - Increases spell ability damage');
            const spiStat = this.createStatBox('SPI', hero.stats.spirit, 'Spirit - Increases healing effectiveness');

            statsRow2.appendChild(strStat);
            statsRow2.appendChild(intStat);
            statsRow2.appendChild(spiStat);

            // Add both rows
            detailStats.appendChild(statsRow1);
            detailStats.appendChild(statsRow2);
        } else {
            // Just add the first row if no expanded stats
            detailStats.appendChild(statsRow1);
        }

        // Abilities section
        const detailAbilities = document.createElement('div');
        detailAbilities.className = 'detail-abilities';

        const abilitiesTitle = document.createElement('h4');
        abilitiesTitle.textContent = 'Abilities';

        detailAbilities.appendChild(abilitiesTitle);

        hero.abilities.forEach(ability => {
            const abilityBox = document.createElement('div');
            abilityBox.className = 'ability-box';

            const abilityName = document.createElement('div');
            abilityName.className = 'ability-name';
            abilityName.textContent = ability.name;

            const abilityDesc = document.createElement('div');
            abilityDesc.className = 'ability-desc';
            abilityDesc.textContent = ability.description;

            abilityBox.appendChild(abilityName);
            abilityBox.appendChild(abilityDesc);
            detailAbilities.appendChild(abilityBox);
            
            // Add tooltip with more detailed info
            if (window.tooltipManager) {
                const cooldownText = ability.cooldown > 0 ? `Cooldown: ${ability.cooldown} turns` : 'No cooldown';
                
                // Get detailed scaling information with formula
                const detailedScaling = this.getDetailedScalingText(ability, hero);
                
                const tooltipContent = `
                    <div class="tooltip-title">${ability.name}</div>
                    <div>${ability.description}</div>
                    <div class="tooltip-content">
                        ${detailedScaling.damageText}
                        <div>${cooldownText}</div>
                        <div>Type: ${ability.damageType || (ability.isHealing ? 'Healing' : 'Damage')}</div>
                        <div>${detailedScaling.scalingText}</div>
                    </div>
                `;
                
                window.tooltipManager.addTooltip(abilityBox, tooltipContent);
                abilityBox.classList.add('has-tooltip');
            }
        });

        // Advantages section
        const detailAdvantages = document.createElement('div');
        detailAdvantages.className = 'detail-advantages';

        const advantagesTitle = document.createElement('h4');
        advantagesTitle.textContent = 'Advantages';

        const advantagesList = document.createElement('div');
        advantagesList.className = 'advantage-list';
        
        let advantageHTML = '';
        let tooltipContent = `<div class="tooltip-title">Type Advantages</div><div class="tooltip-content">`;

        // Add type advantages based on hero type
        switch (hero.type) {
            case 'fire':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.nature}">Nature</span>`;
                tooltipContent += 'Fire does 50% more damage to Nature types.<br>Fire takes 50% more damage from Water types.';
                break;
            case 'water':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.fire}">Fire</span>`;
                tooltipContent += 'Water does 50% more damage to Fire types.<br>Water takes 50% more damage from Nature types.';
                break;
            case 'nature':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.water}">Water</span>`;
                tooltipContent += 'Nature does 50% more damage to Water types.<br>Nature takes 50% more damage from Fire types.';
                break;
            case 'light':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.dark}">Dark</span>`;
                tooltipContent += 'Light does 50% more damage to Dark types.<br>Light takes 50% more damage from Dark types.';
                break;
            case 'dark':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.light}">Light</span>`;
                tooltipContent += 'Dark does 50% more damage to Light types.<br>Dark takes 50% more damage from Light types.';
                break;
            case 'air':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.earth || '#8B4513'}">Earth</span>`;
                tooltipContent += 'Air does 50% more damage to Earth types.<br>Air takes 50% more damage from Electric types.';
                break;
        }
        
        tooltipContent += '</div>';
        advantagesList.innerHTML = advantageHTML;
        
        // Add tooltip to advantages section
        if (window.tooltipManager) {
            window.tooltipManager.addTooltip(advantagesList, tooltipContent);
            advantagesList.classList.add('has-tooltip');
        }

        detailAdvantages.appendChild(advantagesTitle);
        detailAdvantages.appendChild(advantagesList);

        // Add all sections to the detail content
        detailHero.appendChild(detailHeader);
        detailHero.appendChild(detailStats);
        detailHero.appendChild(detailAbilities);
        detailHero.appendChild(detailAdvantages);

        detailContent.appendChild(detailHero);
        
        // If this character has art, add it directly without relying on the observer
        if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[hero.name]) {
            this.addArtToDetailPanel(hero, detailIconContainer);
        }
        } finally {
            // Re-enable art observer after all detail panel updates are complete
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }
    
    /**
     * Get detailed scaling text with formula for ability tooltips
     * @param {Object} ability - The ability object
     * @param {Object} hero - The hero object for stat reference
     * @returns {Object} Object with damageText and scalingText
     */
    getDetailedScalingText(ability, hero) {
        let scalingText = '';
        let damageText = '';
        let statValue = 0;
        
        if (ability.isHealing || ability.damageType === 'healing') {
            // Healing ability scaling with Spirit
            statValue = hero.stats.spirit || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalHealing = ability.damage + scalingAmount;
            
            damageText = `<div>Healing: ${ability.damage} + (50% of Spirit) = ${totalHealing} HP</div>`;
            scalingText = `${ability.name} restores ${ability.damage} + (50% of Spirit) health`;
        } 
        else if (ability.damageType === 'physical') {
            // Physical ability scaling with Strength
            statValue = hero.stats.strength || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalDamage = ability.damage + scalingAmount;
            
            damageText = `<div>Damage: ${ability.damage} + (50% of Strength) = ${totalDamage} pre-defense</div>`;
            scalingText = `${ability.name} deals ${ability.damage} + (50% of Strength) damage`;
        } 
        else if (ability.damageType === 'spell') {
            // Spell ability scaling with Intellect
            statValue = hero.stats.intellect || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalDamage = ability.damage + scalingAmount;
            
            damageText = `<div>Damage: ${ability.damage} + (50% of Intellect) = ${totalDamage} pre-defense</div>`;
            scalingText = `${ability.name} deals ${ability.damage} + (50% of Intellect) damage`;
        }
        else if (ability.damageType === 'utility') {
            // Utility ability scaling with Spirit
            damageText = `<div>Effect scales with Spirit</div>`;
            scalingText = `${ability.name}'s effectiveness scales with Spirit`;
        }
        else {
            // Default case (no scaling)
            damageText = ability.isHealing ? 
                `<div>Healing: ${ability.damage} HP</div>` : 
                `<div>Damage: ${ability.damage} points</div>`;
            scalingText = "No scaling";
        }
        
        return { damageText, scalingText };
    }
    
    /**
     * Add character art directly to a detail panel without using the observer
     */
    addArtToDetailPanel(hero, detailIconContainer) {
        // Find art wrapper or create one
        let artWrapper = detailIconContainer.querySelector('.hero-art-wrapper');
        if (!artWrapper) {
            artWrapper = document.createElement('div');
            artWrapper.className = 'hero-art-wrapper';
            artWrapper.style.display = 'block';
            detailIconContainer.appendChild(artWrapper);
        }
        
        // Clear any existing art
        while (artWrapper.firstChild) {
            artWrapper.removeChild(artWrapper.firstChild);
        }
        
        // Clone image from cache
        const newImg = window.CHARACTER_IMAGE_CACHE[hero.name].cloneNode(true);
        
        // Set styling for detail view
        newImg.className = 'character-art team-builder-art';
        newImg.alt = hero.name;
        newImg.style.position = 'absolute';
        
        // Get character positioning data
        const character = this.availableHeroes.find(c => c.id == hero.id);
        const artSettings = character?.detailArt || character?.teamBuilderArt || character?.art || {};
        
        // Apply custom positioning for this character
        newImg.style.left = artSettings.left || '-30px';
        newImg.style.top = artSettings.top || '-45px';
        newImg.style.width = artSettings.width || '140px';
        newImg.style.height = artSettings.height || '140px';
        newImg.style.visibility = 'visible';
        newImg.style.display = 'block';
        newImg.style.zIndex = '100';
        
        // Add the image to the wrapper
        artWrapper.appendChild(newImg);
        
        // Add relevant classes
        detailIconContainer.classList.add('has-art');
        const detailHero = detailIconContainer.closest('.detail-hero');
        if (detailHero) detailHero.classList.add('has-art');
    }
    
    /**
     * Update an existing hero details panel without rebuilding the entire DOM structure
     * This applies to all heroes to preserve character art in the details panel
     */
    updateExistingHeroDetails(detailHero) {
        const hero = this.selectedHeroDetails;
        
        // Disable observer while updating
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            // Important: Update the data attributes on the wrapper to match the new hero
            const detailIconContainer = detailHero.querySelector('.hero-avatar-container.detail-icon-container');
            if (detailIconContainer) {
                // Update the container to reflect the new character
                detailIconContainer.dataset.characterId = hero.id;
                detailIconContainer.dataset.characterName = hero.name;
                
                // Add art directly if available, bypassing observer
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[hero.name]) {
                    this.addArtToDetailPanel(hero, detailIconContainer);
                }
            }
            
            // Update background color for the detail hero container
            if (detailHero) {
                detailHero.style.backgroundColor = `${this.typeColors[hero.type]}22`;
            }
        
            // Update the hero name and tags
            const heroNameEl = detailHero.querySelector('.detail-name-type h3');
            if (heroNameEl) heroNameEl.textContent = hero.name;
            
            // Update the type, role, and rarity tags
            const typeTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(1)');
            if (typeTag) {
                typeTag.style.backgroundColor = this.typeColors[hero.type];
                typeTag.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);
            }
            
            const roleTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(2)');
            if (roleTag) roleTag.textContent = hero.role;
            
            const rarityTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(3)');
            if (rarityTag) {
                rarityTag.style.backgroundColor = this.rarityColors[hero.rarity];
                rarityTag.textContent = hero.rarity;
            }
            
            // Get or create stats container
            const detailStats = detailHero.querySelector('.detail-stats');
            if (detailStats) {
                // Clear existing stat rows
                detailStats.innerHTML = '';

                // First row of stats (existing)
                const statsRow1 = document.createElement('div');
                statsRow1.className = 'stats-row';
                statsRow1.style.display = 'flex';
                statsRow1.style.justifyContent = 'space-between';
                statsRow1.style.gap = '8px';

                const hpStat = this.createStatBox('HP', hero.stats.hp, 'Health Points - How much damage a character can take before being defeated');
                const atkStat = this.createStatBox('ATK', hero.stats.attack, 'Attack Power - Determines basic attack damage');
                const defStat = this.createStatBox('DEF', hero.stats.defense, 'Defense - Reduces damage taken from attacks');
                const spdStat = this.createStatBox('SPD', hero.stats.speed, 'Speed - Determines turn order in battle (higher goes first)');
                
                statsRow1.appendChild(hpStat);
                statsRow1.appendChild(atkStat);
                statsRow1.appendChild(defStat);
                statsRow1.appendChild(spdStat);
                
                // Only add second row if expanded stats exist
                if (hero.stats.strength && hero.stats.intellect && hero.stats.spirit) {
                    // Second row of stats (new)
                    const statsRow2 = document.createElement('div');
                    statsRow2.className = 'stats-row';
                    statsRow2.style.display = 'flex';
                    statsRow2.style.justifyContent = 'space-between';
                    statsRow2.style.gap = '8px';

                    const strStat = this.createStatBox('STR', hero.stats.strength, 'Strength - Increases physical ability damage');
                    const intStat = this.createStatBox('INT', hero.stats.intellect, 'Intellect - Increases spell ability damage');
                    const spiStat = this.createStatBox('SPI', hero.stats.spirit, 'Spirit - Increases healing effectiveness');

                    statsRow2.appendChild(strStat);
                    statsRow2.appendChild(intStat);
                    statsRow2.appendChild(spiStat);

                    // Add rows to stats container
                    detailStats.appendChild(statsRow1);
                    detailStats.appendChild(statsRow2);
                } else {
                    // Just add the first row if no expanded stats
                    detailStats.appendChild(statsRow1);
                }
            }
            
            // Update abilities (a bit more complex - might need to rebuild this section)
            const abilitiesContainer = detailHero.querySelector('.detail-abilities');
            if (abilitiesContainer) {
                // Keep the title but replace all ability boxes
                const abilitiesTitle = abilitiesContainer.querySelector('h4');
                abilitiesContainer.innerHTML = '';
                abilitiesContainer.appendChild(abilitiesTitle);
                
                // Re-add all abilities
                hero.abilities.forEach(ability => {
                    const abilityBox = document.createElement('div');
                    abilityBox.className = 'ability-box';

                    const abilityName = document.createElement('div');
                    abilityName.className = 'ability-name';
                    abilityName.textContent = ability.name;

                    const abilityDesc = document.createElement('div');
                    abilityDesc.className = 'ability-desc';
                    abilityDesc.textContent = ability.description;

                    abilityBox.appendChild(abilityName);
                    abilityBox.appendChild(abilityDesc);
                    abilitiesContainer.appendChild(abilityBox);
                    
                    // Re-add tooltips
                    if (window.tooltipManager) {
                        const cooldownText = ability.cooldown > 0 ? `Cooldown: ${ability.cooldown} turns` : 'No cooldown';
                        
                        // Get detailed scaling information with formula
                        const detailedScaling = this.getDetailedScalingText(ability, hero);
                        
                        const tooltipContent = `
                            <div class="tooltip-title">${ability.name}</div>
                            <div>${ability.description}</div>
                            <div class="tooltip-content">
                                ${detailedScaling.damageText}
                                <div>${cooldownText}</div>
                                <div>Type: ${ability.damageType || (ability.isHealing ? 'Healing' : 'Damage')}</div>
                                <div>${detailedScaling.scalingText}</div>
                            </div>
                        `;
                        
                        window.tooltipManager.addTooltip(abilityBox, tooltipContent);
                        abilityBox.classList.add('has-tooltip');
                    }
                });
            }
            
            // Update advantages section
            const advantagesList = detailHero.querySelector('.advantage-list');
            if (advantagesList) {
                let advantageHTML = '';
                let tooltipContent = `<div class="tooltip-title">Type Advantages</div><div class="tooltip-content">`;

                // Update type advantages based on hero type
                switch (hero.type) {
                    case 'fire':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.nature}">Nature</span>`;
                        tooltipContent += 'Fire does 50% more damage to Nature types.<br>Fire takes 50% more damage from Water types.';
                        break;
                    case 'water':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.fire}">Fire</span>`;
                        tooltipContent += 'Water does 50% more damage to Fire types.<br>Water takes 50% more damage from Nature types.';
                        break;
                    case 'nature':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.water}">Water</span>`;
                        tooltipContent += 'Nature does 50% more damage to Water types.<br>Nature takes 50% more damage from Fire types.';
                        break;
                    case 'light':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.dark}">Dark</span>`;
                        tooltipContent += 'Light does 50% more damage to Dark types.<br>Light takes 50% more damage from Dark types.';
                        break;
                    case 'dark':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.light}">Light</span>`;
                        tooltipContent += 'Dark does 50% more damage to Light types.<br>Dark takes 50% more damage from Light types.';
                        break;
                    case 'air':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.earth || '#8B4513'}">Earth</span>`;
                        tooltipContent += 'Air does 50% more damage to Earth types.<br>Air takes 50% more damage from Electric types.';
                        break;
                }
                
                tooltipContent += '</div>';
                advantagesList.innerHTML = advantageHTML;
                
                // Update tooltip for advantages section
                if (window.tooltipManager) {
                    window.tooltipManager.addTooltip(advantagesList, tooltipContent);
                    if (!advantagesList.classList.contains('has-tooltip')) {
                        advantagesList.classList.add('has-tooltip');
                    }
                }
            }
        
        } finally {
            // Re-enable the observer when done
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }

    /**
     * Render battle mode options
     */
    renderBattleModes() {
        const battleModes = document.getElementById('battle-modes');
        battleModes.innerHTML = '';

        const modes = [
            {
                id: 'random',
                name: 'Random Opponent',
                description: 'Battle against a randomly generated team'
            },
            {
                id: 'custom',
                name: 'Custom Battle',
                description: 'Choose your opponent\'s team composition'
            },
            {
                id: 'campaign',
                name: 'Campaign Mode',
                description: 'Fight through increasingly difficult encounters'
            }
        ];

        modes.forEach(mode => {
            const modeElement = document.createElement('div');
            
            // Add special class for custom mode when selecting enemy team
            let selectedClass = mode.id === this.battleMode ? 'selected' : '';
            if (mode.id === 'custom' && this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                selectedClass = 'selected enemy-selection-active';
            }
            
            modeElement.className = `battle-mode ${selectedClass}`;
            modeElement.dataset.modeId = mode.id;

            const modeName = document.createElement('div');
            modeName.className = 'battle-mode-name';
            modeName.textContent = mode.name;
            
            // Add indicator for enemy team selection
            if (mode.id === 'custom' && this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                modeName.innerHTML = `${mode.name} <span style="color: #ff4757; font-size: 12px;">(Selecting Enemy)</span>`;
            }

            const modeDesc = document.createElement('div');
            modeDesc.className = 'battle-mode-desc';
            modeDesc.textContent = mode.description;

            modeElement.appendChild(modeName);
            modeElement.appendChild(modeDesc);
            battleModes.appendChild(modeElement);

            // Add event listener
            modeElement.addEventListener('click', () => {
                // Only allow changing battle mode if not in enemy selection mode
                if (!this.isSelectingEnemyTeam || mode.id === this.battleMode) {
                    this.battleMode = mode.id;
                    this.renderBattleModes();
                    
                    // Reset enemy selection when changing modes
                    if (this.isSelectingEnemyTeam && mode.id !== 'custom') {
                        this.isSelectingEnemyTeam = false;
                        this.renderTeamSlots();
                    }
                } else {
                    // If in enemy selection, show a message that they should complete or cancel enemy selection first
                    if (window.soundManager) {
                        window.soundManager.play('error');
                    }
                    alert('Please complete enemy team selection or click "Back to Your Team" before changing battle mode');
                }
            });
        });
    }

    /**
     * Update the start battle button state
     */
    updateStartBattleButton() {
        const startButton = document.getElementById('start-battle');
        const hasTeamMembers = this.selectedHeroes.some(hero => hero !== null);
        
        // For Custom Battle mode, we need to check if we're ready to select enemy team
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // If we have team members but haven't begun enemy team selection
            if (hasTeamMembers) {
                startButton.textContent = 'Choose Enemy Team';
                startButton.disabled = false;
            } else {
                startButton.textContent = 'Start Battle';
                startButton.disabled = true;
            }
        } else {
            // For Random and Campaign modes, or if we're already selecting enemy team
            startButton.textContent = 'Start Battle';
            
            if (this.isSelectingEnemyTeam) {
                // When selecting enemy team, we need at least one enemy
                startButton.disabled = !this.enemySelectedHeroes.some(hero => hero !== null);
            } else {
                // For Random or Campaign, just check player team
                startButton.disabled = !hasTeamMembers;
            }
        }
    }

    /**
     * Helper function to create a stat box
     * @param {string} label - Stat label
     * @param {number} value - Stat value
     * @param {string} tooltip - Tooltip text
     * @returns {HTMLElement} The stat box element
     */
    createStatBox(label, value, tooltip) {
        const statBox = document.createElement('div');
        statBox.className = 'stat-box';
        statBox.style.flex = '1';
        statBox.style.padding = '5px';
        statBox.style.backgroundColor = '#1e272e';
        statBox.style.borderRadius = '5px';
        statBox.style.textAlign = 'center';

        const statLabel = document.createElement('div');
        statLabel.className = 'stat-label';
        statLabel.textContent = label;

        const statValue = document.createElement('div');
        statValue.className = 'stat-value';
        statValue.textContent = value;

        statBox.appendChild(statLabel);
        statBox.appendChild(statValue);

        // Add tooltip if provided
        if (tooltip && window.tooltipManager) {
            window.tooltipManager.addTooltip(statBox, tooltip);
            statBox.classList.add('has-tooltip');
        }

        return statBox;
    }

    /**
     * Calculate team synergies
     * @returns {string[]} An array of synergy descriptions
     */
    calculateSynergies() {
        const heroes = this.selectedHeroes.filter(hero => hero !== null);
        if (heroes.length < 2) return [];

        const types = heroes.map(hero => hero.type);
        const roles = heroes.map(hero => hero.role);
        
        const typeCounts = {};
        types.forEach(type => {
            typeCounts[type] = (typeCounts[type] || 0) + 1;
        });
        
        const roleCounts = {};
        roles.forEach(role => {
            roleCounts[role] = (roleCounts[role] || 0) + 1;
        });
        
        const synergies = [];
        
        // Check for type synergies
        Object.entries(typeCounts).forEach(([type, count]) => {
            if (count >= 2) {
                synergies.push(`${type.charAt(0).toUpperCase() + type.slice(1)} Alliance (${count}): +${count * 10}% ${type} damage`);
            }
        });
        
        // Check for role synergies
        if (roleCounts['Warrior'] >= 2) synergies.push('Warrior (2): +20% defense');
        if (roleCounts['Mage'] >= 2) synergies.push('Mage (2): +20% ability power');
        if (roleCounts['Ranger'] >= 2) synergies.push('Ranger (2): +15% attack speed');
        if (roleCounts['Knight'] >= 2) synergies.push('Knight (2): +25% max health');
        if (roleCounts['Assassin'] >= 2) synergies.push('Assassin (2): +30% critical hit chance');
        if (roleCounts['Cleric'] >= 2) synergies.push('Cleric (2): +40% healing effectiveness');
        
        return synergies;
    }

    /**
     * Select a hero to view details
     * @param {Object} hero - The hero to select
     */
    selectHeroDetails(hero) {
        // Disable observer during hero selection to prevent excessive log messages
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            this.selectedHeroDetails = hero;
            this.renderHeroGrid();
            this.renderHeroDetails();
            this.renderTeamSlots();
            
            // Play select sound
            if (window.soundManager) {
                window.soundManager.play('select');
            }
        } finally {
            // Re-enable observer when done
            // Note: this is redundant with the one in renderHeroDetails, but ensures
            // it happens even if renderHeroDetails fails
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }

    /**
     * Add the selected hero to a team slot
     * @param {number} position - The slot position (0-2)
     */
    addHeroToTeam(position) {
        if (!this.selectedHeroDetails) return;
        
        // Determine which team we're modifying
        const targetTeam = this.isSelectingEnemyTeam ? this.enemySelectedHeroes : this.selectedHeroes;

        // Check if hero is already in team
        const existingIndex = targetTeam.findIndex(h => h && h.id === this.selectedHeroDetails.id);
        if (existingIndex !== -1) {
            targetTeam[existingIndex] = null;
        }

        // Update the correct team
        if (this.isSelectingEnemyTeam) {
            this.enemySelectedHeroes[position] = this.selectedHeroDetails;
        } else {
            this.selectedHeroes[position] = this.selectedHeroDetails;
        }
        
        this.renderTeamSlots();
        
        // Play add sound
        if (window.soundManager) {
            window.soundManager.play('add');
        }
    }

    /**
     * Remove a hero from a team slot
     * @param {number} position - The slot position (0-2)
     */
    removeHeroFromTeam(position) {
        // Remove from the appropriate team
        if (this.isSelectingEnemyTeam) {
            this.enemySelectedHeroes[position] = null;
        } else {
            this.selectedHeroes[position] = null;
        }
        
        this.renderTeamSlots();
        
        // Play remove sound
        if (window.soundManager) {
            window.soundManager.play('remove');
        }
    }

    /**
     * Initialize event listeners for the start battle button
     */
    setupEventListeners() {
        const startButton = document.getElementById('start-battle');
        startButton.addEventListener('click', () => {
            if (!startButton.disabled) {
                this.startBattle();
            }
        });
    }
    
    /**
     * Initialize the character art image loader
     */
    async initializeImageLoader() {
        try {
            // Check if window.TeamBuilderImageLoader is available (using window explicitly)
            if (typeof window.TeamBuilderImageLoader === 'undefined') {
                console.warn('TeamBuilderImageLoader not found, skipping image loading');
                return;
            }
            
            // Create the image loader
            this.imageLoader = new window.TeamBuilderImageLoader();
            
            // Initialize it
            await this.imageLoader.initialize();
            
            console.log('TeamBuilderUI: Image loader initialized');
        } catch (error) {
            console.error('Error initializing image loader:', error);
        }
    }

    /**
     * Start a battle with the selected team
     */
    startBattle() {
        // For Custom Battle mode, we need to switch to enemy team selection if not done yet
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // Filter out empty slots
            const team = this.selectedHeroes.filter(hero => hero !== null);
            
            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }
            
            // Switch to enemy team selection mode
            this.isSelectingEnemyTeam = true;
            this.renderTeamSlots();
            this.updateStartBattleButton();
            
            // Play selection sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
            
            return; // Exit without starting battle
        }
        
        // Filter out empty slots
        const team = this.selectedHeroes.filter(hero => hero !== null);
        
        if (team.length === 0) {
            alert('Please select at least one hero for your team!');
            // Play error sound
            if (window.soundManager) {
                window.soundManager.play('error');
            }
            return;
        }
        
        // Play battle start sound
        if (window.soundManager) {
            window.soundManager.play('battle_start');
        }

        console.log('Starting battle with team:', team);
        console.log('Battle mode:', this.battleMode);

        // Remove any existing battle UI elements
        const existingBattleUI = document.getElementById('battle-ui');
        if (existingBattleUI) {
            document.body.removeChild(existingBattleUI);
        }
        
        // Switch to battle scene
        document.getElementById('team-builder-container').classList.remove('active');
        
        // Clear the game container and make it active
        const gameContainer = document.getElementById('game-container');
        gameContainer.innerHTML = ''; // Clear any previous content
        gameContainer.classList.add('active');

        // Initialize the battle manager and start the battle
        if (this.teamManager) {
            this.teamManager.setPlayerTeam(team);
            
            // For Custom battle, use the selected enemy team
            if (this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                const enemyTeam = this.enemySelectedHeroes.filter(hero => hero !== null);
                if (enemyTeam.length > 0) {
                    this.teamManager.setCustomEnemyTeam(enemyTeam);
                } else {
                    // Fallback if somehow no enemies were selected
                    this.teamManager.generateEnemyTeam('random');
                }
            } else {
                // For other modes, generate enemy team as usual
                this.teamManager.generateEnemyTeam(this.battleMode);
            }
            
            // Start the battle with our teams
            if (window.battleManager) {
                // We need to ensure BattleUI is available before starting the battle
                if (typeof window.BattleUI === 'undefined') {
                    console.error('BattleUI class not found, attempting to load it');
                    
                    // Dynamically load the BattleUI script
                    const loadBattleUI = new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'js/ui/BattleUI.js';
                        script.onload = () => {
                            console.log('BattleUI script loaded successfully');
                            resolve();
                        };
                        script.onerror = () => {
                            console.error('Failed to load BattleUI script');
                            reject(new Error('Failed to load BattleUI script'));
                        };
                        document.head.appendChild(script);
                    });
                    
                    // Try to load the script before continuing
                    loadBattleUI.then(() => {
                        this.startBattleWithDelay();
                    }).catch(error => {
                        console.error('Error loading BattleUI:', error);
                        alert('Failed to load battle system. Please refresh and try again.');
                    });
                    
                    return; // Exit and wait for script to load
                }
                
                // BattleUI is available, proceed with starting the battle
                this.startBattleWithDelay();
            }
        }
    }

    /**
     * Get ordinal suffix for a number
     * @param {number} n - The number
     * @returns {string} The ordinal suffix (st, nd, rd, th)
     */
    getOrdinalSuffix(n) {
        const s = ['th', 'st', 'nd', 'rd'];
        const v = n % 100;
        return (s[(v - 20) % 10] || s[v] || s[0]);
    }
    
    /**
     * Start the battle with a delay to ensure scripts are loaded
     */
    startBattleWithDelay() {
        // Make sure the battleManager is initialized with BattleUI
        setTimeout(() => {
            try {
                // Initialize BattleUI first if needed
                if (!window.battleManager.battleUI) {
                    window.battleManager.initialize();
                }
                
                // Then start the battle
                window.battleManager.startBattle(
                    this.teamManager.playerTeam,
                    this.teamManager.enemyTeam
                );
            } catch (error) {
                console.error('Error starting battle:', error);
                alert('Error starting battle. See console for details.');
            }
        }, 500); // Increased delay to ensure script loading
    }
}


===== FILE: TeamBuilderUIUpdates.js =====
/**
 * TeamBuilderUIUpdates.js
 * Updates to the TeamBuilderUI class to support Phaser Battle Scene transition
 *
 * @version 0.5.0.3 (with added diagnostics)
 */

// Wait for DOM content to be loaded
document.addEventListener('DOMContentLoaded', function() {
    // Check if TeamBuilderUI exists
    if (typeof TeamBuilderUI !== 'function') {
        console.error('TeamBuilderUIUpdates: TeamBuilderUI class not found!');
        return;
    }

    /**
     * Start a battle with Phaser instead of DOM-based battle UI
     * @param {Array} team - The player's team
     * @param {string} battleMode - The battle mode (random, custom, campaign)
     */
    TeamBuilderUI.prototype.startBattleWithPhaser = async function(team, battleMode) {

        // --- BEGIN DIAGNOSTIC LOGS ---
        console.log(`[DEBUG] startBattleWithPhaser called at ${new Date().toLocaleTimeString()}`);
        console.log(`[DEBUG] window.game exists? `, !!window.game);
        if (window.game) {
            console.log(`[DEBUG] window.game.isRunning? `, window.game.isRunning); // Check if Phaser game loop is running
            console.log(`[DEBUG] window.game.scene exists? `, !!window.game.scene); // Check if scene manager exists
            if (window.game.scene) {
                 // Use Object.keys on the keys object provided by Phaser's scene manager
                 console.log(`[DEBUG] Scene keys known to Phaser: `, Object.keys(window.game.scene.keys));
                 // Check if the key 'BattleScene' exists within the keys object
                 console.log(`[DEBUG] BattleScene registered? `, window.game.scene.keys.hasOwnProperty('BattleScene'));
                 // Attempt to retrieve the scene instance; will be null if not added or inactive
                 console.log(`[DEBUG] Attempting to get BattleScene instance: `, window.game.scene.getScene('BattleScene'));
            } else {
                console.error("[DEBUG] window.game.scene is NOT defined!");
            }
        } else {
             console.error("[DEBUG] window.game is NOT defined when startBattleWithPhaser is called!");
        }
        // Log the data *before* preparing it, ensuring window.battleManager is checked
        console.log(`[DEBUG] Battle data prerequisites:`, { team, battleMode, battleManager: window.battleManager });
        // --- END DIAGNOSTIC LOGS ---


        try {
            // If no team is provided, use the selected heroes
            if (!team) {
                team = this.selectedHeroes.filter(hero => hero !== null);
            }

            // If no battle mode is provided, use the current mode
            if (!battleMode) {
                battleMode = this.battleMode;
            }

            console.log('Starting Phaser battle with team:', team);
            console.log('Battle mode:', battleMode);

            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }

            // Play battle start sound
            if (window.soundManager) {
                window.soundManager.play('battle_start');
            }

            // Initialize the team manager
            if (this.teamManager) {
                this.teamManager.setPlayerTeam(team);

                // For Custom battle, use the selected enemy team
                let teamGenerationPromise;
                if (battleMode === 'custom' && this.isSelectingEnemyTeam) {
                    const enemyTeam = this.enemySelectedHeroes.filter(hero => hero !== null);
                    if (enemyTeam.length > 0) {
                        this.teamManager.setCustomEnemyTeam(enemyTeam);
                        teamGenerationPromise = Promise.resolve(); // No async work needed
                    } else {
                        // Fallback if somehow no enemies were selected
                        teamGenerationPromise = this.teamManager.generateEnemyTeam('random');
                    }
                } else {
                    // For other modes, generate enemy team as usual
                    teamGenerationPromise = this.teamManager.generateEnemyTeam(battleMode);
                }
                
                // Wait for team generation to complete before proceeding
                console.log('Waiting for enemy team generation to complete...');
                try {
                    await teamGenerationPromise;
                    console.log('Enemy team generation complete, proceeding with battle');
                } catch (error) {
                    console.error('Error during enemy team generation:', error);
                    alert('Error generating enemy team. Please try again.');
                    return;
                }

                // Check if Phaser is properly initialized using the utility function
                if (!window.isPhaserReady || !window.isPhaserReady()) {
                    console.error('Phaser game or scene manager not ready, falling back to original battle UI');
                    // Fallback to old battle UI, but only if not already in a fallback loop
                    if (!this._fallingBack) {
                        this._fallingBack = true;
                        this.startBattleWithOriginalUI(team, battleMode);
                        setTimeout(() => { this._fallingBack = false; }, 500); // Reset fallback flag after a delay
                    }
                    return;
                }

                // Hide the team builder UI
                const teamBuilderContainer = document.getElementById('team-builder-container');
                if (teamBuilderContainer) {
                    teamBuilderContainer.style.display = 'none';
                }

                // Show Phaser container
                const gameContainer = document.getElementById('game-container');
                if (gameContainer) {
                    gameContainer.style.display = 'block';
                }

                // Get Phaser canvas and ensure it's visible
                const canvas = document.querySelector('#game-container canvas'); // More specific selector
                if (canvas) {
                    canvas.style.display = 'block';
                } else {
                    console.warn("Phaser canvas element not found inside #game-container.");
                }

                // --- Ensure BattleScene is Added Before Starting ---
                if (!window.game.scene.getScene('BattleScene')) {
                     if (window.BattleScene) {
                         try {
                             window.game.scene.add('BattleScene', window.BattleScene);
                             console.log('[startBattleWithPhaser] BattleScene added dynamically.');
                         } catch (sceneAddError) {
                              console.error("Error dynamically adding BattleScene:", sceneAddError);
                              alert("Failed to prepare BattleScene. Cannot start battle.");
                              // Attempt to revert UI state
                              if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                              if (gameContainer) gameContainer.style.display = 'none';
                              return;
                         }
                     } else {
                         console.error("BattleScene class not available when trying to start battle!");
                         alert("BattleScene is not loaded. Cannot start battle.");
                          // Attempt to revert UI state
                         if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                         if (gameContainer) gameContainer.style.display = 'none';
                         return;
                     }
                 }
                 // --- End Scene Add Check ---


                try {
                    // Prepare battle data for the scene
                    const battleData = {
                        playerTeam: this.teamManager.playerTeam,
                        enemyTeam: this.teamManager.enemyTeam,
                        battleMode: battleMode,
                        battleManager: window.battleManager // Ensure this uses the correct global instance
                    };

                    // Check battleManager just before starting scene
                    if(!battleData.battleManager) {
                        console.error("CRITICAL: battleManager is undefined just before starting BattleScene!");
                        alert("Battle logic manager is missing. Cannot start battle.");
                         // Attempt to revert UI state
                         if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                         if (gameContainer) gameContainer.style.display = 'none';
                        return;
                    }

                    // Implement polling mechanism to wait for scene to be fully registered
                    const checkSceneReadyAndStart = (sceneKey, data, maxAttempts = 20, attempt = 1) => {
                        const sceneInstance = window.game.scene.getScene(sceneKey);
                        // Also check if the key is known, as getScene might return null even if added but not fully ready
                        const sceneKeyExists = window.game.scene.keys.hasOwnProperty(sceneKey); 

                        if (sceneInstance && sceneKeyExists) {
                            console.log(`[DEBUG] BattleScene is ready on attempt ${attempt}. Starting scene...`);
                            try {
                                window.game.scene.start(sceneKey, data);
                                console.log('Phaser BattleScene started successfully via check.');
                            } catch (startError) {
                                console.error(`[DEBUG] Error during scene.start('${sceneKey}'):`, startError);
                                alert(`Failed to start BattleScene even after it seemed ready. Error: ${startError.message}`);
                                // Revert UI state
                                if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                                if (gameContainer) gameContainer.style.display = 'none';
                            }
                        } else if (attempt < maxAttempts) {
                            console.log(`[DEBUG] BattleScene not ready yet (Attempt ${attempt}/${maxAttempts}). Waiting 100ms...`);
                            setTimeout(() => checkSceneReadyAndStart(sceneKey, data, maxAttempts, attempt + 1), 100);
                        } else {
                            console.error(`[DEBUG] BattleScene failed to become ready after ${maxAttempts} attempts.`);
                            alert("Error: Battle scene did not become ready in time. Cannot start battle.");
                            // Revert UI state
                            if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                            if (gameContainer) gameContainer.style.display = 'none';
                        }
                    };

                    // Use the polling check instead of directly starting the scene
                    checkSceneReadyAndStart('BattleScene', battleData);
                    console.log('Initiated polling for BattleScene readiness');

                } catch (error) {
                    console.error('Error starting Phaser BattleScene:', error);
                    // Show error message to user
                    alert('There was an error starting the battle. Falling back to original battle UI.');

                    // Fallback to old battle UI
                    if (!this._fallingBack) {
                        this._fallingBack = true;
                        this.startBattleWithOriginalUI(team, battleMode);
                        setTimeout(() => { this._fallingBack = false; }, 500);
                    }
                }
            } else {
                 console.error("TeamManager not available in startBattleWithPhaser!");
                 alert("Team Manager error. Cannot start battle.");
            }
        } catch (error) {
            console.error('Error in startBattleWithPhaser:', error);
            // Attempt emergency fallback to original battle UI
            if (!this._fallingBack) {
                this._fallingBack = true;
                 // Ensure team is defined for fallback
                 const fallbackTeam = team || this.selectedHeroes.filter(hero => hero !== null);
                 const fallbackMode = battleMode || this.battleMode;
                this.startBattleWithOriginalUI(fallbackTeam, fallbackMode);
                setTimeout(() => { this._fallingBack = false; }, 500);
            }
        }
    };

    /**
     * Start a battle with the original DOM-based battle UI
     * This is used as a fallback when Phaser initialization fails
     * @param {Array} team - The player's team
     * @param {string} battleMode - The battle mode (random, custom, campaign)
     */
    TeamBuilderUI.prototype.startBattleWithOriginalUI = function(team, battleMode) {
        // Use the original startBattle method that was saved
        if (typeof this.startBattleOriginal === 'function') {
            console.log('Falling back to original battle UI');
            // Call the original function which handles its own logic
            this.startBattleOriginal();
        } else {
            console.error('Original startBattle method not found, cannot fallback');
            // Show error message to user
            alert('There was an error starting the battle. Please refresh the page and try again.');
        }
    };

    /**
     * Handle return from Phaser battle scene
     */
    TeamBuilderUI.prototype.onReturnFromPhaserBattle = function() {
        try {
            console.log('Returned from Phaser battle');

            // Show the team builder UI
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) {
                teamBuilderContainer.style.display = 'block'; // Or 'flex', check your CSS
            }

            // Hide Phaser container
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.style.display = 'none';
            }

            // Hide canvas specifically
            const canvas = document.querySelector('#game-container canvas');
            if (canvas) {
                canvas.style.display = 'none';
            }

            // Reset enemy team selection if needed
            if (this.isSelectingEnemyTeam) {
                this.isSelectingEnemyTeam = false;
                this.renderTeamSlots();
            }

            // Update battle modes display
            this.renderBattleModes();

            // Play UI sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
        } catch (error) {
            console.error('Error in onReturnFromPhaserBattle:', error);
            // Try showing the team builder UI anyway as a fallback
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if(teamBuilderContainer) teamBuilderContainer.style.display = 'block'; // Or 'flex'
        }
    };

    /**
     * Legacy method name for backward compatibility
     */
    TeamBuilderUI.prototype.onReturnFromBattle = TeamBuilderUI.prototype.onReturnFromPhaserBattle;

    /**
     * Override the original startBattle to use Phaser version
     * Original method will be kept as fallback
     */
    // Ensure startBattleOriginal actually exists before trying to assign it
    if (typeof TeamBuilderUI.prototype.startBattle === 'function') {
         TeamBuilderUI.prototype.startBattleOriginal = TeamBuilderUI.prototype.startBattle;
    } else {
         console.error("Original TeamBuilderUI.prototype.startBattle not found for backup!");
         // Define a dummy original if needed to prevent errors later, though this indicates a bigger problem
         TeamBuilderUI.prototype.startBattleOriginal = function() { console.error("startBattleOriginal fallback called - original missing!"); };
    }


    TeamBuilderUI.prototype.startBattle = async function() {
        // For Custom Battle mode, we need to switch to enemy team selection if not done yet
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // Filter out empty slots
            const team = this.selectedHeroes.filter(hero => hero !== null);

            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }

            // Switch to enemy team selection mode
            this.isSelectingEnemyTeam = true;
            this.renderTeamSlots();
            this.updateStartBattleButton();

            // Play selection sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }

            return; // Exit without starting battle
        }

        // Get the selected team
        const team = this.selectedHeroes.filter(hero => hero !== null);

        // Check if we should use Phaser battle scene or fallback to original
        const usePhaser = true; // Set to true to always use Phaser, false to use original

        if (usePhaser) {
            // Call the Phaser-specific method
            await this.startBattleWithPhaser(team, this.battleMode);
        } else {
            // Call the original DOM-based method (if it was correctly backed up)
             if (typeof this.startBattleOriginal === 'function') {
                 this.startBattleOriginal();
             } else {
                  console.error("Cannot call original startBattle - backup failed.");
                  alert("Error initiating battle.");
             }
        }
    };

    console.log('TeamBuilderUIUpdates: Successfully added methods and diagnostics to TeamBuilderUI prototype');
});

===== FILE: TooltipManager.js =====
/**
 * Tooltip Manager
 * Manages tooltip display for UI elements
 */

class TooltipManager {
    /**
     * Create a new Tooltip Manager
     */
    constructor() {
        this.tooltip = null;
        this.initialize();
    }

    /**
     * Initialize the tooltip element
     */
    initialize() {
        // Create tooltip element if it doesn't exist
        if (!this.tooltip) {
            this.tooltip = document.createElement('div');
            this.tooltip.className = 'tooltip';
            this.tooltip.style.display = 'none';
            document.body.appendChild(this.tooltip);

            // Add mousemove event to move tooltip with cursor
            document.addEventListener('mousemove', (e) => {
                if (this.tooltip.style.display === 'block') {
                    const offset = 15; // Distance from cursor
                    
                    // Position tooltip based on cursor position
                    this.tooltip.style.left = (e.pageX + offset) + 'px';

                    // Make sure tooltip doesn't go off-screen
                    const tooltipRect = this.tooltip.getBoundingClientRect();
                    if (e.pageY + offset + tooltipRect.height > window.innerHeight) {
                        this.tooltip.style.top = (e.pageY - tooltipRect.height - offset) + 'px';
                    } else {
                        this.tooltip.style.top = (e.pageY + offset) + 'px';
                    }
                }
            });
        }
    }

    /**
     * Show tooltip with content
     * @param {string} content - HTML content for the tooltip
     */
    show(content) {
        this.tooltip.innerHTML = content;
        this.tooltip.style.display = 'block';
    }

    /**
     * Hide tooltip
     */
    hide() {
        this.tooltip.style.display = 'none';
    }

    /**
     * Add tooltip to an element
     * @param {HTMLElement} element - Element to add tooltip to
     * @param {string|Function} content - Content for tooltip or function returning content
     */
    addTooltip(element, content) {
        element.addEventListener('mouseenter', () => {
            const tooltipContent = typeof content === 'function' ? content() : content;
            this.show(tooltipContent);
        });

        element.addEventListener('mouseleave', () => {
            this.hide();
        });
    }
}

// Create a singleton instance
const tooltipManager = new TooltipManager();

// Make it available globally
window.tooltipManager = tooltipManager;


===== FILE: BattleFlowTester.js =====
/**
 * BattleFlowTester.js
 * Utility for testing the BattleFlowController implementation
 * Version 0.5.9 - 2025-05-20
 */

// Create a global test utility object
window.testBattleFlow = {
    /**
     * Enable the BattleFlowController
     * @returns {boolean} Success status
     */
    enable: function() {
        if (window.battleManager && window.battleManager.battleFlowController) {
            console.log("[TestUtil] Enabling BattleFlowController");
            return window.battleManager.battleFlowController.enableFlowController();
        }
        console.error("[TestUtil] BattleManager or BattleFlowController not available");
        return false;
    },
    
    /**
     * Disable the BattleFlowController
     * @returns {boolean} Success status
     */
    disable: function() {
        if (window.battleManager && window.battleManager.battleFlowController) {
            console.log("[TestUtil] Disabling BattleFlowController");
            return window.battleManager.battleFlowController.disableFlowController();
        }
        console.error("[TestUtil] BattleManager or BattleFlowController not available");
        return false;
    },
    
    /**
     * Start a test battle with BattleFlowController enabled
     * @returns {boolean} Success status
     */
    test: function() {
        if (window.teamBuilderUI) {
            console.log("[TestUtil] Starting test battle with BattleFlowController enabled");
            this.enable();
            window.teamBuilderUI.startQuickBattle();
            return true;
        }
        console.error("[TestUtil] TeamBuilderUI not available");
        return false;
    },
    
    /**
     * Check if BattleFlowController is currently enabled
     * @returns {boolean} Enabled status
     */
    isEnabled: function() {
        if (window.battleManager) {
            return !!window.battleManager.useNewFlowController;
        }
        return false;
    },
    
    /**
     * Toggle the BattleFlowController state
     * @returns {boolean} New state
     */
    toggle: function() {
        if (window.battleManager) {
            window.battleManager.toggleFlowController();
            console.log(`[TestUtil] BattleFlowController ${this.isEnabled() ? 'enabled' : 'disabled'}`);
            return this.isEnabled();
        }
        return false;
    },
    
    /**
     * Run a comparison test that starts two battles in sequence:
     * First with legacy implementation, then with BattleFlowController
     */
    compareImplementations: function() {
        if (!window.teamBuilderUI) {
            console.error("[TestUtil] TeamBuilderUI not available");
            return false;
        }
        
        console.log("[TestUtil] Running implementation comparison test");
        
        // First, run with legacy implementation
        this.disable();
        console.log("[TestUtil] Starting battle with legacy implementation");
        window.teamBuilderUI.startQuickBattle();
        
        // Schedule a test with the new implementation after 5 seconds
        console.log("[TestUtil] Will test new implementation in 5 seconds...");
        setTimeout(() => {
            console.log("[TestUtil] Starting battle with BattleFlowController");
            this.enable();
            window.teamBuilderUI.startQuickBattle();
        }, 5000);
        
        return true;
    },
    
    /**
     * Display the current status of the BattleFlowController
     */
    status: function() {
        const enabled = this.isEnabled();
        console.log(`[TestUtil] BattleFlowController Status:`);
        console.log(`- Enabled: ${enabled}`);
        console.log(`- Available: ${!!(window.battleManager && window.battleManager.battleFlowController)}`);
        
        if (window.battleManager && window.battleManager.battleFlowController) {
            console.log(`- Controller methods implemented: ${Object.getOwnPropertyNames(
                Object.getPrototypeOf(window.battleManager.battleFlowController)
            ).filter(m => m !== 'constructor').join(', ')}`);
        }
        
        return {
            enabled: enabled,
            available: !!(window.battleManager && window.battleManager.battleFlowController),
            battleManager: !!window.battleManager,
            teamBuilderUI: !!window.teamBuilderUI
        };
    },
    
    /**
     * Display helpful usage information in the console
     */
    help: function() {
        console.log(`
BattleFlowController Test Utility

Available commands:
    testBattleFlow.enable()               - Enable BattleFlowController
    testBattleFlow.disable()              - Disable BattleFlowController
    testBattleFlow.toggle()               - Toggle BattleFlowController state
    testBattleFlow.isEnabled()            - Check if BattleFlowController is enabled
    testBattleFlow.test()                 - Start a test battle with BattleFlowController enabled
    testBattleFlow.compareImplementations() - Run battles with both implementations for comparison
    testBattleFlow.status()               - Display current status
    testBattleFlow.help()                 - Show this help information
        `);
    }
};

// Automatically display help information when this file loads
console.log('BattleFlowTester loaded - Use testBattleFlow.help() for available commands');


===== FILE: DirectImageLoader.js =====
/**
 * DirectImageLoader.js
 * A special utility to load character images directly from the file system
 * This ensures the image gets loaded even when relative paths aren't working
 */

window.DirectImageLoader = {
    // Base paths to try in order
    basePaths: [
        '',
        '/',
        './',
        '../',
        '../../'
    ],
    
    // Character image lookup table
    characterImages: {
        'Aqualia': 'assets/images/Character Art/Aqualia.png',
        'Drakarion': 'assets/images/Character Art/Drakarion.png',
        'Zephyr': 'assets/images/Character Art/Zephyr.png',
        'Lumina': 'assets/images/Character Art/Lumina.png',
        'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
        'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
        'Caste': 'assets/images/Character Art/Caste.png'
    },
    
    // Store characters data globally
    charactersData: null,
    
    /**
     * Load characters data from JSON
     */
    loadCharactersData: async function() {
        try {
            const response = await fetch('data/characters.json');
            const data = await response.json();
            this.charactersData = data.characters;
            console.log('DirectImageLoader: Loaded characters data', this.charactersData);
        } catch (err) {
            console.error('DirectImageLoader: Failed to load characters.json', err);
        }
    },
    
    /**
     * Get an image element for a character
     * @param {string} characterName - The name of the character
     * @returns {HTMLImageElement} - Image element with the character art
     */
    getCharacterImage: function(characterName) {
        if (!this.characterImages[characterName]) {
            console.error(`No image path defined for character: ${characterName}`);
            return null;
        }
        
        const img = new Image();
        const imagePath = this.characterImages[characterName];
        
        // For debugging, track when the image loads or fails
        img.onload = () => console.log(`SUCCESS: Loaded character image for ${characterName} from ${img.src}`);
        img.onerror = () => console.error(`FAILED: Could not load character image for ${characterName} from ${img.src}`);
        
        // Set the source directly
        img.src = imagePath;
        
        return img;
    },
    
    /**
     * Insert character images directly into the DOM, replacing placeholders
     * This is called automatically when the page loads
     */
    injectCharacterImages: function() {
        // Check if we're in a battle screen
        const battleUI = document.getElementById('battle-ui');
        if (!battleUI) return;
        
        // SKIP if there's any active animation in progress
        const activeAnimations = document.querySelectorAll('.character-moving, [id^="clone-"]');
        if (activeAnimations.length > 0) {
            console.log('DirectImageLoader: Skipping image injection during active animation');
            return;
        }
        
        console.log('DirectImageLoader: Checking for character circles to replace with images');
        
        // Look for characters that should have images
        Object.keys(this.characterImages).forEach(characterName => {
            // Look for character elements with this name
            document.querySelectorAll('.character-circle').forEach(circle => {
                // SKIP if this circle is already part of an animation clone
                if (circle.closest('[id^="clone-"]')) return;
                
                // SKIP if circle already has art to avoid redundant processing
                if (circle.querySelector('.character-art')) return;
                
                // SKIP if circle has the artLoaded attribute
                if (circle.dataset.artLoaded === 'true') return;
                
                // Check if this is a container for the character we're looking for
                const container = circle.closest('.flex.flex-col');
                if (!container) return;
                
                const nameElement = container.querySelector('.text-sm.font-semibold');
                if (!nameElement || nameElement.textContent !== characterName) return;
                
                // Get character ID from the circle ID if available
                const circleId = circle.id;
                let characterId = null;
                let teamInfo = null;
                
                if (circleId) {
                    const idMatch = circleId.match(/character-(player|enemy)_(\d+)/);
                    if (idMatch) {
                        teamInfo = idMatch[1]; // 'player' or 'enemy'
                        characterId = idMatch[2]; // numeric ID
                    }
                }
                
                console.log(`Found ${characterName} element (${teamInfo}_${characterId}), injecting image`);
                
                // Set up the container for images
                circle.classList.add('character-art-container');
                circle.style.backgroundColor = 'transparent'; // Changed to transparent
                circle.style.boxShadow = 'none'; // Removed shadow
                
                // Mark this circle as having art loaded
                circle.dataset.artLoaded = 'true';
                circle.dataset.characterName = characterName;
                if (characterId) circle.dataset.characterId = characterId;
                if (teamInfo) circle.dataset.team = teamInfo;
                
                // Check for cached image in the global cache
                let img;
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[characterName]) {
                    console.log(`Using cached image for ${characterName}`);
                    img = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                } else {
                    // Create a new image if no cache available
                    img = new Image();
                    img.src = this.characterImages[characterName];
                    
                    // Add to global cache for future use
                    if (!window.CHARACTER_IMAGE_CACHE) window.CHARACTER_IMAGE_CACHE = {};
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                }
                
                img.className = 'character-art';
                img.alt = characterName;
                img.dataset.characterName = characterName;
                if (characterId) img.dataset.characterId = characterId;
                if (teamInfo) img.dataset.team = teamInfo;
                
                img.style.width = '80px';
                img.style.height = '120px';
                img.style.objectFit = 'contain';
                img.style.position = 'absolute';
                
                // Look for custom art positioning in the characters data
                let customPositioning = false;
                if (this.charactersData) {
                    // Try to find the character data
                    const characterData = this.charactersData.find(c => c.name === characterName);
                    if (characterData && characterData.art) {
                        console.log(`Found custom art settings for ${characterName}`, characterData.art);
                        // Apply custom positioning
                        if (characterData.art.top) {
                            img.style.top = characterData.art.top;
                            img.dataset.originalTop = characterData.art.top; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.left) {
                            img.style.left = characterData.art.left;
                            img.dataset.originalLeft = characterData.art.left; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.width) img.style.width = characterData.art.width;
                        if (characterData.art.height) img.style.height = characterData.art.height;
                    }
                }
                
                // Use default positioning only if no custom positioning found
                if (!customPositioning) {
                    img.style.top = '-52px';
                    img.dataset.originalTop = '-52px';
                    img.style.left = '-2px';
                    img.dataset.originalLeft = '-2px';
                }
                
                img.style.zIndex = '10';
                img.style.pointerEvents = 'none';
                
                // Empty the text and add the image
                circle.textContent = '';
                circle.appendChild(img);
            });
        });
    }
};

// Global flag to disable DirectImageLoader during animations
window.disableDirectImageLoader = false;

// Run image injector when DOM is ready
window.addEventListener('load', async function() {
    // Load character data first
    await window.DirectImageLoader.loadCharactersData();
    
    // Wait a bit for battle UI to initialize
    setTimeout(() => {
        window.DirectImageLoader.injectCharacterImages();
    }, 1000);
    
    // Also check periodically for new characters that might appear
    // Use a longer interval (reduced from 3000ms to 5000ms) and check the disable flag
    let intervalId = setInterval(() => {
        if (window.disableDirectImageLoader) {
            console.log('DirectImageLoader: Skipping periodic check (disabled)');
            return;
        }
        window.DirectImageLoader.injectCharacterImages();
    }, 5000);
    
    // Store the interval ID in the DirectImageLoader object
    window.DirectImageLoader.intervalId = intervalId;
});

// Add utility function to temporarily disable the DirectImageLoader during animations
window.disableDirectImageLoaderDuringAnimation = function() {
    window.disableDirectImageLoader = true;
    console.log('DirectImageLoader: Disabled during animation');
    
    // Re-enable after a short delay
    setTimeout(() => {
        window.disableDirectImageLoader = false;
        console.log('DirectImageLoader: Re-enabled after animation');
    }, 2000); // 2 seconds should cover most animations
};

console.log('DirectImageLoader initialized for character art');


===== FILE: ImageDebugger.js =====
/**
 * ImageDebugger.js
 * Utility for debugging image loading issues in the game
 * Debug button removed as character art implementation is now stable
 */


window.ImageDebugger = {
    /**
     * Test loading an image from various paths
     * @param {string} imageName - Base name of the image file (e.g., "Aqualia.png")
     * @returns {Promise<string>} - Promise resolving to the working path or error message
     */
    testImagePaths: async function(imageName) {
        // Set up possible paths to test
        const paths = [
            `./assets/images/Character Art/${imageName}`,
            `/assets/images/Character Art/${imageName}`,
            `assets/images/Character Art/${imageName}`,
            `../assets/images/Character Art/${imageName}`,
            `C:/Personal/AutoBattler/assets/images/Character Art/${imageName}`,
            `../../assets/images/Character Art/${imageName}`
        ];
        
        const results = {};
        
        // Create a div to display loading status in the UI
        const debugDiv = document.createElement('div');
        debugDiv.style.position = 'fixed';
        debugDiv.style.top = '10px';
        debugDiv.style.right = '10px';
        debugDiv.style.backgroundColor = 'rgba(0,0,0,0.8)';
        debugDiv.style.color = 'white';
        debugDiv.style.padding = '10px';
        debugDiv.style.zIndex = '9999';
        debugDiv.style.maxWidth = '400px';
        debugDiv.style.maxHeight = '400px';
        debugDiv.style.overflow = 'auto';
        debugDiv.style.fontFamily = 'monospace';
        debugDiv.style.fontSize = '12px';
        debugDiv.innerHTML = '<h3>Image Path Testing</h3>';
        document.body.appendChild(debugDiv);
        
        // Test each path
        for (const path of paths) {
            const result = await this.testSinglePath(path, debugDiv);
            results[path] = result;
        }
        
        // Add a close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.marginTop = '10px';
        closeButton.style.padding = '5px 10px';
        closeButton.addEventListener('click', () => document.body.removeChild(debugDiv));
        debugDiv.appendChild(closeButton);
        
        // Return the results summary
        return results;
    },
    
    /**
     * Test loading a single image path
     * @param {string} path - Path to test
     * @param {HTMLElement} debugDiv - Debug display element
     * @returns {Promise<string>} - Promise resolving to success or error message
     */
    testSinglePath: function(path, debugDiv) {
        return new Promise((resolve) => {
            const img = new Image();
            const statusElement = document.createElement('div');
            statusElement.innerHTML = `Testing: ${path} <span style="color:yellow">â³</span>`;
            debugDiv.appendChild(statusElement);
            
            // Set a timeout for loading
            const timeout = setTimeout(() => {
                statusElement.innerHTML = `Testing: ${path} <span style="color:orange">âŒ› Timed out after 5s</span>`;
                resolve('Timed out');
            }, 5000);
            
            img.onload = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:green">âœ“ Success (${img.width}x${img.height})</span>`;
                
                // Display the image as thumbnail
                const thumb = document.createElement('img');
                thumb.src = path;
                thumb.style.width = '50px';
                thumb.style.height = '50px';
                thumb.style.objectFit = 'contain';
                thumb.style.marginLeft = '10px';
                statusElement.appendChild(thumb);
                
                resolve('Success');
            };
            
            img.onerror = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:red">âœ— Failed</span>`;
                resolve('Failed');
            };
            
            img.src = path;
        });
    },
    
    // Character-specific debug methods removed as they're no longer needed
};

// Global debug functions removed

console.log('ImageDebugger initialized - debugging UI elements removed.');


===== FILE: TeamBuilderImageLoader.js =====
/**
 * TeamBuilderImageLoader.js
 * Loads and injects character art into the Team Builder UI
 * Based on the existing DirectImageLoader.js functionality
 */

// Create a global cache for character images that persists beyond class instances
window.CHARACTER_IMAGE_CACHE = window.CHARACTER_IMAGE_CACHE || {};

class TeamBuilderImageLoader {
    constructor() {
        this.characterData = null;
        this.processedContainers = new WeakSet(); // Track processed containers to avoid reprocessing
        this.loadedCharacters = new Set(); // Track which characters already have art loaded
        this.cachedImages = new Map(); // NEW: Cache for character images to prevent flickering
        this.checkInterval = 2000; // Check every 2 seconds (reduced frequency)
        this.imageCheckTimer = null;
        this.debugMode = false; // Control logging verbosity
        this.lastProcessTime = Date.now();
        this.characterImages = {
            'Aqualia': 'assets/images/Character Art/Aqualia.png',
            'Drakarion': 'assets/images/Character Art/Drakarion.png',
            'Zephyr': 'assets/images/Character Art/Zephyr.png',
            'Lumina': 'assets/images/Character Art/Lumina.png',
            'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
            'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
            'Caste': 'assets/images/Character Art/Caste.png'
        };
    }

    /**
    * Initialize the image loader
    */
async initialize() {
    console.log('TeamBuilderImageLoader: Initializing...');
    
    // Load character data
    try {
    const response = await fetch('data/characters.json');
    this.characterData = await response.json();
    console.log('TeamBuilderImageLoader: Character data loaded');
    } catch (err) {
    console.error('TeamBuilderImageLoader: Failed to load character data', err);
    this.characterData = { characters: [] }; // Empty fallback
    }
    
    // Start periodic checking for new character elements
    this.startImageCheck();
    
    // Do an initial check with debug enabled
    setTimeout(() => {
    console.log('TeamBuilderImageLoader: Performing initial detailed check...');
    this.forceCheck(true);
    
    // Preload all character images immediately
    this.preloadCharacterImages();
    }, 1000);
}
    
    /**
     * Preload and cache all available character images
     */
    async preloadCharacterImages() {
        console.log('TeamBuilderImageLoader: Preloading all character images...');
        
        // Get all characters that have images defined
        const charactersWithArt = Object.keys(this.characterImages);
        if (charactersWithArt.length === 0) {
            console.warn('TeamBuilderImageLoader: No character images defined');
            return;
        }
        
        // Preload each character's image
        for (const characterName of charactersWithArt) {
            try {
                const imagePath = this.characterImages[characterName];
                if (!imagePath) continue;
                
                console.log(`TeamBuilderImageLoader: Preloading ${characterName}'s image...`);
                
                // Create a new image element
                const img = new Image();
                
                // Set up onload handler
                img.onload = () => {
                    // Store in global cache
                    window.CHARACTER_IMAGE_CACHE[characterName] = img;
                    console.log(`TeamBuilderImageLoader: ${characterName}'s image preloaded and stored in global cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    // Also store in instance cache
                    this.cachedImages.set(characterName, img);
                    this.loadedCharacters.add(characterName);
                };
                
                // Set the source to trigger loading
                img.src = imagePath;
            } catch (err) {
                console.error(`TeamBuilderImageLoader: Error preloading ${characterName}'s image`, err);
            }
        }
    }
    


    /**
     * Start periodically checking for character elements that need art
     */
    startImageCheck() {
        // Clear any existing timer
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
        }
        
        // Set up periodic check - just basic checking, no forced updates
        this.imageCheckTimer = setInterval(() => {
            this.checkAndLoadImages();
        }, this.checkInterval);
        
        // Run an immediate check
        this.checkAndLoadImages();
    }

    /**
     * Check for character elements and load images if needed
     */
    checkAndLoadImages() {
        // Throttle checks to prevent excessive processing
        const now = Date.now();
        if (now - this.lastProcessTime < 500) { // minimum 500ms between full checks
            return;
        }
        this.lastProcessTime = now;
        
        // Find all character containers EXCEPT the detail container
        // We now handle detail container separately to avoid observer issues
        const containers = document.querySelectorAll('.hero-avatar-container:not(.detail-icon-container)');
        
        if (this.debugMode) {
            console.log(`TeamBuilderImageLoader: Checking ${containers.length} avatar containers`);
        }
        
        // First pass: immediately hide all circles where art is available
        containers.forEach(container => {
            const characterName = container.dataset.characterName;
            if (characterName && this.characterImages[characterName]) {
                // This character has art available, immediately hide the circle
                const avatarCircle = container.querySelector('.hero-avatar, .detail-icon');
                if (avatarCircle) {
                    avatarCircle.style.display = 'none';
                    avatarCircle.style.backgroundColor = 'transparent';
                    avatarCircle.textContent = ''; // Clear any letter placeholders
                }
                
                // Add the has-art class to the container for CSS targeting
                container.classList.add('has-art');
            }
        });
        
        // Now process containers that need art
        let artLoadedInThisPass = false;
        
        containers.forEach(container => {
            // Always process detail view containers, otherwise check if already processed
            const isDetailView = container.classList.contains('detail-icon-container');
            if (!isDetailView && this.processedContainers.has(container)) {
                return;
            }
            
            const characterId = container.dataset.characterId;
            const characterName = container.dataset.characterName;
            
            // Skip if no character ID
            if (!characterId) return;
            
            // Process and load art for this character if needed
            if (this.loadCharacterArt(container, characterId, characterName)) {
                artLoadedInThisPass = true;
            }
        });
        
        // Report if we actually loaded art in this pass (helps with debugging)
        if (artLoadedInThisPass && this.debugMode) {
            console.log('TeamBuilderImageLoader: New art was loaded in this check pass');
        }
    }

    /**
     * Load art for a specific character
     * @returns {boolean} Whether new art was loaded
     */
    loadCharacterArt(container, characterId, characterName) {
        // Special handling for character details view
        const isDetailView = container.classList.contains('detail-icon-container');
        
        // If this is the detail view, always process it (even if processed before)
        // This helps ensure the art is always shown in the character details panel
        if (!isDetailView) {
            // For non-detail views, mark container as processed to avoid multiple attempts
            this.processedContainers.add(container);
        }
        
        // Check if this character has art defined
        if (!this.characterImages[characterName]) {
            if (this.debugMode) {
                console.log(`TeamBuilderImageLoader: No art defined for ${characterName}`);
            }
            
            // Don't add placeholders anymore - just return false and let containers be invisible
            return false; // No art defined
        }
        
        // Critical: If character is already loaded, just make sure container is properly styled
        if (this.loadedCharacters.has(characterName)) {
            const artWrapper = container.querySelector('.hero-art-wrapper');
            
            if (artWrapper) {
                artWrapper.style.display = 'block';
                
                // If no inner content in wrapper, we need to add the image
                // (for newly created UI elements)
                if (artWrapper.innerHTML.trim() === '') {
                    this.createAndAddArt(container, characterId, characterName, false);
                    return true; // Consider as new art being added
                }
            }
            
            return false; // No new art loaded
        }
        
        // If we get here, character needs art and hasn't been loaded yet
        return this.createAndAddArt(container, characterId, characterName, true);
    }

    /**
     * Create and add character art to a container
     * @param {HTMLElement} container - The container element
     * @param {string} characterId - Character ID
     * @param {string} characterName - Character name
     * @param {boolean} isFirstLoad - Whether this is the first time loading this character
     * @returns {boolean} Whether the art was successfully added
     */
    async createAndAddArt(container, characterId, characterName, isFirstLoad) {
        // Find character data
        const character = this.findCharacterData(characterId, characterName);
        if (!character) {
            console.log(`TeamBuilderImageLoader: Character data not found for ${characterName}`);
            return false;
        }
        
        // Check if the wrapper exists
        const artWrapper = container.querySelector('.hero-art-wrapper');
        
        if (!artWrapper) {
            console.error('TeamBuilderImageLoader: No art wrapper found for', characterName);
            return false;
        }
        
        // Try to load the image
        try {
            const imagePath = this.characterImages[characterName];
            
            // Check if we already have a cached image for this character
            let img;
            if (this.cachedImages.has(characterName)) {
                // Use the cached image data to create a new image element
                img = this.cachedImages.get(characterName).cloneNode(true);
                console.log(`TeamBuilderImageLoader: Using cached image for ${characterName}`);
            } else {
                // Load the image for the first time
                const imageExists = await this.checkImageExists(imagePath);
                
                if (!imageExists) {
                    console.log(`TeamBuilderImageLoader: No image found for ${characterName}`);
                    return false;
                }
                
                // Create a new image element
                img = document.createElement('img');
                img.src = imagePath;
                img.onload = () => {
                    // Cache the loaded image for future use
                    this.cachedImages.set(characterName, img.cloneNode(true));
                    
                    // Also store in global cache for persistent access
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                    console.log(`TeamBuilderImageLoader: Added ${characterName} to global image cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    console.log(`TeamBuilderImageLoader: Cached image for ${characterName}`);
                };
            }
            
            // Determine if this is a detail view
            const isDetailView = container.classList.contains('detail-icon-container');
            
            // Use teamBuilderArt if available, otherwise fall back to regular art
            let artSettings;
            
            if (isDetailView) {
                // For detail view, use special positioning
                artSettings = character.detailArt || character.teamBuilderArt || character.art || {};
                
                // If no specific settings, use these defaults for detail view
                if (!artSettings.left) artSettings.left = '-30px';
                if (!artSettings.top) artSettings.top = '-45px';
                if (!artSettings.width) artSettings.width = '140px';
                if (!artSettings.height) artSettings.height = '140px';
            } else {
                // Regular view
                artSettings = character.teamBuilderArt || character.art || {};
            }
            
            // Set image properties
            img.className = 'character-art team-builder-art';
            img.alt = characterName;
            
            // Apply position settings
            img.style.position = 'absolute';
            img.style.left = artSettings.left || '0px';
            img.style.top = artSettings.top || '0px';
            
            if (artSettings.width) {
                img.style.width = artSettings.width;
            }
            
            if (artSettings.height) {
                img.style.height = artSettings.height;
            }
            
            // Store original positions for animation handling
            img.dataset.originalLeft = artSettings.left || '0px';
            img.dataset.originalTop = artSettings.top || '0px';
            
            // PRESERVE EXISTING ART: Check if art already exists before replacing
            const existingArt = artWrapper.querySelector('.character-art');
            if (!existingArt) {
                // Only clear and add if there's no existing art
                artWrapper.innerHTML = '';
                artWrapper.appendChild(img);
            }
            
            artWrapper.style.display = 'block';
            
            // Set all parent elements with appropriate classes
            container.classList.add('has-art'); // Mark container as having art
            
            // Add has-art to the parent card/content element if it exists
            const heroCard = container.closest('.hero-card');
            if (heroCard) heroCard.classList.add('has-art');
            
            const slotContent = container.closest('.slot-content');
            if (slotContent) slotContent.classList.add('has-art');
            
            const detailHero = container.closest('.detail-hero');
            if (detailHero) detailHero.classList.add('has-art');
            
            // Record that we've loaded this character's art
            // This is important to avoid reloading across different containers
            this.loadedCharacters.add(characterName);
            
            // Always log for detail view to help track issues
            if (isFirstLoad || isDetailView) {
                console.log(`TeamBuilderImageLoader: Loaded art for ${characterName}${isDetailView ? ' (detail view)' : ''}`);
            }
            
            return true;
        } catch (err) {
            console.error(`TeamBuilderImageLoader: Error loading art for ${characterName}`, err);
            return false;
        }
    }

    /**
     * Find character data by ID or name
     */
    findCharacterData(id, name) {
        if (!this.characterData || !this.characterData.characters) {
            return null;
        }
        
        // Try to find by ID first
        let character = this.characterData.characters.find(c => c.id == id);
        
        // Fall back to finding by name
        if (!character && name) {
            character = this.characterData.characters.find(c => 
                c.name.toLowerCase() === name.toLowerCase()
            );
        }
        
        return character;
    }

    /**
     * Manually trigger a check for new images and reset processing cache
     * @param {boolean} debug - Enable debug output
     * @param {boolean} resetCache - Whether to reset the processed containers cache
     */
    forceCheck(debug = false, resetCache = false) {
        // Temporarily enable debug mode if requested
        const prevDebugMode = this.debugMode;
        this.debugMode = debug;
        
        if (debug) {
            console.log("TeamBuilderImageLoader: Force checking images");
        }
        
        // Reset the processed containers cache if requested
        // This will force reprocessing of all containers
        if (resetCache) {
            if (debug) {
                console.log("TeamBuilderImageLoader: Resetting processed containers cache");
            }
            this.processedContainers = new WeakSet();
            this.loadedCharacters = new Set();
        }
        
        // Check for new images
        this.checkAndLoadImages();
        
        // Restore previous debug mode
        this.debugMode = prevDebugMode;
    }

    /**
     * Check if an image exists
     */
    async checkImageExists(imagePath) {
        try {
            const response = await fetch(imagePath, { method: 'HEAD' });
            return response.ok;
        } catch (err) {
            return false;
        }
    }

    /**
     * Clean up resources
     */
    destroy() {
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
            this.imageCheckTimer = null;
        }
    }
}

// Export the class
// Create DOM observer to ensure character art is never removed
window.setupCharacterArtMutationObserver = function() {
    // First, completely disconnect any existing observer to ensure clean slate
    if (window.characterArtObserver) {
        window.characterArtObserver.disconnect();
        window.characterArtObserver = null;
        console.log('Reset existing character art observer');
    }
    
    console.log('Setting up character art mutation observer');
    
    // Static flag to completely disable observer when needed
    window.observerDisabled = false;
    
    // Throttling variable
    let throttleId = null;
    // Boolean flag to prevent re-entrance
    let isRestoring = false;
    
    // Create a mutation observer to watch for DOM changes
    window.characterArtObserver = new MutationObserver(function(mutations) {
        // Skip if globally disabled or already processing or throttled
        if (window.observerDisabled || isRestoring || throttleId) return;
        
        // Check if any mutation is directly affecting a detail container
        // If so, skip processing entirely
        const shouldSkip = mutations.some(mutation => {
            return mutation.target.closest('.detail-icon-container') !== null;
        });
        
        if (shouldSkip) return;
        
        // Set up throttling with requestAnimationFrame instead of setTimeout
        if (throttleId) return; // already scheduled
        
        throttleId = requestAnimationFrame(() => {
            try {
                // Set isRestoring flag to prevent re-entrance
                isRestoring = true;
                
                // Temporarily disconnect the observer to prevent self-triggering
                window.characterArtObserver.disconnect();
                
                // Use a flag to track if we did any art restoration
                let didRestoreArt = false;
                
                // Process mutations
                mutations.forEach(function(mutation) {
                    // Only process if we have element changes and not in a detail container
                    if ((mutation.type === 'childList' || mutation.type === 'attributes') && 
                        !mutation.target.closest('.detail-icon-container')) {
                        
                        // Check for any character containers that are missing their art
                        // EXPLICITLY EXCLUDE the detail-icon-container to avoid any processing
                        document.querySelectorAll('.hero-avatar-container[data-character-name]:not(.detail-icon-container)').forEach(container => {
                            const characterName = container.dataset.characterName;
                            
                            // Only process if we have this character in our cache
                            if (window.CHARACTER_IMAGE_CACHE[characterName]) {
                                // EARLY EXIT: Skip if art already present
                                if (container.querySelector('.character-art')) return;
                                
                                // EARLY EXIT: Skip if already synced in this animation frame
                                if (container.dataset.artSynced === '1') return;
                                container.dataset.artSynced = '1';
                                
                                // Check if art wrapper exists
                                const artWrapper = container.querySelector('.hero-art-wrapper');
                                
                                // Clean any duplicate arts before proceeding
                                if (artWrapper) {
                                    const extraArts = artWrapper.querySelectorAll('.character-art:not(:first-child)');
                                    extraArts.forEach(el => el.remove());
                                }
                                
                                // If art wrapper is missing, create it
                                let wrapper = artWrapper;
                                if (!wrapper) {
                                    wrapper = document.createElement('div');
                                    wrapper.className = 'hero-art-wrapper';
                                    wrapper.style.display = 'block';
                                    container.appendChild(wrapper);
                                }
                                
                                // Clone from global cache and add
                                const newImg = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                                newImg.style.visibility = 'visible';
                                newImg.style.display = 'block';
                                wrapper.appendChild(newImg);
                                
                                // Force proper class hierarchy
                                container.classList.add('has-art');
                                
                                // Add has-art to parent elements
                                const heroCard = container.closest('.hero-card');
                                if (heroCard) heroCard.classList.add('has-art');
                                
                                const slotContent = container.closest('.slot-content');
                                if (slotContent) slotContent.classList.add('has-art');
                                
                                // Track successful restoration
                                const added = true; // Flag to track if we actually added art
                                if (added) console.log(`Restored art for ${characterName}`);
                                didRestoreArt = true;
                            }
                        });
                    }
                });
                
                // Only log if we actually did something
                if (didRestoreArt) {
                    console.log('Observer restored art for some characters');
                }
            } finally {
                // Reset throttle ID
                throttleId = null;
                // Reset isRestoring flag
                isRestoring = false;
                
                // Reconnect the observer after processing
                if (!window.observerDisabled) {
                    // Reconnect only to the targeted containers
                    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
                    targets.forEach(t => window.characterArtObserver.observe(t, {
                        childList: true,
                        subtree: true,
                        attributes: true
                    }));
                }
            }
        }, 50); // Increase throttle to 50ms for more stability
    });

    // Observe only the grids that actually recycle DOM
    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
    targets.forEach(t => window.characterArtObserver.observe(t, {
        childList: true, // Watch for added/removed nodes
        subtree: true,   // Watch the entire subtree
        attributes: true // Watch for attribute changes
    }));
};

// Utility to temporarily disable observer during complex DOM operations
window.disableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = true;
        window.characterArtObserver.disconnect();
        console.log('Character art observer disabled');
    }
};

// Utility to re-enable observer
window.enableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = false;
        // Observe only the necessary containers
        const targets = document.querySelectorAll('#heroes-grid, #team-slots');
        targets.forEach(t => window.characterArtObserver.observe(t, {
            childList: true,
            subtree: true,
            attributes: true
        }));
        console.log('Character art observer re-enabled');
    }
};

window.TeamBuilderImageLoader = TeamBuilderImageLoader;


===== FILE: game.js =====
/**
 * Main game initialization file
 * This will be the entry point for the AutoBattler game
 *
 * @version 0.5.0.3 (Updated with BattleManager Instantiation & Deferred Scene Add)
 */

// Global variables
let teamManager;
let teamBuilderUI;
let battleManager; // Declared here
let gameConfig = {
    width: 2000,
    height: 1200
};

// Check if BattleUI is defined
function checkBattleUI() {
    if (typeof window.BattleUI === 'undefined') {
        console.warn('BattleUI (DOM version) not defined when game.js loads! This might be ok if only using Phaser.');
    } else {
        console.log('BattleUI (DOM version) is defined and available!');
    }
}

// Wait for DOM to load before initializing the game
window.onload = async function() {
    console.log('Game loading...');

    // Check BattleUI status
    checkBattleUI();

    // Try to load config file
    await loadConfigFile();
    console.log('Config loaded, gameConfig:', gameConfig);

    // Initialize team manager
    teamManager = new TeamManager();
    console.log('TeamManager initialized');

    // Initialize team builder UI
    teamBuilderUI = new TeamBuilderUI(teamManager);
    console.log('TeamBuilderUI created, initializing...');
    await teamBuilderUI.initialize();
    console.log('TeamBuilderUI initialized');

    // Initialize Battle Manager (Crucial Step)
    // Check if BattleManager class exists before creating instance
    if (typeof window.BattleManager === 'function') {
        // Pass null for the scene initially, as Phaser isn't fully ready yet.
        // Pass the ID of your battle log container.
        battleManager = new window.BattleManager(null, 'battle-log-content'); // Instantiate the manager
        window.battleManager = battleManager; // Assign the INSTANCE to window.battleManager (lowercase 'b')
        console.log('BattleManager instance created and assigned to window.battleManager');

         // Optional but recommended: Initialize the BattleManager if it has an async initialize method
         if (battleManager && typeof battleManager.initialize === 'function') {
             // Make sure to await if initialize is async
             // *** NOTE: We removed the auto-creation of BattleUI from BattleManager.initialize ***
             await battleManager.initialize();
             console.log('BattleManager initialized (without auto-creating DOM BattleUI)');
             // BattleBridge will be initialized later by BattleScene with both components
         } else {
             console.log('BattleManager instance created (no separate initialize method found or needed).');
             // BattleBridge will be initialized later by BattleScene with both components
         }

    } else {
        console.error('BattleManager class definition not found on window! Cannot create BattleManager instance.');
        // Stop execution or show an error here
        alert("Critical Error: BattleManager class not found. Battle cannot start.");
        return; // Stop further execution in onload
    }

    // Initialize Phaser game (will be used for battle scene)
    try {
        window.game = initPhaserGame(); // Phaser game instance is assigned here
        console.log('Phaser game initialized successfully');

        // --- POTENTIAL FUTURE STEP: Link BattleManager to Phaser Scene ---
        // (Conceptual code remains unchanged)

    } catch (error) {
        console.error('Failed to initialize Phaser game:', error);
        alert('Failed to initialize Phaser. Battle cannot start.');
    }

    // --- ADDED BLOCK: Defer Adding BattleScene ---
    // Now that Phaser game instance should exist, try adding the scene
    if (window.game && window.BattleScene) {
        if (!window.game.scene.getScene('BattleScene')) { // Check if not already added
            try {
                window.game.scene.add('BattleScene', window.BattleScene);
                console.log('BattleScene added to game post-initialization.');
            } catch (sceneError) {
                 console.error("Error adding BattleScene to game:", sceneError);
                 alert("Failed to add BattleScene. Check console.");
            }
        } else {
             console.log('BattleScene was already added to the game instance.');
        }
    } else {
         if(!window.game) console.warn('Phaser game instance (window.game) not available to add scene.');
         if(!window.BattleScene) console.warn('BattleScene class not found when attempting to add scene post-initialization. Check script load order in index.html.');
    }
    // --- END ADDED BLOCK ---


    // --- Ensure Managers are Exposed Globally ---
    window.teamManager = teamManager;
    window.teamBuilderUI = teamBuilderUI;
    window.battleManager = battleManager; // Expose the created instance
    console.log("Managers exposed globally for debugging.");
};

/**
 * Load the project configuration file
 */
async function loadConfigFile() {
    // ... (loadConfigFile function remains unchanged) ...
    try {
        const response = await fetch('project.config');
        const configText = await response.text();

        // Parse the config file
        const configLines = configText.split('\n');
        let currentSection = '';

        configLines.forEach(line => {
            line = line.trim();

            // Section header
            if (line.startsWith('[') && line.endsWith(']')) {
                currentSection = line.substring(1, line.length - 1);
                return;
            }

            // Parse key-value pairs
            if (line.includes('=')) {
                const parts = line.split('=');
                const key = parts[0].trim();
                let value = parts[1].trim();

                // Remove quotes if present
                if (value.startsWith('"') && value.endsWith('"')) {
                    value = value.substring(1, value.length - 1);
                }

                // Store game dimensions
                if (currentSection === 'game') {
                    if (key === 'width') {
                        gameConfig.width = parseInt(value);
                    } else if (key === 'height') {
                        gameConfig.height = parseInt(value);
                    } else if (key === 'title') {
                        document.title = value;
                    }
                }
            }
        });

        console.log('Loaded game config:', gameConfig);
    } catch (error) {
        console.error('Error loading config file:', error);
        // Use default values if config file cannot be loaded
    }
}


/**
 * Initialize the Phaser game
 * @returns {Phaser.Game | null} The initialized Phaser game instance or null on error
 */
function initPhaserGame() {
    try {
        // Make sure Phaser is loaded
        if (typeof Phaser === 'undefined') {
            console.error('Phaser is not loaded! Make sure Phaser library is included before game.js');
            return null;
        }

        // Make sure PhaserConfig is loaded
        if (typeof window.PhaserConfig === 'undefined') {
            console.error('PhaserConfig is not loaded! Creating emergency configuration...');

            // Create emergency PhaserConfig (Consider moving this to a separate error handling file)
            window.PhaserConfig = {
                initContainer: function(id) {
                     const container = document.getElementById(id) || document.createElement('div');
                     if (!container.id) {
                         container.id = id;
                         document.body.appendChild(container);
                     }
                     // Ensure styling for visibility control
                     container.style.position = 'absolute'; // Or relevant positioning
                     container.style.top = '0';
                     container.style.left = '0';
                     container.style.width = '100%'; // Or specific dimensions
                     container.style.height = '100%';
                     container.style.zIndex = '1'; // Ensure it can be layered
                     container.style.display = 'none'; // Start hidden
                     return container;
                },
                create: function(config) {
                     return {
                         type: Phaser.AUTO,
                         width: config.width || 1280,
                         height: config.height || 720,
                         parent: 'game-container', // Should match initContainer ID
                         backgroundColor: '#333344',
                         scene: [] // Start with empty scene array
                     };
                }
            };
             console.error('PhaserConfig emergency fallback created. Check script load order.');
             // Re-check after creating fallback
             if (typeof window.PhaserConfig === 'undefined') {
                 throw new Error("Failed to create PhaserConfig fallback.");
             }
        }

        // Create Phaser container using our utility
        const phaserContainer = window.PhaserConfig.initContainer('game-container');
        if (!phaserContainer) {
             throw new Error("Failed to initialize Phaser container.");
        }

        // Create Phaser configuration
        const config = window.PhaserConfig.create(gameConfig);
        if (!config) {
             throw new Error("Failed to create Phaser configuration.");
        }

        // Initialize Phaser game
        let game = new Phaser.Game(config);
        if (!game) {
             throw new Error("Phaser.Game constructor failed.");
        }

        // Make sure we have a global reference *immediately* after creation
        window.game = game;

        // --- SCENE ADDITION REMOVED FROM HERE ---
        // The BattleScene will be added later in the onload function

        // Hide Phaser container initially as we start with DOM UI
        if (phaserContainer) {
            phaserContainer.style.display = 'none';
        }

        return game; // Return the game instance
    } catch (error) {
        console.error('Error initializing Phaser game:', error);
        alert('There was an error initializing the battle system. Please refresh the page and try again.');
        // Attempt to clean up partially created elements if possible
        const phaserContainer = document.getElementById('phaser-container'); // Use correct ID
        if(phaserContainer && phaserContainer.parentNode) {
            phaserContainer.parentNode.removeChild(phaserContainer);
        }
        return null;
    }
}


// Add a utility function to check if Phaser is ready
window.isPhaserReady = function() {
    return (
        typeof Phaser !== 'undefined' &&
        window.game && // Check if game instance exists
        window.game.scene && // Check if scene manager exists
        typeof window.game.scene.start === 'function' // Check if core scene method exists
    );
};

// Note: Global exposure is now handled at the end of the onload function
// to ensure variables are assigned before being exposed.

===== FILE: Ability.js =====
/**
 * Ability Class
 * Represents special abilities that characters can use in battle
 */

class Ability {
    /**
     * Create a new Ability
     * @param {string} name - The name of the ability
     * @param {number} damage - Base damage or healing amount
     * @param {number} cooldown - Number of turns before ability can be used again
     * @param {boolean} isHealing - Whether ability heals or damages
     * @param {object} effects - Additional effects (status effects, buffs, etc.)
     */
    constructor(name, damage, cooldown, isHealing = false, effects = {}) {
        this.name = name;
        this.damage = damage;
        this.cooldown = cooldown;
        this.currentCooldown = 0;
        this.isHealing = isHealing;
        this.effects = effects;
    }

    // Methods to be implemented
}


===== FILE: Character.js =====
/**
 * Character Class
 * Base class for all battling units in the AutoBattler game
 */

class Character {
    /**
     * Create a new Character
     * @param {string} name - Character name
     * @param {string} type - Element/type (fire, water, etc.)
     * @param {number} hp - Health points
     * @param {number} attack - Attack power
     * @param {number} defense - Defense value
     * @param {number} x - X position on screen
     * @param {number} y - Y position on screen
     * @param {number} color - Color representation (hexadecimal)
     */
    constructor(name, type, hp, attack, defense, x, y, color) {
        this.name = name;
        this.type = type;
        this.maxHp = hp;
        this.currentHp = hp;
        this.attack = attack;
        this.defense = defense;
        this.x = x;
        this.y = y;
        this.color = color;
        this.sprite = null;
        this.text = null;
        this.abilities = [];
        this.abilityCooldowns = {};
    }

    // Methods to be implemented
}


===== FILE: BattleFlowTester.js =====
/**
 * BattleFlowTester.js
 * Utility for testing the BattleFlowController implementation
 * Version 0.5.9 - 2025-05-20
 */

// Create a global test utility object
window.testBattleFlow = {
    /**
     * Enable the BattleFlowController
     * @returns {boolean} Success status
     */
    enable: function() {
        if (window.battleManager && window.battleManager.battleFlowController) {
            console.log("[TestUtil] Enabling BattleFlowController");
            return window.battleManager.battleFlowController.enableFlowController();
        }
        console.error("[TestUtil] BattleManager or BattleFlowController not available");
        return false;
    },
    
    /**
     * Disable the BattleFlowController
     * @returns {boolean} Success status
     */
    disable: function() {
        if (window.battleManager && window.battleManager.battleFlowController) {
            console.log("[TestUtil] Disabling BattleFlowController");
            return window.battleManager.battleFlowController.disableFlowController();
        }
        console.error("[TestUtil] BattleManager or BattleFlowController not available");
        return false;
    },
    
    /**
     * Start a test battle with BattleFlowController enabled
     * @returns {boolean} Success status
     */
    test: function() {
        if (window.teamBuilderUI) {
            console.log("[TestUtil] Starting test battle with BattleFlowController enabled");
            this.enable();
            window.teamBuilderUI.startQuickBattle();
            return true;
        }
        console.error("[TestUtil] TeamBuilderUI not available");
        return false;
    },
    
    /**
     * Check if BattleFlowController is currently enabled
     * @returns {boolean} Enabled status
     */
    isEnabled: function() {
        if (window.battleManager) {
            return !!window.battleManager.useNewFlowController;
        }
        return false;
    },
    
    /**
     * Toggle the BattleFlowController state
     * @returns {boolean} New state
     */
    toggle: function() {
        if (window.battleManager) {
            window.battleManager.toggleFlowController();
            console.log(`[TestUtil] BattleFlowController ${this.isEnabled() ? 'enabled' : 'disabled'}`);
            return this.isEnabled();
        }
        return false;
    },
    
    /**
     * Run a comparison test that starts two battles in sequence:
     * First with legacy implementation, then with BattleFlowController
     */
    compareImplementations: function() {
        if (!window.teamBuilderUI) {
            console.error("[TestUtil] TeamBuilderUI not available");
            return false;
        }
        
        console.log("[TestUtil] Running implementation comparison test");
        
        // First, run with legacy implementation
        this.disable();
        console.log("[TestUtil] Starting battle with legacy implementation");
        window.teamBuilderUI.startQuickBattle();
        
        // Schedule a test with the new implementation after 5 seconds
        console.log("[TestUtil] Will test new implementation in 5 seconds...");
        setTimeout(() => {
            console.log("[TestUtil] Starting battle with BattleFlowController");
            this.enable();
            window.teamBuilderUI.startQuickBattle();
        }, 5000);
        
        return true;
    },
    
    /**
     * Display the current status of the BattleFlowController
     */
    status: function() {
        const enabled = this.isEnabled();
        console.log(`[TestUtil] BattleFlowController Status:`);
        console.log(`- Enabled: ${enabled}`);
        console.log(`- Available: ${!!(window.battleManager && window.battleManager.battleFlowController)}`);
        
        if (window.battleManager && window.battleManager.battleFlowController) {
            console.log(`- Controller methods implemented: ${Object.getOwnPropertyNames(
                Object.getPrototypeOf(window.battleManager.battleFlowController)
            ).filter(m => m !== 'constructor').join(', ')}`);
        }
        
        return {
            enabled: enabled,
            available: !!(window.battleManager && window.battleManager.battleFlowController),
            battleManager: !!window.battleManager,
            teamBuilderUI: !!window.teamBuilderUI
        };
    },
    
    /**
     * Display helpful usage information in the console
     */
    help: function() {
        console.log(`
BattleFlowController Test Utility

Available commands:
    testBattleFlow.enable()               - Enable BattleFlowController
    testBattleFlow.disable()              - Disable BattleFlowController
    testBattleFlow.toggle()               - Toggle BattleFlowController state
    testBattleFlow.isEnabled()            - Check if BattleFlowController is enabled
    testBattleFlow.test()                 - Start a test battle with BattleFlowController enabled
    testBattleFlow.compareImplementations() - Run battles with both implementations for comparison
    testBattleFlow.status()               - Display current status
    testBattleFlow.help()                 - Show this help information
        `);
    }
};

// Automatically display help information when this file loads
console.log('BattleFlowTester loaded - Use testBattleFlow.help() for available commands');


===== FILE: DirectImageLoader.js =====
/**
 * DirectImageLoader.js
 * A special utility to load character images directly from the file system
 * This ensures the image gets loaded even when relative paths aren't working
 */

window.DirectImageLoader = {
    // Base paths to try in order
    basePaths: [
        '',
        '/',
        './',
        '../',
        '../../'
    ],
    
    // Character image lookup table
    characterImages: {
        'Aqualia': 'assets/images/Character Art/Aqualia.png',
        'Drakarion': 'assets/images/Character Art/Drakarion.png',
        'Zephyr': 'assets/images/Character Art/Zephyr.png',
        'Lumina': 'assets/images/Character Art/Lumina.png',
        'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
        'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
        'Caste': 'assets/images/Character Art/Caste.png'
    },
    
    // Store characters data globally
    charactersData: null,
    
    /**
     * Load characters data from JSON
     */
    loadCharactersData: async function() {
        try {
            const response = await fetch('data/characters.json');
            const data = await response.json();
            this.charactersData = data.characters;
            console.log('DirectImageLoader: Loaded characters data', this.charactersData);
        } catch (err) {
            console.error('DirectImageLoader: Failed to load characters.json', err);
        }
    },
    
    /**
     * Get an image element for a character
     * @param {string} characterName - The name of the character
     * @returns {HTMLImageElement} - Image element with the character art
     */
    getCharacterImage: function(characterName) {
        if (!this.characterImages[characterName]) {
            console.error(`No image path defined for character: ${characterName}`);
            return null;
        }
        
        const img = new Image();
        const imagePath = this.characterImages[characterName];
        
        // For debugging, track when the image loads or fails
        img.onload = () => console.log(`SUCCESS: Loaded character image for ${characterName} from ${img.src}`);
        img.onerror = () => console.error(`FAILED: Could not load character image for ${characterName} from ${img.src}`);
        
        // Set the source directly
        img.src = imagePath;
        
        return img;
    },
    
    /**
     * Insert character images directly into the DOM, replacing placeholders
     * This is called automatically when the page loads
     */
    injectCharacterImages: function() {
        // Check if we're in a battle screen
        const battleUI = document.getElementById('battle-ui');
        if (!battleUI) return;
        
        // SKIP if there's any active animation in progress
        const activeAnimations = document.querySelectorAll('.character-moving, [id^="clone-"]');
        if (activeAnimations.length > 0) {
            console.log('DirectImageLoader: Skipping image injection during active animation');
            return;
        }
        
        console.log('DirectImageLoader: Checking for character circles to replace with images');
        
        // Look for characters that should have images
        Object.keys(this.characterImages).forEach(characterName => {
            // Look for character elements with this name
            document.querySelectorAll('.character-circle').forEach(circle => {
                // SKIP if this circle is already part of an animation clone
                if (circle.closest('[id^="clone-"]')) return;
                
                // SKIP if circle already has art to avoid redundant processing
                if (circle.querySelector('.character-art')) return;
                
                // SKIP if circle has the artLoaded attribute
                if (circle.dataset.artLoaded === 'true') return;
                
                // Check if this is a container for the character we're looking for
                const container = circle.closest('.flex.flex-col');
                if (!container) return;
                
                const nameElement = container.querySelector('.text-sm.font-semibold');
                if (!nameElement || nameElement.textContent !== characterName) return;
                
                // Get character ID from the circle ID if available
                const circleId = circle.id;
                let characterId = null;
                let teamInfo = null;
                
                if (circleId) {
                    const idMatch = circleId.match(/character-(player|enemy)_(\d+)/);
                    if (idMatch) {
                        teamInfo = idMatch[1]; // 'player' or 'enemy'
                        characterId = idMatch[2]; // numeric ID
                    }
                }
                
                console.log(`Found ${characterName} element (${teamInfo}_${characterId}), injecting image`);
                
                // Set up the container for images
                circle.classList.add('character-art-container');
                circle.style.backgroundColor = 'transparent'; // Changed to transparent
                circle.style.boxShadow = 'none'; // Removed shadow
                
                // Mark this circle as having art loaded
                circle.dataset.artLoaded = 'true';
                circle.dataset.characterName = characterName;
                if (characterId) circle.dataset.characterId = characterId;
                if (teamInfo) circle.dataset.team = teamInfo;
                
                // Check for cached image in the global cache
                let img;
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[characterName]) {
                    console.log(`Using cached image for ${characterName}`);
                    img = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                } else {
                    // Create a new image if no cache available
                    img = new Image();
                    img.src = this.characterImages[characterName];
                    
                    // Add to global cache for future use
                    if (!window.CHARACTER_IMAGE_CACHE) window.CHARACTER_IMAGE_CACHE = {};
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                }
                
                img.className = 'character-art';
                img.alt = characterName;
                img.dataset.characterName = characterName;
                if (characterId) img.dataset.characterId = characterId;
                if (teamInfo) img.dataset.team = teamInfo;
                
                img.style.width = '80px';
                img.style.height = '120px';
                img.style.objectFit = 'contain';
                img.style.position = 'absolute';
                
                // Look for custom art positioning in the characters data
                let customPositioning = false;
                if (this.charactersData) {
                    // Try to find the character data
                    const characterData = this.charactersData.find(c => c.name === characterName);
                    if (characterData && characterData.art) {
                        console.log(`Found custom art settings for ${characterName}`, characterData.art);
                        // Apply custom positioning
                        if (characterData.art.top) {
                            img.style.top = characterData.art.top;
                            img.dataset.originalTop = characterData.art.top; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.left) {
                            img.style.left = characterData.art.left;
                            img.dataset.originalLeft = characterData.art.left; // Store original for animations
                            customPositioning = true;
                        }
                        if (characterData.art.width) img.style.width = characterData.art.width;
                        if (characterData.art.height) img.style.height = characterData.art.height;
                    }
                }
                
                // Use default positioning only if no custom positioning found
                if (!customPositioning) {
                    img.style.top = '-52px';
                    img.dataset.originalTop = '-52px';
                    img.style.left = '-2px';
                    img.dataset.originalLeft = '-2px';
                }
                
                img.style.zIndex = '10';
                img.style.pointerEvents = 'none';
                
                // Empty the text and add the image
                circle.textContent = '';
                circle.appendChild(img);
            });
        });
    }
};

// Global flag to disable DirectImageLoader during animations
window.disableDirectImageLoader = false;

// Run image injector when DOM is ready
window.addEventListener('load', async function() {
    // Load character data first
    await window.DirectImageLoader.loadCharactersData();
    
    // Wait a bit for battle UI to initialize
    setTimeout(() => {
        window.DirectImageLoader.injectCharacterImages();
    }, 1000);
    
    // Also check periodically for new characters that might appear
    // Use a longer interval (reduced from 3000ms to 5000ms) and check the disable flag
    let intervalId = setInterval(() => {
        if (window.disableDirectImageLoader) {
            console.log('DirectImageLoader: Skipping periodic check (disabled)');
            return;
        }
        window.DirectImageLoader.injectCharacterImages();
    }, 5000);
    
    // Store the interval ID in the DirectImageLoader object
    window.DirectImageLoader.intervalId = intervalId;
});

// Add utility function to temporarily disable the DirectImageLoader during animations
window.disableDirectImageLoaderDuringAnimation = function() {
    window.disableDirectImageLoader = true;
    console.log('DirectImageLoader: Disabled during animation');
    
    // Re-enable after a short delay
    setTimeout(() => {
        window.disableDirectImageLoader = false;
        console.log('DirectImageLoader: Re-enabled after animation');
    }, 2000); // 2 seconds should cover most animations
};

console.log('DirectImageLoader initialized for character art');


===== FILE: ImageDebugger.js =====
/**
 * ImageDebugger.js
 * Utility for debugging image loading issues in the game
 * Debug button removed as character art implementation is now stable
 */


window.ImageDebugger = {
    /**
     * Test loading an image from various paths
     * @param {string} imageName - Base name of the image file (e.g., "Aqualia.png")
     * @returns {Promise<string>} - Promise resolving to the working path or error message
     */
    testImagePaths: async function(imageName) {
        // Set up possible paths to test
        const paths = [
            `./assets/images/Character Art/${imageName}`,
            `/assets/images/Character Art/${imageName}`,
            `assets/images/Character Art/${imageName}`,
            `../assets/images/Character Art/${imageName}`,
            `C:/Personal/AutoBattler/assets/images/Character Art/${imageName}`,
            `../../assets/images/Character Art/${imageName}`
        ];
        
        const results = {};
        
        // Create a div to display loading status in the UI
        const debugDiv = document.createElement('div');
        debugDiv.style.position = 'fixed';
        debugDiv.style.top = '10px';
        debugDiv.style.right = '10px';
        debugDiv.style.backgroundColor = 'rgba(0,0,0,0.8)';
        debugDiv.style.color = 'white';
        debugDiv.style.padding = '10px';
        debugDiv.style.zIndex = '9999';
        debugDiv.style.maxWidth = '400px';
        debugDiv.style.maxHeight = '400px';
        debugDiv.style.overflow = 'auto';
        debugDiv.style.fontFamily = 'monospace';
        debugDiv.style.fontSize = '12px';
        debugDiv.innerHTML = '<h3>Image Path Testing</h3>';
        document.body.appendChild(debugDiv);
        
        // Test each path
        for (const path of paths) {
            const result = await this.testSinglePath(path, debugDiv);
            results[path] = result;
        }
        
        // Add a close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.marginTop = '10px';
        closeButton.style.padding = '5px 10px';
        closeButton.addEventListener('click', () => document.body.removeChild(debugDiv));
        debugDiv.appendChild(closeButton);
        
        // Return the results summary
        return results;
    },
    
    /**
     * Test loading a single image path
     * @param {string} path - Path to test
     * @param {HTMLElement} debugDiv - Debug display element
     * @returns {Promise<string>} - Promise resolving to success or error message
     */
    testSinglePath: function(path, debugDiv) {
        return new Promise((resolve) => {
            const img = new Image();
            const statusElement = document.createElement('div');
            statusElement.innerHTML = `Testing: ${path} <span style="color:yellow">â³</span>`;
            debugDiv.appendChild(statusElement);
            
            // Set a timeout for loading
            const timeout = setTimeout(() => {
                statusElement.innerHTML = `Testing: ${path} <span style="color:orange">âŒ› Timed out after 5s</span>`;
                resolve('Timed out');
            }, 5000);
            
            img.onload = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:green">âœ“ Success (${img.width}x${img.height})</span>`;
                
                // Display the image as thumbnail
                const thumb = document.createElement('img');
                thumb.src = path;
                thumb.style.width = '50px';
                thumb.style.height = '50px';
                thumb.style.objectFit = 'contain';
                thumb.style.marginLeft = '10px';
                statusElement.appendChild(thumb);
                
                resolve('Success');
            };
            
            img.onerror = () => {
                clearTimeout(timeout);
                statusElement.innerHTML = `Testing: ${path} <span style="color:red">âœ— Failed</span>`;
                resolve('Failed');
            };
            
            img.src = path;
        });
    },
    
    // Character-specific debug methods removed as they're no longer needed
};

// Global debug functions removed

console.log('ImageDebugger initialized - debugging UI elements removed.');


===== FILE: TeamBuilderImageLoader.js =====
/**
 * TeamBuilderImageLoader.js
 * Loads and injects character art into the Team Builder UI
 * Based on the existing DirectImageLoader.js functionality
 */

// Create a global cache for character images that persists beyond class instances
window.CHARACTER_IMAGE_CACHE = window.CHARACTER_IMAGE_CACHE || {};

class TeamBuilderImageLoader {
    constructor() {
        this.characterData = null;
        this.processedContainers = new WeakSet(); // Track processed containers to avoid reprocessing
        this.loadedCharacters = new Set(); // Track which characters already have art loaded
        this.cachedImages = new Map(); // NEW: Cache for character images to prevent flickering
        this.checkInterval = 2000; // Check every 2 seconds (reduced frequency)
        this.imageCheckTimer = null;
        this.debugMode = false; // Control logging verbosity
        this.lastProcessTime = Date.now();
        this.characterImages = {
            'Aqualia': 'assets/images/Character Art/Aqualia.png',
            'Drakarion': 'assets/images/Character Art/Drakarion.png',
            'Zephyr': 'assets/images/Character Art/Zephyr.png',
            'Lumina': 'assets/images/Character Art/Lumina.png',
            'Sylvanna': 'assets/images/Character Art/Sylvanna.png',
            'Vaelgor': 'assets/images/Character Art/Vaelgor.png',
            'Caste': 'assets/images/Character Art/Caste.png'
        };
    }

    /**
    * Initialize the image loader
    */
async initialize() {
    console.log('TeamBuilderImageLoader: Initializing...');
    
    // Load character data
    try {
    const response = await fetch('data/characters.json');
    this.characterData = await response.json();
    console.log('TeamBuilderImageLoader: Character data loaded');
    } catch (err) {
    console.error('TeamBuilderImageLoader: Failed to load character data', err);
    this.characterData = { characters: [] }; // Empty fallback
    }
    
    // Start periodic checking for new character elements
    this.startImageCheck();
    
    // Do an initial check with debug enabled
    setTimeout(() => {
    console.log('TeamBuilderImageLoader: Performing initial detailed check...');
    this.forceCheck(true);
    
    // Preload all character images immediately
    this.preloadCharacterImages();
    }, 1000);
}
    
    /**
     * Preload and cache all available character images
     */
    async preloadCharacterImages() {
        console.log('TeamBuilderImageLoader: Preloading all character images...');
        
        // Get all characters that have images defined
        const charactersWithArt = Object.keys(this.characterImages);
        if (charactersWithArt.length === 0) {
            console.warn('TeamBuilderImageLoader: No character images defined');
            return;
        }
        
        // Preload each character's image
        for (const characterName of charactersWithArt) {
            try {
                const imagePath = this.characterImages[characterName];
                if (!imagePath) continue;
                
                console.log(`TeamBuilderImageLoader: Preloading ${characterName}'s image...`);
                
                // Create a new image element
                const img = new Image();
                
                // Set up onload handler
                img.onload = () => {
                    // Store in global cache
                    window.CHARACTER_IMAGE_CACHE[characterName] = img;
                    console.log(`TeamBuilderImageLoader: ${characterName}'s image preloaded and stored in global cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    // Also store in instance cache
                    this.cachedImages.set(characterName, img);
                    this.loadedCharacters.add(characterName);
                };
                
                // Set the source to trigger loading
                img.src = imagePath;
            } catch (err) {
                console.error(`TeamBuilderImageLoader: Error preloading ${characterName}'s image`, err);
            }
        }
    }
    


    /**
     * Start periodically checking for character elements that need art
     */
    startImageCheck() {
        // Clear any existing timer
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
        }
        
        // Set up periodic check - just basic checking, no forced updates
        this.imageCheckTimer = setInterval(() => {
            this.checkAndLoadImages();
        }, this.checkInterval);
        
        // Run an immediate check
        this.checkAndLoadImages();
    }

    /**
     * Check for character elements and load images if needed
     */
    checkAndLoadImages() {
        // Throttle checks to prevent excessive processing
        const now = Date.now();
        if (now - this.lastProcessTime < 500) { // minimum 500ms between full checks
            return;
        }
        this.lastProcessTime = now;
        
        // Find all character containers EXCEPT the detail container
        // We now handle detail container separately to avoid observer issues
        const containers = document.querySelectorAll('.hero-avatar-container:not(.detail-icon-container)');
        
        if (this.debugMode) {
            console.log(`TeamBuilderImageLoader: Checking ${containers.length} avatar containers`);
        }
        
        // First pass: immediately hide all circles where art is available
        containers.forEach(container => {
            const characterName = container.dataset.characterName;
            if (characterName && this.characterImages[characterName]) {
                // This character has art available, immediately hide the circle
                const avatarCircle = container.querySelector('.hero-avatar, .detail-icon');
                if (avatarCircle) {
                    avatarCircle.style.display = 'none';
                    avatarCircle.style.backgroundColor = 'transparent';
                    avatarCircle.textContent = ''; // Clear any letter placeholders
                }
                
                // Add the has-art class to the container for CSS targeting
                container.classList.add('has-art');
            }
        });
        
        // Now process containers that need art
        let artLoadedInThisPass = false;
        
        containers.forEach(container => {
            // Always process detail view containers, otherwise check if already processed
            const isDetailView = container.classList.contains('detail-icon-container');
            if (!isDetailView && this.processedContainers.has(container)) {
                return;
            }
            
            const characterId = container.dataset.characterId;
            const characterName = container.dataset.characterName;
            
            // Skip if no character ID
            if (!characterId) return;
            
            // Process and load art for this character if needed
            if (this.loadCharacterArt(container, characterId, characterName)) {
                artLoadedInThisPass = true;
            }
        });
        
        // Report if we actually loaded art in this pass (helps with debugging)
        if (artLoadedInThisPass && this.debugMode) {
            console.log('TeamBuilderImageLoader: New art was loaded in this check pass');
        }
    }

    /**
     * Load art for a specific character
     * @returns {boolean} Whether new art was loaded
     */
    loadCharacterArt(container, characterId, characterName) {
        // Special handling for character details view
        const isDetailView = container.classList.contains('detail-icon-container');
        
        // If this is the detail view, always process it (even if processed before)
        // This helps ensure the art is always shown in the character details panel
        if (!isDetailView) {
            // For non-detail views, mark container as processed to avoid multiple attempts
            this.processedContainers.add(container);
        }
        
        // Check if this character has art defined
        if (!this.characterImages[characterName]) {
            if (this.debugMode) {
                console.log(`TeamBuilderImageLoader: No art defined for ${characterName}`);
            }
            
            // Don't add placeholders anymore - just return false and let containers be invisible
            return false; // No art defined
        }
        
        // Critical: If character is already loaded, just make sure container is properly styled
        if (this.loadedCharacters.has(characterName)) {
            const artWrapper = container.querySelector('.hero-art-wrapper');
            
            if (artWrapper) {
                artWrapper.style.display = 'block';
                
                // If no inner content in wrapper, we need to add the image
                // (for newly created UI elements)
                if (artWrapper.innerHTML.trim() === '') {
                    this.createAndAddArt(container, characterId, characterName, false);
                    return true; // Consider as new art being added
                }
            }
            
            return false; // No new art loaded
        }
        
        // If we get here, character needs art and hasn't been loaded yet
        return this.createAndAddArt(container, characterId, characterName, true);
    }

    /**
     * Create and add character art to a container
     * @param {HTMLElement} container - The container element
     * @param {string} characterId - Character ID
     * @param {string} characterName - Character name
     * @param {boolean} isFirstLoad - Whether this is the first time loading this character
     * @returns {boolean} Whether the art was successfully added
     */
    async createAndAddArt(container, characterId, characterName, isFirstLoad) {
        // Find character data
        const character = this.findCharacterData(characterId, characterName);
        if (!character) {
            console.log(`TeamBuilderImageLoader: Character data not found for ${characterName}`);
            return false;
        }
        
        // Check if the wrapper exists
        const artWrapper = container.querySelector('.hero-art-wrapper');
        
        if (!artWrapper) {
            console.error('TeamBuilderImageLoader: No art wrapper found for', characterName);
            return false;
        }
        
        // Try to load the image
        try {
            const imagePath = this.characterImages[characterName];
            
            // Check if we already have a cached image for this character
            let img;
            if (this.cachedImages.has(characterName)) {
                // Use the cached image data to create a new image element
                img = this.cachedImages.get(characterName).cloneNode(true);
                console.log(`TeamBuilderImageLoader: Using cached image for ${characterName}`);
            } else {
                // Load the image for the first time
                const imageExists = await this.checkImageExists(imagePath);
                
                if (!imageExists) {
                    console.log(`TeamBuilderImageLoader: No image found for ${characterName}`);
                    return false;
                }
                
                // Create a new image element
                img = document.createElement('img');
                img.src = imagePath;
                img.onload = () => {
                    // Cache the loaded image for future use
                    this.cachedImages.set(characterName, img.cloneNode(true));
                    
                    // Also store in global cache for persistent access
                    window.CHARACTER_IMAGE_CACHE[characterName] = img.cloneNode(true);
                    console.log(`TeamBuilderImageLoader: Added ${characterName} to global image cache`);
                    
                    // Set up mutation observer if not already set up
                    if (typeof window.setupCharacterArtMutationObserver === 'function') {
                        window.setupCharacterArtMutationObserver();
                    }
                    
                    console.log(`TeamBuilderImageLoader: Cached image for ${characterName}`);
                };
            }
            
            // Determine if this is a detail view
            const isDetailView = container.classList.contains('detail-icon-container');
            
            // Use teamBuilderArt if available, otherwise fall back to regular art
            let artSettings;
            
            if (isDetailView) {
                // For detail view, use special positioning
                artSettings = character.detailArt || character.teamBuilderArt || character.art || {};
                
                // If no specific settings, use these defaults for detail view
                if (!artSettings.left) artSettings.left = '-30px';
                if (!artSettings.top) artSettings.top = '-45px';
                if (!artSettings.width) artSettings.width = '140px';
                if (!artSettings.height) artSettings.height = '140px';
            } else {
                // Regular view
                artSettings = character.teamBuilderArt || character.art || {};
            }
            
            // Set image properties
            img.className = 'character-art team-builder-art';
            img.alt = characterName;
            
            // Apply position settings
            img.style.position = 'absolute';
            img.style.left = artSettings.left || '0px';
            img.style.top = artSettings.top || '0px';
            
            if (artSettings.width) {
                img.style.width = artSettings.width;
            }
            
            if (artSettings.height) {
                img.style.height = artSettings.height;
            }
            
            // Store original positions for animation handling
            img.dataset.originalLeft = artSettings.left || '0px';
            img.dataset.originalTop = artSettings.top || '0px';
            
            // PRESERVE EXISTING ART: Check if art already exists before replacing
            const existingArt = artWrapper.querySelector('.character-art');
            if (!existingArt) {
                // Only clear and add if there's no existing art
                artWrapper.innerHTML = '';
                artWrapper.appendChild(img);
            }
            
            artWrapper.style.display = 'block';
            
            // Set all parent elements with appropriate classes
            container.classList.add('has-art'); // Mark container as having art
            
            // Add has-art to the parent card/content element if it exists
            const heroCard = container.closest('.hero-card');
            if (heroCard) heroCard.classList.add('has-art');
            
            const slotContent = container.closest('.slot-content');
            if (slotContent) slotContent.classList.add('has-art');
            
            const detailHero = container.closest('.detail-hero');
            if (detailHero) detailHero.classList.add('has-art');
            
            // Record that we've loaded this character's art
            // This is important to avoid reloading across different containers
            this.loadedCharacters.add(characterName);
            
            // Always log for detail view to help track issues
            if (isFirstLoad || isDetailView) {
                console.log(`TeamBuilderImageLoader: Loaded art for ${characterName}${isDetailView ? ' (detail view)' : ''}`);
            }
            
            return true;
        } catch (err) {
            console.error(`TeamBuilderImageLoader: Error loading art for ${characterName}`, err);
            return false;
        }
    }

    /**
     * Find character data by ID or name
     */
    findCharacterData(id, name) {
        if (!this.characterData || !this.characterData.characters) {
            return null;
        }
        
        // Try to find by ID first
        let character = this.characterData.characters.find(c => c.id == id);
        
        // Fall back to finding by name
        if (!character && name) {
            character = this.characterData.characters.find(c => 
                c.name.toLowerCase() === name.toLowerCase()
            );
        }
        
        return character;
    }

    /**
     * Manually trigger a check for new images and reset processing cache
     * @param {boolean} debug - Enable debug output
     * @param {boolean} resetCache - Whether to reset the processed containers cache
     */
    forceCheck(debug = false, resetCache = false) {
        // Temporarily enable debug mode if requested
        const prevDebugMode = this.debugMode;
        this.debugMode = debug;
        
        if (debug) {
            console.log("TeamBuilderImageLoader: Force checking images");
        }
        
        // Reset the processed containers cache if requested
        // This will force reprocessing of all containers
        if (resetCache) {
            if (debug) {
                console.log("TeamBuilderImageLoader: Resetting processed containers cache");
            }
            this.processedContainers = new WeakSet();
            this.loadedCharacters = new Set();
        }
        
        // Check for new images
        this.checkAndLoadImages();
        
        // Restore previous debug mode
        this.debugMode = prevDebugMode;
    }

    /**
     * Check if an image exists
     */
    async checkImageExists(imagePath) {
        try {
            const response = await fetch(imagePath, { method: 'HEAD' });
            return response.ok;
        } catch (err) {
            return false;
        }
    }

    /**
     * Clean up resources
     */
    destroy() {
        if (this.imageCheckTimer) {
            clearInterval(this.imageCheckTimer);
            this.imageCheckTimer = null;
        }
    }
}

// Export the class
// Create DOM observer to ensure character art is never removed
window.setupCharacterArtMutationObserver = function() {
    // First, completely disconnect any existing observer to ensure clean slate
    if (window.characterArtObserver) {
        window.characterArtObserver.disconnect();
        window.characterArtObserver = null;
        console.log('Reset existing character art observer');
    }
    
    console.log('Setting up character art mutation observer');
    
    // Static flag to completely disable observer when needed
    window.observerDisabled = false;
    
    // Throttling variable
    let throttleId = null;
    // Boolean flag to prevent re-entrance
    let isRestoring = false;
    
    // Create a mutation observer to watch for DOM changes
    window.characterArtObserver = new MutationObserver(function(mutations) {
        // Skip if globally disabled or already processing or throttled
        if (window.observerDisabled || isRestoring || throttleId) return;
        
        // Check if any mutation is directly affecting a detail container
        // If so, skip processing entirely
        const shouldSkip = mutations.some(mutation => {
            return mutation.target.closest('.detail-icon-container') !== null;
        });
        
        if (shouldSkip) return;
        
        // Set up throttling with requestAnimationFrame instead of setTimeout
        if (throttleId) return; // already scheduled
        
        throttleId = requestAnimationFrame(() => {
            try {
                // Set isRestoring flag to prevent re-entrance
                isRestoring = true;
                
                // Temporarily disconnect the observer to prevent self-triggering
                window.characterArtObserver.disconnect();
                
                // Use a flag to track if we did any art restoration
                let didRestoreArt = false;
                
                // Process mutations
                mutations.forEach(function(mutation) {
                    // Only process if we have element changes and not in a detail container
                    if ((mutation.type === 'childList' || mutation.type === 'attributes') && 
                        !mutation.target.closest('.detail-icon-container')) {
                        
                        // Check for any character containers that are missing their art
                        // EXPLICITLY EXCLUDE the detail-icon-container to avoid any processing
                        document.querySelectorAll('.hero-avatar-container[data-character-name]:not(.detail-icon-container)').forEach(container => {
                            const characterName = container.dataset.characterName;
                            
                            // Only process if we have this character in our cache
                            if (window.CHARACTER_IMAGE_CACHE[characterName]) {
                                // EARLY EXIT: Skip if art already present
                                if (container.querySelector('.character-art')) return;
                                
                                // EARLY EXIT: Skip if already synced in this animation frame
                                if (container.dataset.artSynced === '1') return;
                                container.dataset.artSynced = '1';
                                
                                // Check if art wrapper exists
                                const artWrapper = container.querySelector('.hero-art-wrapper');
                                
                                // Clean any duplicate arts before proceeding
                                if (artWrapper) {
                                    const extraArts = artWrapper.querySelectorAll('.character-art:not(:first-child)');
                                    extraArts.forEach(el => el.remove());
                                }
                                
                                // If art wrapper is missing, create it
                                let wrapper = artWrapper;
                                if (!wrapper) {
                                    wrapper = document.createElement('div');
                                    wrapper.className = 'hero-art-wrapper';
                                    wrapper.style.display = 'block';
                                    container.appendChild(wrapper);
                                }
                                
                                // Clone from global cache and add
                                const newImg = window.CHARACTER_IMAGE_CACHE[characterName].cloneNode(true);
                                newImg.style.visibility = 'visible';
                                newImg.style.display = 'block';
                                wrapper.appendChild(newImg);
                                
                                // Force proper class hierarchy
                                container.classList.add('has-art');
                                
                                // Add has-art to parent elements
                                const heroCard = container.closest('.hero-card');
                                if (heroCard) heroCard.classList.add('has-art');
                                
                                const slotContent = container.closest('.slot-content');
                                if (slotContent) slotContent.classList.add('has-art');
                                
                                // Track successful restoration
                                const added = true; // Flag to track if we actually added art
                                if (added) console.log(`Restored art for ${characterName}`);
                                didRestoreArt = true;
                            }
                        });
                    }
                });
                
                // Only log if we actually did something
                if (didRestoreArt) {
                    console.log('Observer restored art for some characters');
                }
            } finally {
                // Reset throttle ID
                throttleId = null;
                // Reset isRestoring flag
                isRestoring = false;
                
                // Reconnect the observer after processing
                if (!window.observerDisabled) {
                    // Reconnect only to the targeted containers
                    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
                    targets.forEach(t => window.characterArtObserver.observe(t, {
                        childList: true,
                        subtree: true,
                        attributes: true
                    }));
                }
            }
        }, 50); // Increase throttle to 50ms for more stability
    });

    // Observe only the grids that actually recycle DOM
    const targets = document.querySelectorAll('#heroes-grid, #team-slots');
    targets.forEach(t => window.characterArtObserver.observe(t, {
        childList: true, // Watch for added/removed nodes
        subtree: true,   // Watch the entire subtree
        attributes: true // Watch for attribute changes
    }));
};

// Utility to temporarily disable observer during complex DOM operations
window.disableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = true;
        window.characterArtObserver.disconnect();
        console.log('Character art observer disabled');
    }
};

// Utility to re-enable observer
window.enableArtObserver = function() {
    if (window.characterArtObserver) {
        window.observerDisabled = false;
        // Observe only the necessary containers
        const targets = document.querySelectorAll('#heroes-grid, #team-slots');
        targets.forEach(t => window.characterArtObserver.observe(t, {
            childList: true,
            subtree: true,
            attributes: true
        }));
        console.log('Character art observer re-enabled');
    }
};

window.TeamBuilderImageLoader = TeamBuilderImageLoader;

