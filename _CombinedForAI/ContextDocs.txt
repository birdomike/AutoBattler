

===== FILE: Enhanced Turn Highlighting - Current Implementation.md =====
# Enhanced Turn Highlighting - Current Implementation

## Overview

The Enhanced Turn Highlighting system visually indicates which character is currently taking their action during battle by displaying a team-colored floor marker beneath that character. This creates a dynamic visual cue that helps players track the flow of actions within each turn.

## Core Files

1. **TurnIndicator.js** (`C:\Personal\AutoBattler\js\phaser\components\battle\TurnIndicator.js`)
   - Dedicated component that explicitly handles the turn indicator visuals
   - Creates and animates the flattened ellipse floor marker
   - Controls size, color, animation, and visibility of the indicator
   - Centralizes all turn highlighting visual logic in one component

2. **TeamContainer.js** (`C:\Personal\AutoBattler\js\phaser\components\battle\TeamContainer.js`)
   - Contains `showTurnIndicator()` and `clearTurnIndicators()` methods
   - Manages which character within the team should display the indicator
   - Calls the appropriate character's highlight/unhighlight methods

3. **CharacterSprite.js** (`C:\Personal\AutoBattler\js\phaser\components\battle\CharacterSprite.js`)
   - Contains stub `highlight()` and `unhighlight()` methods
   - These methods now delegate to TurnIndicator.js rather than implementing the visuals directly
   - Provides backward compatibility with the previous implementation

4. **BattleScene.js** (`C:\Personal\AutoBattler\js\phaser\scenes\BattleScene.js`)
   - Contains the handler method `updateActiveCharacterVisuals(characterData)`
   - Listens for CHARACTER_ACTION events from the core battle logic via BattleBridge

5. **BattleFlowController.js** (`C:\Personal\AutoBattler\js\battle_logic\core\BattleFlowController.js`)
   - Dispatches the CHARACTER_ACTION event via BattleBridge
   - Triggers the event immediately before a character's action is applied in `executeNextAction()`

## How It Works

1. During a battle turn, `BattleFlowController.executeNextAction()` determines which character (`action.actor`) is about to perform an action.

2. `BattleFlowController` dispatches a CHARACTER_ACTION event via BattleBridge, including the `action.actor` data.

3. `BattleScene` receives this CHARACTER_ACTION event and calls `updateActiveCharacterVisuals(characterData)`.

4. The handler extracts the currently acting character's data from the event.

5. The handler calls `clearTurnIndicators()` on both the player and enemy TeamContainer instances. This hides the indicator from the previously acting character.

6. The handler identifies the correct TeamContainer for the currently acting character and calls its `showTurnIndicator()` method, passing the character's identifier.

7. `TeamContainer.showTurnIndicator()` finds the corresponding CharacterSprite instance for the acting character and calls its `highlight()` method.

8. `CharacterSprite.highlight()` delegates to TurnIndicator, which creates and displays the visual floor marker and starts its animation.

9. This process repeats each time a CHARACTER_ACTION event is dispatched for the next character in the turn sequence.

## Visual Components

The turn indicator is now implemented as a single component in TurnIndicator.js:

- **Floor Marker**: A flattened, team-colored ellipse positioned beneath the character
- **Animation**: A pulsing effect achieved through alpha tweening
- **Team-Based Colors**: Blue for player team, red for enemy team

The highlight is now a flat ellipse rendered by Phaser's graphics/ellipse objects, positioned to appear as if it is on the ground beneath the character.

## Tweakable Values

The following key parameters can be adjusted in TurnIndicator.js:

### Size and Shape
```javascript
// Controls the width of the ellipse (current value: 56)
const radius = 56; 

// Controls the height as a ratio of width (current value: 0.27)
this.fillEllipse(0, 0, radius, radius * 0.27);
```

### Position Fine-Tuning
```javascript
// Default vertical offset - adjust to move indicator up/down (current value: -8)
showAt(x, y, color, duration = 300, offsetY = -8)
```

### Visual Appearance
```javascript
// Base opacity of the ellipse (current value: 0.9)
this.fillStyle(color, 0.9);

// Team colors (blue for player, red for enemy)
// These are passed from TeamContainer
```

### Animation Settings
```javascript
// Animation parameters (pulsing effect)
this.fadeTween = this.scene.tweens.add({
    targets: this,
    alpha: { from: 0.3, to: 0.7 }, // Alpha range for pulsing
    duration: 1200,                // Animation duration in ms
    ease: 'Sine.easeInOut',        // Animation easing function
    yoyo: true,                    // Makes animation reverse
    repeat: -1                     // Infinite repetition
});
```

## Evolution History

The turn highlighting system has evolved significantly over time:

1. **Original Version**: Used a bright yellow pulsing circle.
2. **Version 0.5.1.9**: Added 3D effect with shadow and team colors.
3. **Version 0.5.2.0**: Improved positioning relative to character feet.
4. **Version 0.5.2.1**: Adjusted vertical positioning (-17px offset).
5. **Version 0.5.2.3**: Fixed rendering issues by replacing Graphics with Ellipse.
6. **Version 0.5.2.4**: Improved shape for better 3D appearance (wider/flatter).
7. **Version 0.5.2.5**: Reduced size by 50% to fit between health bar and feet.
8. **Fix (v0.5.24c)**: Changed trigger from TURN_STARTED to CHARACTER_ACTION for correct highlighting.
9. **Version 0.6.2.5**: Moved implementation from CharacterSprite to TurnIndicator.
10. **Version 0.6.2.6**: Removed shadow for a cleaner, simpler appearance.
11. **Latest**: Reduced size by 25% while maintaining proportions.

## Future Considerations

If further adjustments are needed:

- For better visibility, increase the base opacity or animation alpha range values
- For better size/proportions, adjust the radius and height ratio
- For better positioning, fine-tune the offsetY parameter when calling showAt()
- For different appearance, consider alternative animation patterns or shape configurations

## Implementation Benefits

The current implementation offers several advantages:

1. **Separation of Concerns**: TurnIndicator.js now explicitly controls all turn indicator functionality
2. **Simplified Maintenance**: Visual tweaks only need to be made in one file
3. **Cleaner Code**: Removed duplicate highlighting code from CharacterSprite
4. **Consistent Styling**: All turn indicators share the same visual implementation
5. **Simpler Visual Design**: Removed shadow for a cleaner, more streamlined look


===== FILE: HowStuffWorks_BattleEventDispatcher.md =====
# How The Battle Event System Works

*As of **Version 0.5.28.1 - BattleEventDispatcher Implementation (Phase 3)***

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Event Flow](#event-flow)
4. [Component Integration](#component-integration)
5. [Event Types and Structure](#event-types-and-structure)
6. [Implementation Details](#implementation-details)
7. [Usage Examples](#usage-examples)
8. [Error Handling](#error-handling)
9. [Future Directions](#future-directions)

## Overview

The Battle Event System is a core communication infrastructure that enables different components of the AutoBattler game to communicate without direct dependencies. It follows a mediator pattern, allowing battle-related events (damage, healing, actions, etc.) to flow from the core battle logic to various UI components and other systems through a standardized interface.

Prior to version 0.5.28.1, battle events were dispatched directly through the `battleBridge` global object, requiring components to know about this specific implementation and leading to inconsistent event structures. The new system introduces the `BattleEventDispatcher` as a dedicated component for handling all event dispatching with improved validation, standardization, and error handling, while maintaining backward compatibility.

## Architecture

The battle event system uses a layered architecture with clear separation of concerns:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   â”‚     â”‚                    â”‚     â”‚                â”‚     â”‚                  â”‚
â”‚  Battle Logic     â”‚â”€â”€â”€â”€â–¶â”‚  BattleManager     â”‚â”€â”€â”€â”€â–¶â”‚  Event         â”‚â”€â”€â”€â”€â–¶â”‚  UI Components   â”‚
â”‚  Components       â”‚     â”‚  (Facade Methods)  â”‚     â”‚  Dispatcher    â”‚     â”‚  (Listeners)     â”‚
â”‚                   â”‚     â”‚                    â”‚     â”‚                â”‚     â”‚                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                           â–²                        â”‚                        â–²
        â”‚                           â”‚                        â”‚                        â”‚
        â”‚                           â”‚                        â”‚                        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             Direct Component                                    UI Event
             Communication                                       Consumption
                                                                 
```

### Key Components

1. **BattleEventDispatcher** (`js/battle_logic/events/BattleEventDispatcher.js`)
   - Centralized event dispatching component
   - Validates event data before dispatching
   - Standardizes event structures
   - Provides specialized methods for common event types

2. **BattleManager** (`js/managers/BattleManager.js`)
   - Contains facade methods that delegate to the dispatcher
   - Provides fallback mechanisms when the dispatcher isn't available
   - Coordinates between game logic and event system

3. **BattleBridge** (`js/phaser/bridge/BattleBridge.js`)
   - Underlying event bus that BattleEventDispatcher uses
   - Maintains listeners and handles final event delivery
   - Links the core battle logic with Phaser UI components

4. **UI Components** (Various Phaser components)
   - Register as listeners for specific event types
   - Update visuals in response to game state changes communicated via events

## Event Flow

Events flow through the system in a specific sequence:

1. **Origination**: A battle logic component (e.g., DamageCalculator) needs to notify the system about an event (e.g., character taking damage)

2. **Facade Method Call**:
   ```javascript
   // Component calls the appropriate facade method on BattleManager
   this.battleManager.dispatchDamageEvent(target, damage, source, ability);
   ```

3. **Event Dispatching**:
   - BattleManager delegates to BattleEventDispatcher
   - BattleEventDispatcher validates and standardizes the event data
   - BattleEventDispatcher dispatches the event to battleBridge

4. **Event Propagation**:
   - BattleBridge delivers the event to all registered listeners
   - Listeners update UI or trigger game logic in response

5. **Response Handling**: Any component that needs to react to the event does so through its registered listener

### Example Flow: Character Damage

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚     â”‚                 â”‚     â”‚                      â”‚
â”‚ DamageCalculatorâ”‚     â”‚ BattleManager   â”‚     â”‚ BattleEventDispatcherâ”‚
â”‚                 â”‚     â”‚                 â”‚     â”‚                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                         â”‚
         â”‚ applyDamage()         â”‚                         â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶                         â”‚
         â”‚                       â”‚                         â”‚
         â”‚                       â”‚ dispatchDamageEvent()   â”‚
         â”‚                       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
         â”‚                       â”‚                         â”‚
         â”‚                       â”‚                         â”‚ validate data
         â”‚                       â”‚                         â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
         â”‚                       â”‚                         â”‚
         â”‚                       â”‚                         â”‚ dispatch to battleBridge
         â”‚                       â”‚                         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚                         â”‚                           â”‚
         â”‚                       â”‚                         â”‚                           â–¼
         â”‚                       â”‚                         â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚                         â”‚             â”‚                     â”‚
         â”‚                       â”‚                         â”‚             â”‚ BattleBridge        â”‚
         â”‚                       â”‚                         â”‚             â”‚                     â”‚
         â”‚                       â”‚                         â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                         â”‚                        â”‚
         â”‚                       â”‚                         â”‚                        â”‚ notify listeners
         â”‚                       â”‚                         â”‚                        â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚                         â”‚                        â”‚               â”‚
         â”‚                       â”‚                         â”‚                        â”‚               â–¼
         â”‚                       â”‚                         â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚                         â”‚             â”‚                          â”‚
         â”‚                       â”‚                         â”‚             â”‚ UI Components            â”‚
         â”‚                       â”‚                         â”‚             â”‚ (CharacterSprite, etc.) â”‚
         â”‚                       â”‚                         â”‚             â”‚                          â”‚
         â”‚                       â”‚                         â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                         â”‚
```

## Component Integration

### BattleEventDispatcher

The BattleEventDispatcher initializes with a reference to BattleManager and creates a standardized interface for all battle events:

```javascript
class BattleEventDispatcher {
    constructor(battleManager) {
        this.battleManager = battleManager;
        this.initialized = false;
        this.eventListeners = new Map(); // Store custom event listeners
        
        // Reference to battleBridge event types
        this.eventTypes = window.battleBridge?.eventTypes || this.getDefaultEventTypes();
        
        // Verify battleBridge availability
        if (window.battleBridge) {
            this.initialized = true;
            console.log("[BattleEventDispatcher] Initialized with battleBridge");
        } else {
            console.warn("[BattleEventDispatcher] battleBridge not found - events may not dispatch correctly");
        }
    }
    
    // Core methods and specialized event methods...
}
```

### BattleManager Integration

BattleManager initializes the BattleEventDispatcher during component initialization:

```javascript
async initializeComponentManagers() {
    // ... other components initialization
    
    // Initialize event dispatcher (Stage 7)
    if (window.BattleEventDispatcher) {
        this.battleEventDispatcher = new window.BattleEventDispatcher(this);
        console.log('BattleManager: BattleEventDispatcher initialized');
        
        // Verify methods exist
        console.log('>>> BattleEventDispatcher instance check:', {
            dispatchEvent: typeof this.battleEventDispatcher.dispatchEvent === 'function',
            dispatchCharacterDamagedEvent: typeof this.battleEventDispatcher.dispatchCharacterDamagedEvent === 'function',
            dispatchCharacterHealedEvent: typeof this.battleEventDispatcher.dispatchCharacterHealedEvent === 'function'
        });
    }
    
    // ... more components initialization
}
```

And provides facade methods that delegate to the dispatcher:

```javascript
dispatchDamageEvent(target, amount, source = null, ability = null) {
    // Direct delegation - no toggle mechanism
    if (this.battleEventDispatcher) {
        return this.battleEventDispatcher.dispatchCharacterDamagedEvent(target, amount, source, ability);
    }
    
    // Minimal fallback
    console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch damage event`);
    
    // Try direct battleBridge as last resort
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
                character: target,
                target: target,
                amount: amount,
                source: source,
                ability: ability,
                newHealth: target.currentHp,
                maxHealth: target.stats.hp
            });
            return true;
        } catch (error) {
            console.error(`[BattleManager] Error dispatching damage event:`, error);
        }
    }
    
    return false;
}
```

### Battle Logic Components

Components like DamageCalculator, HealingProcessor, AbilityProcessor, and BattleFlowController use these facade methods:

```javascript
// In DamageCalculator.js
applyDamage(target, amount, source, ability, damageType) {
    // ... damage application logic
    
    // Dispatch damage event
    if (this.battleManager.dispatchDamageEvent) {
        // Use the new facade method
        this.battleManager.dispatchDamageEvent(target, actualDamage, source, ability);
    } else if (window.battleBridge && actualDamage > 0) {
        // Fallback to direct battleBridge call if facade not available
        try {
            window.battleBridge.dispatchEvent(/* ... */);
        } catch (error) {
            console.error('[DamageCalculator] Error dispatching CHARACTER_DAMAGED event:', error);
        }
    }
    
    // ... return result
}
```

## Event Types and Structure

The battle system uses a consistent set of event types, defined in the BattleEventDispatcher:

```javascript
getDefaultEventTypes() {
    return {
        BATTLE_INITIALIZED: 'battle_initialized',
        BATTLE_STARTED: 'battle_started',
        BATTLE_ENDED: 'battle_ended',
        TURN_STARTED: 'turn_started',
        TURN_ENDED: 'turn_ended',
        CHARACTER_ACTION: 'character_action',
        CHARACTER_DAMAGED: 'character_damaged',
        CHARACTER_HEALED: 'character_healed',
        CHARACTER_DEFEATED: 'character_defeated',
        STATUS_EFFECT_APPLIED: 'status_effect_applied',
        STATUS_EFFECT_REMOVED: 'status_effect_removed',
        STATUS_EFFECT_UPDATED: 'status_effect_updated',
        STATUS_EFFECTS_CHANGED: 'status_effects_changed',
        ABILITY_USED: 'ability_used',
        PASSIVE_TRIGGERED: 'passive_triggered',
        BATTLE_UI_INTERACTION: 'battle_ui_interaction',
        BATTLE_LOG: 'battle_log'
    };
}
```

### Core Event Structures

Each event type has a standardized structure:

#### CHARACTER_DAMAGED Event
```javascript
{
    character: target,          // The character taking damage
    target: target,             // Same as character (for backward compatibility)
    newHealth: target.currentHp, // Updated health value
    maxHealth: target.stats.hp, // Maximum health
    amount: actualDamage,       // Damage amount
    source: source,             // Character causing the damage
    ability: ability            // Ability used (if applicable)
}
```

#### CHARACTER_HEALED Event
```javascript
{
    character: target,          // The character being healed
    target: target,             // Same as character (for backward compatibility)
    newHealth: target.currentHp, // Updated health value
    maxHealth: target.stats.hp, // Maximum health
    amount: healAmount,         // Healing amount
    source: source,             // Character causing the healing
    ability: ability            // Ability used (if applicable)
}
```

#### CHARACTER_ACTION Event
```javascript
{
    character: character,       // The character performing the action
    action: action              // The action data (ability, target, etc.)
}
```

#### BATTLE_ENDED Event
```javascript
{
    winner: result,             // 'player', 'enemy', or 'draw'
    result: result,             // Same as winner (for backward compatibility)
    reason: reason              // Reason for battle end
}
```

## Implementation Details

### Specialized Event Methods

The BattleEventDispatcher provides specialized methods for common event types:

```javascript
// Dispatch a battle log message event
dispatchBattleLogEvent(message, type = 'default') {
    return this.dispatchEvent(this.eventTypes.BATTLE_LOG || 'battle_log', {
        message,
        type
    });
}

// Dispatch a character damaged event
dispatchCharacterDamagedEvent(target, amount, source = null, ability = null) {
    // Validate parameters
    if (!target) {
        console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_DAMAGED: target is missing");
        return false;
    }
    
    // ... validation and event construction
    
    return this.dispatchEvent(this.eventTypes.CHARACTER_DAMAGED || 'character_damaged', {
        character: target,
        target: target,
        newHealth: target.currentHp,
        maxHealth: target.stats?.hp || 100,
        amount,
        source,
        ability
    });
}
```

### Parameter Validation

The dispatcher performs comprehensive parameter validation:

```javascript
dispatchEvent(eventType, eventData) {
    // Parameter validation
    if (!eventType) {
        console.error("[BattleEventDispatcher] Invalid event type: null or undefined");
        return false;
    }
    
    if (!eventData || typeof eventData !== 'object') {
        console.warn("[BattleEventDispatcher] Event data should be an object, using empty object instead");
        eventData = {};
    }
    
    // ... event dispatching
}
```

### Local Event Listeners

The dispatcher supports local event listeners for component-specific events:

```javascript
// Add an event handler for a specific event type
addEventHandler(eventType, handler) {
    if (!eventType || typeof handler !== 'function') {
        console.error("[BattleEventDispatcher] Invalid eventType or handler");
        return false;
    }
    
    if (!this.eventListeners.has(eventType)) {
        this.eventListeners.set(eventType, []);
    }
    
    this.eventListeners.get(eventType).push(handler);
    return true;
}

// Remove an event handler
removeEventHandler(eventType, handler) {
    if (!eventType || !this.eventListeners.has(eventType)) {
        return false;
    }
    
    const listeners = this.eventListeners.get(eventType);
    const index = listeners.indexOf(handler);
    
    if (index !== -1) {
        listeners.splice(index, 1);
        return true;
    }
    
    return false;
}

// Notify all listeners for a specific event type
notifyListeners(eventType, eventData) {
    if (!this.eventListeners.has(eventType)) {
        return;
    }
    
    const listeners = this.eventListeners.get(eventType);
    listeners.forEach(handler => {
        try {
            handler(eventData);
        } catch (error) {
            console.error(`[BattleEventDispatcher] Error in event handler for ${eventType}:`, error);
        }
    });
}
```

### Fallback Mechanisms

The system implements robust fallbacks at multiple levels:

1. **BattleEventDispatcher Fallbacks**:
   - Falls back to default event types if battleBridge.eventTypes is unavailable
   - Handles errors in local event listeners

2. **BattleManager Facade Fallbacks**:
   - Falls back to direct battleBridge calls if the dispatcher is unavailable
   - Provides clear error messages for troubleshooting

3. **Component-Level Fallbacks**:
   - Components check for both the facade method and direct battleBridge as options
   - Implement appropriate error handling in both paths

## Usage Examples

### Dispatching Damage Events

```javascript
// From DamageCalculator.js
if (this.battleManager.dispatchDamageEvent) {
    // Use the new facade method
    this.battleManager.dispatchDamageEvent(target, actualDamage, source, ability);
} else if (window.battleBridge && actualDamage > 0) {
    // Fallback to direct battleBridge call
    try {
        window.battleBridge.dispatchEvent(
            window.battleBridge.eventTypes.CHARACTER_DAMAGED, 
            {
                character: target,
                target: target,
                newHealth: target.currentHp,
                maxHealth: target.stats.hp,
                amount: actualDamage,
                source: source,
                ability: ability
            }
        );
    } catch (error) {
        console.error('[DamageCalculator] Error dispatching CHARACTER_DAMAGED event:', error);
    }
}
```

### Dispatching Healing Events

```javascript
// From HealingProcessor.js
if (this.battleManager.dispatchHealingEvent && actualHealing > 0) {
    this.battleManager.dispatchHealingEvent(target, actualHealing, source, ability);
} else if (window.battleBridge && actualHealing > 0) {
    try {
        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_HEALED, {
            character: target, 
            target: target,
            newHealth: target.currentHp, 
            maxHealth: target.stats.hp,
            amount: actualHealing, 
            source: source, 
            ability: ability
        });
    } catch (error) {
        console.error('[HealingProcessor] Error dispatching CHARACTER_HEALED event:', error);
    }
}
```

### Dispatching Battle Start/End Events

```javascript
// From BattleFlowController.js - Battle Start
if (this.battleManager.dispatchBattleEvent) {
    // Use the facade method
    this.battleManager.dispatchBattleEvent(
        window.battleBridge?.eventTypes.BATTLE_STARTED || 'battle_started', 
        { playerTeam, enemyTeam }
    );
} else if (window.battleBridge) {
    // Fallback to direct call
    try {
        window.battleBridge.dispatchEvent(
            window.battleBridge.eventTypes.BATTLE_STARTED, 
            { playerTeam, enemyTeam }
        );
    } catch (error) {
        console.error('[BattleFlowController] Error dispatching BATTLE_STARTED event:', error);
    }
}

// From BattleFlowController.js - Battle End
if (this.battleManager.dispatchBattleEndEvent) {
    this.battleManager.dispatchBattleEndEvent(result, 'standard');
} else if (window.battleBridge) {
    try {
        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_ENDED, {
            result: result,
            winner: result,
            playerTeam: this.battleManager.playerTeam,
            enemyTeam: this.battleManager.enemyTeam
        });
    } catch (error) {
        console.error("[BattleFlowController] Error dispatching battle end event:", error);
    }
}
```

## Error Handling

The battle event system implements comprehensive error handling across all levels:

### 1. Component-Level Error Handling

```javascript
// In components like DamageCalculator
try {
    window.battleBridge.dispatchEvent(/* ... */);
} catch (error) {
    console.error('[DamageCalculator] Error dispatching CHARACTER_DAMAGED event:', error);
}
```

### 2. Dispatcher-Level Error Handling

```javascript
// In BattleEventDispatcher.js
dispatchEvent(eventType, eventData) {
    // ... validation and listener notification
    
    // Then dispatch via battleBridge if available
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(eventType, eventData);
            return true;
        } catch (error) {
            console.error(`[BattleEventDispatcher] Error dispatching ${eventType} via battleBridge:`, error);
        }
    }
    
    return false;
}
```

### 3. Facade-Level Error Handling

```javascript
// In BattleManager.js
dispatchDamageEvent(target, amount, source = null, ability = null) {
    // ... dispatcher delegation
    
    // Try direct battleBridge as last resort
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(/* ... */);
            return true;
        } catch (error) {
            console.error(`[BattleManager] Error dispatching damage event:`, error);
        }
    }
    
    return false;
}
```

### 4. Local Listener Error Handling

```javascript
// In BattleEventDispatcher.js
notifyListeners(eventType, eventData) {
    // ... get listeners
    
    listeners.forEach(handler => {
        try {
            handler(eventData);
        } catch (error) {
            console.error(`[BattleEventDispatcher] Error in event handler for ${eventType}:`, error);
        }
    });
}
```

## Future Directions

As the battle event system continues to evolve, several enhancements are planned:

1. **Enhanced Event Validation**:
   - Add more specific validation for each event type
   - Implement schema validation for event structure
   - Add runtime type checking for critical properties

2. **Event Diagnostics**:
   - Add event tracking and diagnostic tools
   - Implement event logging for debugging
   - Create event visualization for development

3. **Performance Optimization**:
   - Profile event dispatch performance
   - Implement batched event dispatching for high-frequency events
   - Optimize memory usage with event pooling

4. **Developer Tools**:
   - Create event monitoring interface
   - Implement event replay for bug reproduction
   - Add event filtering for focused debugging

5. **Additional Specialized Event Types**:
   - Expand event types for more game mechanics
   - Add specialized dispatchers for new systems
   - Implement hierarchical event structure

---

## Conclusion

The Battle Event System is a critical communication infrastructure that allows the game's components to interact without tight coupling. With the introduction of the BattleEventDispatcher in Version 0.5.28.1, the system now provides standardized event dispatching with improved validation, error handling, and backward compatibility.

By following the patterns and practices outlined in this guide, developers can effectively use the battle event system to communicate between components while maintaining clean separation of concerns and robust error handling.


===== FILE: HowStuffWorks_PhaserPositioning.md =====
# How Positioning Works in Phaser: A Technical Guide for AutoBattler

## 1. Introduction

### Why Understanding Positioning is Critical

Positioning elements correctly is one of the most fundamental yet challenging aspects of game UI development. In our AutoBattler game, proper positioning affects:

- Character placement on the battlefield
- Visual elements like action indicators, health bars, and floating damage text
- Animations between game objects
- The overall player experience

This document exists because of lessons learned from fixing positioning issues such as the Action Indicator bug (v0.6.3.12), where ability names would appear at the top left of the screen instead of above the character. Understanding these concepts will help prevent similar issues in future development.

## 2. Phaser's Display Object Hierarchy

### The Scene Graph Concept

Phaser, like most game engines, uses a "scene graph" to organize game objects in a hierarchical tree structure. This hierarchy fundamentally affects how positioning works.

```
Scene
â”‚
â”œâ”€â”€ Container A
â”‚   â”œâ”€â”€ Sprite 1
â”‚   â”œâ”€â”€ Text 1
â”‚   â””â”€â”€ Container B
â”‚       â”œâ”€â”€ Sprite 2
â”‚       â””â”€â”€ Text 2
â”‚
â””â”€â”€ Container C
    â””â”€â”€ Sprite 3
```

### Key Properties of the Scene Graph

- **Transformations cascade downward**: If you move Container A, all its children (Sprite 1, Text 1, and Container B with its children) move as well.
- **Local coordinates are relative**: Each object's position is defined relative to its parent, not to the scene.
- **Origin affects positioning**: The origin (pivot point) of an object affects how position and rotation are applied.

### In AutoBattler Terms

Our battle scene has a structure like:

```
BattleScene
â”‚
â”œâ”€â”€ TeamContainer (Player)
â”‚   â”œâ”€â”€ CharacterSprite 1
â”‚   â”‚   â”œâ”€â”€ Background Circle
â”‚   â”‚   â”œâ”€â”€ Character Image
â”‚   â”‚   â”œâ”€â”€ Name Text
â”‚   â”‚   â”œâ”€â”€ Health Bar Container
â”‚   â”‚   â”‚   â”œâ”€â”€ Health Bar Background
â”‚   â”‚   â”‚   â”œâ”€â”€ Health Bar
â”‚   â”‚   â”‚   â””â”€â”€ HP Text
â”‚   â”‚   â”œâ”€â”€ Action Indicator
â”‚   â”‚   â””â”€â”€ Status Effect Container
â”‚   â”‚
â”‚   â”œâ”€â”€ CharacterSprite 2
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ TeamContainer (Enemy)
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ UI Container
    â”œâ”€â”€ Battle Log
    â”œâ”€â”€ Control Panel
    â””â”€â”€ ...
```

This hierarchy is crucial to understand when positioning UI elements.

## 3. Coordinate Systems Explained

### Local vs. Global Coordinates

Understanding the difference between local and global coordinates is essential for proper positioning:

- **Local coordinates**: Relative to the parent object's origin (0,0)
- **Global/world coordinates**: Absolute position within the scene

![Local vs Global Coordinates](https://placeholder-for-diagram-of-coordinates.png)

*Note: The diagram would show the Scene origin (0,0), a parent container with (x=100, y=100) and its origin within the scene, and a child at local coordinates (x=50, y=50) relative to Container's origin, resulting in global coordinates of (x=150, y=150). This visualization clearly demonstrates the relationship between the Scene, Container, and Child coordinate spaces.*

### Converting Between Coordinate Systems

Phaser provides methods to convert between coordinate systems:

```javascript
// Get global position of a local point
let globalPoint = new Phaser.Math.Vector2();
gameObject.getWorldTransformMatrix().transformPoint(localX, localY, globalPoint);
// Most commonly, using (0,0) gets the global position of the gameObject's origin point:
// gameObject.getWorldTransformMatrix().transformPoint(0, 0, globalPoint);

// Convert global to local
let localPoint = new Phaser.Math.Vector2();
gameObject.getWorldTransformMatrix().invert().transformPoint(globalX, globalY, localPoint);
// The resulting localPoint coordinates will be relative to the gameObject's origin
```

### The Container Paradigm

Containers are a powerful organizing tool in Phaser. When you add an object to a container:

```javascript
container.add(gameObject);
```

The gameObject's position becomes relative to the container. If gameObject was at (100, 100) in scene coordinates, and then is added to a container at (50, 50), its new local position will be (50, 50) to maintain the same visual position.

### The Origin Point

Every game object has an origin (or pivot point) that affects positioning. By default:

- The origin is (0.5, 0.5) - the center of the object
- Position coordinates refer to where this origin point will be placed

```javascript
// Center the origin (default)
gameObject.setOrigin(0.5, 0.5);

// Set origin to top-left corner
gameObject.setOrigin(0, 0);
```

This origin also affects how rotation and scaling transformations are applied. When you rotate or scale an object, these transformations pivot around the origin point, which can dramatically change the visual result depending on where the origin is set.

## 4. AutoBattler's UI Architecture

### Team Containers

Our battle UI uses two main team containers positioned on opposite sides of the screen:

```javascript
// In TeamContainer.js
this.container = scene.add.container(config.x, config.y);
```

The player team is typically positioned on the left side (around x=400), and the enemy team on the right (around x=800).

### Character Sprites

Each CharacterSprite is a complex nested structure:

```javascript
// In CharacterSprite.js
this.container = scene.add.container(this.config.x, this.config.y);
// Various elements are added to this container
this.container.add(this.circle);
this.container.add(this.characterImage);
this.container.add(this.nameText);
this.container.add(this.healthBarContainer);
```

The container hierarchy means that positioning the character's visual elements is done relative to the character container's origin (0,0).

### UI Layers

The battle UI has several layers with different coordinate contexts:

1. **Game World Layer**: Contains team containers and characters
2. **UI Overlay Layer**: Contains battle controls, logs, etc.
3. **Combat Effect Layer**: Contains animations, floating text, etc.

Elements in different layers need different positioning approaches.

## 5. Common Positioning Scenarios

### Character Placement in Formation

Characters are positioned within their team containers using a formation pattern:

```javascript
// In TeamContainer.js
const positions = getFormationPositions(this.characterCount);
for (let i = 0; i < this.characters.length; i++) {
    const sprite = new CharacterSprite(scene, character, {
        x: positions[i].x,
        y: positions[i].y
    });
    this.container.add(sprite.container);
}
```

The positions are determined by predefined formations based on the number of characters.

### Floating Elements (Action Text, Damage Numbers)

Floating elements typically need to:
1. Be positioned relative to their character
2. Move independently of the character

For the Action Indicator text, we position it above the character:

```javascript
// In ActionIndicator.js
if (this.parent.container) {
    this.parent.container.add(this.text);
    // Position above the character's head
    this.text.setPosition(0, -60);
}
```

The key insight from our recent bug fix is that once an object is added to a container, its position is relative to that container's origin.

### Animations Between Objects

Animations that involve multiple objects (like attack animations) require careful coordinate handling:

```javascript
// In CharacterSprite.js - showAttackAnimation method
// Get GLOBAL position of attacker
let attackerGlobalPos = new Phaser.Math.Vector2();
this.container.getWorldTransformMatrix().transformPoint(0, 0, attackerGlobalPos);

// Get GLOBAL position of target
let targetGlobalPos = new Phaser.Math.Vector2();
targetSprite.container.getWorldTransformMatrix().transformPoint(0, 0, targetGlobalPos);

// Calculate movement vector in global space
const moveToX = originalX + (targetX_global - originalX) * 0.7;
const moveToY = originalY + (targetY_global - originalY) * 0.7;

// Convert back to local space for the tween
let moveToLocal = { x: 0, y: 0 };
// convert global coordinates to local space...
```

This complex transformation ensures characters move correctly toward their targets.

## 6. Lessons from the Action Indicator Issue

### The Problem

In the Action Indicator bug, ability names would appear at the top-left of the screen (around x=0, y=100) instead of above the character's head. 

### Root Causes

1. **Initialization Issue**: The text was created at (0,0) with no initial offset
   ```javascript
   // Before fix
   this.text = this.scene.add.text(0, 0, '', { /* styles */ });
   ```

2. **Container Misunderstanding**: The text was added to the character's container, but its position wasn't correctly set relative to the container origin
   ```javascript
   // Before fix
   this.parent.container.add(this.text);
   // Missing: this.text.setPosition(0, -60);  
   ```

3. **Inconsistent Positioning Logic**: The `updatePosition` method wasn't properly handling container-based positioning

### The Solution

1. **Set Initial Position**: Position the text above the character from creation
   ```javascript
   // After fix
   this.text = this.scene.add.text(0, -60, '', { /* styles */ });
   ```

2. **Consistent Container Positioning**: Explicitly position relative to container after adding
   ```javascript
   // After fix
   if (this.parent.container) {
       this.parent.container.add(this.text);
       this.text.setPosition(0, -60);
   }
   ```

3. **Clearer Positioning Logic**: Better handle container vs. direct scene positioning
   ```javascript
   // After fix
   if (this.parent.container) {
       // Position is relative to container
       this.text.setPosition(0, -60);
   } else {
       // Position relative to scene coordinates
       const xPos = this.parent.x || 0;
       const yPos = (this.parent.y || 0) - 60;
       this.text.setPosition(xPos, yPos);
   }
   ```

### Key Insight

The key insight from this bug was: **When an object is added to a container, its position is in the container's local coordinate space.** 

An offset of (0, -60) means "60 pixels above the container's origin" regardless of where the container is in the world.

## 7. Best Practices for New UI Elements

### Positioning Decision Tree

When adding a new UI element, decide:

1. **What is the parent context?**
   - If it should move with a character: Add to character container
   - If it's static UI: Add directly to the scene or UI container
   
2. **What coordinate system to use?**
   - If added to container: Use positions relative to container origin
   - If added to scene: Use global scene coordinates
   
3. **Does it need to interact with objects in different containers?**
   - If yes: Use coordinate transformations (getWorldTransformMatrix)

### Debugging Techniques

For positioning issues:

1. **Visual Debugging**: Add temporary colored dots/rectangles to visualize positions
   ```javascript
   // Add a red dot at target position for debugging
   const debugDot = scene.add.circle(targetX, targetY, 5, 0xff0000);
   // Remove after 3 seconds
   scene.time.delayedCall(3000, () => debugDot.destroy());
   ```

2. **Log Coordinate Values**: Log both local and global positions
   ```javascript
   console.log(`Local: (${gameObject.x}, ${gameObject.y})`);
   
   let globalPos = new Phaser.Math.Vector2();
   gameObject.getWorldTransformMatrix().transformPoint(0, 0, globalPos);
   console.log(`Global: (${globalPos.x}, ${globalPos.y})`);
   ```

3. **Check Parent-Child Relationships**: Verify the object is in the expected container
   ```javascript
   console.log(`Parent: ${gameObject.parentContainer ? gameObject.parentContainer.name : 'scene'}`);
   ```

### Testing Positions Across Different Configurations

- Test with different team sizes (1 vs. 3 vs. 6 characters)
- Test with different window sizes and resolutions
- Test animations when characters are in different positions

## 8. Code Examples

### Properly Positioning New UI Elements

When creating a new floating element above a character:

```javascript
class NewFloatingElement {
    constructor(scene, parentSprite) {
        this.scene = scene;
        this.parent = parentSprite;
        
        // Create the visual element
        this.visual = scene.add.sprite(0, -70, 'iconTexture');
        
        // Important: Add to parent's container
        if (this.parent.container) {
            this.parent.container.add(this.visual);
            // Position is already set relative to container (0, -70)
        } else {
            // Fallback if no container
            this.updatePosition();
        }
    }
    
    updatePosition() {
        if (!this.parent || !this.visual) return;
        
        if (this.parent.container) {
            // Relative to container
            this.visual.setPosition(0, -70);
        } else {
            // Global coordinates
            const parentGlobal = new Phaser.Math.Vector2();
            this.parent.getWorldTransformMatrix().transformPoint(0, 0, parentGlobal);
            this.visual.setPosition(parentGlobal.x, parentGlobal.y - 70);
        }
    }
}
```

### Animating Between Different Containers

When animating between elements in different containers:

```javascript
function animateBetweenContainers(source, target, animatedSprite) {
    // Get global positions
    let sourceGlobal = new Phaser.Math.Vector2();
    source.container.getWorldTransformMatrix().transformPoint(0, 0, sourceGlobal);
    
    let targetGlobal = new Phaser.Math.Vector2();
    target.container.getWorldTransformMatrix().transformPoint(0, 0, targetGlobal);
    
    // Create the sprite in the scene (not in any container)
    const sprite = scene.add.sprite(sourceGlobal.x, sourceGlobal.y, animatedSprite.texture);
    
    // Animate in global coordinates
    scene.tweens.add({
        targets: sprite,
        x: targetGlobal.x,
        y: targetGlobal.y,
        duration: 500,
        onComplete: () => {
            sprite.destroy();
        }
    });
}

// Alternative approach: Temporarily re-parent an existing sprite
function animateExistingSpriteBetweenContainers(sprite, sourceContainer, targetContainer, scene) {
    // Store original position and parent
    const originalParent = sprite.parentContainer;
    const originalLocalPos = { x: sprite.x, y: sprite.y };
    
    // Get current global position
    let globalPos = new Phaser.Math.Vector2();
    sprite.getWorldTransformMatrix().transformPoint(0, 0, globalPos);
    
    // Get target global position
    let targetGlobal = new Phaser.Math.Vector2();
    targetContainer.getWorldTransformMatrix().transformPoint(0, 0, targetGlobal);
    
    // Remove from current container
    if (sourceContainer) {
        sourceContainer.remove(sprite);
    }
    
    // Add directly to scene at current global position
    scene.add.existing(sprite);
    sprite.setPosition(globalPos.x, globalPos.y);
    
    // Animate in scene coordinates
    scene.tweens.add({
        targets: sprite,
        x: targetGlobal.x,
        y: targetGlobal.y,
        duration: 500,
        onComplete: () => {
            // Re-parent to original container or target container as needed
            // This example returns it to the original parent
            scene.children.remove(sprite);
            originalParent.add(sprite);
            sprite.setPosition(originalLocalPos.x, originalLocalPos.y);
        }
    });
}

// Note: The first approach (creating a temporary sprite) is generally cleaner
// and avoids altering the main scene graph unnecessarily. Use the second
// approach only when you specifically need to animate the original object.
```

### Creating UI at Specific Scene Depths

Use depth property to control rendering order:

```javascript
// UI elements should be above game objects
const uiPanel = scene.add.container(400, 300);
uiPanel.setDepth(100);  // Higher depth = renders on top

// Combat effects should be above characters but below UI
const effectSprite = scene.add.sprite(400, 300, 'effectTexture');
effectSprite.setDepth(50);

// Character sprites at standard depth
characterSprite.container.setDepth(10);
```

Important note: `setDepth()` is local to the current Scene. For complex UIs that might use multiple overlaid Phaser Scenes in the future (e.g., a dedicated UI Scene on top of the BattleScene), true cross-scene layering would involve Phaser's Scene management API methods like `scene.bringToTop()`. However, for our current single-scene approach, depth values work perfectly.

## 9. Common Pitfalls to Avoid

### 1. Missing Parent-Child Relationships

**Don't:**
```javascript
// Create text positioned relative to a container
const actionText = scene.add.text(container.x, container.y - 60, "Attack");
// Problem: Text won't move when container moves
```

**Do:**
```javascript
// Create text as child of container
const actionText = scene.add.text(0, -60, "Attack");
container.add(actionText);
// Now text moves with container
```

### 2. Mixing Coordinate Systems

**Don't:**
```javascript
// Getting global position
let globalPos = { x: container.x, y: container.y };
// Problem: container.x/y are local to its parent, not global!
```

**Do:**
```javascript
// Getting global position
let globalPos = new Phaser.Math.Vector2();
container.getWorldTransformMatrix().transformPoint(0, 0, globalPos);
```

### 3. Ignoring Origin Points

**Don't:**
```javascript
// Create element without considering origin
const healthBar = scene.add.rectangle(charX, charY + 50, 80, 10, 0xff0000);
// Problem: Rectangle will be centered at that position by default!
```

**Do:**
```javascript
// Create element with explicit origin
const healthBar = scene.add.rectangle(charX, charY + 50, 80, 10, 0xff0000);
healthBar.setOrigin(0, 0.5); // Left-center origin for horizontal bar
```

### 4. Not Cleaning Up When Destroying Objects

**Don't:**
```javascript
// Simply remove the main object
characterSprite.container.destroy();
// Problem: Child objects or references might still exist!
```

**Do:**
```javascript
// Properly clean up all related objects and references
characterSprite.destroy(); // Handles all cleanup internally
```

## 10. Conclusion

Understanding Phaser's positioning system is crucial for creating visually correct and interactive game elements. By remembering these key principles:

1. **Understand the container hierarchy** and how it affects positioning
2. **Be consistent with coordinate systems** (local vs. global)
3. **Set positions explicitly** when adding to containers
4. **Use proper debugging techniques** to identify positioning issues

By following these guidelines, you can avoid positioning bugs like the Action Indicator issue and create more robust UI components that work correctly in all scenarios.

Remember: In Phaser, positioning is always relative to the parent, and transformations cascade down the display hierarchy. When in doubt, log both local and global positions to understand what's happening.


===== FILE: Lessons Learned.md =====
Lessons Learned:
an in-depth "Lessons Learned" document that captures the specific technical challenges and solutions encountered during the first shot at our Phaser integration: (Focused on implementing a Team Builder UI with Phaser)

Note: Versions listed are from a different branch- Just take the overall lesson, dont focus on version numbers. 

# Phaser Integration - Comprehensive Lessons Learned

## 1. Core Architecture and Initialization Issues

### Key Problems Encountered
- **Global Object Registration Failures**: Version 0.5.2.1 revealed critical errors where Phaser modules weren't properly attached to the window object, causing `Cannot read properties of undefined (reading 'initContainer')` errors.
- **Scene Lifecycle Management**: Version 0.5.3.2 showed issues with scene state detection using non-existent `isPending()` method instead of directly checking `sys.status`.
- **Incomplete Error Handling**: Early versions lacked comprehensive try/catch blocks, allowing silent failures that were difficult to diagnose.

### Solutions That Worked
- **Explicit Global Registration**: Adding explicit `window.ModuleName = ModuleName` statements with console verification.
- **Immediate Visual Feedback**: Creating high-contrast visual elements to confirm scene creation.
- **Defense in Depth**: Implementing multiple checks for object existence and multiple approaches for the same functionality.

### Lesson for Future Implementation
When integrating a Canvas-based framework like Phaser into an existing DOM application:
1. **Create a Global Registration Pattern**: Standardize a pattern for attaching all modules to the global scope with verification.
2. **Verify Scene States Correctly**: Use `scene.sys.status` rather than assuming method availability.
3. **Implement Comprehensive Visibility Testing**: Add high-contrast elements during development to confirm rendering.

## 2. UI Component Rendering Challenges

### Key Problems Encountered
- **Rounded Rectangle Errors**: Version 0.5.4.1b revealed that `setRoundedRectangle` calls don't exist in Phaser 3.55.2, causing visual elements to fail.
- **Clipping/Masking Failures**: ScrollableList component showed `TypeError: this.contentContainer.setClipRect is not a function` in version 0.5.4.1d.
- **Interactive Element Errors**: Multiple errors like `Container.setInteractive must specify a Shape or call setSize() first` in various components.

### Solutions That Worked
- **Proper Graphics API Usage**: Replaced non-existent methods with the proper Phaser 3.55.2 Graphics methods (`fillRoundedRect`, `strokeRoundedRect`).
- **Multiple Masking Fallbacks**: Implemented a progressive fallback system with three different masking approaches (GeometryMask â†’ BitmapMask â†’ Scissor).
- **Standardized Interactive Element Helper**: Created a centralized utility that follows the correct sequence: setSize() first, then setInteractive() with proper hit area.

### Lesson for Future Implementation
When creating UI components in Phaser:
1. **Validate API Methods**: Explicitly check that the Phaser methods you're using exist in your specific version.
2. **Implement Progressive Fallbacks**: Create multiple approaches for critical functionality with automatic detection and fallback.
3. **Sequence Matters**: For interactive elements, follow a strict ordering: setSize() â†’ create hit area â†’ setInteractive() â†’ add event listeners.

## 3. Data Access and State Management

### Key Problems Encountered
- **TeamManager Access Failures**: Multiple versions showed difficulty accessing the existing TeamManager from Phaser scenes.
- **Method Binding Issues**: Functions were losing their `this` context when accessed across module boundaries.
- **Inconsistent Data Access Patterns**: Different code used different approaches to access the same managers.

### Solutions That Worked
- **Bridge Design Pattern**: Implemented a "bridge" object that uses polling to continuously check for the real manager.
- **Method Reference Binding**: Explicitly binding methods using `.bind(manager)` when storing references.
- **Multiple Access Strategies**: Implementing multiple fallback approaches for accessing managers:
  ```javascript
  // Try multiple approaches to get TeamManager
  if (window.teamManager) {
      // Approach 1
  } else if (window.TeamManager) {
      // Approach 2
  } else if (typeof teamManager !== 'undefined') {
      // Approach 3
  } else if (this.scene.sys.registry.has('teamManager')) {
      // Approach 4
  }
  ```

### Lesson for Future Implementation
For data sharing between DOM and Canvas-based systems:
1. **Use the Bridge Pattern**: Create a dedicated bridge object that handles communication between systems.
2. **Preserve Method Context**: Always bind methods when storing them as references.
3. **Implement Multiple Access Strategies**: Don't assume a single way of accessing shared state will always work.

## 4. Debugging and Development Tools

### Key Problems Encountered
- **Limited Inspector Access**: Unlike DOM, Phaser canvas elements can't be inspected with browser tools.
- **Position Identification Challenges**: Difficult to identify the exact coordinates for positioning elements.
- **Object Identification**: No way to determine which object is under the cursor.

### Solutions That Worked
- **Custom Coordinate Display**: Created real-time X/Y coordinate tracking in version 0.5.5.2.
- **Object Identification System**: Added object name display alongside coordinates when hovering over elements in 0.5.5.3.
- **Interactive Layout Mode**: Implemented 'L' key toggle for drag-and-drop positioning with coordinate logging in 0.5.5.4.
- **Clipboard Integration**: Added 'Y' key shortcut to copy object name to clipboard for easy referencing in code.

### Lesson for Future Implementation
For Canvas-based UI development:
1. **Create Custom Inspector Tools**: Implement your own debugging tools since browser inspectors can't see inside Canvas.
2. **Use Object Naming Conventions**: Systematically name all important objects for identification.
3. **Implement Interactive Positioning**: Create tools for visually positioning elements and extracting coordinates.
4. **Add Console Integration**: Enable copying element names to clipboard for direct use in your code.

## 5. Component Design Patterns

### Key Problems Encountered
- **Inconsistent Component Initialization**: Different components followed different patterns for setup and initialization.
- **Circular Dependencies**: Components sometimes referenced each other creating initialization race conditions.
- **Error Propagation**: Errors in one component would cascade to others without proper isolation.

### Solutions That Worked
- **Standardized Component Lifecycle**: Implemented consistent initialization patterns across components.
- **Centralized Interactive Helper**: Created `InteractiveHelper` utility for standardized interactive setup.
- **Error Insulation**: Added targeted error handling within each component to prevent cascading failures.

### Lesson for Future Implementation
For component-based architecture:
1. **Standardize Component Patterns**: Create consistent initialization and lifecycle patterns across all components.
2. **Centralize Common Functionality**: Use utility classes for shared functionality instead of duplicating code.
3. **Implement Component-Level Error Handling**: Each component should handle its own errors and prevent propagation.

## 6. Specific Phaser API Pitfalls 

### Key Problems Encountered
- **Array Method Usage on Objects**: Errors like `TypeError: this.scene.manager.keys.includes is not a function` from version 0.5.3.0.
- **Renderer-Specific Features**: Some features working in WebGL but not Canvas renderer or vice versa.
- **Method Existence Assumptions**: Assuming methods exist without checking (e.g., `isPending()`, `setClipRect`).

### Solutions That Worked
- **Object Key Conversion**: Using `Object.keys(obj).includes()` instead of `obj.includes()`.
- **Renderer Detection**: Implementing renderer-type detection and adaptive feature usage.
- **Method Existence Checking**: Adding explicit checks before calling methods: `if (typeof obj.method === 'function')`.

### Lesson for Future Implementation
For Phaser API usage:
1. **Verify Object Types**: Check if you're using array methods on actual arrays, not objects.
2. **Detect Renderer Type**: Always check which renderer is active before using renderer-specific features.
3. **Verify Method Existence**: Always check if methods exist before calling them, especially for less common API features.

## 7. Parallel UI Management

### Key Problems Encountered
- **UI Toggling Issues**: Problems when switching between DOM and Phaser UIs.
- **State Synchronization**: Keeping data in sync between two parallel UI systems.
- **Resource Cleanup**: Memory leaks from improper cleanup when toggling UIs.

### Solutions That Worked
- **Enhanced Scene State Detection**: Properly checking `scene.sys.status` for accurate state management.
- **Improved Event Handling**: Better event listeners for UI transitions with cleanup.
- **Bridge Pattern for Data Sharing**: Using the TeamManager bridge to maintain synchronized state.

### Lesson for Future Implementation
For managing parallel UI systems:
1. **Properly Manage Scene States**: Understand and correctly check scene states during transitions.
2. **Implement Complete Cleanup**: Always remove all event listeners and dispose resources when switching UIs.
3. **Use Data Bridges**: Implement dedicated bridge objects for data synchronization between UI systems.

## 8. Recommendations for Battle UI Implementation

Based on these lessons, here are specific recommendations for implementing the Battle UI with Phaser:

1. **Start with Version 0.5.0.0** which contains the base Phaser integration without the TeamBuilder-specific code.

2. **Transplant these critical debugging tools** from later versions:
   - The coordinate display system from 0.5.5.2
   - The object name identification system from 0.5.5.3
   - The layout debug mode from 0.5.5.4 (modified for Battle UI elements)

3. **Apply the Bridge Pattern** from 0.5.4.1d to connect BattleManager to Phaser's BattleScene.

4. **Implement proper component initialization** following the patterns in 0.5.4.1c:
   - Set sizes before making components interactive
   - Use properly structured hit areas
   - Implement comprehensive error handling

5. **Use multi-level fallbacks** for critical systems like:
   - Animation rendering
   - Effect visualizations
   - Character positioning

6. **Create high-contrast debug visuals** during development to easily confirm proper rendering.

7. **Establish a proper naming convention** for all Battle UI elements to support debugging.

By applying these lessons learned from the TeamBuilder implementation challenges, you can create a more robust and maintainable Battle UI implementation while avoiding the pitfalls encountered in the previous integration effort.

===== FILE: LessonsLearned_FurtherRefactoring.md =====
# Lessons Learned: Further Refactoring Success Factors

This document captures key insights and success factors from our implementation of Phases 1, 2, and 3 of the "BattleManager Further Refactoring Guide." These lessons can serve as valuable guidelines for future refactoring efforts.

## 1. Structured Planning

### The Power of a Clear, Documented Plan
**Lesson**: Having the "BattleManager Further Refactoring Guide.md" served as an excellent roadmap. It defined the scope, objectives, and validation criteria for each phase before implementation began.

**Why it worked**: Everyone (developers and AI assistants) was aligned on what needed to be done for each specific phase. This reduced ambiguity and kept the effort focused. The guide acted as our shared source of truth for this sprint.

**Implementation**: 
- The guide broke down each phase into clear objectives
- It defined expected outcomes and success criteria
- It established technical requirements and constraints upfront

## 2. Effective Implementation Methodology

### "One-Shot Implementation & Validation" Workflow
**Lesson**: The workflow of implementing a single component, updating BattleManager with facades (or direct calls for utilities), and then stopping for validation was highly effective.

**Why it worked**: This iterative approach allowed for immediate testing and confirmation of each isolated change. When errors occurred, it was much easier to pinpoint their origin within that specific phase, rather than trying to debug a massive set of simultaneous changes.

**Implementation**:
- Each phase had a clear beginning and end
- Validation checkpoints were built into the process
- Changes were small enough to be reasoned about completely

### Targeted Code Extraction Based on Prior Architectural Debt
**Lesson**: This refactoring specifically targeted areas where responsibilities were known to be misplaced (e.g., BattleInitializer logic still in BattleManager, StatusEffectDefinitionLoader not being fully autonomous, utility methods mixed in).

**Why it worked**: We were addressing known issues and fulfilling earlier architectural intentions. This meant the "what" and "why" of the refactoring were already well understood.

## 3. Collaboration and Communication

### Effective AI Collaboration with Specific Prompts and Refinements
**Lesson**: The process of receiving detailed implementation plans, providing architectural reviews with suggested refinements, and then giving clear, actionable prompts was key to success.

**Why it worked**: AI assistants excel at generating detailed implementation steps and code, but strategic architectural alignment (like insisting BattleManager be truly free of fallback logic, or using direct static calls for utilities) ensured the changes met higher-level goals.

**Implementation**:
- Plans were reviewed with architectural considerations in mind
- Refinements were specific and actionable
- Final implementations had clear approval criteria

## 4. Technical Execution

### Incremental Reduction of BattleManager Complexity
**Lesson**: Each phase visibly and measurably reduced BattleManager's size and complexity (as evidenced by line count tracking).

**Why it worked**: This provided positive reinforcement and a clear sense of progress. It also meant that with each phase, the remaining BattleManager code became slightly easier to work with for the next phase.

**Implementation**:
- Phase 1 (BattleInitializer): ~180 lines removed
- Phase 2 (StatusEffectDefinitionLoader): ~85 lines removed
- Phase 3 (BattleUtilities): ~40 lines removed

### Adherence to Established Project Conventions
**Lesson**: The guide explicitly mentioned, and implementations adhered to, critical technical requirements like no ES Modules, global window registration, and correct script loading order.

**Why it worked**: This prevented a whole class of integration errors that can arise when new code doesn't follow the established patterns of the existing codebase.

**Implementation**:
- Used standard script loading with `window` registration
- Maintained consistent naming conventions
- Followed existing component architecture patterns
- Properly ordered script loading in index.html

## 5. Documentation and Validation

### Thorough Changelog Discipline
**Lesson**: Maintaining detailed technical changelogs for each (sub)version provides immense value.

**Why it worked**: It documents the "what, why, and how" for each set of changes, which is invaluable for future debugging, onboarding, and understanding the evolution of the system.

**Implementation**:
- High-level changelog entries for each phase
- Detailed technical changelogs with implementation specifics
- Code removal metrics and architectural benefits documented

### Testing and Validation as Non-Negotiable Steps
**Lesson**: Commitment to testing after each phase was fundamental to the smooth progression.

**Why it worked**: It caught potential issues immediately, preventing them from compounding. This is the core of the "validate before proceeding" principle.

**Implementation**:
- Console monitoring for unexpected errors
- Functionality testing after each phase
- Manual verification of component interactions

## 6. Additional Success Factors

### Clear System Architecture Vision
**Lesson**: Having a clear vision of the target architecture (component-based with separation of concerns) guided all refactoring decisions.

**Why it worked**: Every change was evaluated against whether it moved the system closer to the target architecture, providing a consistent direction for refactoring efforts.

### Appropriate Use of Component Patterns
**Lesson**: Different components called for different patterns - facades for stateful components (BattleInitializer), complete extraction for loaders (StatusEffectDefinitionLoader), and static utilities for stateless helpers (BattleUtilities).

**Why it worked**: By matching the implementation pattern to the nature of the component, we avoided unnecessary complexity and achieved clean separations.

## 7. Recommendations for Future Refactoring

1. **Continue with the phase-by-phase approach** to maintain control and visibility
2. **Document architectural intentions** for each component being extracted
3. **Measure and celebrate progress** with metrics like lines of code reduced
4. **Maintain testing discipline** with thorough validation between phases
5. **Keep changelogs detailed and current** for future reference

## Conclusion

The success of this refactoring effort wasn't accidental. It was the result of a well-defined plan, a focused scope for each step, clear collaboration roles, adherence to existing technical standards, and rigorous validation. This approach serves as an excellent model for future refactoring work and significant feature additions.


===== FILE: LessonsLearned_Stage5.md =====
# Lessons Learned: Stage 5 Refactoring - AbilityProcessor

This document captures key insights and successful strategies from Stage 5 of the BattleManager refactoring plan, which focused on implementing the AbilityProcessor component.

## Success Factors

The Stage 5 refactoring was completed efficiently with minimal issues, representing a significant improvement over earlier stages. Several factors contributed to this success:

### 1. Upfront Planning and Component Boundaries

**What Worked Well:**
- Creating a detailed implementation plan before writing any code
- Clearly defining the component's responsibilities and boundaries
- Identifying all required methods and dependencies before starting
- Planning method signatures and return values in advance

**Why It Matters:**
This eliminated ambiguity about what code belonged where and prevented scope creep during implementation. Having a clear "contract" for the component made implementation straightforward.

### 2. Systematic Extraction with Parallel Structure

**What Worked Well:**
- Maintaining the same method signatures and behavior patterns when extracting methods
- Preserving exact behavior while moving code to a new location
- Using search to identify all related code before extraction
- Preserving all event dispatching logic precisely as it was in the original

**Why It Matters:**
This approach minimized the risk of subtle behavior changes and ensured that all UI updates and event listeners continued to work without modification.

### 3. Defensive Implementation

**What Worked Well:**
- Adding comprehensive parameter validation for all public methods
- Implementing thorough error handling for component dependencies
- Adding meaningful error messages for debugging
- Providing fallback behavior when components aren't available

**Why It Matters:**
This made the code more robust against runtime errors and provided clear debugging information when something went wrong, rather than silent failures or cryptic errors.

### 4. Clear Delegation Pattern

**What Worked Well:**
- Using a consistent pattern for all facade methods in BattleManager
- Ensuring the toggle mechanism worked identically across all methods
- Adding warning messages in fallback paths
- Keeping facade methods minimal (7-8 lines each)

**Why It Matters:**
Consistency made the code more predictable and easier to maintain. The thin facades provide a clean separation between coordination (BattleManager) and implementation (AbilityProcessor).

### 5. Two-Phase Approach with Toggle Mechanism

**What Worked Well:**
- Implementing functionality first while preserving original code
- Using the toggle mechanism to A/B test new vs. original implementation
- Cleanup as a separate phase after verification
- Removing code systematically with clear backup strategy

**Why It Matters:**
This approach minimized risk by allowing easy rollback if issues were found, while enabling progressive refactoring without breaking functionality.

### 6. Comprehensive Documentation

**What Worked Well:**
- Documenting changes in both technical and high-level changelogs
- Including precise metrics on code reduction
- Explaining the reasoning behind changes
- Maintaining a clear record of implementation decisions

**Why It Matters:**
This makes future maintenance easier by explaining why changes were made, not just what was changed, and provides context for anyone working on the codebase in the future.

## Complete Implementation Process

Below is a step-by-step guide that encapsulates the entire process used for the AbilityProcessor implementation, which can serve as a template for future component refactoring:

### Phase 1: Implementation

1. **Planning**
   - Identify all methods to extract (for AbilityProcessor: `processEffect`, `applyActionEffect`, `applyRandomStatusEffect`)
   - Map all dependencies needed by these methods
   - Understand all event dispatching requirements
   - Document expected method signatures and return values

2. **Script Integration**
   - Update index.html to include the new component script
   - Ensure proper loading order (dependencies before component, component before BattleManager)
   ```html
   <!-- Important: Place component after its dependencies -->
   <script src="js/battle_logic/damage/DamageCalculator.js" defer></script>
   <script src="js/battle_logic/damage/HealingProcessor.js" defer></script>
   <!-- AbilityProcessor - Must load after status and damage components -->
   <script src="js/battle_logic/abilities/AbilityProcessor.js" defer></script>
   <!-- This must come before BattleManager -->
   ```

3. **Component Implementation**
   - Create or update the shell implementation with full functionality
   - Implement all methods with identical signatures to the original
   - Add comprehensive parameter validation
   - Add defensive checks for all dependencies
   - Preserve all event dispatching from the original implementation
   - Add proper global window registration for traditional script loading:
   ```javascript
   // Make Component available globally for traditional scripts
   if (typeof window !== 'undefined') {
     window.AbilityProcessor = AbilityProcessor;
     console.log("AbilityProcessor class definition loaded and exported to window.AbilityProcessor");
   }
   
   // Legacy global assignment for maximum compatibility
   window.AbilityProcessor = AbilityProcessor;
   ```

4. **BattleManager Updates**
   - Add component initialization in `initializeComponentManagers()`
   ```javascript
   // Initialize ability processor
   if (window.AbilityProcessor) {
       this.abilityProcessor = new window.AbilityProcessor(this);
       console.log('BattleManager: AbilityProcessor initialized');
       
       // Verify methods exist
       console.log('>>> AbilityProcessor instance check:', {
           processEffect: typeof this.abilityProcessor.processEffect,
           applyActionEffect: typeof this.abilityProcessor.applyActionEffect
       });
   }
   ```
   - Update `useNewImplementation` flag to include component availability check
   - Add toggle mechanism to each extracted method:
   ```javascript
   methodName(params) {
       // REFACTORING: Use new implementation if toggle is enabled
       if (this.useNewImplementation && this.abilityProcessor) {
           return this.abilityProcessor.methodName(params);
       }
       
       // Original implementation follows
       // ... original code remains for now ...
   }
   ```

5. **Documentation**
   - Create detailed technical changelog
   - Update high-level changelog
   - Document specific implementation choices

6. **Testing**
   - Load game and start battle
   - Test with both toggle states (old and new implementation)
   - Verify all events and UI updates work correctly

### Phase 2: Cleanup

1. **Backup**
   - Make backup of BattleManager.js before cleanup

2. **Method Cleanup**
   - For each method, remove original implementation code
   - Keep method signature and delegation code
   - Add fallback with warning for when component is unavailable
   ```javascript
   methodName(params) {
       // REFACTORING: Use new implementation if toggle is enabled
       if (this.useNewImplementation && this.abilityProcessor) {
           return this.abilityProcessor.methodName(params);
       }
       
       // Original implementation has been removed (v0.5.26.1_Cleanup)
       // Implementation now in AbilityProcessor.methodName
       console.warn("BattleManager using legacy methodName - AbilityProcessor not available");
       return fallbackBehavior();
   }
   ```

3. **Documentation Update**
   - Create cleanup changelog with metrics
   - Update high-level changelog
   - Document lines of code removed

4. **Final Testing**
   - Verify game still works with cleaned methods
   - Ensure all functionality remains intact
   - Check console for any warnings or errors

By following this process for each component, we maintain a consistent, methodical approach to refactoring that preserves functionality while steadily reducing complexity in BattleManager.

## Key Implementation Techniques

### 1. Method Extraction Pattern

```javascript
// ORIGINAL BATTLEMANAGER METHOD
methodName(params) {
  // Complex implementation
}

// STEP 1: Add toggle and delegation
methodName(params) {
  // REFACTORING: Use new implementation if toggle is enabled
  if (this.useNewImplementation && this.abilityProcessor) {
    return this.abilityProcessor.methodName(params);
  }
  
  // Original implementation remains
  // ...original code...
}

// STEP 2: After verification, clean up
methodName(params) {
  // REFACTORING: Use new implementation if toggle is enabled
  if (this.useNewImplementation && this.abilityProcessor) {
    return this.abilityProcessor.methodName(params);
  }
  
  // Original implementation has been removed (cleanup version)
  console.warn("BattleManager using legacy methodName - Component not available");
  return fallbackBehavior();
}
```

### 2. Defensive Component Availability Pattern

```javascript
// Check for required dependencies before using them
if (!this.damageCalculator) {
  console.error("[AbilityProcessor] DamageCalculator component not found! Cannot calculate damage.");
  return { damage: 0, scalingText: '', scalingStat: 0 }; // Safe default return value
}

// Only then use the component
return this.damageCalculator.calculateDamage(attacker, target, ability, effect);
```

### 3. Event Dispatching Preservation

```javascript
// Ensure all events are dispatched as in the original code
if (window.battleBridge && healAmount > 0) {
  try {
    window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_HEALED, {
      character: target,
      newHealth: target.currentHp,
      maxHealth: target.stats.hp,
      amount: healAmount,
      source: actor,
      ability: ability
    });
  } catch (error) {
    console.error('[AbilityProcessor] Error dispatching CHARACTER_HEALED event:', error);
  }
}
```

## Areas for Further Improvement

While Stage 5 went smoothly, these areas could be improved further:

1. **More Automated Testing**: Implementing automated tests would provide additional confidence when making changes.
2. **Event Documentation**: Creating a comprehensive list of all events and their required payload structures would reduce the risk of missing events.
3. **Standardized Error Handling**: Developing a centralized error handling pattern could make debugging easier.
4. **Component Registration System**: A formal system for registering and accessing components could replace direct references.

## Application to Future Refactoring Stages

For future stages (TargetingSystem, ActionGenerator, etc.), we should:

1. Continue using the detailed planning phase before implementation
2. Maintain the two-phase approach (implement, then clean up)
3. Use the same defensive coding patterns to handle dependencies
4. Apply consistent documentation practices
5. Continue precise extraction of methods with careful event preservation

The success of Stage 5 demonstrates that with proper planning and methodical execution, even complex refactoring can be accomplished efficiently with minimal risk.

===== FILE: LessonsLearned_Stage6.md =====
# Lessons Learned: Stage 6 Refactoring - Passive Ability System

This document captures key insights and lessons from Stage 6 of the BattleManager refactoring plan, which focused on implementing the Passive Ability System (PassiveTriggerTracker and PassiveAbilityManager components).

## Lesson 1: Complete Component Dependencies Before Refactoring

### What Went Wrong
The implementation of Stage 6 revealed incomplete implementation of the BattleFlowController from an earlier stage, leading to runtime errors in production:

- Missing methods were being called (`startNextTurn()`, `checkBattleEnd()`, etc.)
- Methods existed in the delegation chain but not in the target component
- Battle flow was broken because core methods needed for full combat flow were absent

### Root Causes
- **Over-focused Implementation Plan**: Concentrated narrowly on the specific component being implemented without validating dependent components were complete
- **Incomplete Interface Definitions**: Component interfaces (required methods) weren't fully defined before coding began
- **Missing Dependency Validation**: No explicit checks to verify all expected methods actually existed on target components
- **Insufficient Cross-Component Testing**: Testing focused on component behavior rather than complete system flow

### Recommendations
1. **Document Full Component Interface First**: Before implementing any component, create a complete list of all methods it must implement, including those that will be called by other components.

2. **Create Dependency Maps**: Document which components call which methods on other components, and ensure all needed methods exist:
   ```
   BattleManager â†’ BattleFlowController.startNextTurn()
   BattleManager â†’ BattleFlowController.checkBattleEnd() 
   BattleFlowController â†’ BattleManager.logMessage()
   ```

3. **Verify Interfaces During Initialization**: Add diagnostic code that explicitly checks for the existence of all required methods:
   ```javascript
   // Add to initialization
   console.log('Component method validation:', {
     startNextTurn: typeof this.battleFlowController?.startNextTurn === 'function',
     checkBattleEnd: typeof this.battleFlowController?.checkBattleEnd === 'function',
     // ...other required methods
   });
   ```
   
4. **Implement Method Stubs Early**: When creating a new component, add stub implementations of all interface methods immediately, even with minimal functionality:
   ```javascript
   // Early stub implementation
   checkBattleEnd() {
     console.warn("Method not fully implemented yet");
     return false; // Safe default
   }
   ```

5. **Integration Testing Plan**: Include tests that explicitly verify the end-to-end flow across components, not just individual component behavior.

## Lesson 2: Defensive Implementation Works

### What Worked Well
Despite the issues with missing methods, the defensive implementation patterns applied to PassiveAbilityManager prevented cascade failures:

- Comprehensive parameter validation caught invalid inputs early
- Explicit dependency checks prevented null reference errors
- Fallback behaviors kept the system running even with missing components
- Clear error messaging made problem diagnosis straightforward

### Effective Techniques
- **Parameter Validation**: 
  ```javascript
  if (!character) {
    console.error("[PassiveAbilityManager] Invalid character parameter");
    return [];
  }
  ```

- **Component Availability Checks**:
  ```javascript
  if (!this.passiveTriggerTracker) {
    console.warn("[PassiveAbilityManager] PassiveTriggerTracker not available");
  }
  ```

- **Safe Access Patterns**:
  ```javascript
  const passiveId = ability.id || ability.name;
  ```

- **Graceful Degradation**:
  ```javascript
  if (this.passiveTriggerTracker && this.passiveTriggerTracker.hasFiredThisTurn(...)) {
    // Specific behavior when available
  } else {
    // Safe fallback behavior
  }
  ```

### Recommendations
1. **Continue Defensive Implementation**: Apply these patterns to all components consistently
2. **Extend Validation**: Add even more validation, particularly for cross-component calls
3. **Centralize Validation**: Consider helper methods or utilities for common validation patterns

## Lesson 3: Start with Full Flow Testing

### What We Learned
Component testing in isolation wasn't sufficient to catch cross-component issues:

- Individual components worked correctly when tested directly
- Issues only appeared when following the full battle flow
- Method delegation chains revealed gaps in implementation

### Recommendations
1. **Flow-First Testing**: Start testing with the complete end-to-end flow to identify missing implementation points
2. **Critical Path Validation**: Identify and test critical paths through the system before focusing on edge cases
3. **Regression Test Suite**: Create a suite of tests that verify the complete battle flow from start to conclusion

## Lesson 4: Refactoring Order Matters

### What We Learned
The order of component implementation affected system stability:

- Core flow components (BattleFlowController) needed to be completed before specialized components
- Delegating from established components to incomplete components led to runtime errors
- The architecture assumed complete implementations of all dependencies

### Recommendations
1. **Dependency-Ordered Implementation**: Refactor components in dependency order, starting with core flow components
2. **Complete Before Continuing**: Ensure each component is fully implemented before moving to components that depend on it
3. **Interface-First Approach**: Define and implement component interfaces completely before adding complex internal logic

## Implementation Plan Improvements for Future Stages

For remaining refactoring stages, enhance the implementation plans with:

1. **Comprehensive Interface Documentation**: Document all methods each component must implement, including those called by other components
2. **Dependency Validation Steps**: Include explicit steps to validate all dependencies and inter-component method calls
3. **Method Stub Phase**: Add an initial phase that implements stubs for all interface methods before adding complex logic
4. **Full-Flow Testing**: Include tests that verify the complete system flow, not just individual component behavior
5. **Cross-Component Validation**: Add explicit validation code that checks for the existence of all required methods during initialization

By applying these lessons, future refactoring stages will avoid similar issues and progress more smoothly.


===== FILE: Lessons_Learned_Stage3_BattleFlow_Refactoring.md =====
# Lessons Learned from Refactoring Stage 3: Battle Flow Control

This document compiles key lessons learned during Stage 3 of the BattleManager refactoring process, where we moved core battle flow control from the monolithic BattleManager to the new BattleFlowController component. These insights should guide future refactoring stages and similar architectural changes.

## 1. File Organization and Path Management

### Lesson: Update All Path References When Moving Files
**From**: CHANGELOG_0.5.16_ScriptPathFix.md

When refactoring file locations, all references in HTML script tags must be updated to match new directory structures. In our case, the BattleFlowController script path in index.html remained pointed at the old location (`js/managers/`) when the actual file was in the new location (`js/battle_logic/core/`).

```html
<!-- INCORRECT -->
<script src="js/managers/BattleFlowController.js"></script>

<!-- CORRECT -->
<script src="js/battle_logic/core/BattleFlowController.js"></script>
```

JavaScript's behavior when instantiating undefined constructors can be misleading - it doesn't always throw immediate errors. Our sequence of events was:
1. BattleManager calls `new window.BattleFlowController()`
2. JavaScript "succeeds" in creating an object
3. The object has no methods because the actual class definition never loaded

### Action Item:
- Create a script path verification step in your refactoring checklist
- Add path validation to build or test process
- Consider using script module bundlers for production to reduce path dependency issues

## 2. Asynchronous Method Handling

### Lesson: Properly Await Asynchronous Methods
**From**: CHANGELOG_0.5.18_BattleFlow_Diagnostics.md

When refactoring methods that return Promises, ensure all calls to these methods use the `await` keyword. In our case, `checkBattleEnd()` was an async method, but was being called without `await`:

```javascript
// INCORRECT - Doesn't properly wait for result
if (this.checkBattleEnd()) {
    return; // Battle ended, don't continue
}

// CORRECT - Properly waits for result
if (await this.checkBattleEnd()) {
    return; // Battle ended, don't continue
}
```

Failing to use `await` can cause subtle timing issues where execution continues before asynchronous operations complete, leading to unpredictable behavior.

### Action Item:
- Audit all async methods during refactoring to ensure proper await usage
- Consider using linting rules that enforce proper Promise handling
- Add explicit return type annotations for async methods to make their nature clear

## 3. Method Delegation Verification

### Lesson: Verify Internal Calls After Refactoring
**From**: CHANGELOG_0.5.19_BattleFlow_Cooldowns.md

When moving logic between classes during refactoring, we must verify *all* internal method calls made *within* the moved logic blocks. The battle stalling issue we encountered happened because `BattleFlowController.finishTurn()` still contained a call to `this.battleManager.reduceCooldowns()` - a method that didn't exist on the refactored BattleManager.

```javascript
// INCORRECT - Calling a method that doesn't exist in the refactored architecture
async finishTurn() {
    this.battleManager.turnInProgress = false;
    this.battleManager.reduceCooldowns(); // ERROR: This method doesn't exist
    // ...
}

// CORRECT - Implementing the required logic directly
async finishTurn() {
    this.battleManager.turnInProgress = false;
    
    // Process player team cooldowns
    this.battleManager.playerTeam.forEach(character => {
        if (character && character.abilities && Array.isArray(character.abilities)) {
            character.abilities.forEach(ability => {
                if (ability && ability.currentCooldown && ability.currentCooldown > 0) {
                    ability.currentCooldown--;
                }
            });
        }
    });
    // ...
}
```

When refactoring, we must ensure that either:
1. All necessary sub-logic (like cooldown reduction) is also moved or implemented within the new component.
2. Any required helper methods called on other components are explicitly verified to exist or are created as part of the refactoring.

### Action Item:
- Create a cross-reference of all methods called within refactored code blocks
- Verify each referenced method exists in the new architecture
- Document critical dependencies between components

## 4. Event Dispatch Completeness

### Lesson: Ensure All Required Events Are Dispatched
**From**: CHANGELOG_0.5.20_Health_Bar_Events.md

When refactoring event-based systems, ensure all necessary events are still being dispatched from their new locations. In our case, health bars weren't updating visually because the `CHARACTER_DAMAGED` and `CHARACTER_HEALED` events weren't being dispatched after moving health calculation logic from BattleManager to BattleFlowController.

```javascript
// MISSING - Event dispatch code wasn't moved with the health calculation logic
action.target.currentHp = Math.max(0, action.target.currentHp - action.damage);
const actualDamage = previousHp - action.target.currentHp;
// No event dispatch, so UI doesn't update

// CORRECTED - Added proper event dispatch to update the UI
action.target.currentHp = Math.max(0, action.target.currentHp - action.damage);
const actualDamage = previousHp - action.target.currentHp;

// Dispatch CHARACTER_DAMAGED event via BattleBridge
if (window.battleBridge && actualDamage > 0) {
    try {
        window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
            character: action.target,
            target: action.target,
            newHealth: action.target.currentHp,
            maxHealth: action.target.stats.hp,
            amount: actualDamage,
            source: action.actor,
            ability: action.ability
        });
    } catch (error) {
        console.error('[BattleFlowController] Error dispatching CHARACTER_DAMAGED event:', error);
    }
}
```

This demonstrates how moving the core logic isn't sufficient - we must also maintain all side effects like event dispatching to preserve the system's overall behavior.

### Action Item:
- Create a catalog of all events dispatched by refactored code
- Ensure each event is still dispatched from the new component
- Add comprehensive event-related tests to verify proper event flow

## 5. Property vs. Method Access

### Lesson: Be Consistent with State Access Patterns
**From**: CHANGELOG_0.5.17_BattleFlowFixes_Success.md

When refactoring, pay attention to how object state is accessed. In our case, we had inconsistent patterns where some code used method calls (`char.isDefeated()`) while refactored code used property access (`char.isDead || char.currentHp <= 0`).

```javascript
// INCORRECT - Method doesn't exist in the refactored architecture
const playerDefeated = this.battleManager.playerTeam.filter(char => char.isDefeated()).length;

// CORRECT - Use property access consistent with the architecture
const playerDefeated = this.battleManager.playerTeam.filter(char => char.isDead || char.currentHp <= 0).length;
```

These mismatches in state access patterns can be particularly troublesome because the TypeScript compiler doesn't catch them, and they only manifest at runtime.

### Action Item:
- Document standard patterns for state access (properties vs. methods)
- Use consistent patterns across the codebase
- Create a catalog of critical state properties and their access methods

## 6. Diagnostic Logging Strategies

### Lesson: Strategic Diagnostic Logging Is Invaluable
**From**: CHANGELOG_0.5.15_DiagnosticLogging.md and CHANGELOG_0.5.18_BattleFlow_Diagnostics.md

When refactoring complex systems, strategic diagnostic logging is invaluable for identifying issues. We successfully used:

1. **Tracing Execution Flow**: Adding logs at key steps to see where execution stops:
   ```javascript
   console.log(`>>> BFC.executeNextAction: Effect applied for ${action?.actor?.name}.`);
   console.log(`>>> BFC.executeNextAction: Checking battle end...`);
   // ...
   console.log(`>>> BFC.executeNextAction: Scheduling next action...`);
   ```

2. **Instance Verification**: Adding logs immediately after object creation to verify proper initialization:
   ```javascript
   const controller = new BattleFlowController(this);
   console.log("[BattleManager] Created BattleFlowController instance:", controller);
   console.log("[BattleManager] Controller methods:", {
       startBattle: typeof controller.startBattle,
       startNextTurn: typeof controller.startNextTurn,
       executeNextAction: typeof controller.executeNextAction
   });
   ```

3. **Object Inspection**: Using detailed property inspection to troubleshoot missing methods:
   ```javascript
   console.log("[BattleManager] Controller prototype chain:", 
       Object.getPrototypeOf(this.battleFlowController));
   ```

These techniques quickly identified both the method delegation issues and the asynchronous flow problems.

### Action Item:
- Create reusable diagnostic logging utilities for future refactoring efforts
- Add clearly marked debugging code with removal reminders
- Document key execution paths that benefit from tracing

## 7. Defensive Programming in Refactored Code

### Lesson: Add Robust Error Handling and Type Checking
**From**: CHANGELOG_0.5.19_BattleFlow_Cooldowns.md

When refactoring components that interact with complex data structures, add robust error handling and type checking to prevent runtime issues. Our cooldown reduction implementation demonstrates good defensive programming:

```javascript
// Comprehensive null and type checking
this.battleManager.playerTeam.forEach(character => {
    if (character && character.abilities && Array.isArray(character.abilities)) {
        character.abilities.forEach(ability => {
            if (ability && ability.currentCooldown && ability.currentCooldown > 0) {
                ability.currentCooldown--;
            }
        });
    }
});
```

This approach safeguards against:
- Null/undefined characters
- Missing ability arrays
- Non-array ability properties
- Missing or invalid cooldown values

### Action Item:
- Implement consistent defensive programming patterns in refactored code
- Create robust validation utilities for complex data structures
- Add runtime type checking for critical properties

## 8. Sequential Refactoring Approach

### Lesson: The Graduated Extraction with Checkpoints Strategy Works
**From**: CHANGELOG_0.5.13b_BattleManager_Legacy_Code_Cleanup.md

Our approach of carefully planned, sequential refactoring with explicit checkpoints proved highly effective. We were able to:

1. Create shell files with minimal implementation first
2. Add toggle mechanism to control when new components were used
3. Implement one component at a time with verification at each step
4. Only remove legacy code once new components were verified working

This methodical approach allowed us to identify and fix issues without introducing catastrophic failures:
- Path reference issues were caught at Checkpoint #1
- Method delegation issues were caught at Checkpoint #2
- Event dispatch issues were caught at Checkpoint #3

### Action Item:
- Formalize the checkpoint verification process for future refactoring stages
- Document specific test cases for each checkpoint
- Create a standardized verification checklist for each refactoring stage

## 9. Clean Facade Pattern Implementation

### Lesson: Maintain Thin Delegating Methods
**From**: CHANGELOG_0.5.13b_BattleManager_Legacy_Code_Cleanup.md

Successfully implementing the facade pattern requires maintaining clean, thin delegating methods without leftover implementation code. Our initial implementation had remnants of original code remaining after proper delegation methods:

```javascript
// PROBLEM: Clean delegation method followed by orphaned implementation code
endBattle(result) {
    // Proper delegation
    this.battleFlowController.endBattle(result);
} // Method ends here

// Orphaned code causing syntax errors
this.battleActive = false;
// ...more orphaned code...
```

The clean, final implementation completely removed all legacy code, leaving only the delegation methods:

```javascript
// CORRECT: Clean delegation method with no orphaned code
endBattle(result) {
    // Delegate to the flow controller
    this.battleFlowController.endBattle(result);
}
// Next method follows properly
```

### Action Item:
- Implement a systematic cleanup step after implementing delegation methods
- Use automated testing to verify no orphaned code remains
- Consider static analysis tools to detect structural issues in JavaScript

## 10. Detailed Event Payload Design

### Lesson: Comprehensive Event Data Improves System Flexibility
**From**: CHANGELOG_0.5.20_Health_Bar_Events.md

When designing event payloads, include comprehensive data to support both current and potential future functionality. Our enhanced health event payloads demonstrate this:

```javascript
window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
    character: action.target,   // For backward compatibility
    target: action.target,      // Explicit target reference
    newHealth: action.target.currentHp,  // Current health after change
    maxHealth: action.target.stats.hp,   // Maximum possible health
    amount: actualDamage,       // Amount of damage applied
    source: action.actor,       // Character that caused the damage
    ability: action.ability     // Ability that was used (if applicable)
});
```

This comprehensive event data:
- Maintains backward compatibility with existing listeners
- Provides explicit source/target relationships
- Includes both absolute and relative health values
- Creates extensibility for future visual enhancements

### Action Item:
- Create standard event payload patterns with consistent property naming
- Document event structure for all system events
- Include potential future use cases when designing event payloads

## Conclusion

These lessons learned from Stage 3 of our refactoring effort provide valuable guidance for future refactoring stages. By incorporating these insights into our development process, we can:

1. Avoid repeating similar issues in future refactoring stages
2. Create more robust and maintainable code
3. Implement more efficient troubleshooting approaches
4. Improve our overall refactoring methodology

As we move forward with Stages 4-7 of the BattleManager refactoring, we'll apply these lessons to create a smoother, more reliable implementation process.

===== FILE: BattleManager  Stage 6 Refactoring- Implementation Plan.md =====
# Stage 6 Refactoring Plan: Passive Ability System

## Components to Implement

For Stage 6, we need to implement two key components:

1. **PassiveTriggerTracker** - Track and manage passive ability trigger state
2. **PassiveAbilityManager** - Process and execute passive abilities

## Detailed Implementation Plan

### Version 0.5.27.1 - PassiveTriggerTracker Implementation- Complete

**Purpose**: Extract passive ability trigger tracking into a dedicated component

**Key Responsibilities**:
- Track which passive abilities have triggered this turn
- Track which passive abilities have triggered this battle
- Provide methods to record and check trigger status
- Handle trigger stack counting

**Implementation Steps**:
1. Create `js/battle_logic/passives/PassiveTriggerTracker.js`
2. Implement core tracking methods:
   - `recordTrigger(character, passiveId, trigger)` - Record a passive trigger
   - `hasFiredThisTurn(character, passiveId, trigger)` - Check if fired this turn
   - `hasFiredThisBattle(character, passiveId, trigger)` - Check if fired this battle
   - `resetTurnTracking()` - Clear per-turn tracking
   - `getMaxStacksForPassive(passiveId)` - Get trigger stack counts
3. Extract tracking logic from `processPassiveAbilities` method
4. Add proper initialization in BattleManager
5. Implement toggle for testing and backward compatibility

**Extracted Code From BattleManager**:
- Tracking initialization: `character.passiveTriggeredThisTurn` and `this.passiveTriggersThisBattle`
- Logic for tracking duplicate triggers

### Version 0.5.27.1_Cleanup - PassiveTriggerTracker Cleanup- complete

**Purpose**: Remove original tracking code and finalize the delegation

**Implementation Steps**:
1. Verify PassiveTriggerTracker functionality in battle testing
2. Remove original tracking initialization code from BattleManager
3. Update references to use new component
4. Ensure proper error handling for missing component
5. Document code reduction metrics

**Expected Code Reduction**:
- Approximately 25-30 lines of tracking initialization and duplicate trigger checking code
- Removes complex Map-based tracking from BattleManager
- Eliminates character-level tracking properties, centralizing state management

### Version 0.5.27.2 - PassiveAbilityManager Implementation- complete

**Purpose**: Extract passive ability execution logic into a dedicated component

**Key Responsibilities**:
- Determine which passives should trigger for an event
- Execute passive behaviors through behavior system
- Handle passive ability effects and messaging
- Coordinate with PassiveTriggerTracker

**Implementation Steps**:
1. Create `js/battle_logic/passives/PassiveAbilityManager.js`
2. Implement core methods:
   - `processPassiveAbilities(trigger, character, additionalData)` - Main entry point
   - `executePassiveBehavior(behavior, context)` - Execute specific passive
   - `canTriggerPassive(character, ability, trigger)` - Check if passive can trigger
   - `getPassivesByTriggerType(character, trigger)` - Find passives of specific trigger type
3. Extract execution logic from BattleManager's `processPassiveAbilities`
4. Add proper initialization and dependencies
5. Implement toggle mechanism for testing

**Extracted Code From BattleManager**:
- Passive validation logic (checking if character is alive, has passives)
- Context creation for passive behaviors
- Behavior execution and error handling
- Logging passive activation messages

### Version 0.5.27.2_Cleanup - PassiveAbilityManager Cleanup- Complete

**Purpose**: Remove original passive execution code and finalize the delegation

**Implementation Steps**:
1. Verify PassiveAbilityManager functionality in battle testing
2. Remove original passive execution code from BattleManager
3. Create thin facade method that delegates to PassiveAbilityManager
4. Add proper error handling for missing component
5. Document code reduction metrics

**Expected Code Reduction**:
- Approximately 70-80 lines from the entire `processPassiveAbilities` method
- Removes complex passive execution logic from BattleManager
- Eliminates deep nesting of ability iteration and condition checking
- Reduces error-prone manual event dispatching

### Total Expected Code Reduction for Stage 6

- Approximately 95-110 lines of code removed from BattleManager
- Converts complex, deeply nested passive handling logic to clean delegation calls
- Centralizes passive ability system in dedicated components
- Improves maintainability by isolating passive ability concerns

## Implementation Approach

We'll follow the successful "Extract-Verify-Remove" approach from Stage 5, with these key considerations:

### Component Architecture

1. **PassiveTriggerTracker**:
   - Standalone component with minimal dependencies
   - Simple data structure for tracking state
   - Public API for recording and checking triggers
   - Reset methods for turn boundaries

2. **PassiveAbilityManager**:
   - Depends on PassiveTriggerTracker and BattleBehaviors
   - Public API matches BattleManager method signatures
   - Enhanced error handling for component dependencies
   - Full preservation of event dispatching

### Technical Considerations

1. **Global Window Registration**:
   ```javascript
   // Make PassiveTriggerTracker available globally for traditional scripts
   if (typeof window !== 'undefined') {
     window.PassiveTriggerTracker = PassiveTriggerTracker;
     console.log("PassiveTriggerTracker class definition loaded and exported to window.PassiveTriggerTracker");
   }
   
   // Legacy global assignment for maximum compatibility
   window.PassiveTriggerTracker = PassiveTriggerTracker;
   ```

2. **BattleManager Toggle Mechanism**:
   ```javascript
   processPassiveAbilities(trigger, character, additionalData = {}) {
       // REFACTORING: Use new implementation if toggle is enabled
       if (this.useNewImplementation && this.passiveAbilityManager) {
           return this.passiveAbilityManager.processPassiveAbilities(trigger, character, additionalData);
       }
       
       // Original implementation follows
       // ... original code remains for now ...
   }
   ```

3. **Component Initialization**:
   ```javascript
   async initializeComponentManagers() {
       // ... existing initialization code ...
       
       // Initialize passive system components
       if (window.PassiveTriggerTracker) {
           this.passiveTriggerTracker = new window.PassiveTriggerTracker();
           console.log('BattleManager: PassiveTriggerTracker initialized');
       }
       
       if (window.PassiveAbilityManager) {
           this.passiveAbilityManager = new window.PassiveAbilityManager(this, this.passiveTriggerTracker);
           console.log('BattleManager: PassiveAbilityManager initialized');
       }
   }
   ```

## Success Criteria

1. **Functionality Preservation**:
   - Passive abilities should trigger exactly as before
   - No changes to game behavior despite code reorganization
   - All battle log messages maintained

2. **Code Organization**:
   - Clear separation of responsibilities between components
   - PassiveTriggerTracker handles state tracking
   - PassiveAbilityManager handles execution logic

3. **Code Reduction**:
   - At least 95 lines removed from BattleManager
   - Thin facade methods remain for backward compatibility
   - Precise metrics documented in each cleanup changelog



This plan follows the proven methodical approach from the previous stages, ensuring we maintain functionality while improving code organization and maintainability. Each component is designed to handle a specific responsibility, making the system easier to understand, test, and extend. The code reduction metrics will help quantify the success of this refactoring effort.

===== FILE: BattleManager  Stage7_Combined_Implementation_Plan.md =====
# Combined Refactor and Cleanup Plan: Stage 7 Implementation

## Overview

This plan combines both the implementation and cleanup into a single operation for each component, creating a more streamlined approach. This aligns with the "Single-Path Implementation" strategy mentioned in the Stage 4 lessons learned document. We'll maintain clear separation between the two components but implement each with its cleanup in one step.

## Pre-Implementation Steps

### 1. Backup Strategy
- Create a branch or commit in Git before starting (for easy rollback)
- Save copies of the original files:
  - `BattleManager.js` â†’ `BattleManager.js.pre_stage7`
  - `BattleEventDispatcher.js` â†’ `BattleEventDispatcher.js.pre_stage7`
  - `BattleLogManager.js` â†’ `BattleLogManager.js.pre_stage7`

### 2. Preparation
- Ensure all required dependencies are loaded in the correct order in `index.html`
- Confirm Stage 6 components work correctly (all previous delegations function properly)

## Component 1: BattleEventDispatcher Implementation

### Version 0.5.28.1 - Complete BattleEventDispatcher Implementation

1. **Fix Module Syntax and Implementation**
```javascript
/**
 * BattleEventDispatcher.js
 * Handles dispatching battle events to UI and other systems
 * Version 0.5.28.1 - Combined implementation and cleanup
 */

class BattleEventDispatcher {
    /**
     * Create a new Battle Event Dispatcher
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        this.initialized = false;
        this.eventListeners = new Map(); // Store custom event listeners
        
        // Reference to battleBridge event types
        this.eventTypes = window.battleBridge?.eventTypes || {};
        
        // Verification and logging
        if (window.battleBridge) {
            this.initialized = true;
            console.log("[BattleEventDispatcher] Initialized with battleBridge");
        } else {
            console.warn("[BattleEventDispatcher] battleBridge not found - events may not dispatch correctly");
        }
    }

    /**
     * Dispatch a battle event
     * @param {string} eventType - The type of event
     * @param {Object} eventData - The event data
     * @returns {boolean} True if dispatched successfully
     */
    dispatchEvent(eventType, eventData) {
        // Parameter validation
        if (!eventType) {
            console.error("[BattleEventDispatcher] Invalid event type: null or undefined");
            return false;
        }
        
        if (!eventData || typeof eventData !== 'object') {
            console.warn("[BattleEventDispatcher] Event data should be an object, using empty object instead");
            eventData = {};
        }
        
        // Console logging for debugging
        console.log(`[BattleEventDispatcher] Dispatching ${eventType}`);
        
        // First, notify custom listeners
        this.notifyListeners(eventType, eventData);
        
        // Then dispatch via battleBridge if available
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(eventType, eventData);
                return true;
            } catch (error) {
                console.error(`[BattleEventDispatcher] Error dispatching ${eventType} via battleBridge:`, error);
            }
        }
        
        return false;
    }

    /**
     * Add an event handler for a specific event type
     * @param {string} eventType - The type of event to listen for
     * @param {Function} handler - The handler function
     * @returns {boolean} True if handler was added successfully
     */
    addEventHandler(eventType, handler) {
        if (!eventType || typeof handler !== 'function') {
            console.error("[BattleEventDispatcher] Invalid eventType or handler");
            return false;
        }
        
        if (!this.eventListeners.has(eventType)) {
            this.eventListeners.set(eventType, []);
        }
        
        this.eventListeners.get(eventType).push(handler);
        return true;
    }
    
    /**
     * Remove an event handler
     * @param {string} eventType - The type of event
     * @param {Function} handler - The handler function to remove
     * @returns {boolean} True if handler was removed successfully
     */
    removeEventHandler(eventType, handler) {
        if (!eventType || !this.eventListeners.has(eventType)) {
            return false;
        }
        
        const listeners = this.eventListeners.get(eventType);
        const index = listeners.indexOf(handler);
        
        if (index !== -1) {
            listeners.splice(index, 1);
            return true;
        }
        
        return false;
    }
    
    /**
     * Notify all listeners for a specific event type
     * @param {string} eventType - The type of event
     * @param {Object} eventData - The event data
     */
    notifyListeners(eventType, eventData) {
        if (!this.eventListeners.has(eventType)) {
            return;
        }
        
        const listeners = this.eventListeners.get(eventType);
        listeners.forEach(handler => {
            try {
                handler(eventData);
            } catch (error) {
                console.error(`[BattleEventDispatcher] Error in event handler for ${eventType}:`, error);
            }
        });
    }

    /**
     * Dispatch a battle log message event
     * @param {string} message - The log message
     * @param {string} type - The message type
     * @returns {boolean} True if dispatched successfully
     */
    dispatchBattleLogEvent(message, type = 'default') {
        return this.dispatchEvent(this.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
            message,
            type
        });
    }
    
    /**
     * Dispatch a character damaged event
     * @param {Object} character - The damaged character
     * @param {number} amount - The damage amount
     * @param {Object} source - The damage source
     * @param {Object} ability - The ability used
     * @returns {boolean} True if dispatched successfully
     */
    dispatchCharacterDamagedEvent(character, amount, source = null, ability = null) {
        return this.dispatchEvent(this.eventTypes.CHARACTER_DAMAGED || 'CHARACTER_DAMAGED', {
            character,
            target: character, // For backward compatibility
            newHealth: character.currentHp,
            maxHealth: character.stats.hp,
            amount,
            source,
            ability
        });
    }
    
    /**
     * Dispatch a character healed event
     * @param {Object} character - The healed character
     * @param {number} amount - The healing amount
     * @param {Object} source - The healing source
     * @param {Object} ability - The ability used
     * @returns {boolean} True if dispatched successfully
     */
    dispatchCharacterHealedEvent(character, amount, source = null, ability = null) {
        return this.dispatchEvent(this.eventTypes.CHARACTER_HEALED || 'CHARACTER_HEALED', {
            character,
            newHealth: character.currentHp,
            maxHealth: character.stats.hp,
            amount,
            source,
            ability
        });
    }
}

// Make BattleEventDispatcher available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleEventDispatcher = BattleEventDispatcher;
    console.log("BattleEventDispatcher class definition loaded and exported to window.BattleEventDispatcher");
}

// Legacy global assignment for maximum compatibility
window.BattleEventDispatcher = BattleEventDispatcher;
```

2. **Add BattleManager Integration**
   - Update `initializeComponentManagers()` in BattleManager.js:

```javascript
// Initialize event dispatcher (Stage 7)
if (window.BattleEventDispatcher) {
    this.battleEventDispatcher = new window.BattleEventDispatcher(this);
    console.log('BattleManager: BattleEventDispatcher initialized');
    
    // Verify methods exist
    console.log('>>> BattleEventDispatcher instance check:', {
        dispatchEvent: typeof this.battleEventDispatcher.dispatchEvent === 'function',
        addEventHandler: typeof this.battleEventDispatcher.addEventHandler === 'function',
        removeEventHandler: typeof this.battleEventDispatcher.removeEventHandler === 'function'
    });
}
```

3. **Add Direct Facade Method in BattleManager**
   - Add this method to BattleManager without toggle:

```javascript
/**
 * Dispatch a battle event
 * @param {string} eventType - The type of event
 * @param {Object} eventData - The event data
 * @returns {boolean} True if dispatched successfully
 */
dispatchBattleEvent(eventType, eventData) {
    // Direct delegation - no toggle mechanism for streamlined implementation
    if (this.battleEventDispatcher) {
        return this.battleEventDispatcher.dispatchEvent(eventType, eventData);
    }
    
    // Minimal fallback implementation (no original implementation preserved)
    console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch ${eventType}`);
    
    // Try direct battleBridge as last resort
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(eventType, eventData);
            return true;
        } catch (error) {
            console.error(`[BattleManager] Error dispatching ${eventType}:`, error);
        }
    }
    
    return false;
}
```

## Component 2: BattleLogManager Implementation

### Version 0.5.28.2 - Complete BattleLogManager Implementation

1. **Fix Module Syntax and Implementation**
```javascript
/**
 * BattleLogManager.js
 * Manages battle log messages and formatting
 * Version 0.5.28.2 - Combined implementation and cleanup
 */

class BattleLogManager {
    /**
     * Create a new Battle Log Manager
     * @param {Object} battleManager - The main battle manager
     * @param {Object} eventDispatcher - The event dispatcher
     */
    constructor(battleManager, eventDispatcher) {
        this.battleManager = battleManager;
        this.eventDispatcher = eventDispatcher;
        
        // Validate dependencies
        if (!this.eventDispatcher) {
            console.warn("[BattleLogManager] EventDispatcher not provided, messages won't be dispatched");
        }
        
        // Initialize validation lists
        this.validTypes = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy', 'status'];
        
        // Log initialization
        console.log("[BattleLogManager] Initialized");
    }

    /**
     * Log a message to the battle log
     * @param {string} message - The message to log
     * @param {string} type - The type of message (default, info, success, action, error)
     * @returns {boolean} True if logged successfully
     */
    logMessage(message, type = 'default') {
        // Parameter validation
        if (!message) {
            console.warn("[BattleLogManager] Empty message not logged");
            return false;
        }
        
        // Ensure type is valid
        if (!this.validTypes.includes(type)) {
            console.warn(`[BattleLogManager] Invalid type '${type}', defaulting to 'default'`);
            type = 'default';
        }
        
        // Log to console for debugging
        console.log(`[BattleLog ${type}]: ${message}`);
        
        // Dispatch via eventDispatcher if available
        if (this.eventDispatcher) {
            return this.eventDispatcher.dispatchBattleLogEvent(message, type);
        }
        
        // Direct fallback if no eventDispatcher
        if (window.battleBridge) {
            try {
                window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
                    message: message,
                    type: type
                });
                return true;
            } catch (error) {
                console.error('[BattleLogManager] Error dispatching log message:', error);
            }
        }
        
        return false;
    }

    /**
     * Format a message with character information
     * @param {string} message - The base message
     * @param {Object} character - The character
     * @param {string} type - The message type
     * @returns {string} The formatted message
     */
    formatMessage(message, character, type = 'default') {
        // If no character provided, return original message
        if (!character) {
            return message;
        }
        
        // Add team identifier
        const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
        return `${character.name}${teamIdentifier} ${message}`;
    }

    /**
     * Display a summary of all characters' health at the end of a turn
     * @returns {boolean} True if summary was displayed successfully
     */
    displayTurnSummary() {
        this.logMessage('------ END OF TURN SUMMARY ------', 'info');
        
        // Show player team summary
        this.logMessage('Player Team:', 'info');
        
        if (!this.battleManager || !Array.isArray(this.battleManager.playerTeam)) {
            this.logMessage('Error: Player team not available', 'error');
        } else {
            this.battleManager.playerTeam.forEach(character => {
                const status = character.isDead ? 'ðŸ’€ DEFEATED' : 
                              `HP: ${character.currentHp}/${character.stats.hp}`;
                const statusColor = this.determineHealthColor(character);
                this.logMessage(`  ${character.name}: ${status}`, statusColor);
            });
        }
        
        // Show enemy team summary
        this.logMessage('Enemy Team:', 'info');
        
        if (!this.battleManager || !Array.isArray(this.battleManager.enemyTeam)) {
            this.logMessage('Error: Enemy team not available', 'error');
        } else {
            this.battleManager.enemyTeam.forEach(character => {
                const status = character.isDead ? 'ðŸ’€ DEFEATED' : 
                              `HP: ${character.currentHp}/${character.stats.hp}`;
                const statusColor = this.determineHealthColor(character);
                this.logMessage(`  ${character.name}: ${status}`, statusColor);
            });
        }
        
        this.logMessage('--------------------------------', 'info');
        
        return true;
    }

    /**
     * Determine the color to use for health status
     * @param {Object} character - The character
     * @returns {string} The color type to use
     */
    determineHealthColor(character) {
        if (!character) return 'default';
        
        if (character.isDead) return 'error';
        
        const healthPercent = character.currentHp / character.stats.hp;
        
        if (healthPercent < 0.3) return 'error';
        if (healthPercent < 0.7) return 'action';
        return 'success';
    }
}

// Make BattleLogManager available globally for traditional scripts
if (typeof window !== 'undefined') {
    window.BattleLogManager = BattleLogManager;
    console.log("BattleLogManager class definition loaded and exported to window.BattleLogManager");
}

// Legacy global assignment for maximum compatibility
window.BattleLogManager = BattleLogManager;
```

2. **Add BattleManager Integration**
   - Update `initializeComponentManagers()` in BattleManager.js:

```javascript
// Initialize battle log manager after event dispatcher (Stage 7)
if (window.BattleLogManager && this.battleEventDispatcher) {
    this.battleLogManager = new window.BattleLogManager(this, this.battleEventDispatcher);
    console.log('BattleManager: BattleLogManager initialized');
    
    // Verify methods exist
    console.log('>>> BattleLogManager instance check:', {
        logMessage: typeof this.battleLogManager.logMessage === 'function',
        displayTurnSummary: typeof this.battleLogManager.displayTurnSummary === 'function'
    });
}
```

3. **Replace Original Methods in BattleManager with Direct Facade Methods**
   - Replace `logMessage()` in BattleManager:

```javascript
/**
 * Log a message to the battle log
 * @param {string} message - The message to log
 * @param {string} type - The type of message (default, info, success, action, error)
 * @returns {boolean} True if logged successfully
 */
logMessage(message, type = 'default') {
    // Direct delegation - no toggle mechanism for streamlined implementation
    if (this.battleLogManager) {
        return this.battleLogManager.logMessage(message, type);
    }
    
    // Minimal fallback implementation (no original implementation preserved)
    console.warn(`[BattleManager] BattleLogManager not available, using minimal logging`);
    console.log(`[BattleLog ${type}]: ${message}`);
    
    // Try direct UI or battleBridge communication as last resort
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
                message: message,
                type: type
            });
        } catch (error) {
            console.error('[BattleManager] Error dispatching log event:', error);
        }
    }
    
    return false;
}
```

   - Replace `displayTurnSummary()` in BattleManager:

```javascript
/**
 * Display a summary of all characters' health at the end of a turn
 * @returns {boolean} True if summary was displayed successfully
 */
displayTurnSummary() {
    // Direct delegation - no toggle mechanism for streamlined implementation
    if (this.battleLogManager) {
        return this.battleLogManager.displayTurnSummary();
    }
    
    // Minimal fallback with warning
    console.warn("[BattleManager] BattleLogManager not available, cannot display turn summary");
    return false;
}
```

## Integration in index.html

Ensure proper script loading order:

```html
<!-- Stage 7 Components - Must be loaded before BattleManager -->
<script src="js/battle_logic/events/BattleEventDispatcher.js" defer></script>
<script src="js/battle_logic/events/BattleLogManager.js" defer></script>

<!-- BattleManager -->
<script src="js/managers/BattleManager.js" defer></script>
```

## Testing and Rollback Strategy

### Verification Tests

1. **Basic Initialization Verification**
   - Check console for component initialization success messages 
   - Verify method availability in console logs

2. **BattleEventDispatcher Functionality Tests**
   - Start a battle and check if events dispatch correctly
   - Watch for proper UI updates showing event handling

3. **BattleLogManager Functionality Tests**
   - Check for battle log messages appearing in the UI
   - Verify turn summary displays with team identification

### Rollback Strategy

If anything goes wrong:

1. **Immediate Rollback**
   - Use Git to revert to the pre-stage7 commit
   - Alternatively, restore the `.pre_stage7` backup files

2. **Partial Rollback Options**
   - If just one component fails, can roll back only that component
   - Restore the original BattleManager method(s) that were replaced

3. **Issues to Monitor**
   - Event dispatching failures (UI not updating)
   - Missing battle log messages
   - Console errors related to missing methods

## Documentation

Create the following changelog entries:

### High-Level Changelog (changelog.md)
```
### Version 0.5.28 - Stage 7 Refactoring (Event and Logging System)
- **Technical**: Completed Stage 7 of BattleManager refactoring with combined implementation/cleanup
- **Technical**: Extracted event dispatching to BattleEventDispatcher component 
- **Technical**: Moved battle log functionality to BattleLogManager component
- **Technical**: Reduced BattleManager size by ~80 lines through extraction
```

### Detailed Technical Changelog (CHANGELOG_0.5.28_Stage7_Refactoring.md)
```
# Version 0.5.28 - Stage 7 Refactoring (Event and Logging System)

This release implements Stage 7 of the BattleManager refactoring plan, extracting event dispatching and battle logging into specialized components. Unlike previous stages, we've combined the implementation and cleanup into a single step for a more streamlined process.

## Overview
- Implemented BattleEventDispatcher for centralized event handling
- Created BattleLogManager for battle log messages and formatting
- Removed event and logging code from BattleManager
- Added direct facade methods without toggles

## Implementation Details

### BattleEventDispatcher
The BattleEventDispatcher centralizes all event dispatching through a consistent interface:

- Provides methods for adding and removing event handlers
- Dispatches events to both custom handlers and battleBridge
- Implements helper methods for common event types
- Includes comprehensive error handling and validation

### BattleLogManager
The BattleLogManager handles all battle log messages and formatting:

- Formats messages with team identification
- Manages turn summary presentation
- Includes validation and error handling
- Uses BattleEventDispatcher for event dispatching

### Direct Facade Implementation
Unlike previous stages, we've implemented direct facade methods without toggle mechanisms:

- Simplified the implementation by removing toggle code
- Added robust fallbacks for when components aren't available
- Maintained backward compatibility through facade methods

## Code Reduction Metrics
- Removed ~40 lines from BattleManager related to event dispatching
- Removed ~40 lines from BattleManager related to battle logging
- Total reduction: ~80 lines

## Testing Notes
- Full battle flow testing with both DOM and Phaser UI
- Verified event dispatching to UI components
- Confirmed all battle log messages display correctly

## Lessons Applied
- Used combined implementation/cleanup approach from Stage 4 lessons
- Applied defensive programming patterns from Stage 5 and 6
- Implemented comprehensive error handling from Stage 6
```

## Summary

This combined approach implements both components and their direct facade methods in BattleManager in a single step, eliminating the toggle mechanism. Key differences from the previous approach:

1. No toggle implementation - direct delegation immediately
2. Minimal fallback code instead of preserving original implementation
3. Clear rollback strategy using source control
4. Both components implemented fully in a single operation

The risk is higher, but the payoff is a cleaner, more direct implementation without the temporary toggle state. If any issues arise, we can use the source control rollback mechanism to restore the original state.

===== FILE: BattleManager  Stage7_Implementation_Plan.md =====
# Stage 7 Detailed Implementation Plan: Event and Logging System

## Overview

This plan details the implementation of Stage 7 of the BattleManager refactoring, focusing on the BattleEventDispatcher and BattleLogManager components. These components will centralize event dispatching and battle logging functionality, following the established architectural patterns from previous stages.

## Component 1: BattleEventDispatcher

### Version 0.5.28.1 - BattleEventDispatcher Implementation

**Purpose**: Centralize event dispatching and provide a standardized event system interface.

#### Implementation Steps:

1. **Fix Module Syntax**
   - Remove `export default` statement
   - Replace with proper global window registration pattern:
   ```javascript
   // Make BattleEventDispatcher available globally for traditional scripts
   if (typeof window !== 'undefined') {
     window.BattleEventDispatcher = BattleEventDispatcher;
     console.log("BattleEventDispatcher class definition loaded and exported to window.BattleEventDispatcher");
   }
   
   // Legacy global assignment for maximum compatibility
   window.BattleEventDispatcher = BattleEventDispatcher;
   ```

2. **Core Methods Implementation**
   - **Constructor**: Add proper defensive initialization
   ```javascript
   constructor(battleManager) {
     this.battleManager = battleManager;
     this.initialized = false;
     this.eventListeners = new Map(); // Store custom event listeners
     
     // Reference to battleBridge event types
     this.eventTypes = window.battleBridge?.eventTypes || {};
     
     // Verification and logging
     if (window.battleBridge) {
       this.initialized = true;
       console.log("[BattleEventDispatcher] Initialized with battleBridge");
     } else {
       console.warn("[BattleEventDispatcher] battleBridge not found - events may not dispatch correctly");
     }
   }
   ```

   - **dispatchEvent**: Enhanced with validation and error handling
   ```javascript
   dispatchEvent(eventType, eventData) {
     // Parameter validation
     if (!eventType) {
       console.error("[BattleEventDispatcher] Invalid event type: null or undefined");
       return false;
     }
     
     if (!eventData || typeof eventData !== 'object') {
       console.warn("[BattleEventDispatcher] Event data should be an object, using empty object instead");
       eventData = {};
     }
     
     // Console logging for debugging
     console.log(`[BattleEventDispatcher] Dispatching ${eventType}:`, 
        typeof eventData === 'object' ? { ...eventData } : eventData);
     
     // First, notify custom listeners
     this.notifyListeners(eventType, eventData);
     
     // Then dispatch via battleBridge if available
     if (window.battleBridge) {
       try {
         window.battleBridge.dispatchEvent(eventType, eventData);
         return true;
       } catch (error) {
         console.error(`[BattleEventDispatcher] Error dispatching ${eventType} via battleBridge:`, error);
       }
     }
     
     return false;
   }
   ```

   - **Custom Event Handling Methods**
   ```javascript
   addEventHandler(eventType, handler) {
     if (!eventType || typeof handler !== 'function') {
       console.error("[BattleEventDispatcher] Invalid eventType or handler");
       return false;
     }
     
     if (!this.eventListeners.has(eventType)) {
       this.eventListeners.set(eventType, []);
     }
     
     this.eventListeners.get(eventType).push(handler);
     return true;
   }
   
   removeEventHandler(eventType, handler) {
     if (!eventType || !this.eventListeners.has(eventType)) {
       return false;
     }
     
     const listeners = this.eventListeners.get(eventType);
     const index = listeners.indexOf(handler);
     
     if (index !== -1) {
       listeners.splice(index, 1);
       return true;
     }
     
     return false;
   }
   
   notifyListeners(eventType, eventData) {
     if (!this.eventListeners.has(eventType)) {
       return;
     }
     
     const listeners = this.eventListeners.get(eventType);
     listeners.forEach(handler => {
       try {
         handler(eventData);
       } catch (error) {
         console.error(`[BattleEventDispatcher] Error in event handler for ${eventType}:`, error);
       }
     });
   }
   ```

   - **Helper Methods for Common Events**
   ```javascript
   dispatchBattleLogEvent(message, type = 'default') {
     return this.dispatchEvent(this.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
       message,
       type
     });
   }
   
   dispatchCharacterDamagedEvent(character, amount, source = null, ability = null) {
     return this.dispatchEvent(this.eventTypes.CHARACTER_DAMAGED || 'CHARACTER_DAMAGED', {
       character,
       target: character, // For backward compatibility
       newHealth: character.currentHp,
       maxHealth: character.stats.hp,
       amount,
       source,
       ability
     });
   }
   
   dispatchCharacterHealedEvent(character, amount, source = null, ability = null) {
     return this.dispatchEvent(this.eventTypes.CHARACTER_HEALED || 'CHARACTER_HEALED', {
       character,
       newHealth: character.currentHp,
       maxHealth: character.stats.hp,
       amount,
       source,
       ability
     });
   }
   ```

3. **BattleManager Integration**
   - Add component initialization in BattleManager's `initializeComponentManagers()`
   ```javascript
   // Initialize event dispatcher (Stage 7)
   if (window.BattleEventDispatcher) {
       this.battleEventDispatcher = new window.BattleEventDispatcher(this);
       console.log('BattleManager: BattleEventDispatcher initialized');
       
       // Verify methods exist
       console.log('>>> BattleEventDispatcher instance check:', {
           dispatchEvent: typeof this.battleEventDispatcher.dispatchEvent === 'function',
           addEventHandler: typeof this.battleEventDispatcher.addEventHandler === 'function',
           removeEventHandler: typeof this.battleEventDispatcher.removeEventHandler === 'function'
       });
   }
   ```

4. **Add Facade Methods with Toggle in BattleManager**
   ```javascript
   // Direct facade to eventDispatcher - will be minimally used
   // since most events are dispatched from other components
   dispatchBattleEvent(eventType, eventData) {
     // REFACTORING: Use new implementation if toggle is enabled
     if (this.useNewImplementation && this.battleEventDispatcher) {
       return this.battleEventDispatcher.dispatchEvent(eventType, eventData);
     }
     
     // Original implementation (minimal wrapper around battleBridge)
     if (window.battleBridge) {
       try {
         window.battleBridge.dispatchEvent(eventType, eventData);
         return true;
       } catch (error) {
         console.error(`[BattleManager] Error dispatching ${eventType}:`, error);
       }
     }
     
     return false;
   }
   ```

### Version 0.5.28.1_Cleanup - BattleEventDispatcher Cleanup

After verifying the BattleEventDispatcher works correctly:

1. **Remove Original Implementation from BattleManager**
   - Keep only the thin facade method
   ```javascript
   dispatchBattleEvent(eventType, eventData) {
     // REFACTORING: Use new implementation if toggle is enabled
     if (this.useNewImplementation && this.battleEventDispatcher) {
       return this.battleEventDispatcher.dispatchEvent(eventType, eventData);
     }
     
     // Original implementation has been removed (v0.5.28.1_Cleanup)
     console.warn("BattleManager using legacy dispatchBattleEvent - BattleEventDispatcher not available");
     return false;
   }
   ```

## Component 2: BattleLogManager

### Version 0.5.28.2 - BattleLogManager Implementation

**Purpose**: Centralize all battle log message formatting and dispatching.

#### Implementation Steps:

1. **Fix Module Syntax**
   - Remove `export default` statement
   - Replace with proper global window registration pattern using the same approach as BattleEventDispatcher

2. **Core Methods Implementation**
   - **Constructor**: Add proper defensive initialization
   ```javascript
   constructor(battleManager, eventDispatcher) {
     this.battleManager = battleManager;
     this.eventDispatcher = eventDispatcher;
     
     // Validate dependencies
     if (!this.eventDispatcher) {
       console.warn("[BattleLogManager] EventDispatcher not provided, messages won't be dispatched");
     }
     
     // Initialize validation lists
     this.validTypes = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy', 'status'];
     
     // Log initialization
     console.log("[BattleLogManager] Initialized");
   }
   ```

   - **logMessage**: Enhanced with validation and formatting
   ```javascript
   logMessage(message, type = 'default') {
     // Parameter validation
     if (!message) {
       console.warn("[BattleLogManager] Empty message not logged");
       return false;
     }
     
     // Ensure type is valid
     if (!this.validTypes.includes(type)) {
       console.warn(`[BattleLogManager] Invalid type '${type}', defaulting to 'default'`);
       type = 'default';
     }
     
     // Log to console for debugging
     console.log(`[BattleLog ${type}]: ${message}`);
     
     // Dispatch via eventDispatcher if available
     if (this.eventDispatcher) {
       return this.eventDispatcher.dispatchBattleLogEvent(message, type);
     }
     
     // Direct fallback if no eventDispatcher
     if (window.battleBridge) {
       try {
         window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
           message: message,
           type: type
         });
         return true;
       } catch (error) {
         console.error('[BattleLogManager] Error dispatching log message:', error);
       }
     }
     
     return false;
   }
   ```

   - **Format Message**: Format messages with team identifiers
   ```javascript
   formatMessage(message, character, type = 'default') {
     // If no character provided, return original message
     if (!character) {
       return message;
     }
     
     // Add team identifier
     const teamIdentifier = character.team === 'player' ? ' (ally)' : ' (enemy)';
     return `${character.name}${teamIdentifier} ${message}`;
   }
   ```

   - **Display Turn Summary**: Enhanced from BattleManager implementation
   ```javascript
   displayTurnSummary() {
     this.logMessage('------ END OF TURN SUMMARY ------', 'info');
     
     // Show player team summary
     this.logMessage('Player Team:', 'info');
     
     if (!this.battleManager || !Array.isArray(this.battleManager.playerTeam)) {
       this.logMessage('Error: Player team not available', 'error');
     } else {
       this.battleManager.playerTeam.forEach(character => {
         const status = character.isDead ? 'ðŸ’€ DEFEATED' : 
                       `HP: ${character.currentHp}/${character.stats.hp}`;
         const statusColor = this.determineHealthColor(character);
         this.logMessage(`  ${character.name}: ${status}`, statusColor);
       });
     }
     
     // Show enemy team summary
     this.logMessage('Enemy Team:', 'info');
     
     if (!this.battleManager || !Array.isArray(this.battleManager.enemyTeam)) {
       this.logMessage('Error: Enemy team not available', 'error');
     } else {
       this.battleManager.enemyTeam.forEach(character => {
         const status = character.isDead ? 'ðŸ’€ DEFEATED' : 
                       `HP: ${character.currentHp}/${character.stats.hp}`;
         const statusColor = this.determineHealthColor(character);
         this.logMessage(`  ${character.name}: ${status}`, statusColor);
       });
     }
     
     this.logMessage('--------------------------------', 'info');
     
     return true;
   }
   ```

   - **Helper Methods for Health Color**
   ```javascript
   determineHealthColor(character) {
     if (!character) return 'default';
     
     if (character.isDead) return 'error';
     
     const healthPercent = character.currentHp / character.stats.hp;
     
     if (healthPercent < 0.3) return 'error';
     if (healthPercent < 0.7) return 'action';
     return 'success';
   }
   ```

3. **BattleManager Integration**
   - Add component initialization in BattleManager's `initializeComponentManagers()`
   ```javascript
   // Initialize battle log manager after event dispatcher (Stage 7)
   if (window.BattleLogManager && this.battleEventDispatcher) {
     this.battleLogManager = new window.BattleLogManager(this, this.battleEventDispatcher);
     console.log('BattleManager: BattleLogManager initialized');
     
     // Verify methods exist
     console.log('>>> BattleLogManager instance check:', {
       logMessage: typeof this.battleLogManager.logMessage === 'function',
       displayTurnSummary: typeof this.battleLogManager.displayTurnSummary === 'function'
     });
   }
   ```

4. **Add Facade Method with Toggle in BattleManager**
   ```javascript
   logMessage(message, type = 'default') {
     // REFACTORING: Use new implementation if toggle is enabled
     if (this.useNewImplementation && this.battleLogManager) {
       return this.battleLogManager.logMessage(message, type);
     }
     
     // Original implementation
     // Log to console for debugging
     console.log(`[BattleLog ${type}]: ${message}`);
     
     // Dispatch event through BattleBridge if available
     if (window.battleBridge) {
       try {
         window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.BATTLE_LOG, {
           message: message,
           type: type
         });
       } catch (error) {
         console.warn('Failed to dispatch battle log event:', error);
       }
     }
     
     // Add to DOM battle log if in DOM mode and battleUI is available
     if (this.uiMode === "dom" && this.battleUI) {
       try {
         this.battleUI.addLogMessage(message, type);
       } catch (error) {
         console.error('Error adding message to battle UI:', error);
       }
     }
     
     return true;
   }
   ```

### Version 0.5.28.2_Cleanup - BattleLogManager Cleanup

After verifying the BattleLogManager works correctly:

1. **Remove Original Implementation from BattleManager's logMessage method**
   - Keep only the thin facade method
   ```javascript
   logMessage(message, type = 'default') {
     // REFACTORING: Use new implementation if toggle is enabled
     if (this.useNewImplementation && this.battleLogManager) {
       return this.battleLogManager.logMessage(message, type);
     }
     
     // Original implementation has been removed (v0.5.28.2_Cleanup)
     // Implementation now in BattleLogManager.logMessage
     console.warn("BattleManager using legacy logMessage - BattleLogManager not available");
     
     // Minimal fallback implementation
     console.log(`[BattleLog ${type}]: ${message}`);
     
     return false;
   }
   ```

2. **Remove Original Implementation from BattleManager's displayTurnSummary method**
   - Keep only the thin facade method
   ```javascript
   displayTurnSummary() {
     // REFACTORING: Use new implementation if toggle is enabled
     if (this.useNewImplementation && this.battleLogManager) {
       return this.battleLogManager.displayTurnSummary();
     }
     
     // Original implementation has been removed (v0.5.28.2_Cleanup)
     // Implementation now in BattleLogManager.displayTurnSummary
     console.warn("BattleManager using legacy displayTurnSummary - BattleLogManager not available");
     
     return false;
   }
   ```

## Integration in index.html

Ensure proper script loading order by adding the new component scripts before BattleManager.js:

```html
<!-- Stage 7 Components - Must be loaded before BattleManager -->
<script src="js/battle_logic/events/BattleEventDispatcher.js" defer></script>
<script src="js/battle_logic/events/BattleLogManager.js" defer></script>

<!-- BattleManager -->
<script src="js/managers/BattleManager.js" defer></script>
```

## Testing Approach

1. **Initial Setup Testing**
   - Verify both components load without errors
   - Check console for component initialization messages
   - Verify method validation in console output

2. **BattleEventDispatcher Testing**
   - Test registration of event handlers
   - Verify events dispatch through both custom listeners and battleBridge
   - Test error handling with invalid event types

3. **BattleLogManager Testing**
   - Verify basic message logging
   - Test turn summary display
   - Check message formatting with team identifiers

4. **Toggle Testing**
   - Test with toggle enabled (new implementation)
   - Test with toggle disabled (original implementation)
   - Ensure both paths work correctly

5. **Full Flow Testing**
   - Run a complete battle cycle
   - Verify all battle log messages appear correctly
   - Check all event types are dispatched

## Implementation Dependencies

1. **BattleEventDispatcher Dependencies**:
   - BattleManager (for team access)
   - battleBridge (for event dispatching)

2. **BattleLogManager Dependencies**:
   - BattleEventDispatcher (for event dispatching)
   - BattleManager (for team access)

## Success Criteria

1. **Code Organization**:
   - Event dispatching logic centralized in BattleEventDispatcher
   - Logging logic centralized in BattleLogManager
   - Clear separation of concerns

2. **Compatibility**:
   - All existing UI components still receive events
   - No visual or functional changes to battle system
   - Both DOM and Phaser UI modes fully functional

3. **Code Quality**:
   - Follows established patterns (global window registration, defensive programming)
   - Implements proper error handling and validation
   - Provides detailed diagnostics and logging

4. **Code Reduction**:
   - BattleManager.js file size reduced
   - Event handling logic removed from BattleManager
   - Logging logic removed from BattleManager

===== FILE: BattleManager_Further_Refactoring_Guide.md =====
# BattleManager Further Refactoring Guide

## Introduction

This guide outlines the continued refactoring of BattleManager.js to enhance its modularity and ensure it functions as a true orchestrator component. While significant progress has been made through the previous 7-stage refactoring plan, several responsibilities remain embedded within BattleManager that should be extracted into dedicated components.

We will follow a **"One-Shot Implementation & Validation"** workflow:

1. For each phase, we'll implement a single component completely
2. Implementation will include creating the new component file, moving the relevant logic, and updating BattleManager.js with facade methods
3. After each phase is complete, all changes will be validated before proceeding to the next phase
4. This iterative approach minimizes risk and ensures each component works correctly before further changes

## Phase 1: Complete BattleInitializer Component Implementation

### Context
BattleInitializer.js was planned as part of Stage 1 of the original refactoring plan but was not fully implemented. Key methods like `ensureCompleteCharacterInitialization`, `prepareTeamForBattle`, and `generateCharacterId` still contain their full logic within BattleManager.js, rather than being properly delegated.

### Objective
Move all team and character initialization logic from BattleManager.js into BattleInitializer.js. This will reduce BattleManager.js by approximately 170-180 lines of code and properly encapsulate team initialization responsibilities.

### Tasks

1. **Create/Update BattleInitializer.js**
   - Location: `js/battle_logic/core/BattleInitializer.js`
   - Define the `BattleInitializer` class
   - Implement the following methods:
     - `ensureCompleteCharacterInitialization(team, teamType)` - Move logic from BattleManager
     - `prepareTeamForBattle(team)` - Move logic from BattleManager
     - `generateCharacterId()` - Move logic from BattleManager
     - `initializeTeamsAndCharacters(rawPlayerTeam, rawEnemyTeam)` - Create new method to handle both teams at once

2. **Update BattleManager.js**
   - Ensure `this.battleInitializer` is properly initialized in `initializeComponentManagers()`
   - Replace the original methods with facade methods that delegate to `this.battleInitializer`
   - Update `startBattle()` to use the new component for team preparation
   - Add appropriate fallbacks if `this.battleInitializer` is not available

3. **Add Script Reference**
   - Ensure `BattleInitializer.js` is included in `index.html` with proper loading order

### Validation Point
After implementation:
- Verify BattleManager.js is significantly slimmer in these sections
- Confirm the facade pattern is correctly implemented
- Test that battles initialize correctly with all character data intact
- Verify team initialization works with both default and custom teams

## Phase 2: Enhance StatusEffectDefinitionLoader

### Context
Currently, BattleManager.js still contains JSON parsing logic for status effects and hardcoded fallback definitions. This logic should be fully moved to the StatusEffectDefinitionLoader component to complete the Stage 2 refactoring.

### Objective
Ensure all status effect definition loading logic resides exclusively in StatusEffectDefinitionLoader.js, reducing BattleManager.js by approximately 80-85 lines.

### Tasks

1. **Enhance StatusEffectDefinitionLoader.js**
   - Location: `js/battle_logic/status/StatusEffectDefinitionLoader.js`
   - Implement/complete the following methods:
     - `loadDefinitionsFromJson()` - Move logic from BattleManager.loadStatusEffectDefinitions
     - `setupFallbackDefinitions()` - Move logic from BattleManager.setupFallbackStatusEffects
     - Ensure compatibility with both DOM and Phaser UI modes

2. **Update BattleManager.js**
   - Simplify `loadStatusEffectDefinitions()` to be a pure delegation method
   - Simplify `setupFallbackStatusEffects()` to be a pure delegation method
   - Update initialization code to properly use the enhanced StatusEffectDefinitionLoader
   - Add appropriate fallbacks for backwards compatibility

### Validation Point
After implementation:
- Verify status effect definitions load correctly from JSON
- Confirm fallback definitions are properly created when JSON loading fails
- Ensure all status effects work correctly in battle
- Check that status effect icons and tooltips function as expected

## Phase 3: Create BattleUtilities Component

### Context
BattleManager.js contains several utility methods that are not directly related to battle management. These methods should be extracted into a dedicated utilities component.

### Objective
Consolidate generic utility functions into a separate BattleUtilities.js class, reducing BattleManager.js by approximately 40 lines.

### Tasks

1. **Create BattleUtilities.js**
   - Location: `js/battle_logic/utilities/BattleUtilities.js`
   - Implement the following static methods:
     - `getAllCharacters(battleManager)` - Move from BattleManager
     - `getCharacterByUniqueId(battleManager, uniqueId)` - Move from BattleManager
     - `shuffleArray(array)` - Move from BattleManager
     - `safeBattleStringify(obj, space)` - Move from BattleManager

2. **Update BattleManager.js**
   - Convert existing utility methods to facade methods that call BattleUtilities static methods
   - Add appropriate error handling and fallbacks
   - Implement method documentation for the new facade methods

3. **Add Script Reference**
   - Ensure `BattleUtilities.js` is included in `index.html` with proper loading order

### Validation Point
After implementation:
- Verify all utility functions work correctly when called through BattleManager
- Confirm direct calls to BattleUtilities static methods work from other components
- Test safeBattleStringify with circular references to ensure it handles them correctly
- Ensure character lookup and team iteration functions work properly in battle

## Implementation Considerations

1. **Global Registration Pattern**
   - All components must follow the global window registration pattern used throughout the project
   - Do not use ES Module syntax (import/export)
   - Register classes on the window object for traditional script access
   
2. **Backward Compatibility**
   - Add defensive fallbacks in BattleManager for when components are not available
   - Maintain the same method signatures for all facade methods
   - Provide helpful console warnings when falling back to legacy behavior

3. **Documentation**
   - Update changelogs for each phase (both high-level and technical)
   - Document the purpose and responsibilities of each new component
   - Add comprehensive JSDoc comments to all new methods

4. **Loading Order**
   - Ensure dependencies are loaded before components in index.html
   - Component scripts must load before BattleManager.js
   - Validate loading order in all test scenarios


===== FILE: BattleManager_Refactoring_Plan_Big Picture.md =====
# BattleManager Refactoring Plan: New Files and Structure

## Current Directory Structure
```
js/
â”œâ”€â”€ battle_logic/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ BattleManager.js (refactored, ~300 lines)
â”‚   â”‚   â”œâ”€â”€ BattleFlowController.js (~300 lines)
â”‚   â”‚   â””â”€â”€ BattleInitializer.js (~200 lines)
â”‚   â”œâ”€â”€ status/
â”‚   â”‚   â”œâ”€â”€ StatusEffectManager.js (~350 lines)
â”‚   â”‚   â””â”€â”€ StatusEffectDefinitionLoader.js (~150 lines)
â”‚   â”œâ”€â”€ damage/
â”‚   â”‚   â”œâ”€â”€ DamageCalculator.js (~200 lines)
â”‚   â”‚   â”œâ”€â”€ HealingProcessor.js (~150 lines)
â”‚   â”‚   â””â”€â”€ TypeEffectivenessCalculator.js (~100 lines)
â”‚   â”œâ”€â”€ abilities/
â”‚   â”‚   â”œâ”€â”€ AbilityProcessor.js (~250 lines)
â”‚   â”‚   â”œâ”€â”€ TargetingSystem.js (~200 lines)
â”‚   â”‚   â””â”€â”€ ActionGenerator.js (~250 lines)
â”‚   â”œâ”€â”€ passives/
â”‚   â”‚   â”œâ”€â”€ PassiveAbilityManager.js (~200 lines)
â”‚   â”‚   â””â”€â”€ PassiveTriggerTracker.js (~150 lines)
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ BattleEventDispatcher.js (~150 lines)
â”‚   â”‚   â””â”€â”€ BattleLogManager.js (~150 lines)
â”‚   â”œâ”€â”€ ActionDecisionBehaviors.js
â”‚   â”œâ”€â”€ BattleBehaviors.js
â”‚   â”œâ”€â”€ BehaviorRegistry.js
â”‚   â”œâ”€â”€ PassiveBehaviors.js
â”‚   â””â”€â”€ TargetingBehaviors.js
```

## Planned Directory Structure with Debug System
```
js/
â”œâ”€â”€ battle_logic/
â”‚   â”œâ”€â”€ [...existing structure...]
â”œâ”€â”€ debug/ (NEW)
â”‚   â”œâ”€â”€ DebugManager.js (~100 lines)
â”‚   â”œâ”€â”€ BattleDebugger.js (~150 lines)
â”‚   â”œâ”€â”€ TeamBuilderDebugger.js (~100 lines)
â”‚   â””â”€â”€ LoggingUtilities.js (~80 lines)
```

## Detailed Breakdown of Each File

### Core Battle Management

#### 1. BattleManager.js (refactored, ~300 lines)
**Purpose**: Main coordination class that delegates to specialized managers  
**Responsibilities**:
- Provide public API for other systems to interact with battle logic
- Maintain references to all component managers
- Hold basic battle state (active/paused/turn number)
- Store configuration settings and UI mode  

**Key Methods**:
- `initialize()` - Entry point that sets up all managers
- `startBattle()` - Facade method that delegates to BattleFlowController
- `togglePause()`, `pauseBattle()`, `resumeBattle()` - Battle flow control
- `setSpeed()` - Adjust battle speed multiplier  

**Relationships**:
- Owns instances of all other manager classes
- Primary interface for UI components via BattleBridge

#### 2. BattleFlowController.js (~300 lines)
**Purpose**: Manages the sequence and flow of battle from start to finish  
**Responsibilities**:
- Control turn sequence and action execution
- Utilize BehaviorRegistry for action decisions and targeting
- Manage battle state transitions  

**Key Methods**:
- `startBattle()` - Initialize teams and begin battle sequence
- `startNextTurn()` - Process turn start and prepare actions
- `generateTurnActions()` - Create actions using BehaviorRegistry
- `executeNextAction()` - Process the next queued action
- `finishTurn()` - Handle end-of-turn effects and cooldowns
- `checkBattleEnd()` - Check victory/defeat conditions  

**Relationships**:
- Called by BattleManager
- Uses BehaviorRegistry for decision-making
- Coordinates with StatusEffectManager for effect processing
- Utilizes AbilityProcessor for ability execution
- Uses PassiveAbilityManager for passive triggers

#### 3. BattleInitializer.js (~200 lines)
**Purpose**: Handle setup and initialization of battle components  
**Responsibilities**:
- Prepare team data for battle
- Load required data and systems
- Initialize state for a new battle  

**Key Methods**:
- `initialize()` - Main setup method
- `prepareTeamForBattle()` - Convert team data to battle-ready format
- `validateTeamData()` - Ensure team data is complete and correct
- `generateCharacterId()` - Create unique identifiers for characters
- `initializeBehaviorSystem()` - Set up behavior registry connection  

**Relationships**:
- Called by BattleManager during initialization
- Works with StatusEffectDefinitionLoader to load effect definitions

### Status Effect System

#### 4. StatusEffectManager.js (~350 lines)
**Purpose**: Manage application and processing of status effects  
**Responsibilities**:
- Apply and remove status effects on characters
- Process effects at turn start
- Handle effect stacking, duration, and expiration  

**Key Methods**:
- `processStatusEffects()` - Process all effects at turn start
- `addStatusEffect()` - Apply new effects or refresh existing ones
- `removeStatusEffect()` - Remove an effect from a character
- `getActiveEffects()` - Get all active effects on a character
- `updateStatusIcons()` - Trigger UI updates for status visualization  

**Relationships**:
- Used by BattleFlowController
- Uses StatusEffectDefinitionLoader for effect definitions
- Communicates with UI via BattleBridge

#### 5. StatusEffectDefinitionLoader.js (~150 lines)
**Purpose**: Load and validate status effect definitions  
**Responsibilities**:
- Load effect definitions from JSON
- Provide fallback definitions if loading fails
- Validate effect data integrity  

**Key Methods**:
- `loadDefinitions()` - Load from JSON file
- `validateDefinition()` - Ensure definition is valid
- `setupFallbackDefinitions()` - Create defaults if loading fails
- `getDefinition()` - Get a definition by ID  

**Relationships**:
- Used by StatusEffectManager
- Used by BattleInitializer during setup

### Damage System

#### 6. DamageCalculator.js (~200 lines)
**Purpose**: Handle all damage calculations  
**Responsibilities**:
- Calculate damage amounts based on stats and types
- Apply modifiers like critical hits and random variance
- Handle damage reduction from defense  

**Key Methods**:
- `calculateDamage()` - Core damage formula method
- `applyDefenseReduction()` - Apply defense stat effects
- `applyRandomVariance()` - Add random damage variance
- `calculateCritical()` - Handle critical hit calculations
- `calculateStatScaling()` - Apply STR/INT scaling  

**Relationships**:
- Used by AbilityProcessor
- Uses TypeEffectivenessCalculator for type advantages

#### 7. HealingProcessor.js (~150 lines)
**Purpose**: Handle healing calculations and health restoration  
**Responsibilities**:
- Calculate and apply healing amounts
- Handle resurrection logic
- Process healing-triggered effects  

**Key Methods**:
- `applyHealing()` - Core healing method
- `calculateHealingAmount()` - Determine healing with modifiers
- `applyStatScaling()` - Apply Spirit stat scaling
- `checkAndResetDeathStatus()` - Handle resurrection
- `processHealingEffects()` - Handle additional healing effects  

**Relationships**:
- Used by AbilityProcessor
- Called by StatusEffectManager for healing effects

#### 8. TypeEffectivenessCalculator.js (~100 lines)
**Purpose**: Calculate type advantage effects  
**Responsibilities**:
- Determine damage multipliers based on attacker/defender types
- Handle type immunities and special relationships
- Generate descriptive messages for type effects  

**Key Methods**:
- `calculateTypeMultiplier()` - Get damage multiplier
- `isImmune()` - Check for type immunity
- `getTypeAdvantageText()` - Get descriptive text
- `getTypeSpecialRelationship()` - Check for special type relationships  

**Relationships**:
- Used by DamageCalculator
- Used by AbilityProcessor

### Ability System

#### 9. AbilityProcessor.js (~250 lines)
**Purpose**: Execute ability effects and manage ability state  
**Responsibilities**:
- Process ability effects on targets
- Apply damage, healing, and status effects
- Manage ability cooldowns  

**Key Methods**:
- `processEffect()` - Process a single effect
- `applyEffectToTarget()` - Apply effect to a specific target
- `applyActionEffect()` - Apply all effects from an action
- `processAbilityByType()` - Handle different ability types
- `manageCooldowns()` - Update ability cooldowns  

**Relationships**:
- Used by BattleFlowController
- Uses DamageCalculator and HealingProcessor
- Uses StatusEffectManager for status effects

#### 10. TargetingSystem.js (~200 lines)
**Purpose**: Determine targets for abilities based on targeting rules
**Responsibilities**:
- Select appropriate targets for abilities
- Apply targeting logic based on ability type
- Handle area-of-effect targeting

**Key Methods**:
- `selectTarget()` - Find appropriate target based on targeting rules
- `getValidTargets()` - Get all valid targets for an ability
- `resolveTargeting()` - Resolve targeting for different ability types

**Relationships**:
- Used by AbilityProcessor
- Used by BattleBehaviors for action decision making

#### 11. ActionGenerator.js (~250 lines)
**Purpose**: Generate action objects for battle turns
**Responsibilities**:
- Create action objects for characters
- Determine which abilities to use
- Calculate base damage for actions

**Key Methods**:
- `generateAction()` - Create an action for a character
- `chooseAbility()` - Select an appropriate ability to use
- `createActionObject()` - Build the complete action object

**Relationships**:
- Used by BattleFlowController
- Uses BehaviorRegistry for decision making
- Uses TargetingSystem for target selection

### Passive System

#### 12. PassiveAbilityManager.js (~200 lines)
**Purpose**: Manage passive ability execution  
**Responsibilities**:
- Process passive abilities when triggers occur
- Execute passive behaviors
- Coordinate with PassiveTriggerTracker  

**Key Methods**:
- `processPassiveAbilities()` - Process passives for a trigger
- `executePassiveBehavior()` - Execute passive effects
- `canTriggerPassive()` - Check if passive can trigger
- `getPassivesByTriggerType()` - Find passives of specific trigger type  

**Relationships**:
- Used by BattleFlowController
- Uses PassiveTriggerTracker to track triggers
- Uses BattleLogManager for passive trigger messages

#### 13. PassiveTriggerTracker.js (~150 lines)
**Purpose**: Track passive ability triggers  
**Responsibilities**:
- Record passive triggers by turn and battle
- Provide trigger status information
- Reset tracking on turn/battle boundaries  

**Key Methods**:
- `recordTrigger()` - Record that a passive triggered
- `hasFiredThisTurn()` - Check if passive fired this turn
- `hasFiredThisBattle()` - Check if passive fired in battle
- `resetTurnTracking()` - Clear per-turn tracking
- `getMaxStacksForPassive()` - Get trigger stack counts  

**Relationships**:
- Used by PassiveAbilityManager
- Updated by BattleFlowController at turn boundaries

### Event & Logging System

#### 14. BattleEventDispatcher.js (~150 lines)
**Purpose**: Handle event dispatching for battle events
**Responsibilities**:
- Provide standardized event dispatching interface
- Ensure events reach proper listeners
- Handle event propagation and bubbling

**Key Methods**:
- `dispatchEvent()` - Send event to listeners
- `addEventHandler()` - Register listener for events
- `removeEventHandler()` - Unregister event listener

**Relationships**:
- Used by all battle components for communication
- Communicates with BattleBridge for UI updates

#### 15. BattleLogManager.js (~150 lines)
**Purpose**: Format and manage battle log messages  
**Responsibilities**:
- Create formatted battle log messages
- Generate battle summaries
- Format messages with team identifiers  

**Key Methods**:
- `logMessage()` - Format message and dispatch
- `formatMessage()` - Apply type-specific formatting
- `displayTurnSummary()` - Create turn summary
- `createTeamSummary()` - Generate team health report
- `colorizeByHealth()` - Add color based on health level  

**Relationships**:
- Used by all other components for logging
- Communicates with UI via BattleBridge

### Debug System (Planned)

#### 16. DebugManager.js (~100 lines)
**Purpose**: Central configuration and control for the debugging system  
**Responsibilities**:
- Provide global debug toggle and verbosity settings
- Maintain namespaced logging categories
- Configure log filtering and formatting

**Key Methods**:
- `initialize()` - Setup debug system with desired configuration
- `setEnabled(boolean)` - Master toggle for all debugging
- `setVerbosity(level)` - Control log detail level (error, warn, info, debug, trace)
- `namespace(name)` - Create or access a debug namespace

**Relationships**:
- Used by all components that need debugging
- Parent of domain-specific debuggers

#### 17. BattleDebugger.js (~150 lines)
**Purpose**: Battle system specific debugging utilities  
**Responsibilities**:
- Provide battle-domain specific logging methods
- Track battle state for debugging purposes
- Offer specialized battle visualization utilities

**Key Methods**:
- `logInitialization(component, status)` - Component initialization tracking
- `logTurnProgress(turn, character)` - Turn progression information
- `logAction(actor, target, ability)` - Action execution details
- `logDamage(source, target, amount, type)` - Damage application tracking

**Relationships**:
- Used by battle system components
- Configured by DebugManager

#### 18. TeamBuilderDebugger.js (~100 lines)
**Purpose**: Team Builder specific debugging utilities  
**Responsibilities**:
- Provide team builder domain specific logging
- Track team composition and validation

**Key Methods**:
- `logSelection(character)` - Track character selection events
- `logTeamValidation(team, issues)` - Report team validation issues
- `logUIState(component, state)` - Track UI component states

**Relationships**:
- Used by team builder components
- Configured by DebugManager

#### 19. LoggingUtilities.js (~80 lines)
**Purpose**: Shared logging utilities and formatters  
**Responsibilities**:
- Format log output consistently
- Provide timing utilities for performance tracking
- Handle log routing (console vs storage)

**Key Methods**:
- `formatMessage(namespace, level, message)` - Consistent formatting
- `startTimer(label)` / `endTimer(label)` - Performance measurement
- `stringifyObject(obj)` - Safe object serialization for logging

**Relationships**:
- Used by all debugger components
- Configured by DebugManager

## Implementation Approach

The implementation follows a "Clean As You Go" methodology, where each component is:
1. Extracted and implemented in its own file
2. Verified with toggle testing
3. Immediately integrated with legacy code removed
4. Thoroughly documented in the changelog

This approach eliminates the need for a final cleanup phase and ensures continuous functionality throughout the refactoring process.

### Critical Implementation Notes for ES Module Compatibility

Based on lessons learned in Version 0.5.1.3a, all component files must follow these guidelines:

1. **DO NOT USE ES MODULE SYNTAX**: The game uses traditional script loading, not ES modules
2. **Use Global Window Registration Pattern**:
   ```javascript
   // Make ClassName available globally for traditional scripts
   if (typeof window !== 'undefined') {
     window.ClassName = ClassName;
     console.log("ClassName class definition loaded and exported to window.ClassName");
   }
   
   // Legacy global assignment for maximum compatibility
   window.ClassName = ClassName;
   ```
3. **Script Loading Order**: Components must be loaded before BattleManager.js in index.html
4. **BattleManager Initialization**: Use global window objects instead of dynamic imports:
   ```javascript
   // Check for globally registered class
   if (window.BattleFlowController) {
     // Create instance from global
     this.battleFlowController = new window.BattleFlowController(this);
     console.log('BattleManager: BattleFlowController component initialized');
   } else {
     console.warn("BattleFlowController not found on global window object");
     // Fall back to original implementation
     this.useNewImplementation = false;
   }
   ```

### Implementation Stages

#### Stage 1: Setup and Infrastructure (âœ“ COMPLETED)
- Create the directory structure for all planned components
- Create shell files with proper global registration but minimal implementation
- Modify BattleManager to include toggle mechanism and component references
- CHECKPOINT #1: Test that the game still works with toggle disabled
- CLEANUP: Remove duplicate initialization code after verification

#### Stage 2: Status Effect System (âœ“ COMPLETED)
- Implement StatusEffectManager.js and StatusEffectDefinitionLoader.js with full functionality
- Update BattleManager.initialize() to use window objects instead of dynamic imports
- Add conditional code in BattleManager to toggle between implementations for status effect methods
- Add new component script tags to index.html with proper load order
- CHECKPOINT #2: Test status effect application with toggle on/off
- CLEANUP: Remove original status effect handling code after verification

#### Stage 3: Battle Flow Control (âœ“ COMPLETED)
- Implement BattleFlowController.js with turn and action management
- Update toggle mechanism for turn flow methods
- CHECKPOINT #3: Test complete battle sequence with toggle on/off
- CLEANUP: Remove original battle flow control code after verification

#### Stage 4: Damage and Healing System (âœ“ COMPLETED)
- Implement DamageCalculator.js, HealingProcessor.js, and TypeEffectivenessCalculator.js
- Connect to BattleFlowController and enable in toggle
- CHECKPOINT #4: Test damage calculations with toggle on/off
- CLEANUP: Remove original damage and healing code after verification

#### Stage 5: Ability Processing (âœ“ COMPLETED)
- Implement AbilityProcessor.js, TargetingSystem.js, and ActionGenerator.js
- Update BattleManager with toggle for ability processing
- CHECKPOINT #5: Test ability execution with toggle on/off
- CLEANUP: Remove original ability processing code after verification

#### Stage 6: Passive Ability System (âœ“ COMPLETED)
- Implement PassiveAbilityManager.js and PassiveTriggerTracker.js
- Connect to BattleFlowController and enable in toggle
- CHECKPOINT #6: Test passive ability triggers with toggle on/off
- CLEANUP: Remove original passive ability code after verification

#### Stage 7: Events and Logging- Complete
- Implement BattleEventDispatcher.js and BattleLogManager.js
- Complete integration of all components
- CHECKPOINT #7: Test complete system with toggle on/off
- CLEANUP: Remove original event and logging code after verification

#### Stage 8: Debug System Implementation- Decided against Refactoring this for now. 
- Create debug system directory structure and base files
- Implement DebugManager with global configuration
- Implement domain-specific debuggers (Battle, TeamBuilder)
- Update components to use debug system instead of direct console logging
- Integrate with existing code patterns
- CHECKPOINT #8: Verify debug toggling and verbosity controls

### Post-Refactoring Optimization- Complete!
After all stages are complete, the BattleManager will function as a thin coordination layer with each responsibility delegated to specialized components. Some final steps may include:
- Remove all toggle mechanisms (no longer needed)
- Update documentation to reflect the new architecture
- Performance profiling and optimization
- Comprehensive test run of all game scenarios with the new architecture

### Integration of Debug System with Existing Components

Components should replace direct console.log calls with debug namespace calls:

```javascript
// BEFORE:
console.log(`[BattleFlowController] Processing turn ${this.currentTurn}`);

// AFTER:
Debug.Battle.logTurnProgress(this.currentTurn, this.activeCharacter);
```

This approach maintains the context-specific nature of debugging while providing structure and control. It also aligns perfectly with the ongoing refactoring to improve modularity and separation of concerns.

===== FILE: BattleManager_Refactoring_Plan_BigPicture_Summary.md =====
# BattleManager Refactoring Plan - Summary

## Overview
Modular refactoring of monolithic BattleManager.js into specialized components using a "Clean As You Go" approach with feature toggles for continuous functionality.

## Directory Structure (High-Level)
```
js/
â”œâ”€â”€ battle_logic/
â”‚   â”œâ”€â”€ core/        - Core battle controller classes
â”‚   â”œâ”€â”€ status/      - Status effect management
â”‚   â”œâ”€â”€ damage/      - Damage calculation and healing
â”‚   â”œâ”€â”€ abilities/   - Ability processing and targeting
â”‚   â”œâ”€â”€ passives/    - Passive ability triggers and tracking
â”‚   â””â”€â”€ events/      - Event dispatching and battle logging
â”œâ”€â”€ debug/ (PLANNED)
    â”œâ”€â”€ DebugManager.js and domain-specific debuggers
```

## Implementation Stages

### Stage 1: Setup and Infrastructure âœ“ COMPLETED
- Create directory structure and shell files
- Add toggle mechanism to BattleManager
- CHECKPOINT: Test with toggle disabled
- CLEANUP: Remove duplicate initialization code

### Stage 2: Status Effect System âœ“ COMPLETED
- Implement StatusEffectManager and StatusEffectDefinitionLoader
- CHECKPOINT: Test status effects with toggle on/off
- CLEANUP: Remove original status effect code

### Stage 3: Battle Flow Control âœ“ COMPLETED
- Implement BattleFlowController with turn management
- CHECKPOINT: Test battle sequence with toggle on/off
- CLEANUP: Remove original flow control code

### Stage 4: Damage and Healing System âœ“ COMPLETED
- Implement DamageCalculator, HealingProcessor, TypeEffectivenessCalculator
- CHECKPOINT: Test damage calculations with toggle on/off
- CLEANUP: Remove original damage and healing code

### Stage 5: Ability Processing ðŸ”„ âœ“ COMPLETED
- Implement AbilityProcessor, TargetingSystem, ActionGenerator
- CHECKPOINT: Test ability execution with toggle on/off
- CLEANUP: Remove original ability processing code

### Stage 6: Passive Ability System â³ Completed
- Implement PassiveAbilityManager and PassiveTriggerTracker
- CHECKPOINT: Test passive triggers with toggle on/off
- CLEANUP: Remove original passive code

### Stage 7: Events and Logging â³ Complete
- Implement BattleEventDispatcher and BattleLogManager
- CHECKPOINT: Test complete system with toggle on/off
- CLEANUP: Remove original event and logging code

### Stage 8: Debug System Implementation â³ Scrapped
- Create debug namespace with domain-specific loggers
- Replace direct console logs with Debug.namespace approach
- CHECKPOINT: Verify debug toggling and verbosity controls

## Critical Technical Requirements

1. **AVOID ES MODULE SYNTAX** - Use traditional script loading
2. **Global Window Registration** - Make classes available via window object
3. **Script Loading Order** - Components must load before BattleManager.js
4. **Defensive Initialization** - Check for component availability before using

## Post-Refactoring Tasks
- Remove all toggle mechanisms
- Update documentation
- Performance profiling and optimization
- Comprehensive testing with new architecture

===== FILE: BattleEventDispatcher_Event_Inventory.md =====
# Comprehensive Event Inventory for BattleEventDispatcher

This document catalogs all event types used in the battle system, including their expected data structures and consumers. It serves as a blueprint for implementing the BattleEventDispatcher component.

## Core Event Types

| Event Type | Description | Dispatchers | Consumers | Data Structure |
|------------|-------------|------------|-----------|----------------|
| **BATTLE_INITIALIZED** | Fired when BattleBridge is initialized | BattleBridge.initialize | BattleScene | `{ battleManager, battleScene }` |
| **BATTLE_STARTED** | Fired when a battle begins | BattleFlowController | BattleControlPanel | `{ playerTeam, enemyTeam }` |
| **BATTLE_ENDED** | Fired when battle concludes | BattleFlowController | BattleScene, DirectBattleLog | `{ winner: 'player'/'enemy'/'draw', reason }` |
| **TURN_STARTED** | Fired at start of a new turn | BattleFlowController | BattleScene, DirectBattleLog | `{ turnNumber, currentCharacter, character }` |
| **TURN_ENDED** | Fired when a turn completes | BattleFlowController | BattleScene | `{ currentCharacter, turnNumber }` |
| **BATTLE_LOG** | General battle messages | BattleLogManager, BattleManager | DirectBattleLog | `{ message, type }` |

## Character Events

| Event Type | Description | Dispatchers | Consumers | Data Structure |
|------------|-------------|------------|-----------|----------------|
| **CHARACTER_ACTION** | Character performing an action | BattleFlowController, ApplyActionEffect | BattleScene, DirectBattleLog | `{ character, action: { type, name, abilityName, target } }` |
| **CHARACTER_DAMAGED** | Character taking damage | ApplyActionEffect, ApplyDamage | BattleScene, DirectBattleLog | `{ character, target, amount, source, ability, newHealth, maxHealth }` |
| **CHARACTER_HEALED** | Character being healed | ApplyActionEffect, ApplyHealing | BattleScene, DirectBattleLog | `{ character, target, amount, source, ability, newHealth, maxHealth }` |
| **CHARACTER_DEFEATED** | Character reduced to 0 HP | ApplyDamage | DirectBattleLog | `{ character, source }` |

## Ability & Passive Events

| Event Type | Description | Dispatchers | Consumers | Data Structure |
|------------|-------------|------------|-----------|----------------|
| **ABILITY_USED** | Ability activation | ProcessAbility | DirectBattleLog | `{ source, ability, targets, result }` |
| **PASSIVE_TRIGGERED** | Passive ability triggered | TriggerPassive | DirectBattleLog | `{ character, triggerType, passiveData, result }` |

## Status Effect Events

| Event Type | Description | Dispatchers | Consumers | Data Structure |
|------------|-------------|------------|-----------|----------------|
| **STATUS_EFFECT_APPLIED** | New status effect on character | AddStatusEffect | BattleScene, StatusEffectContainer, DirectBattleLog | `{ character, statusId, duration, stacks, statusDefinition }` |
| **STATUS_EFFECT_REMOVED** | Status effect removed | RemoveStatusEffect | BattleScene, StatusEffectContainer, DirectBattleLog | `{ character, statusId, statusDefinition }` |
| **STATUS_EFFECT_UPDATED** | Status effect duration/stacks changed | UpdateStatusEffect | StatusEffectContainer | `{ character, statusId, duration, stacks, statusDefinition }` |
| **STATUS_EFFECTS_CHANGED** | Bulk update to status effects | ProcessStatusEffects | StatusEffectContainer | `{ character, effects }` |

## UI Interaction Events

| Event Type | Description | Dispatchers | Consumers | Data Structure |
|------------|-------------|------------|-----------|----------------|
| **BATTLE_UI_INTERACTION** | General UI interactions | BattleBridge methods | BattleScene, DirectBattleLog | Various, common properties: `{ action }` |
| **SPEED_CHANGE** | Battle speed changed | RequestSpeedChange | DirectBattleLog | `{ action: 'speed_change', speed, previousSpeed, turnDelay, actionDelay }` |
| **PAUSE_RESUME** | Battle paused/resumed | RequestPause/Resume | N/A | `{ action: 'pause'/'resume' }` |

## Critical Property Consistency Requirements

For reliable event handling, these properties must be consistent across event dispatches:

### Character Identification
- `character` must be the complete character object
- `character.name` must be present for display
- `character.team` must be 'player' or 'enemy' for team-specific handling
- `character.uniqueId` needed for finding character sprites
- `character.stats.hp` needed for health percentage calculations

### Health Updates
- `newHealth` must be the current health value after change
- `amount` should be the raw amount of damage/healing
- `maxHealth` (or character.stats.hp) needed for health bar percentage

### Event Naming Consistency
- Some handlers use `target` while others expect `character` 
- Some handlers use `source` while others expect `character`
- New implementation should support both property names for backward compatibility

## Implementation Requirements

1. **Preserve Property Names**: Even if properties have redundant information, maintain all properties expected by consumers
2. **Defensive Value Creation**: Use default values when source doesn't provide all properties
3. **Handle Team Prefixing**: Support both prefixed and unprefixed character IDs
4. **Event Validation**: Validate minimal required structure before dispatch
5. **Transparent Fallback**: When using fallback to BattleBridge, preserve exact data structure

## Architectural Clarifications

### BATTLE_LOG Event Flow
The current inventory reflects a transitional state rather than the ideal final architecture. In the final architecture:

1. **Semantic Event Dispatch**: Components like `BattleManager` or `BattleFlowController` should only dispatch semantic events (CHARACTER_ACTION, etc.) that represent what happened in the battle
2. **Event Translation**: `BattleLogManager` should listen to these semantic events
3. **Message Formatting**: `BattleLogManager` should format appropriate human-readable messages
4. **Message Dispatch**: `BattleLogManager` then dispatches these as `BATTLE_LOG` events
5. **UI Consumption**: Only UI components like `DirectBattleLog` should consume `BATTLE_LOG` events

This separation of concerns is cleaner and more maintainable:
- Battle logic components focus on what happened
- `BattleLogManager` focuses on translating events to human-readable messages  
- UI components focus on displaying those messages

### Source/Target Naming Standardization

For the `BattleEventDispatcher` implementation, we will standardize on `source` and `target` terminology internally:

- **Internal Consistency**: Within the dispatcher, use consistent `source` (initiator) and `target` (recipient) naming
- **Semantic Clarity**: This provides clearer meaning about the relationship between entities
- **Backward Compatibility**: While using standardized naming internally, the dispatcher will include both naming patterns in outgoing events for compatibility with existing components

This approach provides a clean internal structure while preventing any disruption to existing systems.


===== FILE: BattleEventDispatcher_Implementation_Plan.md =====
# BattleEventDispatcher Implementation Plan

## Overview

The BattleEventDispatcher will serve as a centralized event bus for the battle system, replacing direct calls to `window.battleBridge.dispatchEvent()` with a more structured, reliable approach. This component will standardize event dispatching, add validation, improve error handling, and provide convenience methods for common event types.

## Component Objectives

1. **Event Standardization**: Use consistent property naming and event structure
2. **Enhanced Validation**: Verify events have required properties before dispatch
3. **Improved Error Handling**: Robust error catching and reporting
4. **Custom Event Support**: Allow component-specific event listeners
5. **Backward Compatibility**: Maintain support for existing event consumers
6. **Fallback Mechanism**: Graceful degradation when dependencies are missing
7. **Specialized Helper Methods**: Convenience methods for common event types

## Core Class Definition

```javascript
/**
 * BattleEventDispatcher.js
 * Handles dispatching battle events to UI and other systems
 * Version 0.5.28.1 - Combined implementation and cleanup
 */

class BattleEventDispatcher {
    /**
     * Create a new Battle Event Dispatcher
     * @param {Object} battleManager - The main battle manager
     */
    constructor(battleManager) {
        this.battleManager = battleManager;
        this.initialized = false;
        this.eventListeners = new Map(); // Store custom event listeners
        
        // Reference to battleBridge event types
        this.eventTypes = window.battleBridge?.eventTypes || this.getDefaultEventTypes();
        
        // Verify battleBridge availability
        if (window.battleBridge) {
            this.initialized = true;
            console.log("[BattleEventDispatcher] Initialized with battleBridge");
        } else {
            console.warn("[BattleEventDispatcher] battleBridge not found - events may not dispatch correctly");
        }
    }

    /**
     * Get default event types if battleBridge is not available
     * @returns {Object} Default event type constants
     */
    getDefaultEventTypes() {
        return {
            BATTLE_INITIALIZED: 'battle_initialized',
            BATTLE_STARTED: 'battle_started',
            BATTLE_ENDED: 'battle_ended',
            TURN_STARTED: 'turn_started',
            TURN_ENDED: 'turn_ended',
            CHARACTER_ACTION: 'character_action',
            CHARACTER_DAMAGED: 'character_damaged',
            CHARACTER_HEALED: 'character_healed',
            CHARACTER_DEFEATED: 'character_defeated',
            STATUS_EFFECT_APPLIED: 'status_effect_applied',
            STATUS_EFFECT_REMOVED: 'status_effect_removed',
            STATUS_EFFECT_UPDATED: 'status_effect_updated',
            STATUS_EFFECTS_CHANGED: 'status_effects_changed',
            ABILITY_USED: 'ability_used',
            PASSIVE_TRIGGERED: 'passive_triggered',
            BATTLE_UI_INTERACTION: 'battle_ui_interaction',
            BATTLE_LOG: 'battle_log'
        };
    }

    // Core event methods here...
}
```

## Core Method Definitions

### 1. Core Event Dispatching

```javascript
/**
 * Dispatch a battle event
 * @param {string} eventType - The type of event
 * @param {Object} eventData - The event data
 * @returns {boolean} True if dispatched successfully
 */
dispatchEvent(eventType, eventData) {
    // Parameter validation
    if (!eventType) {
        console.error("[BattleEventDispatcher] Invalid event type: null or undefined");
        return false;
    }
    
    if (!eventData || typeof eventData !== 'object') {
        console.warn("[BattleEventDispatcher] Event data should be an object, using empty object instead");
        eventData = {};
    }
    
    // Console logging for debugging
    console.log(`[BattleEventDispatcher] Dispatching ${eventType}`);
    
    // First, notify custom listeners
    this.notifyListeners(eventType, eventData);
    
    // Then dispatch via battleBridge if available
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(eventType, eventData);
            return true;
        } catch (error) {
            console.error(`[BattleEventDispatcher] Error dispatching ${eventType} via battleBridge:`, error);
        }
    }
    
    return false;
}

/**
 * Add an event handler for a specific event type
 * @param {string} eventType - The type of event to listen for
 * @param {Function} handler - The handler function
 * @returns {boolean} True if handler was added successfully
 */
addEventHandler(eventType, handler) {
    if (!eventType || typeof handler !== 'function') {
        console.error("[BattleEventDispatcher] Invalid eventType or handler");
        return false;
    }
    
    if (!this.eventListeners.has(eventType)) {
        this.eventListeners.set(eventType, []);
    }
    
    this.eventListeners.get(eventType).push(handler);
    return true;
}

/**
 * Remove an event handler
 * @param {string} eventType - The type of event
 * @param {Function} handler - The handler function to remove
 * @returns {boolean} True if handler was removed successfully
 */
removeEventHandler(eventType, handler) {
    if (!eventType || !this.eventListeners.has(eventType)) {
        return false;
    }
    
    const listeners = this.eventListeners.get(eventType);
    const index = listeners.indexOf(handler);
    
    if (index !== -1) {
        listeners.splice(index, 1);
        return true;
    }
    
    return false;
}

/**
 * Notify all listeners for a specific event type
 * @param {string} eventType - The type of event
 * @param {Object} eventData - The event data
 */
notifyListeners(eventType, eventData) {
    if (!this.eventListeners.has(eventType)) {
        return;
    }
    
    const listeners = this.eventListeners.get(eventType);
    listeners.forEach(handler => {
        try {
            handler(eventData);
        } catch (error) {
            console.error(`[BattleEventDispatcher] Error in event handler for ${eventType}:`, error);
        }
    });
}
```

### 2. Specialized Event Methods

```javascript
/**
 * Dispatch a battle log message event
 * @param {string} message - The log message
 * @param {string} type - The message type
 * @returns {boolean} True if dispatched successfully
 */
dispatchBattleLogEvent(message, type = 'default') {
    return this.dispatchEvent(this.eventTypes.BATTLE_LOG || 'BATTLE_LOG', {
        message,
        type
    });
}

/**
 * Dispatch a character damaged event
 * @param {Object} target - The damaged character
 * @param {number} amount - The damage amount
 * @param {Object} source - The damage source
 * @param {Object} ability - The ability used
 * @returns {boolean} True if dispatched successfully
 */
dispatchCharacterDamagedEvent(target, amount, source = null, ability = null) {
    // Validate parameters
    if (!target) {
        console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_DAMAGED: target is missing");
        return false;
    }
    
    if (typeof amount !== 'number' || isNaN(amount)) {
        console.warn("[BattleEventDispatcher] Invalid damage amount:", amount);
        amount = 0;
    }
    
    // Create a standardized event with both property naming patterns
    return this.dispatchEvent(this.eventTypes.CHARACTER_DAMAGED || 'CHARACTER_DAMAGED', {
        character: target, // Primary standardized property
        target: target,    // Backward compatibility
        newHealth: target.currentHp,
        maxHealth: target.stats?.hp || 100,
        amount,
        source,
        ability
    });
}

/**
 * Dispatch a character healed event
 * @param {Object} target - The healed character
 * @param {number} amount - The healing amount
 * @param {Object} source - The healing source
 * @param {Object} ability - The ability used
 * @returns {boolean} True if dispatched successfully
 */
dispatchCharacterHealedEvent(target, amount, source = null, ability = null) {
    // Validate parameters
    if (!target) {
        console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_HEALED: target is missing");
        return false;
    }
    
    if (typeof amount !== 'number' || isNaN(amount)) {
        console.warn("[BattleEventDispatcher] Invalid healing amount:", amount);
        amount = 0;
    }
    
    // Create a standardized event with both property naming patterns
    return this.dispatchEvent(this.eventTypes.CHARACTER_HEALED || 'CHARACTER_HEALED', {
        character: target, // Primary standardized property
        target: target,    // Backward compatibility
        newHealth: target.currentHp,
        maxHealth: target.stats?.hp || 100,
        amount,
        source,
        ability
    });
}

/**
 * Dispatch a character action event
 * @param {Object} character - The acting character
 * @param {Object} action - The action data
 * @returns {boolean} True if dispatched successfully
 */
dispatchCharacterActionEvent(character, action) {
    // Validate parameters
    if (!character) {
        console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_ACTION: character is missing");
        return false;
    }
    
    if (!action) {
        console.warn("[BattleEventDispatcher] Invalid action data, using empty object");
        action = {};
    }
    
    // Create event data
    return this.dispatchEvent(this.eventTypes.CHARACTER_ACTION || 'CHARACTER_ACTION', {
        character,
        action
    });
}

// Additional specialized methods for STATUS_EFFECT, ABILITY_USED, etc.
```

## Integration with BattleManager

```javascript
// In BattleManager.js - initializeComponentManagers method

// Initialize event dispatcher (Stage 7)
if (window.BattleEventDispatcher) {
    this.battleEventDispatcher = new window.BattleEventDispatcher(this);
    console.log('BattleManager: BattleEventDispatcher initialized');
    
    // Verify methods exist
    console.log('>>> BattleEventDispatcher instance check:', {
        dispatchEvent: typeof this.battleEventDispatcher.dispatchEvent === 'function',
        addEventHandler: typeof this.battleEventDispatcher.addEventHandler === 'function',
        removeEventHandler: typeof this.battleEventDispatcher.removeEventHandler === 'function'
    });
}
```

## BattleManager Facade Method

```javascript
/**
 * Dispatch a battle event
 * @param {string} eventType - The type of event
 * @param {Object} eventData - The event data
 * @returns {boolean} True if dispatched successfully
 */
dispatchBattleEvent(eventType, eventData) {
    // Direct delegation - no toggle mechanism for streamlined implementation
    if (this.battleEventDispatcher) {
        return this.battleEventDispatcher.dispatchEvent(eventType, eventData);
    }
    
    // Minimal fallback implementation (no original implementation preserved)
    console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch ${eventType}`);
    
    // Try direct battleBridge as last resort
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(eventType, eventData);
            return true;
        } catch (error) {
            console.error(`[BattleManager] Error dispatching ${eventType}:`, error);
        }
    }
    
    return false;
}
```

## Helper Methods for Common Events

```javascript
/**
 * Dispatch an event when a character takes damage
 * @param {Object} target - The character taking damage
 * @param {number} amount - Amount of damage
 * @param {Object|null} source - Source of the damage (character or null)
 * @param {Object|null} ability - Ability that caused damage (or null)
 * @returns {boolean} - Success status
 */
dispatchDamageEvent(target, amount, source = null, ability = null) {
    // Direct delegation - no toggle mechanism
    if (this.battleEventDispatcher) {
        return this.battleEventDispatcher.dispatchCharacterDamagedEvent(target, amount, source, ability);
    }
    
    // Minimal fallback
    console.warn(`[BattleManager] BattleEventDispatcher not available, cannot dispatch damage event`);
    
    // Try direct battleBridge as last resort
    if (window.battleBridge) {
        try {
            window.battleBridge.dispatchEvent(window.battleBridge.eventTypes.CHARACTER_DAMAGED, {
                character: target,
                target: target,
                amount: amount,
                source: source,
                ability: ability,
                newHealth: target.currentHp,
                maxHealth: target.stats.hp
            });
            return true;
        } catch (error) {
            console.error(`[BattleManager] Error dispatching damage event:`, error);
        }
    }
    
    return false;
}

// Similar helper methods for healing, actions, etc.
```

## Implementation Approach

### Phase 1: Core Implementation

1. **Create Component File**:
   - Create `js/battle_logic/events/BattleEventDispatcher.js`
   - Implement the core class with constructor and basic validation
   - Add global window exports for compatibility

2. **Implement Core Methods**:
   - `dispatchEvent` - Main event dispatch method
   - `addEventHandler` - Custom event listener registration
   - `removeEventHandler` - Custom event listener removal
   - `notifyListeners` - Custom event notification

3. **Add Helper Methods**:
   - Implement specialized event dispatch methods for common events
   - Include validation and error handling for each

**Testing/Validation After Phase 1:**
- The game should remain 100% operable with no errors
- Component exists but isn't integrated with BattleManager yet
- **Required Test**: Run a basic smoke test by starting the game and running a battle
- **Validation Method**: Verify no errors appear in console related to the new file
- **Success Criteria**: Game functions exactly as before, no console errors related to the new component

### Phase 2: BattleManager Integration

1. **Add Component Initialization**:
   - Update `BattleManager.initializeComponentManagers()` to initialize BattleEventDispatcher
   - Add verification of core methods

2. **Create Facade Method**:
   - Implement `BattleManager.dispatchBattleEvent()` facade method
   - Include robust fallback for when component isn't available

3. **Add Script Tags**:
   - Update `index.html` to include the new component file
   - Ensure proper loading order (before BattleManager)

**Testing/Validation After Phase 2:**
- **This is the critical integration point** - the game MUST remain fully operable
- Component now receives events through BattleManager facade methods
- **Required Tests**:
  1. Complete battle sequence with player and enemy teams
  2. Monitor console for errors or warnings related to event dispatch
  3. Verify all UI elements update correctly (health bars, battle log messages, etc.)
  4. Test the facade methods directly from browser console if possible
- **Validation Method**: Use browser developer tools to monitor network activity and console output
- **Success Criteria**: All UI components receive and process events correctly, no console errors

### Phase 3: Implementation Verification

1. **Basic Event Dispatch Test**:
   - Verify events are properly dispatched and received
   - Test fallback behavior when dependencies aren't available

2. **Helper Method Tests**:
   - Verify specialized event methods work correctly
   - Test validation of parameters

3. **Data Structure Verification**:
   - Ensure event data structures match the inventory
   - Verify backward compatibility property naming

**Testing/Validation After Phase 3:**
- Component is fully operational and handling events correctly
- **Required Tests**: 
  1. Create a test checklist based on Event Inventory for each event type
  2. Verify error handling by intentionally passing invalid data
  3. Confirm both old (`character`) and new (`source`/`target`) property names work
- **Validation Method**: Use browser console to directly call methods and inspect results
- **Success Criteria**: All tests pass with expected results and proper error handling

### Phase 4: Comprehensive Testing

1. **Battle Flow Testing**:
   - Test complete battle scenarios with events
   - Verify all UI components update correctly

2. **Edge Case Testing**:
   - Test with missing or incomplete data
   - Test error handling and recovery

3. **Performance Assessment**:
   - Evaluate any performance impact from additional validation
   - Look for optimization opportunities

**Final Validation:**
- Component is fully integrated and handling all edge cases
- **Required Tests**:
  1. Complete multiple battles with different team compositions
  2. Test with large numbers of status effects to check performance
  3. Test all specialized convenience methods
- **Validation Method**: Observe game behavior and check console for warnings/errors
- **Success Criteria**: No visual glitches, no console errors, consistent performance

## Fallback Strategies

### Direct BattleBridge Fallback
For cases when BattleEventDispatcher is unavailable or fails, BattleManager methods will fall back to using window.battleBridge directly:

```javascript
// In BattleManager.js facade methods
if (window.battleBridge) {
    try {
        window.battleBridge.dispatchEvent(eventType, eventData);
        return true;
    } catch (error) {
        console.error(`[BattleManager] Error dispatching event:`, error);
    }
}
```

### Missing Event Data Recovery
For missing or invalid event data, provide safe defaults:

```javascript
// In specialized event methods
if (!target) {
    console.error("[BattleEventDispatcher] Cannot dispatch CHARACTER_DAMAGED: target is missing");
    return false;
}

if (typeof amount !== 'number' || isNaN(amount)) {
    console.warn("[BattleEventDispatcher] Invalid damage amount:", amount);
    amount = 0; // Safe default
}
```

## Integration with Existing Systems

### BattleBridge Compatibility
The implementation will maintain full compatibility with battleBridge:

1. **Event Type Constants**: Use battleBridge's event types when available
2. **Event Data Structure**: Maintain the same data structure for events
3. **Event Property Naming**: Include both source/target and character naming patterns

### BattleLogManager Integration
The BattleLogManager will eventually listen to semantic events from BattleEventDispatcher:

1. **Initial Integration**: BattleEventDispatcher provides `dispatchBattleLogEvent` as a direct path
2. **Future Architecture**: BattleLogManager will register handlers for semantic events and dispatch log events in response

## Documentation

### High-Level Changelog
```
### Version 0.5.28.1 - BattleEventDispatcher Implementation
- **Technical**: Added BattleEventDispatcher for centralized event handling
- **Technical**: Enhanced event validation and error handling
- **Technical**: Improved event naming consistency
- **Technical**: Added specialized helper methods for common event types
```

### Detailed Technical Changelog
A separate `CHANGELOG_0.5.28.1_BattleEventDispatcher.md` file will include implementation details, challenges, and decisions made during implementation.

## Success Criteria

1. **All Events Correctly Dispatched**: Events reach their intended consumers
2. **Consistent Data Structure**: Event data follows the patterns in the inventory
3. **Backward Compatibility**: Existing components continue to work without modification
4. **Enhanced Validation**: Invalid events produce helpful error messages
5. **No Performance Regression**: No noticeable slowdown in the battle system
6. **Clean Error Handling**: Errors are properly caught and reported
7. **Modular Design**: Code is well-organized with clear single responsibility

Following this plan will ensure a smooth implementation of the BattleEventDispatcher component while maintaining compatibility with existing systems.


===== FILE: BattleScene Refactoring Plan- Big Picture.md =====
# BattleScene Refactoring Plan - Big Picture

This document outlines a phased approach to refactoring the BattleScene.js file, prioritizing the largest code removals first to maximize impact and maintainability.

## Phase 1: Extract Event Management (BattleEventManager) - Complete

**Goal**: Remove the bulk of event listening setup and handling logic from BattleScene.js.

**New Component**: `js/phaser/core/BattleEventManager.js`

**Code to Move from BattleScene.js**:
- `setupCoreEventListeners()`
- `setupStatusEffectListeners()`
- `setupHealthUpdateListeners()`
- `setupActionIndicatorListeners()`
- `handleTurnStarted()` (Note: Only the turn number update part)
- `onCharacterDamaged()` (Triggering health bar updates & floating text)
- `onCharacterHealed()` (Triggering health bar updates & floating text)
- `handleStatusEffectApplied()` (Triggering sprite floating text)
- `handleStatusEffectRemoved()` (Triggering sprite floating text)
- `handleStatusEffectUpdated()` (Currently empty, but belongs here conceptually)
- `onCharacterAction()` (Triggering active character visuals & action text)
- `onAbilityUsed()` (Triggering action text)

**BattleScene.js Changes**:
- `create()`: Instantiate BattleEventManager, passing references to this (the scene) and this.battleBridge.
- Remove all setup...Listeners calls from `create()` and `initializeBattleBridge()`.
- Remove all handle.../on... event handler methods listed above.
- `shutdown()`: Call a destroy() method on BattleEventManager to ensure all listeners are removed.

**Dependencies**:
- BattleEventManager needs references to:
  - BattleBridge (for addEventListener/removeEventListener)
  - BattleScene (initially, to call methods like showFloatingText, updateActiveCharacterVisuals)
  - Potentially TeamDisplayManager, BattleUIManager, BattleFXManager (in later phases)

**Estimated LOC Removed from BattleScene.js**: ~210-250+ lines

## Phase 2: Extract UI Creation & HUD Management (BattleUIManager)- Complete

**Goal**: Remove the methods responsible for creating and managing static UI elements, the HUD, and panels.

**New Component**: `js/phaser/managers/BattleUIManager.js`

**Code to Move from BattleScene.js**:
- `createBackground()`
- `createSceneTitle()`
- `createReturnButton()`
- `createWelcomeMessage()`
- `createBattleLogPanel()` (Will instantiate DirectBattleLog)
- `createBattleControls()` (Will instantiate BattleControlPanel)
- `showBattleOutcome()`
- `showErrorMessage()`
- `updateTurnNumberDisplay()` (Note: The part that updates the text object)
- `updateActionTextDisplay()` (Note: The part that updates the text object)
- `safeGetTextObject()` (Or move to a shared utility class)
- Maybe `createTestPattern()` (if kept for testing)

**BattleScene.js Changes**:
- `create()`: Instantiate BattleUIManager, passing this (the scene). Call an initializeUI() method.
- Remove all the create... and show... methods listed above.
- Remove updateTurnNumberDisplay and updateActionTextDisplay.
- `shutdown()`: Call battleUIManager.destroy()

**Dependencies**:
- BattleUIManager needs reference to Scene (for this.add, this.cameras, this.tweens)
- BattleEventManager (from Phase 1) will need a reference to BattleUIManager

**Estimated LOC Removed from BattleScene.js**: ~130-180 lines

## Phase 3: Extract Team Display & Active Indicator Management (TeamDisplayManager)- Complete

**Goal**: Remove the logic for creating/managing team visuals and handling the active character indicators.

**New Component**: `js/phaser/managers/TeamDisplayManager.js`

**Code to Move from BattleScene.js**:
- `createCharacterTeams()`
- `cleanupCharacterTeams()`
- `updateActiveCharacterVisuals()` (The logic for finding the sprite, calling its highlight, positioning the floor marker)
- Management of the this.turnIndicator instance
- `getTeamData()`

**BattleScene.js Changes**:
- `init()`: Still receives team data.
- `create()`: Instantiate TeamDisplayManager, passing this (the scene) and the initial team data.
- Remove createCharacterTeams, cleanupCharacterTeams, updateActiveCharacterVisuals, getTeamData.
- Remove this.turnIndicator property.
- `shutdown()`: Call teamDisplayManager.destroy()

**Dependencies**:
- TeamDisplayManager needs reference to Scene
- TeamDisplayManager needs TeamContainer, CharacterSprite, TurnIndicator classes
- BattleEventManager needs reference to TeamDisplayManager

**Estimated LOC Removed from BattleScene.js**: ~70-100 lines

## Phase 4: Extract Asset Loading (BattleAssetLoader)- Pausing until Bugs are fixed

**Goal**: Remove asset loading logic from preload.

**New Component**: `js/phaser/core/BattleAssetLoader.js`

**Code to Move from BattleScene.js**:
- All logic currently in `preload()`
- `preloadStatusEffectIcons()`
- `initStatusIconMapping()`

**BattleScene.js Changes**:
- `preload()`: Instantiate BattleAssetLoader, passing this (the scene's loader).
- Remove preloadStatusEffectIcons, initStatusIconMapping.

**Dependencies**: BattleAssetLoader needs reference to Scene (for this.load).

**Estimated LOC Removed from BattleScene.js**: ~40-60 lines

## Phase 5: Extract Visual Effects (BattleFXManager)

**Goal**: Centralize triggering of non-sprite-specific visual effects like floating text and attack animations.

**New Component**: `js/phaser/managers/BattleFXManager.js`

**Code to Move from BattleScene.js**:
- `showFloatingText()`
- `showAttackAnimation()` (Note: The method itself moves, but it calls CharacterSprite.showAttackAnimation)

**BattleScene.js Changes**:
- `create()`: Instantiate BattleFXManager, passing this (the scene).
- Remove showFloatingText, showAttackAnimation.
- `shutdown()`: Call battleFXManager.destroy().

**Dependencies**:
- BattleFXManager needs reference to Scene and TeamDisplayManager
- BattleEventManager needs reference to BattleFXManager

**Estimated LOC Removed from BattleScene.js**: ~30-50 lines

## Phase 6: Extract Debug Tools (PhaserDebugManager) (Optional)

**Goal**: Remove debug-specific UI and logic.

**New Component**: `js/phaser/debug/PhaserDebugManager.js`

**Code to Move from BattleScene.js**:
- `initializeDebugTools()`
- `cleanupDebugTools()`
- `createDebugPanel()` (Also the debug test buttons within createBattleControls)
- `testHealthUpdate()`
- `testActionIndicator()`

**BattleScene.js Changes**:
- `create()`: Instantiate PhaserDebugManager, passing this (the scene).
- Remove the methods listed above.
- `shutdown()`: Call phaserDebugManager.destroy().

**Dependencies**: Needs reference to Scene and potentially other managers.

**Estimated LOC Removed from BattleScene.js**: ~50-80 lines

## Phase 7: Final BattleScene.js Cleanup

**Goal**: Ensure BattleScene.js is a clean orchestrator.

**Actions**:
- Review remaining code
- Remove commented-out sections
- Ensure all logic is delegated
- Update file-level documentation/version


===== FILE: BattleScene_Phase1_BattleEventManager_Implementation.md =====
# Revised Technical Gameplan: BattleEventManager Implementation

## 1. Code to Remove from BattleScene.js

The following methods will be completely removed from BattleScene.js and relocated to BattleEventManager:

```javascript
// Event Setup Methods (~80-90 lines)
setupCoreEventListeners()
setupStatusEffectListeners() 
setupHealthUpdateListeners()
setupActionIndicatorListeners()

// Event Handler Methods (~130-140 lines)
handleTurnStarted(eventData)
handleStatusEffectApplied(data)
handleStatusEffectRemoved(data)
handleStatusEffectUpdated(data)
onCharacterDamaged(data)
onCharacterHealed(data)
onCharacterAction(data)
onAbilityUsed(data)
```

**Total Lines to Remove from BattleScene.js: ~210-230 lines**

## 2. Component Design

### 2.1 Interface Definition
```javascript
class BattleEventManager {
    constructor(scene, battleBridge) {...}
    initialize() {...}
    
    // Event Setup Methods (moved from BattleScene)
    setupCoreEventListeners() {...}
    setupStatusEffectListeners() {...}
    setupHealthUpdateListeners() {...}
    setupActionIndicatorListeners() {...}
    
    // Event Handler Methods (moved from BattleScene)
    handleTurnStarted(data) {...}
    handleStatusEffectApplied(data) {...}
    handleStatusEffectRemoved(data) {...}
    handleStatusEffectUpdated(data) {...}
    onCharacterDamaged(data) {...}
    onCharacterHealed(data) {...}
    onCharacterAction(data) {...}
    onAbilityUsed(data) {...}
    
    // Lifecycle Methods
    cleanup() {...}
    destroy() {...}
}
```

### 2.2 Dependency Map
```
BattleEventManager â†’ BattleBridge (for event listening)
BattleEventManager â†’ BattleScene (for delegate methods)
```

## 3. Implementation Steps

### 3.1 Create New Component File
Create `C:\Personal\AutoBattler\js\phaser\core\BattleEventManager.js` with:
- Constructor with validation
- Global registration pattern
- Event setup and handler methods (copied from BattleScene)
- Proper cleanup/destroy methods
- Defensive implementation patterns

### 3.2 Update BattleScene.js
- Add initialization of BattleEventManager in `create()`
- Remove all extracted methods
- Add destruction in `shutdown()`
- Minor code to connect component

### 3.3 HTML Updates
Add script tag to ensure the component loads in the correct order:
```html
<!-- After BattleBridge but before BattleScene -->
<script src="js/phaser/bridge/BattleBridge.js" defer></script>
<script src="js/phaser/core/BattleEventManager.js" defer></script>
<script src="js/phaser/scenes/BattleScene.js" defer></script>
```

## 4. Key Implementation Details

### 4.1 Method Binding for Event Handlers
```javascript
// In initialize() method:
// Bind all event handlers to preserve 'this' context
this.handleTurnStarted = this.handleTurnStarted.bind(this);
this.onCharacterDamaged = this.onCharacterDamaged.bind(this);
this.onCharacterHealed = this.onCharacterHealed.bind(this);
// ... bind other handlers
```

### 4.2 Event Registration with Bound Methods
```javascript
// In setupCoreEventListeners():
this.battleBridge.addEventListener(
    this.battleBridge.eventTypes.TURN_STARTED, 
    this.handleTurnStarted
);
```

### 4.3 Scene Integration in BattleScene.js
```javascript
// In BattleScene.create():
// Initialize battle event manager
if (this.battleBridge) {
    this.eventManager = new BattleEventManager(this, this.battleBridge);
}
```

### 4.4 Proper Cleanup in BattleScene.js
```javascript
// In BattleScene.shutdown():
if (this.eventManager) {
    this.eventManager.destroy();
    this.eventManager = null;
}
```

## 5. Core Method Implementation

### 5.1 Constructor with Validation
```javascript
constructor(scene, battleBridge) {
    // Validate dependencies
    if (!scene) {
        console.error("[BattleEventManager] Missing required scene reference");
        return;
    }
    
    if (!battleBridge) {
        console.error("[BattleEventManager] Missing required battleBridge reference");
        return;
    }
    
    this.scene = scene;
    this.battleBridge = battleBridge;
    this.boundHandlers = new Map(); // For tracking bound handlers
    
    console.log("[BattleEventManager] Initializing...");
    this.initialize();
}
```

### 5.2 Proper Event Listening Cleanup
```javascript
cleanup() {
    console.log("[BattleEventManager] Cleaning up event listeners");
    
    // Remove all registered event listeners
    if (this.battleBridge) {
        // Remove all listeners using the bound handlers we stored
        for (const [eventType, handler] of this.boundHandlers.entries()) {
            this.battleBridge.removeEventListener(eventType, handler);
        }
    }
    
    // Clear tracking map
    this.boundHandlers.clear();
    
    console.log("[BattleEventManager] Event listeners cleaned up");
}
```

## 6. Success Criteria

1. **Code Reduction**: 
   - BattleScene.js reduced by ~210-230 lines
   - All event setup and handler methods removed
   - BattleScene no longer directly interacts with battleBridge events

2. **Functionality Preservation**:
   - All battle events (damage, healing, turns, etc.) continue to work exactly as before
   - No visual or behavioral changes to the game
   - No new console errors

3. **Code Organization**:
   - Event handling logic centralized in dedicated component
   - BattleScene focused on scene lifecycle and visual management
   - Clear component boundaries established

## 7. Test Points

1. Start a battle and verify:
   - Turn indicator updates properly
   - Character actions display correctly
   - Health updates show properly
   - Status effects appear/disappear correctly
   - Floating damage text appears as expected

2. Check console for expected diagnostics:
   - BattleEventManager initialization logs
   - Event registration confirmations
   - No unexpected errors

3. End battle and verify:
   - No memory leaks (event listeners properly removed)
   - Clean return to team builder

This implementation follows the successful refactoring patterns established in previous components, maintaining the same defensive programming approach while extracting a significant portion of code from BattleScene.js.

===== FILE: Potential Combat System Logic and Integration Improvements.md =====
Okay, let's evaluate the combat system's logic and integration based on the code and design you've implemented.

Overall Assessment:

The combat system has a solid and well-thought-out foundation. The separation of concerns (BattleManager for flow, BehaviorRegistry/ActionDecisionBehaviors for AI logic, JSON files for data, UI classes for presentation) is a strong architectural choice that promotes modularity and flexibility. The move towards a data-driven approach for abilities (effects array) and status effects is excellent for future expansion.

Strengths:

Modularity: The core components are reasonably well-defined and separated. BattleManager doesn't need to know the specifics of how Lumina decides to heal, just that it needs to execute the "decideAction_PrioritizeHeal" behavior via the registry. This makes adding new character AI or abilities cleaner.

Behavior System: Using a registry and dedicated behavior functions (ActionDecisionBehaviors.js, TargetingBehaviors.js, PassiveBehaviors.js) is highly flexible. You can create diverse character personalities and complex targeting rules without cluttering BattleManager.

Data-Driven Design: Defining abilities, characters, and status effects in JSON (characters.json, status_effects.json) is the right way to go. It makes balancing, adding content, and modifying effects much easier than hardcoding values. The effects array in abilities is particularly powerful.

Passive System: The trigger-based passive system (onTurnStart, onDamageTaken, etc.) is robust and covers most standard passive activation scenarios.

Clear Turn Flow: The sequence of events within a turn (status processing -> action generation -> sorting -> execution -> cooldowns -> end-of-turn passives) is logical and follows common turn-based patterns.

Potential Missing Pieces / Areas for Improvement:

Action Resolution Detail:

Accuracy/Evasion: Currently, calculateDamage has a flat 5% miss chance. A more robust system would involve character stats for Accuracy and Evasion, factoring them into hit checks before damage calculation. status_evade exists but isn't part of the core calculation yet.

Critical Hits: Similar to misses, crits are a flat 10% chance in calculateDamage. Adding Critical Hit Chance and Critical Damage stats to characters would allow for more build diversity. status_crit_up exists but needs stat integration.

Resistances/Vulnerabilities: Beyond basic type advantages (calculateTypeMultiplier), you could add resistances/vulnerabilities to specific damage types (e.g., Fire Resistance) or status effects (e.g., Stun Resistance) as character stats or passive effects.

Block/Parry: No mechanics seem present for actively mitigating damage through blocking or parrying, which could add depth for defensive roles.

Targeting Nuances:

Advanced Logic: Current targeting is good (HP, random, allies/enemies). More advanced options could include targeting based on buffs/debuffs (e.g., target lowest defense, target highest attack), specific roles, or threat/aggro (though maybe not intended).

AoE Patterns: targetAllEnemies, targetAllAllies, and targetAdjacentEnemies cover basics. More complex patterns (rows, columns, specific shapes) might be needed later.

Multi-Target Application: Ensure applyActionEffect correctly handles abilities that target multiple entities simultaneously (e.g., applying damage/effects to all targets returned by targetAllEnemies, not just the first).

AI Depth:

Contextual Awareness: The current decision behaviors are good starting points. More advanced AI could consider the entire battle state: ally/enemy buffs/debuffs, remaining cooldowns, enemy types, potential lethal damage, setting up combos, etc.

Adaptive Logic: AI could potentially change its behavior based on the situation (e.g., switch from offensive to defensive when low HP, even if not using decideAction_Defensive).

Status Effect Interactions:

Stacking/Overwriting: The status_effects.json has maxStacks. Ensure addStatusEffect correctly handles stacking values/durations and respects these limits. Define rules for how new effects interact with existing ones (e.g., does a stronger "Attack Up" replace a weaker one? Does "Stun" remove "Regen"?).

Cleansing/Dispelling: No mechanics mentioned for removing buffs from enemies or debuffs from allies.

Resource Management: Currently, only cooldowns limit ability use. Adding a resource system (Mana, Energy, Rage, etc.) could introduce another layer of strategic decision-making for ability usage.

Battle Log Verbosity: The log is functional, but could be enhanced to show why decisions were made (e.g., "Lumina targets Drakarion (Lowest HP Ally)"), indicate critical hits/misses clearly, and show type effectiveness multipliers applied.

Code Structure (BattleManager): As more mechanics get added, BattleManager.js could become very large. Consider if parts of its logic (e.g., processStatusEffects, applyActionEffect, calculateDamage) could be further broken down into helper classes or modules for better organization.

Conclusion:

You have a very well-structured and logical combat system core, particularly with the behavior delegation pattern. It's definitely not "missing" anything fundamental for an auto-battler of this type. The main areas for potential improvement involve adding more depth and nuance to the core mechanics (crits, accuracy, resistances), expanding the AI's decision-making capabilities, and potentially adding resource management. These are typical areas that get refined and expanded as game development progresses and complexity increases. The current foundation is strong enough to build upon.

===== FILE: Claude_Core.md =====
# Claude's Core System Reference for AutoBattler

> **PURPOSE OF THIS DOCUMENT:** This is the primary reference document for Claude to understand the AutoBattler game architecture and systems. It contains information about the core game systems, project structure, and development status. This document focuses on "what the system is" rather than implementation details. For guides on implementation, troubleshooting, and technical procedures, see the companion document "Claude_Implementation.md".

> When Claude needs to understand the game's core architecture, planned features, or current development status, this is the document to reference. This approach reduces token usage while providing focused context about the game's design and systems.
## Key Areas to Focus On
- Component-based architecture with specialized managers
- Phaser Battle Scene Implementation (modular component architecture)
- Enhanced Passive Ability System with dedicated components
- Battle event dispatching system
- Type effectiveness system (data-driven design)
- Defensive programming patterns throughout the codebase
- Project roadmap implementation status

## Game Concept
This is an autobattler game where players select teams of characters that fight automatically against opponent teams. The core appeal is in team building, strategic selection of characters, and watching the battles unfold with some randomness. Characters will gain XP, level up, and unlock new abilities as they progress.

## Project Structure
```
C:\Personal\AutoBattler\
â”‚
â”œâ”€â”€ assets/                   # All game assets
â”‚   â”œâ”€â”€ images/               # Game images and sprites
â”‚   â”‚   â”œâ”€â”€ Arena Art/        # Battle arena backgrounds (12 unique arenas)
â”‚   â”‚   â”œâ”€â”€ Character Art/    # Character artwork
â”‚   â”‚   â”‚   â””â”€â”€ Combat_Version/ # Battle-optimized (80x120px) character sprites
â”‚   â”‚   â””â”€â”€ icons/            # UI and status effect icons
â”‚   â”‚       â””â”€â”€ status/       # Status effect icons
â”‚   â”‚           â””â”€â”€ status-icons/  # 25 status effect icon images
â”‚   â”œâ”€â”€ css/                  # CSS stylesheets with UI styling
â”‚   â””â”€â”€ audio/                # Sound effects and music
â”‚       â””â”€â”€ InCombat_Sounds/  # Battle sound effects (75+ sound files)
â”‚
â”œâ”€â”€ Changelogs/               # Version history documentation
â”‚   â”œâ”€â”€ changelog.md          # High-level changelog (main file)
â”‚   â””â”€â”€ Technical Changelogs/ # Detailed technical changelogs for each version
â”‚
â”œâ”€â”€ Context/                  # Documentation for understanding project architecture
â”‚   â”œâ”€â”€ Battle_Implementation_Plan.md     # Phaser implementation strategy
â”‚   â”œâ”€â”€ Claude_Core.md                     # This file - notes for Claude
â”‚   â”œâ”€â”€ Lessons Learned.md                # Technical retrospectives
â”‚   â”œâ”€â”€ Planning/                         # Architecture & refactoring plans
â”‚   â””â”€â”€ Version 1.0 Vision.md             # Target feature set and roadmap
â”‚
â”œâ”€â”€ data/                     # Game data
â”‚   â”œâ”€â”€ characters.json       # Character definitions with stats and abilities
â”‚   â”œâ”€â”€ status_effects.json   # Status effect definitions
â”‚   â””â”€â”€ type_effectiveness.json # Type relationship data (advantages/disadvantages/immunities)
â”‚
â”œâ”€â”€ examples/                 # Example code and implementations
â”‚   â”œâ”€â”€ passive_character.json           # Sample passive ability character
â”‚   â””â”€â”€ PASSIVE_SYSTEM_IMPLEMENTATION.md # Passive system implementation guide
â”‚
â”œâ”€â”€ js/                       # JavaScript files
â”‚   â”œâ”€â”€ battle_logic/         # Core battle system logic
â”‚   â”‚   â”œâ”€â”€ core/                   # Core battle system components
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleFlowController.js   # Controls turn flow and actions
â”‚   â”‚   â”‚   â””â”€â”€ BattleInitializer.js      # Handles battle setup and team initialization
â”‚   â”‚   â”œâ”€â”€ status/                 # Status effect components
â”‚   â”‚   â”‚   â”œâ”€â”€ StatusEffectManager.js     # Status effect application/processing
â”‚   â”‚   â”‚   â””â”€â”€ StatusEffectDefinitionLoader.js  # Loads effect definitions
â”‚   â”‚   â”œâ”€â”€ damage/                 # Damage calculation components
â”‚   â”‚   â”‚   â”œâ”€â”€ DamageCalculator.js        # Calculates damage with stat scaling
â”‚   â”‚   â”‚   â”œâ”€â”€ HealingProcessor.js        # Handles healing calculations
â”‚   â”‚   â”‚   â””â”€â”€ TypeEffectivenessCalculator.js  # Calculates type advantages
â”‚   â”‚   â”œâ”€â”€ abilities/              # Ability system components
â”‚   â”‚   â”‚   â”œâ”€â”€ AbilityProcessor.js        # Processes ability effects
â”‚   â”‚   â”‚   â”œâ”€â”€ TargetingSystem.js         # Handles ability targeting
â”‚   â”‚   â”‚   â””â”€â”€ ActionGenerator.js         # Generates character actions
â”‚   â”‚   â”œâ”€â”€ passives/               # Passive ability components
â”‚   â”‚   â”‚   â”œâ”€â”€ PassiveAbilityManager.js   # Processes passive abilities
â”‚   â”‚   â”‚   â””â”€â”€ PassiveTriggerTracker.js   # Tracks passive triggers per turn/battle
â”‚   â”‚   â”œâ”€â”€ events/                 # Battle event system
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleEventDispatcher.js   # Centralizes event dispatching
â”‚   â”‚   â”‚   â””â”€â”€ BattleLogManager.js        # Battle log message formatting and display
â”‚   â”‚   â”œâ”€â”€ utilities/              # Utility components and functions
â”‚   â”‚   â”‚   â””â”€â”€ BattleUtilities.js         # Static utility methods
â”‚   â”‚   â”œâ”€â”€ BattleBehaviors.js      # Behavior system for battle actions
â”‚   â”‚   â”œâ”€â”€ BehaviorRegistry.js     # Registry of all available behaviors
â”‚   â”‚   â”œâ”€â”€ ActionDecisionBehaviors.js # Logic for choosing actions
â”‚   â”‚   â”œâ”€â”€ TargetingBehaviors.js   # Logic for selecting targets
â”‚   â”‚   â”œâ”€â”€ PassiveBehaviors.js     # Passive ability implementation
â”‚   â”‚   â””â”€â”€ fallback/               # Fallback behaviors directory
â”‚   â”‚
â”‚   â”œâ”€â”€ entities/             # Character classes and entities
â”‚   â”‚   â”œâ”€â”€ Character.js      # Base character class
â”‚   â”‚   â””â”€â”€ Ability.js        # Abilities system
â”‚   â”‚
â”‚   â”œâ”€â”€ managers/             # Game managers
â”‚   â”‚   â”œâ”€â”€ BattleManager.js  # Orchestrates battle flow via component delegation
â”‚   â”‚   â””â”€â”€ TeamManager.js    # Manages team composition
â”‚   â”‚
â”‚   â”œâ”€â”€ phaser/               # Phaser integration 
â”‚   â”‚   â”œâ”€â”€ assets.js         # Asset management
â”‚   â”‚   â”œâ”€â”€ bridge/           # Communication between game logic and Phaser
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleBridge.js     # Bridge class for battle events
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleBridgeInit.js # Bridge initialization
â”‚   â”‚   â”‚   â””â”€â”€ BattleLogTester.js  # Utilities for testing log messages
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ audio/            # Phaser audio implementation
â”‚   â”‚   â”‚   â””â”€â”€ PhaserSoundManager.js  # Sound system for Phaser
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ components/       # Reusable UI components
â”‚   â”‚   â”‚   â”œâ”€â”€ battle/             # Battle-specific components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BattleControlPanel.js  # Battle controls (speed, pause, etc.)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BattleLogPanel.js      # Original panel-based battle log
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterSprite.js     # Individual character sprites
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DirectBattleLog.js     # Simplified direct text battle log
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TeamContainer.js       # Container for team organization
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.js             # Reusable button component
â”‚   â”‚   â”‚   â””â”€â”€ Panel.js              # Reusable panel component
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ debug/            # Development and debugging tools
â”‚   â”‚   â”‚   â”œâ”€â”€ CoordinateDisplay.js  # Grid and coordinate visualization
â”‚   â”‚   â”‚   â”œâ”€â”€ DebugManager.js       # Debug toolset manager
â”‚   â”‚   â”‚   â””â”€â”€ ObjectIdentifier.js   # Object inspection utilities
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ scenes/           # Phaser scene definitions
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleScene.js       # Main battle scene
â”‚   â”‚   â”‚   â”œâ”€â”€ BootScene.js         # Initial loading scene
â”‚   â”‚   â”‚   â””â”€â”€ TeamBuilderScene.js  # Future Phaser team builder (not implemented)
â”‚   â”‚   â”‚   
â”‚   â”‚   â”œâ”€â”€ config.js         # Bridge configuration
â”‚   â”‚   â”œâ”€â”€ PhaserConfig.js   # Phaser initialization config
â”‚   â”‚   â””â”€â”€ uiManager.js      # UI mode management (DOM vs Phaser)
â”‚   â”‚
â”‚   â”œâ”€â”€ ui/                   # UI components (DOM-based)
â”‚   â”‚   â”œâ”€â”€ BattleUI.js       # Original DOM-based battle interface
â”‚   â”‚   â”œâ”€â”€ BattleUIDebug.js  # Debug utilities for battle UI
â”‚   â”‚   â”œâ”€â”€ SoundManager.js   # Audio system management
â”‚   â”‚   â”œâ”€â”€ TeamBuilderUI.js  # Team selection interface
â”‚   â”‚   â”œâ”€â”€ TeamBuilderUIUpdates.js  # Updates for team builder
â”‚   â”‚   â””â”€â”€ TooltipManager.js # UI tooltip system
â”‚   â”‚
â”‚   â”œâ”€â”€ utilities/            # Utility functions and helpers
â”‚   â”‚   â”œâ”€â”€ DirectImageLoader.js       # Handles image loading for Battle UI
â”‚   â”‚   â”œâ”€â”€ ImageDebugger.js           # Debugging tools for images
â”‚   â”‚   â””â”€â”€ TeamBuilderImageLoader.js  # Handles image loading for Team Builder UI
â”‚   â”‚
â”‚   â””â”€â”€ game.js               # Main game initialization
â”‚
â”œâ”€â”€ lib/                      # Third-party libraries
â”‚   â”œâ”€â”€ phaser-download-instructions.md  # Instructions for updating Phaser
â”‚   â””â”€â”€ phaser.min.js         # Phaser.js library
â”‚
â”œâ”€â”€ _CombinedForAI/          # Utilities for AI assistance
â”‚   â”œâ”€â”€ Changelogs.txt        # Combined changelog text
â”‚   â”œâ”€â”€ CombineforAI_Tool.ps1 # Script to combine files for AI analysis
â”‚   â”œâ”€â”€ ContextDocs.txt       # Combined context documentation
â”‚   â”œâ”€â”€ Data_Examples.txt     # Sample data structures
â”‚   â”œâ”€â”€ FolderStructure.txt   # Directory structure info
â”‚   â”œâ”€â”€ Get_FileStructure_ofGame.ps1 # Script to generate folder structure
â”‚   â”œâ”€â”€ JS_BattleLogic.txt    # Combined battle logic code
â”‚   â”œâ”€â”€ JS_Core.txt           # Combined core game code
â”‚   â”œâ”€â”€ JS_Managers.txt       # Combined manager code
â”‚   â”œâ”€â”€ JS_Phaser.txt         # Combined Phaser implementation code
â”‚   â””â”€â”€ JS_UI.txt             # Combined UI code
â”‚
â”œâ”€â”€ Development_Plan.md       # Original development roadmap
â”œâ”€â”€ Role Base Stat Template.md     # Template for character stat distribution
â”œâ”€â”€ Role Based Stat Multipliers.md # Stat growth rates for different roles
â”œâ”€â”€ Role Chart.md                  # Details on character roles and specializations
â”œâ”€â”€ Type Chart.md                  # Information on elemental types
â”œâ”€â”€ Type Effectiveness Table.md    # Type advantage and weakness relationships
â”œâ”€â”€ GeminiSuggestions.md      # AI-generated suggestions for game systems
â”œâ”€â”€ project.config            # Phaser project configuration
â”œâ”€â”€ index.html                # Main game HTML file
â”œâ”€â”€ test_battle_log.html      # Battle log testing page
â”œâ”€â”€ patch_notes.md            # Simplified patch notes
â””â”€â”€ README.md                 # General project readme
```

## Changelog Documentation System

The game uses a two-level changelog system to track version history:

1. **High-Level Changelog** (`C:\Personal\AutoBattler\Changelogs\changelog.md`):
   - Contains concise summaries of changes for each version
   - Organized by version number and date
   - Categories include: Added, Changed, Fixed, Improved, Technical
   - Intended for quick reference and overview of changes

2. **Detailed Technical Changelogs** (`C:\Personal\AutoBattler\Changelogs\Technical Changelogs\CHANGELOG_X.X.X_SummaryNameofChange.md`):
   - One file per version (e.g., `CHANGELOG_0.4.3.md`)
   - Contains in-depth technical details about implementation
   - Includes code snippets, before/after comparisons
   - Documents problem analysis and solution approach
   - Provides context for why changes were made
   - Useful for developers who need to understand specific implementations

### When Making Changes

When implementing changes to the game:

1. Update the high-level changelog with a concise summary
2. Create a detailed technical changelog file if it's a significant version update
3. Reference the detailed changelog in the high-level entry with: `*Note: For detailed information on specific implementation steps, see CHANGELOG_X.X.X.md*`

This dual approach ensures both quick reference for general changes and detailed documentation for complex implementations.


# System Overview

## Core Game Systems

### Characters System
- Characters have: name, type, role, rarity, level, XP, and abilities
- Characters start at level 1 and can progress to level 20
- **Types**: Fire, Water, Nature, Electric, Ice, Rock, Metal, Air, Light, Dark, Psychic, Poison, Physical, Arcane, Mechanical, Void, Crystal, Storm, Ethereal, Blood, Plague, Gravity (with advantages/disadvantages and immunities)
- **Roles**: Warrior, Sentinel (formerly Knight), Berserker, Ranger, Assassin, Bulwark (formerly Guardian), Mage, Invoker, Sorcerer, Summoner, Occultist (formerly Necromancer), Mystic (formerly Cleric), Champion (formerly Paladin), Wildcaller (formerly Druid), Striker (formerly Monk), Emissary (formerly Bard), Elementalist (formerly Shaman), Warden, Skirmisher, Battlemage, Venomancer, Trickster
- Team synergies based on having multiple characters of same type/role
- **Stats**:
  - HP: Health points
  - Attack: Power of auto-attacks
  - Defense: Damage reduction
  - Speed: Determines turn order
  - Strength: Enhances physical ability damage
  - Intellect: Enhances spell ability damage
  - Spirit: Enhances healing effectiveness

### Battle System
- Turn-based auto-battle with initiative/speed system (fastest characters act first)
- **Core Architecture**:
  - Refactored to a component-based system with specialized managers
  - Clear separation of concerns with dedicated components for:
    - Battle flow control (BattleFlowController)
    - Damage calculation (DamageCalculator)
    - Status effects (StatusEffectManager)
    - Healing (HealingProcessor)
    - Passive abilities (PassiveAbilityManager and PassiveTriggerTracker)
    - Targeting (TargetingSystem)
    - Action generation (ActionGenerator)
  - BattleManager acts as a faÃ§ade and coordinator for these components
- **Battle Visualization Evolution**:
  - Original Battle UI: DOM-based implementation with Tailwind CSS
  - Current approach: Phaser-based Battle Scene with modular component architecture
  - Based on lessons from previous Phaser integration attempts (see `C:\Personal\AutoBattler\Context\Lessons Learned.md`)
- **Combat features**:
  - Type advantages/disadvantages system affecting damage
  - Abilities with cooldowns and effects
  - Status effects (burn, stun, regen, etc.)
  - Critical hit (10%) and miss chance (5%) systems
  - Damage variance (Â±20%)
  - Auto-attacks and special abilities
  - Ability damage scaling with Strength/Intellect/Spirit stats
- **Battle UI includes**:
  - Circle-based character representations with type-specific colors
  - Health bars with dynamic coloring based on remaining health
  - Status effect indicators with tooltips
  - Battle log with detailed information and team identifiers
  - Movement animations for attacks with directional awareness
  - Floating damage/healing numbers
  - Battle controls (speed, pause, next turn)
  - Battle results screen (victory/defeat/draw)

### Expanded Base Stats System
- Implemented a new stat system beyond the basic HP, Attack, Defense stats:
  - **Strength:** Increases physical ability damage (50% scaling)
  - **Intellect:** Increases spell ability damage (50% scaling)
  - **Spirit:** Increases healing effectiveness (50% scaling)
- Added `damageType` property to abilities which determines stat scaling:
  - `"physical"` - Scales with Strength
  - `"spell"` - Scales with Intellect
  - `"healing"` - Scales with Spirit
  - `"utility"` - Effects scale with Spirit, but doesn't deal direct damage
- **Role-specific stat distributions**:
  - Each character has 325 total stat points distributed according to their role
  - Mages have high Intellect, Warriors have high Strength, Clerics have high Spirit
- **Battle calculations**:
  - Physical damage: `base_damage + (strength * 0.5)`
  - Spell damage: `base_damage + (intellect * 0.5)`
  - Healing: `base_healing + (spirit * 0.5)`
- **UI Display**:
  - Added second row of stats in Hero Details panel
  - Enhanced ability tooltips with detailed scaling formulas
  - Battle log shows scaling contributions (e.g., "+73 from Intellect")

### Passive Ability System
- Characters can have special passive abilities that trigger automatically in response to battle events
- **System Architecture**:
  - **PassiveAbilityManager**: Handles execution and processing of passive abilities
  - **PassiveTriggerTracker**: Tracks which passives have triggered during a turn or battle
  - **PassiveBehaviors.js**: Contains behavior functions for different passive abilities
- **Trigger Types**:
  - `onBattleStart`: Triggered when battle begins (team buffs, preparation effects)
  - `onTurnStart`: Triggered at the start of each turn (regeneration, periodic effects)
  - `onDamageTaken`: Triggered when character takes damage (counter, reflect, defensive reactions)
  - `onDamageDealt`: Triggered when character deals damage (vampiric effects, bonus effects)
  - `onHealed`: Triggered when character is healed (bonus health, amplification)
  - `onHealingDone`: Triggered when character heals someone (bonus healing, secondary effects)
  - `onKill`: Triggered when character defeats an enemy (bonus stats, special effects)
  - `onDefeat`: Triggered when character is defeated (death effects, revenge)
- **Key Components**:
  - **PassiveBehaviors.js**: Contains behavior functions for different passive abilities
  - `passiveTrigger`: Property on abilities defining when they trigger (corresponds to trigger types)
  - `passiveBehavior`: Property on abilities referencing which behavior function to use
  - `passiveData`: Optional configuration object to customize passive behavior
- **Visual Feedback**: 
  - Purple text notification appears above character when passive triggers
  - Glowing effect surrounds character briefly
  - Displays the name or effect of the passive ability that triggered
- **Implementation**: 
  - Added in version 0.4.4.3 with basic functionality
  - Enhanced in version 0.4.4.6 with reflection depth tracking and battle-level tracking
  - Further enhanced in version 0.4.4.7 with advanced behaviors and visual feedback
- **Advanced Passive Behaviors**:
  - `passive_OnKillEffect`: Triggers effects (healing, buffs, AoE damage) when killing enemies
  - `passive_CriticalHitBoost`: Increases critical hit chance after specific battle events
  - `passive_StatusOnHit`: Chance to apply status effects to targets when dealing damage
  - `passive_DamageReflectOnHit`: Returns portion of damage back to attacker
  - `passive_TeamBuffOnBattleStart`: Provides buffs to allies at battle start
- **Example Implementation**:
  ```json
  {
    "id": "character_bloodthirst",
    "name": "Bloodthirst",
    "description": "Heals for 10% of max HP when defeating an enemy",
    "abilityType": "Passive",
    "passiveTrigger": "onKill",
    "passiveBehavior": "passive_OnKillEffect",
    "passiveData": {
      "effectType": "heal",
      "value": 0.1
    }
  }
  ```

### Character Art System
- Characters are assigned unique IDs (`uniqueId`) upon creation via BattleInitializer
- **Source ID Linking Pattern**: Stores character IDs rather than direct object references
  - Prevents circular references in status effects and other systems
  - Enables proper attribution of damage/healing sources in the battle log
  - Critical for tracking effect sources across turns
- **ID Resolution**: BattleUtilities provides methods to resolve IDs back to character objects
  - `getCharacterByUniqueId(uniqueId, playerTeam, enemyTeam)`: Finds character by ID across both teams
  - Handles multiple source reference formats for backward compatibility
  - Includes defensive programming with proper error handling
- **Implementation**: 
  - Status effects store the source character's `uniqueId` when applied
  - When effects trigger (damage, healing), the source ID is resolved to the full character
  - Battle log uses the resolved character for proper message formatting
  - The pattern is used throughout damage, healing, and status effect systems
- **Image Loaders:** Two main systems handle character art:
  1. `TeamBuilderImageLoader.js` - For Team Builder UI with advanced caching
  2. `DirectImageLoader.js` - For Battle UI with animation support
- **Multi-Resolution System:**
  - High-resolution original art: Used in TeamBuilder UI
  - Optimized 80x120px battle sprites: Used in Battle Scene (under `Combat_Version/` folder)
  - Pre-sized sprites eliminate WebGL scaling artifacts and pixelation
- **Global Caching:** Uses `window.CHARACTER_IMAGE_CACHE` object to store loaded images
- **Positioning System:** Character art settings in `characters.json`:
  ```json
  "art": {                    // Default art positioning for Battle UI
    "left": "-12px",         // Horizontal positioning
    "top": "-52px",          // Vertical positioning
    "width": "80px",          // Optional width override
    "height": "120px"         // Optional height override
  },
  "teamBuilderArt": {...},   // Optional separate positioning for Team Builder UI
  "detailArt": {...}         // Optional separate positioning for Detail View
  ```
- **Animation System:** Character art follows characters during attack animations using a cloning system
  - Creates a clone of the character for movement
  - Hides original character during animation
  - Recent issue fixed: Characters would briefly display incorrect art during animations
  - Fix implemented in v0.3.4: Improved clone creation and added protection system to prevent DirectImageLoader interference
- **Key Files for Character Art:**
  - `BattleUI.js` - `showAttackAnimation()` method (contains animation logic)
  - `DirectImageLoader.js` - Battle UI image injection
  - `TeamBuilderImageLoader.js` - Team Builder image loading 
- **MutationObserver System for Art Loading**:
  - Only watches specific containers that recycle DOM (#heroes-grid, #team-slots)
  - Uses data attributes to track state and prevent redundant processing
  - Provides early-exit conditions for elements that already have art
  - Uses requestAnimationFrame throttling for performance

### Character ID Management System
- Characters are assigned unique IDs (`uniqueId`) upon creation via BattleInitializer
- **Source ID Linking Pattern**: Stores character IDs rather than direct object references
  - Prevents circular references in status effects and other systems
  - Enables proper attribution of damage/healing sources in the battle log
  - Critical for tracking effect sources across turns
- **ID Resolution**: BattleUtilities provides methods to resolve IDs back to character objects
  - `getCharacterByUniqueId(uniqueId, playerTeam, enemyTeam)`: Finds character by ID across both teams
  - Handles multiple source reference formats for backward compatibility
  - Includes defensive programming with proper error handling
- **Implementation**: 
  - Status effects store the source character's `uniqueId` when applied
  - When effects trigger (damage, healing), the source ID is resolved to the full character
  - Battle log uses the resolved character for proper message formatting
  - The pattern is used throughout damage, healing, and status effect systems

### Team Builder UI
- Implemented as vanilla JavaScript in `js/ui/TeamBuilderUI.js`
- Uses CSS for styling in `assets/css/style.css`
- Displays three panels: available heroes, team selection, and hero details
- Allows selecting heroes, viewing their details, and building a team
- Supports three battle modes: Random, Custom, and Campaign
- Custom Battle mode lets players select both their team and their opponent's team
- Enhanced to show expanded stat system (STR, INT, SPI) in detail view

## Planned Systems

### Character Progression System (To be implemented)
- Characters gain XP from battles
- Each level requires progressively more XP
- Characters unlock additional abilities as they level up:
  - Level 1: One default ability
  - Level 5: Second ability unlocked
  - Level 10: Third ability unlocked
  - Level 15: Fourth ability unlocked
- All characters have a default auto-attack regardless of level
- UI will display locked abilities with level requirements

### Role-Based Stat Growth (To be implemented)
- Each role has unique stat growth multipliers applied per level
- Stats are distributed across Attack, Health, Strength, Intellect, and Spirit
- Each role gets a total of 5.0 stat points per level spread across all stats
- Roles are specialized with distinct archetypes:
  - **Physical Damage Dealers**:
    - Warriors (Pure melee DPS-tank): High ATK/HP/STR (1.5/1.8/1.5)
    - Berserkers (All-in bruiser): Very high ATK/STR (1.8/1.7)
    - Rangers (Ranged glass cannon): Very high ATK/STR (1.7/1.9)
    - Assassins (Burst finisher): Highest ATK/STR (1.9/1.9)
  - **Tank Specialists**:
    - Sentinels (Shielded striker): Highest HP with good STR (2.0/1.8)
    - Bulwarks (Pure tank): Extreme HP with good STR (2.3/1.7)
    - Wardens (Counter-tank/Disruptor): Very high HP (2.0)
  - **Spell Casters**:
    - Mages (Pure spell DPS): Very high INT with some SPI (2.4/0.8)
    - Invokers (Supportive magic amplifier): Extreme INT (2.8) 
    - Sorcerers (High-risk nuker): Extreme INT (2.8)
  - **Healing/Support**:
    - Mystics (Pure healer): Extreme SPI (2.5) 
    - Champions (Tank-healer): Good HP with balanced stats (1.6 HP)
    - Emissaries (Buffer/debuffer): High SPI (1.4)
  - **Hybrid/Specialized**:
    - Battlemages (Melee-caster): Balanced ATK/HP/STR/INT (1.3/1.4/1.3/1.4)
    - Wildcallers (Nature hybrid): Balanced across all stats
    - Venomancers (DoT specialist): High INT/SPI (1.8/1.2)
    - Tricksters (Chaos/RNG): High SPI (1.5) with balanced other stats

### Type Effectiveness System
- **Fully implemented** data-driven type system with complete 22-type effectiveness relationships
- Data stored in `type_effectiveness.json` with advantages, disadvantages, immunities, and special cases
- Each type has specific strengths (does +50% damage) and weaknesses (does -50% damage)
- Some types have immunities (e.g., Metal is immune to Poison, Physical cannot damage Ethereal)
- Special interactions exist (e.g., Ethereal takes 3x damage from Light)
- Enhanced battle log with descriptive type effectiveness messages
- Example relationships:
  - Fire is strong against Nature, Ice, and Metal but weak against Water and Rock
  - Water is strong against Fire, Rock, and Metal but weak against Nature and Electric
  - Light and Dark are opposing forces (strong against each other)
  - Arcane is strong against itself and Nature
  - Ethereal is immune to physical auto-attacks but very vulnerable to Light
  - Mechanical types are strong against Arcane and Poison
  - Void excels against Light and Psychic types

### Arena System (Planned)
- Multiple battle environments with distinct visual styles
- Weather effects (rain, snow, fog) affecting battle conditions
- Time of day variations (day, night, dusk)
- Arena-specific bonuses for certain character types
- Environmental hazards and obstacles
- Arena selection interface before battles

### Equipment System (Planned)
- Characters can equip items that enhance their stats
- Different item types (weapons, armor, accessories)
- Item rarity system affecting bonus strength
- Loot drops from battles
- Inventory management interface

## Current Implementation Status
- **Refactoring Progress**: Major BattleManager refactoring completed
  - All components implemented: StatusEffectManager, BattleFlowController, DamageCalculator, HealingProcessor, TypeEffectivenessCalculator, AbilityProcessor, TargetingSystem, ActionGenerator, PassiveTriggerTracker, PassiveAbilityManager, BattleEventDispatcher, BattleLogManager, BattleInitializer, BattleUtilities
  - Architecture has shifted from monolithic BattleManager to specialized component managers
  - BattleManager now serves as a thin orchestration layer that delegates to specialized components
- Team Builder UI is fully functional with hero selection, team building, and custom battles (DOM-based)
- Phaser Battle Scene development continuing with modular component architecture
- Previous DOM-based Battle UI is being replaced with a Phaser-based implementation
- Expanded base stats system (STR, INT, SPI) fully implemented
- Character progression system (leveling, ability unlocking) not yet implemented
- Character art implemented for all characters with optimized battle versions
- Core data structures and classes are defined and working
- Initiative/speed system implemented for turn-based combat
- Type advantages and status effects are functional with data-driven implementation
- Implementation plan documented in `C:\Personal\AutoBattler\Context\Battle_Implementation_Plan.md`
- Detailed refactoring plan in `C:\Personal\AutoBattler\Context\Planning\BattleManager_Refactoring_Plan_Big Picture.md`

### Defensive Programming Patterns
- The codebase uses consistent defensive programming patterns throughout components:
  - Component availability checks before calling methods
  - Parameter validation at the beginning of methods
  - Graceful fallbacks when dependencies are unavailable
  - Clear error messages with component context ([ComponentName])
  - Proper handling of circular references
  - Safe defaults for missing or invalid parameters
  - Early returns for invalid input states

---

===== FILE: Claude_Implementation.md =====
# Claude's Implementation Guide for AutoBattler

> **PURPOSE OF THIS DOCUMENT:** This is the technical implementation reference for Claude to assist with specific development tasks in the AutoBattler game. It contains detailed guides, code examples, troubleshooting steps, and technical patterns. While "Claude_Core.md" explains what the system is, this document focuses on how to work with the system.

> When Claude needs to assist with adding new features, debugging issues, or understanding technical patterns, this is the document to reference. This focused approach reduces token usage while providing detailed implementation guidance without needing to load the entire system architecture documentation.

> For understanding the overall game architecture, core systems, and development status, refer to the companion document "Claude_Core.md".


# Implementation Guides

## Guide: Adding New Arena Backgrounds

This section provides instructions for adding new arena backgrounds to the battle system. When the user adds a new background image to `C:\Personal\AutoBattler\assets\images\Arena Art`, follow these steps to properly implement it:

### Step 1: Add CSS for the New Background

In `BattleUI.js`, find the Arena backgrounds CSS section (around line 445) and add a new entry for your background:

```css
.arena-newbackground {
    background-image: url('assets/images/Arena Art/New Background.png');
    background-size: cover;
    background-position: center;
}
```

Make sure to use the correct file name and extension, and note that we use relative paths starting with 'assets/' (not '/assets/').

### Step 2: Update the Background Options in BattleUI

Find the `showSettings` method in `BattleUI.js` and update the `bgOptions` array to include your new background. For example:

```javascript
// Only offer backgrounds that actually exist
const bgOptions = ['default', 'grassyfield', 'newbackground'];
```

### Step 3: Update the Background Verification

Find the `verifyBackgroundImages` call in the `initialize` method of BattleUI.js and add your new background to the array:

```javascript
this.verifyBackgroundImages(['default', 'grassyfield', 'newbackground']);
```

### Step 4: Update the setArenaBackground Method

Modify the conditional check at the beginning of the `setArenaBackground` method to include your new background:

```javascript
// Accept valid backgrounds
if (backgroundKey !== 'default' && backgroundKey !== 'grassyfield' && backgroundKey !== 'newbackground') {
    console.log(`Background '${backgroundKey}' not implemented yet, using 'grassyfield' instead`);
    backgroundKey = 'grassyfield';
}
```

Also update the class removal line to include your new background:

```javascript
arenaElement.classList.remove('arena-default', 'arena-grassyfield', 'arena-newbackground');
```

Finally, modify the background image URL selection logic to handle your new background:

```javascript
if (backgroundKey !== 'default') {
    let imageUrl;
    
    switch(backgroundKey) {
        case 'grassyfield':
            imageUrl = 'assets/images/Arena Art/Grassy Field.png';
            break;
        case 'newbackground':
            imageUrl = 'assets/images/Arena Art/New Background.png';
            break;
        default:
            imageUrl = 'assets/images/Arena Art/Grassy Field.png'; // fallback
    }
    
    // Apply the background image
    arenaElement.style.backgroundImage = `url("${imageUrl}")`;
    // ... rest of the code
}
```

### Step 5: Testing the New Background

Test the new background by starting a battle and using the Settings button (gear icon) to select your new background. Make sure it loads correctly and displays properly in the battle arena.

### Troubleshooting Common Issues

1. **Background Not Showing**: Make sure the image path is correct and the file exists in the specified location.
2. **Path Issues**: Ensure you're using relative paths starting with 'assets/' not '/assets/'.
3. **CSS Not Applied**: Check that the CSS class name exactly matches the background key used in the code.
4. **Image Format**: Make sure the image is in a web-friendly format (PNG, JPG, etc.)
5. **File Size**: Large images may cause performance issues - consider optimizing large background images.

## Guide: Integrating New Character Art

This section provides instructions for adding new character art to the game. When the user adds new PNG files to `C:\Personal\AutoBattler\assets\images\Character Art`, follow these steps to properly implement them in both UI contexts.

### Step 1: Update Character Image Paths

The first step is to add the new image paths to both loader systems:

#### In TeamBuilderImageLoader.js

1. Locate the `characterImages` object in the constructor (around line 18)
2. Add a new entry for each character following this format:
   ```javascript
   this.characterImages = {
       'Aqualia': 'assets/images/Character Art/Aqualia.png',
       'NewCharacterName': 'assets/images/Character Art/NewCharacterName.png'
   };
   ```

#### In DirectImageLoader.js

1. Locate the `characterImages` object (around line 21)
2. Add the same entry to maintain consistency:
   ```javascript
   characterImages: {
       'Aqualia': 'assets/images/Character Art/Aqualia.png',
       'NewCharacterName': 'assets/images/Character Art/NewCharacterName.png'
   },
   ```

### Step 2: Create Optimized Battle Version

1. Create a battle-optimized version of the character art at exactly 80x120 pixels
2. Save this optimized version in the `assets/images/Character Art/Combat_Version/` folder
3. Ensure the filename matches the original filename exactly

### Step 3: Add Positioning in characters.json

The character's data in `characters.json` should be updated to include positioning information:

```json
{
  "id": 7,
  "name": "NewCharacterName",
  "type": "fire",
  "role": "Warrior",
  "rarity": "Rare",
  "stats": {
    "hp": 95,
    "attack": 18,
    "defense": 10,
    "speed": 12,
    "strength": 95,
    "intellect": 25,
    "spirit": 24
  },
  "art": {                    // Base positioning for Battle UI
    "left": "-12px",
    "top": "-52px",
    "width": "80px",
    "height": "120px"
  },
  "teamBuilderArt": {        // Specific positioning for Team Builder UI
    "left": "-20px",
    "top": "-45px",
    "width": "90px",
    "height": "130px"
  },
  "detailArt": {             // Specific positioning for Detail View
    "left": "-30px",
    "top": "-45px",
    "width": "140px",
    "height": "140px"
  },
  "abilities": [
    {
      "name": "Sample Ability",
      "damage": 25,
      "cooldown": 3,
      "isHealing": false,
      "damageType": "physical",
      "description": "A strong physical attack"
    }
  ]
}
```

Each positioning context is optional. If a specific context isn't defined, the system will fall back to the next available one in this order:
1. Context-specific setting (detailArt or teamBuilderArt)
2. Generic art setting
3. Default positioning

### Step 4: Implementing in Team Builder UI

The Team Builder UI automatically loads character art through the TeamBuilderImageLoader. Key points:

1. Images are loaded when the Team Builder initializes
2. The image cache is global and persists throughout the session
3. Three UI contexts to consider:
   - Available Heroes grid: Character card thumbnails
   - Team Slots: Selected character thumbnails
   - Hero Details: Larger character portrait

The TeamBuilderImageLoader handles all three contexts based on the art positioning settings:
- For grid and team slots: Uses `teamBuilderArt` or falls back to `art`
- For detail view: Uses `detailArt` or falls back to `teamBuilderArt`, then `art`

### Step 5: Implementing in Battle System UI

The Battle UI loads character art through the DirectImageLoader (DOM version) or the CharacterSprite component (Phaser version). Key differences from Team Builder:

1. Only uses the base `art` positioning (not teamBuilderArt or detailArt)
2. DOM version: Injects art into circle elements with class `.character-circle`
3. Phaser version: Uses optimized battle sprites from the Combat_Version folder
4. Character name is identified through a sibling element with class `.text-sm.font-semibold`

### Step 6: Testing Character Art Integration

After adding new character art:

1. Verify appearance in Team Builder:
   - Check that art appears in the Available Heroes grid
   - Check that art appears when character is selected in team slots
   - Check that art appears properly in the Hero Details panel

2. Verify appearance in Battle UI:
   - Start a battle with the character on your team
   - Check that art appears correctly positioned over the circle
   - Verify that art moves correctly during attack animations

3. Troubleshooting common issues:
   - If art doesn't appear in Team Builder, check browser console for errors in TeamBuilderImageLoader
   - If art doesn't appear in Battle UI, check browser console for errors in DirectImageLoader
   - If art position is incorrect, adjust the positioning values in characters.json
   - If art flickers, ensure the global CHARACTER_IMAGE_CACHE is properly populated

### Example: Complete Implementation Process

1. User adds new character art to `C:\Personal\AutoBattler\assets\images\Character Art\Drakarion.png`
2. User creates optimized battle version at `C:\Personal\AutoBattler\assets\images\Character Art\Combat_Version\Drakarion.png`

3. Update TeamBuilderImageLoader.js:
   ```javascript
   this.characterImages = {
       'Aqualia': 'assets/images/Character Art/Aqualia.png',
       'Drakarion': 'assets/images/Character Art/Drakarion.png'
   };
   ```

4. Update DirectImageLoader.js:
   ```javascript
   characterImages: {
       'Aqualia': 'assets/images/Character Art/Aqualia.png',
       'Drakarion': 'assets/images/Character Art/Drakarion.png'
   },
   ```

5. Update positioning in characters.json for Drakarion:
   ```json
   "art": {
     "left": "-15px",
     "top": "-50px",
     "width": "85px",
     "height": "125px"
   },
   "teamBuilderArt": {
     "left": "-22px",
     "top": "-48px"
   },
   "detailArt": {
     "left": "-35px",
     "top": "-50px",
     "width": "150px",
     "height": "150px"
   }
   ```

6. Verify in browser that Drakarion's art appears correctly in all contexts

## Guide: Using the Expanded Base Stats System

This section provides detailed information on working with the expanded base stats system (Strength, Intellect, Spirit) that has been implemented in the game.

### Stat Overview

The AutoBattler game uses seven primary stats:

1. **HP**: Health Points - How much damage a character can take before being defeated
2. **Attack**: Attack Power - Determines basic attack damage
3. **Defense**: Defense - Reduces damage taken from attacks
4. **Speed**: Speed - Determines turn order in battle (higher goes first)
5. **Strength**: Enhances physical ability damage
6. **Intellect**: Enhances spell ability damage
7. **Spirit**: Enhances healing and utility ability effectiveness

### Ability Types and Stat Scaling

Every ability has a `damageType` property that determines which stat affects its effectiveness:

1. **physical**: Scales with Strength
   - Formula: `base_damage + (strength * 0.5)`
   - Example: A physical ability with 20 base damage used by a character with 100 Strength would deal 20 + (100 * 0.5) = 70 pre-defense damage

2. **spell**: Scales with Intellect
   - Formula: `base_damage + (intellect * 0.5)`
   - Example: A spell ability with 30 base damage used by a character with 140 Intellect would deal 30 + (140 * 0.5) = 100 pre-defense damage

3. **healing**: Scales with Spirit
   - Formula: `base_healing + (spirit * 0.5)`
   - Example: A healing ability with 25 base healing used by a character with 120 Spirit would restore 25 + (120 * 0.5) = 85 health

4. **utility**: Effect scales with Spirit but doesn't deal direct damage
   - These abilities provide effects like buffs, debuffs, or evasion
   - The effectiveness or duration may scale with Spirit (currently a 30% scaling factor)

### Creating Balanced Characters

When balancing characters or creating new ones:

1. **Maintain the 325 Point Total**: Each character should have exactly 325 points distributed across all seven stats to ensure balance
2. **Follow Role Patterns**: Use the Base Stat Template as a guide for appropriate stat distribution by role
3. **Primary Stat Focus**: Ensure characters have appropriate primary stats based on their role:
   - Physical attackers (Warriors, Rangers, etc.): High Strength
   - Spell casters (Mages, Sorcerers, etc.): High Intellect
   - Healers (Clerics, Paladins, etc.): High Spirit

### Adding New Abilities with Proper Scaling

When adding new abilities to the game:

1. Include the `damageType` property for every ability
2. Choose the appropriate type based on the ability's nature:
   ```json
   {
     "name": "Fireball",
     "damage": 30,
     "damageType": "spell",
     "cooldown": 3,
     "isHealing": false,
     "description": "Launches a fiery projectile that deals spell damage"
   }
   ```
3. For healing abilities, include both `isHealing: true` and `damageType: "healing"` for proper handling in both battle logic and UI
4. For utility abilities that don't deal damage, use `damageType: "utility"` to indicate they scale with Spirit

### Example Role-Based Stat Distributions

Here are examples of appropriate stat distributions for different roles (level 1):

1. **Warrior** (Physical Damage Dealer):
   - HP: 122, ATK: 29, DEF: 21, SPD: 9
   - STR: 95, INT: 25, SPI: 24
   - Primary Focus: High Strength for physical abilities

2. **Mage** (Spell Damage Dealer):
   - HP: 82, ATK: 19, DEF: 8, SPD: 13
   - STR: 13, INT: 146, SPI: 44
   - Primary Focus: High Intellect for spell abilities

3. **Cleric** (Healer):
   - HP: 100, ATK: 19, DEF: 19, SPD: 8
   - STR: 13, INT: 48, SPI: 118
   - Primary Focus: High Spirit for healing abilities

4. **Knight** (Defensive Tank):
   - HP: 139, ATK: 26, DEF: 34, SPD: 6
   - STR: 74, INT: 23, SPI: 23
   - Primary Focus: High HP and Defense with moderate Strength

### Testing and Troubleshooting

When testing the expanded stat system:

1. Verify each ability type correctly scales with its corresponding stat
2. Check edge cases with very high or low stat values
3. Ensure healing properly scales with Spirit
4. Test utility abilities to confirm they benefit from Spirit
5. Verify tooltips display correct scaling information
6. Check that battle log messages show correct stat contributions


## Guide: Working with Enhanced Turn Highlighting

This section explains how to modify the turn highlighting system that shows which character is currently active during battle.

### Core Files and Components

- **CharacterSprite.js** (`js/phaser/components/battle/CharacterSprite.js`): Contains the `highlight()` and `unhighlight()` methods that create the visual indicators
- **TeamContainer.js** (`js/phaser/components/battle/TeamContainer.js`): Contains `showTurnIndicator()` and `clearTurnIndicators()` methods
- **BattleScene.js** (`js/phaser/scenes/BattleScene.js`): Contains `handleTurnStarted()` method that triggers the highlighting

### Adjusting the Floor Indicator Appearance

#### Size and Shape

To modify the size and shape of the floor indicators, adjust these values in `CharacterSprite.js`:

```javascript
// Shadow ellipse (larger, appears behind the highlight)
this.shadowEffect = this.scene.add.ellipse(0, bottomOffset, 60, 15, 0x000000, 0.4);
                                           // ^ position   ^ width ^ height ^ color ^ opacity

// Highlight ellipse (team-colored, appears above shadow)
this.highlightEffect = this.scene.add.ellipse(0, bottomOffset - 2, 55, 13, teamColor, 0.4);
                                              // ^ position    ^ width ^ height ^ color ^ opacity
```

- **Width/Height Ratio**: A wider, flatter ellipse (e.g., 60x15) creates a better 3D floor appearance
- **Opacity**: Values between 0.3-0.6 work well (higher = more visible)

#### Vertical Position

To adjust how high/low the indicator appears beneath characters:

```javascript
// Vertical position calculation
bottomOffset = (this.characterImage.height / 2) - 17;
```

- **Larger negative value**: Moves indicator higher (closer to character)
- **Smaller negative value or positive value**: Moves indicator lower (further from character)

#### Team Colors

To change the team color scheme:

```javascript
// Team color definition
const teamColor = this.character?.team === 'player' ? 0x4488ff : 0xff4444;
                                              // ^ player color (blue)  ^ enemy color (red)
```

#### Animation Settings

To adjust the pulsing animation:

```javascript
this.glowTween = this.scene.tweens.add({
    targets: this.highlightEffect,
    alpha: { from: 0.3, to: 0.7 },  // Alpha range (transparency)
    duration: 1200,                 // Animation duration in ms
    ease: 'Sine.easeInOut',         // Easing function
    yoyo: true,                     // Reverse animation
    repeat: -1                      // Infinite looping
});
```

### Implementation Flow

1. `BattleManager` dispatches TURN_STARTED event when a character's turn begins
2. `BattleScene.handleTurnStarted()` receives this event
3. `TeamContainer.showTurnIndicator()` is called for the active character
4. `CharacterSprite.highlight()` creates the visual indicators
5. Animation runs until the turn ends or another character is highlighted
6. `CharacterSprite.unhighlight()` hides the indicators

### Troubleshooting

- **Indicators Not Appearing**: Verify team colors are defined correctly, check console for errors
- **Wrong Position**: Adjust bottomOffset calculation to move indicators up/down
- **Too Large/Small**: Modify ellipse width/height values for better proportions
- **Not Visible Enough**: Increase opacity values (0.4 â†’ 0.6)
- **No Animation**: Check that scene.tweens is available and animation duration isn't set to 0

This system has been refined over multiple versions to create a subtle but effective visual cue for active characters during battle.

---

# Technical Reference

## MutationObserver Pattern for Character Art

The character art system uses an optimized MutationObserver pattern with these key features:

1. **Targeted Observation**: Only specific DOM containers that recycle elements are watched
   ```javascript
   const targets = document.querySelectorAll('#heroes-grid, #team-slots');
   targets.forEach(t => observer.observe(t, {...}));
   ```

2. **Idempotent Processing**: Uses data attributes to track state and prevent redundant work
   ```javascript
   // Early exit checks
   if (container.querySelector('.character-art')) return; // Already has art
   if (container.dataset.artSynced === '1') return;      // Already processed this frame
   container.dataset.artSynced = '1';                    // Mark as processed
   ```

3. **Animation Frame Throttling**: Uses requestAnimationFrame instead of setTimeout
   ```javascript
   if (throttleId) return; // Already scheduled
   throttleId = requestAnimationFrame(() => {
     // Processing logic here
     throttleId = null;
   });
   ```

4. **Cleanup Before Adding**: Removes duplicate elements before adding new ones
   ```javascript
   const extraArts = artWrapper.querySelectorAll('.character-art:not(:first-child)');
   extraArts.forEach(el => el.remove());
   ```

5. **Enable/Disable Control**: Global functions to disable during complex operations
   ```javascript
   window.disableArtObserver();  // Before complex DOM operations
   // ... DOM changes ...
   window.enableArtObserver();   // After changes complete
   ```

This pattern prevents performance issues, reduces console spam, and ensures stable rendering even with frequent DOM changes.

## Project Design Guidelines

- The game aims to be a fun, visually appealing autobattler with strategic depth and progression
- Focus on creating engaging battle animations and visual feedback
- Implement randomness in combat to keep battles interesting
- RPG-style progression with character leveling and ability unlocking
- The project is configured for a 1920x1080 resolution through project.config
- Refer to DEVELOPMENT_PLAN.md for the complete roadmap


===== FILE: Game_Explained.md =====
# AutoBattler Game: How It All Works Together

This document explains how the different components of the AutoBattler game interact with each other, written in understandable terms and with references to specific files where helpful.

This document explains how the different components of the AutoBattler game interact with each other, written in understandable terms and with references to specific files where helpful.

## Core Game Architecture

The AutoBattler game uses a **Model-View-Controller (MVC)** pattern:

- **Model**: Data files (JSON) and core entities (Character, Ability classes)
- **View**: UI components (TeamBuilder UI, Battle UI - both DOM and Phaser-based)
- **Controller**: Component-based architecture with specialized managers coordinated by BattleManager

The architecture has evolved into a component-based system with clear separation of responsibilities.

### Startup Flow

1. When the game loads in the browser, `index.html` includes all necessary JavaScript files
2. `game.js` initializes the game when the window loads
3. The TeamBuilder UI is displayed first, where players select characters
4. When a battle starts, either the DOM-based BattleUI or Phaser-based BattleScene is shown

## Data Management

### Data Sources

The game uses JSON files to store game data:

- `data/characters.json`: Contains all character definitions with stats and abilities
- `data/status_effects.json`: Defines status effects like stun, burn, etc.
- `data/type_effectiveness.json`: Defines type relationships (advantages, disadvantages, immunities, and special cases)

**Note**: While there is an `abilities.json` file in the data directory, it is defunct and not used by the game. All ability data is directly embedded within each character's definition in `characters.json`.

These files are loaded once at startup and provide the foundation for all game entities.

### Entity Classes

Two key entity classes transform the raw JSON data into usable game objects:

- `Character.js`: Creates character objects with methods for taking damage, healing, etc. Also parses and stores the character's embedded abilities.
- `Ability.js`: Handles ability usage, cooldowns, and effects using the ability data extracted from characters.json

Example of data flow:
```
JSON character data (including embedded abilities) â†’ Character object â†’ Added to team â†’ Displayed in UI â†’ Used in battle
```

## Manager Classes - The "Brains" of the Game

### TeamManager (`js/managers/TeamManager.js`)

**Purpose**: Handles everything related to character teams.

**Responsibilities**:
- Creating player and enemy teams
- Storing selected characters
- Generating random enemy teams
- Team validation and balancing

**Key Methods**:
- `createTeam()`: Creates a team from selected character IDs
- `generateEnemyTeam()`: Creates a balanced enemy team
- `getTeam()`: Returns the current player or enemy team

### BattleManager (`js/managers/BattleManager.js`)

**Purpose**: Orchestrates battle processes by delegating to specialized components.

**Responsibilities**:
- Coordinating specialized component managers
- Maintaining references to all components
- Managing core battle state (active/paused/speed)
- Providing facade methods for other systems to interact with battle logic

**Key Methods**:
- `startBattle()`: Delegates to BattleInitializer and BattleFlowController
- `initializeComponentManagers()`: Sets up all component managers
- `setSpeed()`: Adjusts battle animation speed
- `togglePause()`, `pauseBattle()`, `resumeBattle()`: Control battle flow
- Multiple facade methods that delegate to specialized components

## Specialized Component Managers

The game has been refactored to use specialized component managers for specific responsibilities:

### BattleFlowController (`js/battle_logic/core/BattleFlowController.js`)

**Purpose**: Controls the sequence and flow of battle.

**Responsibilities**:
- Managing turn progression
- Handling action execution
- Checking battle end conditions
- Coordinating other components during battle flow

**Key Methods**:
- `startBattle()`: Initializes battle state
- `startNextTurn()`: Processes turn start and prepares actions
- `executeNextAction()`: Processes the next queued action
- `finishTurn()`: Handles end-of-turn effects
- `checkBattleEnd()`: Determines if battle is over

### BattleInitializer (`js/battle_logic/core/BattleInitializer.js`)

**Purpose**: Handles team and character initialization for battle.

**Responsibilities**:
- Preparing team data for battle with comprehensive validation
- Generating unique character IDs for proper reference tracking
- Initializing character stats with default values when needed
- Ensuring all required character properties exist
- Identifying and separating passive abilities for quick reference
- Resetting passive tracking at battle start

**Key Methods**:
- `initializeTeamsAndCharacters()`: Sets up both teams at once
- `ensureCompleteCharacterInitialization()`: Performs comprehensive character validation and initialization
- `prepareTeamForBattle()`: Prepares a single team with battle-specific properties
- `generateCharacterId()`: Creates unique IDs for characters

**Implementation Features**:
- Deep cloning of team data to prevent reference issues (via JSON parse/stringify)
- Comprehensive validation of all character properties
- Default value generation for missing properties (HP, stats, names)
- Unique ID generation that incorporates team type, character name, and random values
- Separate tracking for passive abilities to improve performance
- Detailed logging of initialization process for debugging
- Filtering of invalid characters to prevent runtime errors

### StatusEffectManager (`js/battle_logic/status/StatusEffectManager.js`)

**Purpose**: Manages status effect application and processing.

**Responsibilities**:
- Applying status effects to characters
- Processing effects at turn start
- Managing effect stacking and expiration

**Key Methods**:
- `addStatusEffect()`: Applies a status effect
- `processStatusEffects()`: Processes effects at turn start
- `updateStatusIcons()`: Updates UI for status effects

### DamageCalculator (`js/battle_logic/damage/DamageCalculator.js`)

**Purpose**: Calculates and applies damage.

**Responsibilities**:
- Calculating damage amounts
- Applying type effectiveness
- Handling critical hits and variance

**Key Methods**:
- `calculateDamage()`: Determines damage amount
- `applyDamage()`: Applies damage to characters

### HealingProcessor (`js/battle_logic/damage/HealingProcessor.js`)

**Purpose**: Handles healing calculations and application.

**Responsibilities**:
- Calculating healing amounts
- Applying healing to characters
- Processing resurrection logic

**Key Methods**:
- `applyHealing()`: Applies healing to characters
- `checkAndResetDeathStatus()`: Handles resurrection

### AbilityProcessor (`js/battle_logic/abilities/AbilityProcessor.js`)

**Purpose**: Processes ability effects and manages ability state.

**Responsibilities**:
- Executing ability effects
- Managing ability cooldowns
- Applying effects to targets

**Key Methods**:
- `processEffect()`: Processes a single effect
- `applyActionEffect()`: Applies all effects from an action

### PassiveAbilityManager (`js/battle_logic/passives/PassiveAbilityManager.js`)

**Purpose**: Manages passive ability execution.

**Responsibilities**:
- Processing passive abilities when triggers occur
- Executing passive behaviors through behavior system
- Validating characters before passive processing
- Tracking passive trigger stacks and limits
- Coordinating with PassiveTriggerTracker for state management
- Creating properly formatted log messages for passive activations

**Key Methods**:
- `processPassiveAbilities()`: Main entry point that handles passive ability activation
- `validateCharacter()`: Comprehensive validation of character data before processing
- `canTriggerPassive()`: Determines if a passive ability can trigger based on conditions
- `executePassiveBehavior()`: Executes passive effects through behavior system
- `logPassiveActivation()`: Creates properly formatted log messages with team identifiers
- `getPassivesByTriggerType()`: Retrieves all passives matching a specific trigger type

**Implementation Features**:
- Comprehensive character validation with detailed error messages
- Defensive checks for all required component dependencies
- Max stacks tracking for limiting passive triggers
- Team-aware log messages with proper identifiers
- Detailed debug logging throughout the processing pipeline

### BattleEventDispatcher (`js/battle_logic/events/BattleEventDispatcher.js`)

**Purpose**: Centralizes event dispatching across the battle system.

**Responsibilities**:
- Standardizing event formatting and property naming
- Ensuring events reach proper listeners
- Providing specialized event dispatching methods for different event types
- Handling event validation and error recovery
- Supporting custom event listeners beyond BattleBridge

**Key Methods**:
- `dispatchEvent()`: Core method that sends events to listeners
- `dispatchCharacterDamagedEvent()`: Specialized method for damage events with standardized data
- `dispatchCharacterHealedEvent()`: Specialized method for healing events
- `dispatchPassiveTriggeredEvent()`: Specialized method for passive ability triggers
- `dispatchBattleEndedEvent()`: Handles battle conclusion events
- `dispatchStatusEffectAppliedEvent()`: Handles status effect application
- `addEventHandler()`: Registers custom event listeners
- `removeEventHandler()`: Unregisters custom event listeners
- `notifyListeners()`: Notifies all registered listeners for an event type

**Implementation Features**:
- Comprehensive parameter validation for all event types
- Fallback event types when BattleBridge is unavailable
- Try-catch blocks to prevent event dispatch failures
- Standardized property naming patterns with backward compatibility
- Custom event listener system operating alongside BattleBridge

### BattleLogManager (`js/battle_logic/events/BattleLogManager.js`)

**Purpose**: Formats and manages battle log messages.

**Responsibilities**:
- Creating formatted battle log messages
- Generating battle summaries

**Key Methods**:
- `logMessage()`: Formats and dispatches messages
- `displayTurnSummary()`: Creates turn summary

### Bridge Between Logic and Visuals

BattleManager doesn't directly update the UI. Instead, a sophisticated event-based communication system is used:

1. BattleManager delegates to specialized components (e.g., DamageCalculator processes damage)
2. Components use BattleEventDispatcher to dispatch standardized events (e.g., "CHARACTER_DAMAGED")
3. BattleEventDispatcher validates event data and ensures proper formatting
4. Events flow through BattleBridge to the active UI system
5. UI components listen for these events and update visuals accordingly

The event flow works like this:
```
Specialized Component â†’ BattleEventDispatcher â†’ BattleBridge â†’ UI Components
```

This separation allows the same battle logic to work with either the DOM-based UI or the Phaser-based UI, while maintaining a clean boundary between game logic and visual presentation. The BattleEventDispatcher adds an extra layer of validation and standardization to ensure all events have consistent structures regardless of their source.

## UI Systems

The game has two UI systems: a traditional DOM-based UI and a newer Phaser-based UI.

### DOM-based UI

#### TeamBuilder UI (`js/ui/TeamBuilderUI.js`)

**Purpose**: Allows players to select their team before battle.

**Features**:
- Character grid with filterable heroes
- Team slots for selected characters
- Character detail panel with stats and abilities
- Battle mode selection (Quick, Custom, Campaign)

#### DOM Battle UI (`js/ui/BattleUI.js`)

**Purpose**: The original battle visualization system (being replaced by Phaser).

**Features**:
- Character circles with health bars
- Status effect icons
- Battle log with combat information
- Attack animations
- Battle controls (speed, pause)

### Phaser-based UI

#### Battle Scene (`js/phaser/scenes/BattleScene.js`)

**Purpose**: The new battle visualization system using the Phaser game engine.

**Features**:
- Enhanced graphics with proper game objects
- Optimized character sprites from Combat_Version folder
- Smoother animations and visual effects
- Modular component system for UI elements

#### Component Architecture

The Phaser implementation uses a component-based approach:

- `TeamContainer.js`: Manages a team of characters
- `CharacterSprite.js`: Handles individual character rendering with sophisticated visual effects
- `BattleControlPanel.js`: UI controls for the battle
- `DirectBattleLog.js`: Displays battle messages
- `ActionIndicator.js`: Shows action text above characters
- `StatusEffectContainer.js`: Displays status effect icons

##### CharacterSprite Visual System

The `CharacterSprite` component provides rich visual feedback during battle:

- **Health Visualization**: 
  - Animated health bars that smoothly transition between values
  - Color coding based on health percentage (green > orange > red)
  - Dynamic health text with damage shake and healing bounce animations
  - Glow effects for healing and flash effects for damage

- **Action Feedback**:
  - Character movement animations during attacks with directional awareness
  - Floating damage/healing numbers with size based on amount
  - Special visual effects for critical hits and status applications
  - Action indicators that show what ability is being used

- **Status Visualization**:
  - Status effect icons displayed near characters
  - Visual feedback when status effects are applied/removed
  - Tooltips showing effect details

- **Turn Highlighting**:
  - Active character highlighting with pulsing glow effects
  - Team-colored indicators to show whose turn it is
  - Shadow effects for depth perception

The component uses comprehensive error handling throughout all visual operations, with try-catch blocks to ensure visual effects don't crash the game even if issues occur.

## Battle Bridge: Connecting Core Logic to Phaser

The `BattleBridge` system (`js/phaser/bridge/BattleBridge.js`) acts as a communication layer between the core game logic and the Phaser visualization.

**How it works**:
1. BattleManager executes logic and dispatches events
2. BattleBridge listens for these events
3. BattleBridge forwards events to Phaser components
4. Phaser components update visuals in response

This bridge pattern allows the core battle logic to remain unchanged while supporting different visualization approaches.

## Game Flow: From Start to Finish

1. **Game Initialization**
   - Load data files
   - Initialize TeamBuilderUI
   - Set up event listeners

2. **Team Selection**
   - Player selects characters in TeamBuilderUI
   - TeamManager creates Character objects from selections
   - Player chooses battle mode

3. **Battle Initiation**
   - Player clicks "Start Battle"
   - TeamManager finalizes teams
   - BattleInitializer performs comprehensive character preparation:
     - Deep cloning team data to ensure independence
     - Generating unique IDs for all characters
     - Validating and supplying default values for missing properties
     - Setting initial health values to maximum
     - Initializing ability cooldowns
     - Identifying and separating passive abilities
     - Filtering out invalid characters
   - Either DOM BattleUI or Phaser BattleScene initializes
   - BattleManager prepares the battle state
   - PassiveTriggerTracker resets for the new battle
   - "onBattleStart" passive abilities are processed

4. **Battle Execution**
   - BattleFlowController determines turn order based on Speed stat
   - For each turn:
     - PassiveTriggerTracker resets for the new turn
     - StatusEffectManager processes status effects for all characters
     - ActionGenerator creates an action for the active character
     - TargetingSystem determines appropriate targets
     - AbilityProcessor executes the action's effects
     - DamageCalculator and HealingProcessor handle damage and healing
     - PassiveAbilityManager triggers relevant passive abilities
     - BattleEventDispatcher sends events to update the UI
   - BattleFlowController checks for battle end conditions

5. **Battle Conclusion**
   - BattleManager determines the outcome (victory/defeat)
   - Result screen is displayed
   - Player returns to TeamBuilder UI

## Combat Mechanics

### Turn Order System

**How it works**: 
- Characters are sorted by their Speed stat
- Higher Speed characters act first
- A complete round occurs when all characters have taken a turn
- The process repeats until the battle ends

### Damage Calculation

Damage is calculated by the DamageCalculator component using:
- Base ability damage (from the ability's "value" property)
- Attacker's relevant stat (Strength for physical, Intellect for spell)
  - Specified by the ability's "damageType" property ("physical", "spell", etc.)
  - With scaling factor of 0.5 (50% of the scaling stat)
- Target's defense (reduces damage based on defense value)
- Type effectiveness (calculated by TypeEffectivenessCalculator)
- Random variance (Â±20%)
- Critical hits (10% chance for +50% damage)

Formula:
```
Final Damage = (Base Damage + (Scaling Stat * 0.5)) * Type Multiplier * (1 - Defense Factor) * Variance * Critical Multiplier
```

The DamageCalculator provides detailed information about each factor to the battle log, such as "12 damage + 45 from Intellect"

### Health Management System

The game includes a comprehensive health management system:

**Backend Implementation**:
- Characters store current health in `currentHp` property
- Health changes are processed through DamageCalculator and HealingProcessor
- Health values are validated to prevent negative or NaN values
- Character death status (`isDead`) is automatically updated when health reaches 0
- Health-related events are dispatched through BattleEventDispatcher with detailed data

**Visual Representation**:
- Health bars visually display current health percentage
- Color coding provides immediate health status feedback:
  - Green (>60% health)
  - Orange (30-60% health)
  - Red (<30% health)
- Animated transitions for health changes:
  - Health bars smoothly animate between values
  - Healing shows a green glow effect on the character
  - Damage shows a red flash effect
  - Text shakes when taking damage
  - Text bounces when being healed
- Floating numbers show damage/healing amounts
  - Red numbers for damage
  - Green numbers for healing
  - Larger font for significant amounts

This dual system ensures consistent health tracking internally while providing rich visual feedback to the player.

### Type Effectiveness System

The game implements a data-driven type system with 22 different types managed by the TypeEffectivenessCalculator:

**Implementation**:
- Type relationships are loaded directly from `data/type_effectiveness.json`
- The file contains four key relationship categories:
  - `advantages`: Types that deal +50% damage to other types
  - `disadvantages`: Types that deal -50% damage to other types
  - `immunities`: Types that completely negate damage from certain types (0x damage)
  - `specialCases`: Custom multipliers for unique interactions (e.g., Light deals 3x damage to Ethereal)
- Enhanced battle log provides descriptive messages with color coding:
  - Advantages: "Fire is super effective against Nature!" (success color)
  - Disadvantages: "Fire is not very effective against Water." (info color)
  - Immunities: "Metal is immune to Poison!" (warning color)
  - Special cases: "Light deals massive damage to Ethereal!" (critical color)
- Fallback system provides basic type relationships if JSON fails to load
- Helper methods generate descriptive text for UI tooltips and ability descriptions

**Example Relationships**:
- Fire is strong against Nature, Ice, and Metal but weak against Water and Rock
- Water is strong against Fire, Rock, and Metal but weak against Nature and Electric
- Light and Dark are opposing forces (strong against each other)
- Ethereal is immune to physical auto-attacks but takes 3x damage from Light
- Metal is immune to Poison
- Void excels against Light and Psychic types

### Ability and Effect System

Each character has several abilities defined directly in their character data. Abilities are structured as follows:

**Ability Types**:
- **Active**: Skills that must be manually triggered and have cooldowns
- **Passive**: Automatic abilities that trigger under specific conditions

**Active Ability Properties**:
- `id`: Unique identifier (e.g., "drakarion_flame_strike")
- `name`: Display name
- `damage`: Base damage/healing amount
- `cooldown`: Turns between uses
- `damageType`: What stat it scales with ("physical", "spell", "healing", "utility")
- `targetType`: Who it can target ("SingleEnemy", "AllEnemies", "Self", etc.)
- `selectionWeight`: AI weighting for ability selection
- `effects`: Array of specific effects the ability applies

**Effect Types**:
- `Damage`: Direct damage to targets
- `Healing`: Direct healing to targets
- `ApplyStatus`: Applies status effects like burn, stun, etc.

**Passive Ability Properties**:
- `passiveTrigger`: When it activates ("onBattleStart", "onTurnStart", "onDamageTaken", etc.)
- `passiveBehavior`: Which function handles the effect (e.g., "passive_DamageReflectOnHit")
- `passiveData`: Configuration data for the passive

### Status Effects

Status effects apply temporary conditions to characters:
- Damage over time (burn, poison, bleed)
- Disables (stun, freeze)
- Stat modifications (attack up/down, defense up/down, speed up/down)
- Special conditions (taunt, evade, shield, immune)

Effects are processed at the start of each turn and expire after their set duration.

## Audio System

**[PLANNED BUT NOT FULLY IMPLEMENTED]**

While there are audio files in the `assets/audio/` directory and a `SoundManager.js`, the audio system is not fully implemented. The current structure includes:

- `js/ui/SoundManager.js`: Basic audio management
- `js/phaser/audio/PhaserSoundManager.js`: Phaser-specific sound implementation

The planned system will include:
- Battle sound effects (attacks, abilities, etc.)
- UI sounds (button clicks, character selection)
- Background music
- Volume controls

## Character Art System

The character art system manages the display of character images in the UI.

**Components**:
- `TeamBuilderImageLoader.js`: Loads character art for TeamBuilder
- `DirectImageLoader.js`: Loads character art for DOM Battle UI
- Combat_Version folder: Contains optimized 80x120px sprites for Phaser Battle Scene

**Key Features**:
- Global image caching to prevent repeated loading
- Position customization through character data
- Multi-resolution support (high-res for TeamBuilder, optimized for Battle)
- MutationObserver pattern for efficient DOM updates

## Debug and Development Tools

The game includes several debugging tools to aid in development:

- `CoordinateDisplay.js`: Grid overlay with coordinate tracking (toggle with Ctrl+G)
- `ObjectIdentifier.js`: Inspect game objects
- `DebugManager.js`: Central control for debug tools
- `BattleUIDebug.js`: Special debug features for Battle UI
- `ImageDebugger.js`: Tools for debugging image loading issues

## Planned Systems (Not Yet Implemented)

### 1. Character Progression System
- Characters will gain XP and level up
- New abilities unlock at specific levels
- Stats increase based on role-specific growth rates

### 2. Campaign Mode
- Series of battles with increasing difficulty
- Branching paths for player choice
- Character shard collection to unlock new heroes
- Persistent progression across multiple play sessions

### 3. Equipment System
- Items to boost character stats
- Different equipment types (weapons, armor, accessories)
- Rarity system affecting item power
- Equipment management UI

### 4. Expanded Arena System
- Multiple battle environments with unique visuals
- Weather effects affecting battles
- Arena-specific bonuses for certain character types
- Environmental hazards

## Technical Implementation Details

### Event System

The game uses a centralized event system based on the BattleEventDispatcher component:

1. Components call the BattleEventDispatcher to dispatch events
2. BattleEventDispatcher validates parameters and standardizes event data
3. Event data is distributed through two channels:
   - Custom event handlers registered directly with BattleEventDispatcher
   - BattleBridge for UI component communication
4. UI components update in response to events

**Key Features**:
- Standardized event formatting
- Comprehensive parameter validation for all events
- Specialized dispatching methods for different event types
- Custom event handlers with error isolation
- Proper source tracking via Source ID Linking pattern
- Defensive event validation and error handling
- Fallback systems when BattleBridge is unavailable

**Event Dispatcher Safety**:
- All events are wrapped in try-catch blocks to prevent cascade failures
- Missing parameters receive appropriate default values
- Invalid event types are logged but don't crash the system
- Event data is validated before dispatch
- Multiple property naming patterns for backward compatibility

Example events:
- "CHARACTER_DAMAGED": When a character takes damage
- "CHARACTER_HEALED": When a character is healed
- "CHARACTER_ACTION": When a character performs an action
- "STATUS_EFFECT_APPLIED": When a status effect is applied
- "STATUS_EFFECT_REMOVED": When a status effect expires
- "BATTLE_ENDED": When a battle concludes
- "PASSIVE_TRIGGERED": When a passive ability activates

### Save System

**[PLANNED BUT NOT IMPLEMENTED]**

The game plans to include a save system with:
- Three save slots
- Local storage for progress
- Character unlocks and progression
- Team configurations

### Character ID Management System

The game implements a unique ID system for tracking characters through references:

**Purpose**:
- Preventing circular references when storing character relationships
- Enabling proper attribution of effects in battle log
- Supporting status effect source tracking

**Implementation**:
- BattleInitializer assigns unique IDs to characters via `generateCharacterId()`
- Status effects store source character's `uniqueId` instead of direct references
- When effects trigger, BattleUtilities resolves IDs back to character objects
- This pattern is called "Source ID Linking" and is used throughout the codebase

**Benefits**:
- Avoids memory issues from circular references
- Allows effects to reference their source even after several turns
- Provides proper attribution in battle log for damage-over-time effects

### Performance Optimizations

Several optimizations improve game performance:

- Image caching to prevent repeated loading
- Targeted DOM observation with MutationObserver
- Request animation frame throttling
- Pre-optimized battle sprites
- Defensive loading patterns to prevent errors

## Data-Driven Systems

The game uses data-driven architecture to separate game mechanics from their implementation:

**JSON Configuration Files**:
- `characters.json`: Character definitions with stats, abilities, and visuals
- `status_effects.json`: Status effect definitions with durations and behaviors 
- `type_effectiveness.json`: Complete type interaction matrix for 22 types

**Benefits of Data-Driven Approach**:
- Content updates without code changes
- Clear separation between data and logic
- Easier balancing and testing
- Simplified modding potential

**Implementation Pattern**:
1. Components load JSON data at initialization
2. Data is transformed into internal structures
3. Robust fallback systems ensure functionality if data loading fails
4. Validation ensures data consistency and prevents errors

**Key Data-Driven Components**:
- TypeEffectivenessCalculator: Loads and processes type relationships
- StatusEffectDefinitionLoader: Manages status effect definitions
- BattleBehaviors: Uses data-defined behaviors for character actions
- Character loading: Transforms JSON definitions into game objects

This approach allows designers to adjust game balance and mechanics through data files while maintaining stability through validation and fallback systems.

## File Structure Organization

The codebase is organized into logical directories:

- `assets/`: Game assets (images, audio)
- `data/`: JSON data files (characters, status effects, type effectiveness)
- `js/`: All JavaScript code
  - `battle_logic/`: Core battle mechanics
    - `core/`: Core battle system components (BattleFlowController, BattleInitializer)
    - `status/`: Status effect components
    - `damage/`: Damage and healing components
    - `abilities/`: Ability processing components
    - `passives/`: Passive ability components
    - `events/`: Event management components
    - `utilities/`: Battle-specific utility functions
  - `entities/`: Character and ability classes
  - `managers/`: High-level manager classes (BattleManager, TeamManager)
  - `phaser/`: Phaser implementation
    - `bridge/`: Communication between game logic and Phaser
    - `components/`: Reusable UI components
    - `scenes/`: Phaser scene definitions
  - `ui/`: DOM-based UI components
  - `utilities/`: General helper functions

## Action Generation System

The ActionGenerator component creates actions for characters during battle through a sophisticated multi-stage process:

**Action Generation Pipeline**:
1. **Character Validation**: Comprehensive validation of character data (stats, abilities, health)
2. **Status Check**: Verification that character isn't stunned or otherwise prevented from acting
3. **Ability Selection**: Uses behavior system to choose which ability to use
4. **Target Selection**: Determines appropriate targets through TargetingSystem
5. **Damage Calculation**: Computes expected damage using DamageCalculator
6. **Action Creation**: Assembles a complete action object with all required data

**Ability Selection Process**:
- Characters can have custom decision logic via `actionDecisionLogic` property
- The behavior system evaluates available abilities based on context
- Factors considered include: ability cooldowns, target health, strategic value
- Fallback to weighted random selection if behavior system unavailable
- Selected abilities have cooldowns applied after use

**Special Features**:
- **Multi-Target Handling**: Special processing for abilities that affect multiple targets
- **Target Validation**: Ensures all targets are valid before creating the action
- **Defensive Programming**: Extensive error checking with graceful fallbacks
- **Detailed Logging**: Comprehensive debug information for troubleshooting

## BattleBehaviors System

The game uses a behavior system to determine character actions and abilities:

**Purpose**: Provides flexible, customizable decision-making for characters

**Key Components**:
- `BattleBehaviors.js`: Core behavior execution engine
- `BehaviorRegistry.js`: Centralized registration of available behaviors 
- `ActionDecisionBehaviors.js`: Behaviors for choosing actions/abilities
- `TargetingBehaviors.js`: Behaviors for selecting targets
- `PassiveBehaviors.js`: Behaviors for passive ability effects

**How It Works**:
1. Characters reference behavior IDs in their data
2. When needed, components request the behavior by ID
3. BehaviorRegistry returns the appropriate function
4. The function receives a context object with all needed data
5. The behavior executes and returns a result

**Benefits**:
- Characters can have unique decision-making logic
- New behaviors can be added without changing core systems
- Complex behaviors can be composed from simpler ones
- Easier to test and debug behavior in isolation

This behavior-based approach creates more interesting and varied gameplay while maintaining a clear separation between character data and implementation logic.

## Defensive Programming Patterns

The game implements several defensive programming patterns that ensure stability and error recovery:

1. **Parameter Validation**:
   - All public methods validate parameters before processing
   - Invalid parameters receive appropriate default values when possible
   - Missing dependencies trigger clear warning messages

2. **Error Isolation**:
   - Try-catch blocks surround critical operations
   - Errors in one component don't cascade to others
   - Visual elements have error recovery for rendering issues

3. **Graceful Degradation**:
   - Missing dependencies trigger fallback behaviors
   - Default values are supplied for missing data
   - Event dispatching continues even when some listeners fail

4. **Comprehensive Logging**:
   - Detailed context is provided in error messages
   - Component names are included in log prefixes (e.g., "[BattleInitializer]")
   - Warning/error levels are used appropriately

5. **Null Object Pattern**:
   - Empty arrays/objects are returned instead of null
   - Default visual representations appear when images fail to load
   - Event handlers safely handle missing data

These patterns combine to create a robust system that can recover from many types of errors without crashing or displaying incorrect information to the player.

## Conclusion

The AutoBattler game has evolved into a highly modular, component-based architecture with clear separation of responsibilities:

1. **Component-Based Design**: Each game function is handled by specialized components
2. **Orchestration Pattern**: BattleManager delegates to components rather than implementing logic directly
3. **Data-Driven Systems**: JSON-based configuration for types, status effects, and characters
4. **Defensive Programming**: Robust validation, error handling, and fallbacks throughout
5. **Event-Based Communication**: Centralized event system for loose coupling

This architectural approach provides several key benefits:
- **Maintainability**: Each component has a clear, focused responsibility
- **Testability**: Components can be tested in isolation
- **Extensibility**: New features can be added with minimal changes to existing code
- **UI Flexibility**: Same battle logic works with both DOM and Phaser UIs

As the game continues to develop, the planned systems (character progression, equipment, etc.) will integrate seamlessly with the existing architecture, leveraging the component-based design for a more robust and feature-rich experience.


===== FILE: Version 1.0 Vision.md =====
# VersionÂ 1.0 â€“Â First to Fall

---
## Game Loop: First to Fall

1. **SaveÂ Slot Selection**  
   When first launching the game, players choose one of three save slots (SlotÂ 1,Â 2,Â 3).  
   Each slot holds an independent profileâ€”including unlocked heroes, progression, inventory, and talent data.

2. **Team Builder Phase**  
   **Screen:** TeamBuilderUI (`#team-builder-container`) -No Phaser Integration- DOM based UI for Teambuilder

   - **Available Characters:** 8 initial heroes displayed with art, Type, Role, stats & abilities.  
   - **Filters:** Sort by Role or Type.  
   - **Selection:** Click a hero to animate them into one of 6 shaded team slots.  
   - **Modes:**  
     - **Quick Battle:** Instantly face a random AI team.  
     - **Custom Battle:** Player picks both ally and enemy teams.  
     - **Progression Mode (Campaign):** Series of battles, leveling, and hero unlocks on a **branching, nonâ€‘linear** mapâ€”players choose routes each act for meaningful agency.

3. **Team Setup**  
   - Selected heroes animate into midâ€‘screen slots (3 active slots).  
   - Slots display: Hero name, HP, Type/Role, basic stats & a remove button.  
   - Enemy team slots fill during Custom Battle or autoâ€‘populate in Quick Battle.

4. **Battle Initiation**  
   **Screen:** BattleÂ UI (`#game-container` + Phaser canvas)

   **Visuals & Animations:**  
   - Animated HP bars, statusâ€‘effect icons (burn, stun, regen), floating text for damage/healing/passive triggers.  
   - Autoâ€‘attack â€œbonk & returnâ€ animations; full ability spells with particles (inspired by Hearthstone).  

   **Mechanics:**  
   - Turnâ€‘based autoâ€‘battler via **BattleManager**.  
   - Speed stat â†’ turn order.  
   - Process status effects at turn start.  
   - **Type advantages** apply +/â€“ damage multipliers (see Type Effectiveness Table).  
   - Each hero has 1 Passive (unlocked at lvlÂ 12 in campaign) and 3 Actives (unlock at lvlÂ 1,Â 5,Â 18 in campaign; all available in Quick/Custom).

   **UI Features**  
   - Phaser UI overlays integrated with the Phaser canvas: speed toggle, pause, next-turn & return implemented as Phaser Buttons, styled via Tailwind and positioned by scene layout.  
   - Scrolling battle log rendered in a Phaser UI container, displaying passive triggers, critical hits, misses, and type-effect annotations, with tooltip support.  
   - Themed arena backgrounds loaded as Phaser Sprites or Tilemaps (e.g. â€œGrassy Fieldâ€), with optional parallax or shader effects for added atmosphere.  

5. **Battle Outcome**  
   - Show Victory/Defeat overlay.  
   - Grant XP & Shards in Campaign Mode.  
   - Return to Team Builder or advance along the Campaign map.

6. **Progression Mode (Campaign)**  
   *(Structure draft)*  
   - Heroes begin at LevelÂ 1; max LevelÂ 20.  
   - **Ability Unlock Timeline:**  
     - LvlÂ 1Â â†’ first Active ability  
     - LvlÂ 5Â â†’ second Active ability  
     - LvlÂ 12Â â†’ Passive unlocked  
     - LvlÂ 18Â â†’ Ultimate ability unlocked  
   - Leveling raises stats per Role growth profile.  
   - **Branching Routes:** Players choose varied node paths each act, ensuring nonâ€‘linearity & replay variety.  
   - **Hero Shard System**:  
     - Defeating elites/bosses drops shards of that hero.  
     - Collect 10 shards â†’ permanently unlock the hero.  
     - Duplicate shards convert to **AscensionÂ XP**, raising the heroâ€™s max Level cap for extra power.

   **Optional Systems:**  
   - **Inventory/Loot System**: Relics, gear & consumables drop from nodes; equip to boost stats or unlock effects.  
   - **Talent Tree System (per hero)**: Spend talent points at levelâ€‘up to specialize abilities, passives or stat nodes.

7. **Character Design System**  
   - **22 Roles** and **22 Types** deliver massive variety, teamâ€‘synergies & playstyles.  
   - Each hero is unique in look, lore & mechanicsâ€”fueling the â€œgotta unlock â€™em allâ€ drive.

   ### Role and Archetype Chart
   | #  | Role                                    | Archetype                         |
   |----|-----------------------------------------|-----------------------------------|
   | 1  | **Warrior**                             | Pure melee DPSâ€‘tank               |
   | 2  | **Sentinel** *(formerly Knight)*        | Shielded striker                  |
   | 3  | **Berserker**                           | Allâ€‘in bruiser                    |
   | 4  | **Ranger**                              | Ranged glass cannon               |
   | 5  | **Assassin**                            | Burst finisher                    |
   | 6  | **Bulwark** *(formerly Guardian)*       | Pure tank                         |
   | 7  | **Mage**                                | Pure spell DPS                    |
   | 8  | **Invoker**                             | Supportive Caster / Spell Booster |
   | 9  | **Sorcerer**                            | Highâ€‘risk nuker                   |
   | 10 | **Summoner**                            | Petâ€‘centric caster                |
   | 11 | **Occultist** *(formerly Necromancer)*  | MinionÂ + DoT controller           |
   | 12 | **Mystic** *(formerly Cleric)*          | Pure healer                       |
   | 13 | **Champion** *(formerly Paladin)*       | Hybrid tankâ€‘healer                |
   | 14 | **Wildcaller** *(formerly Druid)*       | Nature hybrid                     |
   | 15 | **Striker** *(formerly Monk)*           | Agile skirmisher                  |
   | 16 | **Emissary** *(formerly Bard)*          | Buffer / debuffer                 |
   | 17 | **Elementalist** *(formerly Shaman)*    | Elemental support                 |
   | 18 | **Warden**                              | Counterâ€‘Tank / Disruptor           |
   | 19 | **Skirmisher**                          | Hitâ€‘andâ€‘run ranged DPS            |
   | 20 | **Battlemage**                          | Hybrid meleeâ€‘caster brawler       |
   | 21 | **Venomancer**                          | Damageâ€‘overâ€‘time Specialist       |
   | 22 | **Trickster**                           | Chaos Controller / RNG Manipulator |

   ### Type Description Table
   | Type          | Description                                       |
   |:--------------|:--------------------------------------------------|
   | **Fire**      | Heat, flame, destructive energy.                  |
   | **Water**     | Fluidity, healing, relentless force.               |
   | **Nature**    | Plants, earth life, natural growth.               |
   | **Electric**  | Energy, speed, sudden shocks.                     |
   | **Ice**       | Cold, stillness, slowing effects.                 |
   | **Rock**      | Durability, raw earth toughness.                  |
   | **Air**       | Wind, agility, freedom.                           |
   | **Light**     | Purity, illumination, righteousness.              |
   | **Dark**      | Shadows, corruption, forbidden power.             |
   | **Metal**     | Armor, resilience, forged strength.               |
   | **Psychic**   | Mind, willpower, telekinetic forces.              |
   | **Poison**    | Toxicity, decay, subversion.                      |
   | **Physical**  | Brute force, martial prowess.                     |
   | **Arcane**    | Ancient magic, mystical forces.                   |
   | **Mechanical**| Constructs, machines, automation.                 |
   | **Void**      | Entropy, corruption of reality, nothingness.      |
   | **Crystal**   | Hardness, magical resonance, energy storage.      |
   | **Storm**     | Tempests, violent weather, unleashed energy.      |
   | **Ethereal**  | Ghosts, phasing, intangible existence.            |
   | **Blood**     | Sacrificial magic, vitality, lifeâ€‘force mastery.  |
   | **Plague**    | Diseases, rot, uncontrollable spread of corruption.|
   | **Gravity**   | Force manipulation, crushing weight distortion.   |

8. **Replayability & Engagement**  
   - Build & refine teams with unlocked heroes  
   - Experiment with Roles/Types for synergies  
   - Chase Hero Shards & Ascension for power growth  
   - Optional Loot + Talent systems deepen customization  
   - Quick/Custom modes offer theorycraft playground  

---
*End of VersionÂ 1.0 Document*


