

===== FILE: BattleUI.js =====
/**
 * Battle UI
 * Manages the user interface during battle
 * Implements a Tailwind CSS-based design
 */

class BattleUI {
    /**
     * Verify that background images are available
     * @param {Array} backgroundKeys - Keys for backgrounds to check
     */
    verifyBackgroundImages(backgroundKeys) {
        console.log('Verifying background images availability...');
        
        backgroundKeys.forEach(key => {
            if (key === 'default') {
                console.log('Default grid pattern background is always available');
                return;
            }
            
            const imageUrl = key === 'grassyfield' ? 
                'assets/images/Arena Art/Grassy Field.png' : 
                `assets/images/Arena Art/${key}.jpg`;
            
            // Create a test image to check if it loads
            const img = new Image();
            img.onload = () => {
                console.log(`âœ… Background image verified: ${imageUrl}`);
            };
            img.onerror = () => {
                console.error(`âŒ Background image not found: ${imageUrl}`);
                // Try an alternative path without leading slash
                const altUrl = key === 'grassyfield' ? 
                    'assets/images/Arena Art/Grassy Field.png' : 
                    `assets/images/Arena Art/${key}.jpg`;
                
                console.log(`Trying alternative path: ${altUrl}`);
                
                const altImg = new Image();
                altImg.onload = () => {
                    console.log(`âœ… Alternative path works: ${altUrl}`);
                    // Update the CSS with the working path
                    this.updateBackgroundImagePath(key, altUrl);
                };
                altImg.onerror = () => {
                    console.error(`âŒ Alternative path also failed: ${altUrl}`);
                    console.log('Checking if directory exists...');
                };
                altImg.src = altUrl;
            };
            img.src = imageUrl;
        });
    }
    
    /**
     * Update background image path in CSS
     * @param {string} key - Background key
     * @param {string} url - Working URL
     */
    updateBackgroundImagePath(key, url) {
        // Find the style element
        const styleEl = document.getElementById('battle-ui-styles');
        if (!styleEl) return;
        
        // Get the current styles
        let css = styleEl.textContent;
        
        // Replace the URL in the CSS
        const regex = new RegExp(`\.arena-${key}\s*{[^}]*background-image:\s*url\(['"]?([^'"\)]+)['"]?\)`, 'g');
        const newCss = css.replace(regex, (match, oldUrl) => {
            return match.replace(oldUrl, url);
        });
        
        // Update the style element
        styleEl.textContent = newCss;
        
        console.log(`Updated CSS with working path for ${key}`);
    }
    /**
     * Create a new Battle UI
     * @param {Phaser.Scene} scene - The Phaser scene for the battle
     * @param {BattleManager} battleManager - Reference to the battle manager
     */
    constructor(scene, battleManager) {
        this.scene = scene;
        this.battleManager = battleManager;
        this.elements = {};
        this.isSetup = false;
        this.playerTeam = [];
        this.enemyTeam = [];
        this.currentTurn = 0;
        this.logMessages = [];
        this.activeCharacter = null;
        this.floatingTexts = [];
        this.typeColors = {
            fire: '#ff4757',
            water: '#1e90ff',
            nature: '#2ed573',
            dark: '#9900cc',
            light: '#ffd700',
            air: '#70a1ff'
        };
        this.arenaBackground = 'grassyfield'; // Use Grassy Field as default background
    }

    /**
     * Initialize the battle UI
     */
    initialize() {
        // Check if already initialized
        if (this.isSetup) {
            console.log('BattleUI: Already initialized, skipping');
            // Even if already initialized, make sure tooltips are cleaned up
            this.cleanupTooltips();
            return;
        }
        
        // Check if battle UI already exists in DOM and remove it if it does
        const existingUI = document.getElementById('battle-ui');
        if (existingUI) {
            console.log('BattleUI: Found existing UI, removing it');
            // Clean up tooltips before removing the UI
            this.cleanupTooltips();
            existingUI.remove();
        }
        
        console.log('BattleUI: Initializing...');
        
        // Clear anything in the game container
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.innerHTML = '';
        } else {
            console.error('Game container not found! Make sure game-container element exists.');
        }
        
        // Add Tailwind CSS if not already present
        this.ensureTailwindCSSIsLoaded();
        
        // Add custom CSS
        this.addCustomStyles();
        
        // Initialize tooltip manager
        this.initializeTooltipManager();
        
        // Create the UI container
        const battleUI = document.createElement('div');
        battleUI.id = 'battle-ui';
        battleUI.className = 'min-h-screen flex flex-col p-4 font-inter';
        battleUI.style.backgroundColor = '#141e2e';
        battleUI.style.color = '#e0e0e0';
        battleUI.style.fontFamily = "'Inter', sans-serif";
        
        // Create header with controls
        const header = this.createHeader();
        battleUI.appendChild(header);
        
        // Create main battle area
        const main = document.createElement('main');
        main.className = 'flex-grow flex gap-4 md:gap-8 items-start justify-center pt-8 relative';
        main.id = 'battle-arena';
        
        // Add arena background
        this.setArenaBackground(main, this.arenaBackground);
        
        // Create player team section
        const playerSection = this.createTeamSection('Your Team', 'text-blue-300');
        
        // Create VS divider
        const vsDiv = document.createElement('div');
        vsDiv.className = 'flex items-center justify-center flex-grow-0 pt-24';
        const vsSpan = document.createElement('span');
        vsSpan.className = 'text-4xl font-bold text-gray-500';
        vsSpan.textContent = 'VS';
        vsDiv.appendChild(vsSpan);
        
        // Create enemy team section
        const enemySection = this.createTeamSection('Enemy Team', 'text-red-300');
        
        // Add team sections to main
        main.appendChild(playerSection);
        main.appendChild(vsDiv);
        main.appendChild(enemySection);
        
        battleUI.appendChild(main);
        
        // Create battle log and add it to the main battle area
        const battleLog = this.createBattleLog();
        main.appendChild(battleLog);
        
        // Add to DOM
        document.body.appendChild(battleUI);
        
        // Store references to key elements
        this.elements = {
            playerTeamContainer: playerSection,
            enemyTeamContainer: enemySection,
            turnDisplay: document.getElementById('turn-display'),
            logContent: document.getElementById('battle-log-content'),
            speedButtons: {
                '1x': document.getElementById('speed-1x'),
                '2x': document.getElementById('speed-2x'),
                '4x': document.getElementById('speed-4x')
            },
            pauseButton: document.getElementById('pause-button'),
            nextTurnButton: document.getElementById('next-turn-button'),
            battleArena: main
        };
        
        this.isSetup = true;
        console.log('BattleUI: Initialized');
        
        // Check available backgrounds
        this.verifyBackgroundImages(['default', 'grassyfield']);
        
        // Check if Tailwind is working correctly and apply fallback styles if needed
        setTimeout(() => {
            if (BattleUIDebug) {
                const snapshot = BattleUIDebug.createSnapshot(this);
                if (!snapshot.tailwindStatus.tailwindWorking) {
                    console.log('BattleUI: Tailwind not working, applying fallback styles');
                    BattleUIDebug.injectFallbackStyles();
                    BattleUIDebug.fixCommonIssues(this);
                }
            }
        }, 500);
    }
    
    /**
     * Ensure Tailwind CSS is loaded
     */
    ensureTailwindCSSIsLoaded() {
        if (!document.getElementById('tailwind-css')) {
            console.log('BattleUI: Adding Tailwind CSS script tag');
            const tailwindScript = document.createElement('script');
            tailwindScript.id = 'tailwind-css';
            tailwindScript.src = 'https://cdn.tailwindcss.com';
            document.head.appendChild(tailwindScript);
            
            // Also add Inter font
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap';
            document.head.appendChild(fontLink);
        }
    }
    
    /**
     * Add custom styles for the battle UI
     */
    addCustomStyles() {
        if (!document.getElementById('battle-ui-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'battle-ui-styles';
            styleEl.textContent = `
                .panel-bg {
                    background-color: #232a40; /* Darker panel color */
                }
                /* Type colors for backgrounds */
                .bg-fire { background-color: #ff4757; }
                .bg-water { background-color: #1e90ff; }
                .bg-nature { background-color: #2ed573; }
                .bg-dark { background-color: #9900cc; }
                .bg-light { background-color: #ffd700; }
                .bg-air { background-color: #70a1ff; }
                
                /* Character Art Styles */
                .character-art-container {
                    background-color: transparent !important;
                    border: none !important;
                    overflow: visible;
                    width: 64px !important;
                    height: 64px !important;
                }
                
                .character-art-wrapper {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 5;
                    pointer-events: none;
                }
                
                .character-art {
                    width: 80px;
                    height: 120px;
                    object-fit: contain;
                    position: absolute;
                    top: -52px;
                    left: -2px; /* Moved more to the right */
                    pointer-events: none;
                    z-index: 10;
                }
                
                /* Special styling for characters with art during active/animation states */
                .active-character .character-art-container {
                    box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.3) !important;
                }
                
                .art-loaded.character-moving img {
                    filter: drop-shadow(0 0 5px rgba(30, 144, 255, 0.8));
                }

                /* Character Circle */
                .character-circle {
                    width: 64px; /* Adjust size as needed */
                    height: 64px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.5rem; /* Size for initial letter */
                    font-weight: bold;
                    margin-bottom: 8px; /* Space between circle and HP bar */
                    border: 2px solid rgba(255, 255, 255, 0.3); /* Subtle border */
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    position: relative; /* Needed for floating text positioning */
                    transition: transform 0.3s ease-in-out;
                }
                /* Character Movement Animations */
                .character-moving {
                    z-index: 100; /* Ensure moving character appears above others */
                }
                /* Text color for light backgrounds */
                .text-dark-on-light { color: #141e2e; }

                /* Simple HP bar style */
                .hp-bar-container {
                    width: 80px; /* Match width roughly to circle */
                    margin: 0 auto; /* Center the bar */
                }
                .hp-bar-background {
                    background-color: #4a5568; /* Gray background for the bar */
                    height: 8px;
                    border-radius: 4px;
                    overflow: hidden;
                    border: 1px solid #2d3748;
                }
                .hp-bar-current {
                    background-color: #48bb78; /* Green for current HP */
                    height: 100%;
                    transition: width 0.3s ease-in-out;
                    border-radius: 4px 0 0 4px; /* Keep left radius */
                }

                /* Highlight for active character */
                .active-character .character-circle { /* Apply glow to the circle */
                    box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6); /* Gold glow */
                    border-color: rgba(255, 215, 0, 0.8);
                }
                .active-character { /* Add scaling to the container */
                     transform: scale(1.05);
                }

                /* Status icons */
                .status-icons-container {
                    margin-top: 4px;
                    display: flex;
                    justify-content: center; /* Center icons below HP bar */
                    gap: 4px; /* Space between icons */
                    min-height: 16px; /* Reserve space even if no icons */
                }
                .status-icon {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    text-align: center;
                    line-height: 16px;
                    font-weight: bold;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
                    cursor: help; /* Show help cursor on hover */
                    transition: transform 0.2s, box-shadow 0.2s;
                    background-color: rgba(0, 0, 0, 0.3); /* Default background color */
                    border: 1px solid rgba(255, 255, 255, 0.3); /* Light border */
                    position: relative;
                    overflow: hidden; /* Make sure icon doesn't overflow the circle */
                    background-size: cover; /* For icon images */
                    background-position: center;
                    background-repeat: no-repeat;
                }
                
                .status-icon:hover {
                    transform: scale(1.3); /* Scale up on hover */
                    box-shadow: 0 0 6px rgba(255, 255, 255, 0.8); /* Glow effect */
                    z-index: 10; /* Ensure it appears above other icons */
                }

                /* Basic button styling */
                .control-button {
                    background-color: #4a5568;
                    padding: 6px 12px;
                    border-radius: 6px;
                    margin-left: 8px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                    font-size: 14px;
                }
                .control-button:hover {
                    background-color: #718096;
                }
                .control-button.active {
                    background-color: #a0aec0;
                    color: #141e2e;
                }

                /* Battle Log Styling */
                .battle-log {
                    height: 180px; /* Increased height */
                    overflow-y: auto;
                    transition: height 0.3s ease-in-out;
                    max-height: 250px;
                    background-color: rgba(28, 33, 48, 0.95) !important; /* More opaque, darker background */
                    /* Hide default scrollbar in different browsers */
                    scrollbar-width: none; /* Firefox */
                    -ms-overflow-style: none; /* IE and Edge */
                }
                
                /* Hide scrollbar for Chrome, Safari and Opera */
                .battle-log::-webkit-scrollbar {
                    display: none;
                }

                /* Simple floating text placeholder */
                .floating-text {
                    position: absolute;
                    top: -25px; /* Position above the circle */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 2px 6px;
                    border-radius: 4px;
                    font-size: 16px;
                    font-weight: bold;
                    white-space: nowrap;
                    z-index: 10; /* Ensure it's above the circle */
                    animation: float-up-fade-out 1.2s forwards;
                }
                
                @keyframes float-up-fade-out {
                    0% {
                        opacity: 0;
                        transform: translate(-50%, 0);
                    }
                    10% {
                        opacity: 1;
                    }
                    80% {
                        opacity: 1;
                    }
                    100% {
                        opacity: 0;
                        transform: translate(-50%, -30px);
                    }
                }
                
                /* Arena backgrounds */
                .arena-default {
                    background-color: #1a1a2e;
                    background-image: linear-gradient(rgba(0,0,0,0.3) 1px, transparent 1px),
                                      linear-gradient(90deg, rgba(0,0,0,0.3) 1px, transparent 1px);
                    background-size: 20px 20px;
                }
                .arena-grassyfield {
                    background-image: url('assets/images/Arena Art/Grassy Field.png');
                    background-size: cover;
                    background-position: center;
                }
                
                /* Victory overlay */
                .victory-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: calc(100% - 200px); /* Leave space for battle log */
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    background-color: rgba(0, 0, 0, 0.7);
                    z-index: 20;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out;
                }
                .victory-text {
                    font-size: 48px;
                    font-weight: bold;
                    margin-bottom: 24px;
                    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
                }
                .victory-button {
                    padding: 12px 24px;
                    background-color: #3742fa;
                    color: white;
                    border-radius: 8px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: background-color 0.2s;
                }
                .victory-button:hover {
                    background-color: #2536e0;
                }
                
                /* Animation for when a character takes damage */
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-5px); }
                    50% { transform: translateX(5px); }
                    75% { transform: translateX(-5px); }
                }
                
                /* Bonk attack animation */
                @keyframes bonk-animation {
                    0% { transform: translateX(-50%) scale(0); opacity: 0; }
                    50% { transform: translateX(-50%) scale(1.5); opacity: 1; }
                    100% { transform: translateX(-50%) scale(1); opacity: 0; }
                }
                
                .attack-bonk {
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 24px;
                    z-index: 110;
                    pointer-events: none;
                }
                
                .animate-bonk {
                    animation: bonk-animation 500ms ease-out forwards;
                }
                
                /* Action Text Animation */
                @keyframes action-text-animation {
                    0% { 
                        opacity: 0;
                        transform: translate(-50%, 10px) scale(0.8);
                    }
                    15% { 
                        opacity: 1;
                        transform: translate(-50%, -5px) scale(1.1);
                    }
                    80% { 
                        opacity: 1;
                        transform: translate(-50%, -5px) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translate(-50%, -15px) scale(0.9);
                    }
                }

                .action-text {
                    position: absolute;
                    top: 10px; /* Adjusted to appear above character container */
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.6);
                    color: white;
                    padding: 3px 8px;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: bold;
                    white-space: nowrap;
                    z-index: 50;
                    animation: action-text-animation 1.8s forwards;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                    pointer-events: none;
                }

                /* Action text colors */
                .action-text-attack {
                    color: #f56565; /* Red for attacks */
                }

                .action-text-ability {
                    color: #4299e1; /* Blue for abilities */
                }

                .action-text-heal {
                    color: #48bb78; /* Green for healing */
                }
                
                /* Make sure battle UI properly fills the screen */
                #battle-ui {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    background-color: #141e2e;
                    color: white;
                    overflow: hidden;
                }
            `;
            document.head.appendChild(styleEl);
        }
    }
    
    /**
     * Create the header with turn indicator and controls
     * @returns {HTMLElement} Header element
     */
    createHeader() {
        const header = document.createElement('header');
        header.className = 'panel-bg rounded-lg p-3 mb-4 flex justify-between items-center shadow-md';
        
        // Turn display
        const turnDiv = document.createElement('div');
        const turnSpan = document.createElement('span');
        turnSpan.id = 'turn-display';
        turnSpan.className = 'text-lg font-semibold';
        turnSpan.textContent = 'Turn: 0';
        turnDiv.appendChild(turnSpan);
        
        // Controls
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'flex items-center';
        
        const speedLabel = document.createElement('span');
        speedLabel.className = 'mr-2 text-sm';
        speedLabel.textContent = 'Speed:';
        controlsDiv.appendChild(speedLabel);
        
        // Speed buttons
        const speedButtons = [
            { id: 'speed-1x', text: '1x', active: true, speed: 1 },
            { id: 'speed-2x', text: '2x', active: false, speed: 2 },
            { id: 'speed-4x', text: '4x', active: false, speed: 4 }
        ];
        
        speedButtons.forEach(btn => {
            const button = document.createElement('button');
            button.id = btn.id;
            button.className = `control-button ${btn.active ? 'active' : ''}`;
            button.textContent = btn.text;
            button.addEventListener('click', () => this.setSpeed(btn.speed));
            controlsDiv.appendChild(button);
        });
        
        // Pause button
        const pauseButton = document.createElement('button');
        pauseButton.id = 'pause-button';
        pauseButton.className = 'control-button ml-4';
        pauseButton.innerHTML = '&#10074;&#10074;'; // Pause symbol
        pauseButton.addEventListener('click', () => this.togglePause());
        controlsDiv.appendChild(pauseButton);
        
        // Next turn button
        const nextTurnButton = document.createElement('button');
        nextTurnButton.id = 'next-turn-button';
        nextTurnButton.className = 'control-button ml-4';
        nextTurnButton.innerHTML = '&#9654;&#9654;'; // Fast forward symbol
        nextTurnButton.addEventListener('click', () => this.nextTurn());
        controlsDiv.appendChild(nextTurnButton);
        
        // Settings button
        const settingsButton = document.createElement('button');
        settingsButton.id = 'settings-button';
        settingsButton.className = 'control-button ml-1';
        settingsButton.innerHTML = '&#9881;'; // Gear symbol
        settingsButton.addEventListener('click', () => this.showSettings());
        controlsDiv.appendChild(settingsButton);
        
        // Back button
        const backButton = document.createElement('button');
        backButton.id = 'back-button';
        backButton.className = 'control-button ml-4';
        backButton.textContent = 'Back';
        backButton.addEventListener('click', () => this.exitBattle());
        controlsDiv.appendChild(backButton);
        
        header.appendChild(turnDiv);
        header.appendChild(controlsDiv);
        
        return header;
    }
    
    /**
     * Create a team section (either player or enemy)
     * @param {string} title - Section title
     * @param {string} titleColor - Color class for the title
     * @returns {HTMLElement} Team section element
     */
    createTeamSection(title, titleColor) {
        const section = document.createElement('section');
        section.className = 'flex flex-col items-center gap-6 w-1/3 md:w-1/4';
        
        const heading = document.createElement('h2');
        heading.className = `text-xl font-semibold mb-2 ${titleColor}`;
        heading.textContent = title;
        
        section.appendChild(heading);
        
        return section;
    }
    
    /**
     * Create the battle log
     * @returns {HTMLElement} Battle log element
     */
    createBattleLog() {
        const logContainer = document.createElement('div');
        logContainer.className = 'absolute bottom-4 left-4';
        logContainer.style.width = '400px'; // Increased width from 300px to 400px
        logContainer.style.zIndex = '30'; // Higher than victory overlay (which is 20)
        
        const logDiv = document.createElement('div');
        logDiv.className = 'rounded-lg p-4 shadow-md battle-log';
        logDiv.style.backgroundColor = 'rgba(28, 33, 48, 0.95)'; // More opaque, darker background // Increased padding from p-3 to p-4
        
        const logHeading = document.createElement('div');
        logHeading.className = 'flex justify-between items-center text-sm font-semibold mb-2 border-b border-gray-600 pb-1';
        
        const logTitle = document.createElement('h3');
        logTitle.textContent = 'Battle Log';
        
        const copyButton = document.createElement('button');
        copyButton.className = 'text-xs py-0 px-2 bg-blue-600 rounded hover:bg-blue-500';
        copyButton.textContent = 'Copy';
        copyButton.addEventListener('click', () => this.copyBattleLog());
        
        logHeading.appendChild(logTitle);
        logHeading.appendChild(copyButton);
        
        const logContent = document.createElement('div');
        logContent.id = 'battle-log-content';
        logContent.className = 'text-xs space-y-2'; // Increased space between entries from space-y-1 to space-y-2
        
        logDiv.appendChild(logHeading);
        logDiv.appendChild(logContent);
        logContainer.appendChild(logDiv);
        
        return logContainer;
    }
    
    /**
     * Set the arena background
     * @param {HTMLElement} arenaElement - Arena element to apply background to
     * @param {string} backgroundKey - Key for the background to apply ('default', 'forest', etc)
     */
    setArenaBackground(arenaElement, backgroundKey) {
        // Only accept 'default' or 'grassyfield' for now
        if (backgroundKey !== 'default' && backgroundKey !== 'grassyfield') {
            console.log(`Background '${backgroundKey}' not implemented yet, using 'grassyfield' instead`);
            backgroundKey = 'grassyfield';
        }
        
        // Remove any existing arena classes
        arenaElement.classList.remove('arena-default', 'arena-grassyfield');
        
        // Add the requested arena class
        arenaElement.classList.add(`arena-${backgroundKey}`);
        
        // Check if the background is an image and verify it exists
        if (backgroundKey === 'grassyfield') {
            const imageUrl = 'assets/images/Arena Art/Grassy Field.png';
            
            // Apply a custom inline style to be absolutely sure it's applied
            arenaElement.style.backgroundImage = `url("${imageUrl}")`;
            arenaElement.style.backgroundSize = 'cover';
            arenaElement.style.backgroundPosition = 'center';
            
            // Attempt to preload the image to verify it exists
            const img = new Image();
            img.onerror = () => {
                console.error(`Failed to load background image: ${imageUrl}`);
                // Fallback to default background if image fails to load
                arenaElement.classList.remove(`arena-${backgroundKey}`);
                arenaElement.classList.add('arena-default');
                arenaElement.style.backgroundImage = '';
                this.arenaBackground = 'default';
            };
            img.src = imageUrl;
        } else {
            // Remove inline style if using default
            arenaElement.style.backgroundImage = '';
        }
        
        this.arenaBackground = backgroundKey;
    }
    
    /**
     * Render characters in the battle UI
     * @param {Array} playerTeam - Player team characters
     * @param {Array} enemyTeam - Enemy team characters
     */
    renderCharacters(playerTeam, enemyTeam) {
        this.playerTeam = playerTeam;
        this.enemyTeam = enemyTeam;
        
        console.log('BattleUI: Rendering characters', playerTeam, enemyTeam);
        
        // Clear existing characters
        const playerSection = this.elements.playerTeamContainer;
        const enemySection = this.elements.enemyTeamContainer;
        
        // Keep the heading, remove other children
        while (playerSection.childNodes.length > 1) {
            playerSection.removeChild(playerSection.lastChild);
        }
        
        while (enemySection.childNodes.length > 1) {
            enemySection.removeChild(enemySection.lastChild);
        }
        
        // Render player team
        playerTeam.forEach(character => {
            const characterElement = this.createCharacterElement(character, 'player');
            playerSection.appendChild(characterElement);
        });
        
        // Render enemy team
        enemyTeam.forEach(character => {
            const characterElement = this.createCharacterElement(character, 'enemy');
            enemySection.appendChild(characterElement);
        });
        
        // Set the first character as active
        if (playerTeam.length > 0) {
            this.setActiveCharacter(playerTeam[0]);
        }
    }
    
    /**
     * Create a character element
     * @param {Object} character - Character data
     * @param {string} team - 'player' or 'enemy'
     * @returns {HTMLElement} Character element
     */
    createCharacterElement(character, team) {
        const container = document.createElement('div');
        container.className = 'flex flex-col items-center text-center';
        
        // Create a unique ID for this character that includes team information
        // This ensures we correctly identify characters even if they have the same name
        character.uniqueId = `${team}_${character.id}`;
        
        container.id = `character-container-${character.uniqueId}`;
        container.dataset.team = team; // Store team info for attack animations
        
        // Character representation (circle or image)
        const circle = document.createElement('div');
        
        // Check if this is a character with art (Aqualia or any character with art property)
        if (character.name === "Aqualia" || (character.art && character.art.enabled !== false)) {
            // Add a class to identify this as a character with art
            circle.className = 'character-circle character-art-container';
            circle.id = `character-${character.uniqueId}`;
            circle.style.position = 'relative'; // Ensure relative positioning for the movement
            circle.dataset.hasArt = 'true'; // Mark this character as having art
            
            // Log that we're creating a character with art
            console.log(`Creating ${character.name} character with art`);
            
            // Use a direct path to the image based on the web server root
            const artPath = `assets/images/Character Art/${character.name}.png`;
            
            // Create a wrapper div to contain the image and properly position it
            const imageWrapper = document.createElement('div');
            imageWrapper.className = 'character-art-wrapper';
            imageWrapper.style.position = 'absolute';
            imageWrapper.style.top = '0';
            imageWrapper.style.left = '0';
            imageWrapper.style.width = '100%';
            imageWrapper.style.height = '100%';
            imageWrapper.style.zIndex = '5';
            
            // Create and add the image element
            const imgElement = new Image();
            imgElement.className = 'character-art';
            imgElement.alt = character.name;
            
            // Apply character-specific art settings if available
            if (character.art) {
                if (character.art.left) {
                    imgElement.style.left = character.art.left;
                    // Store original left value to maintain position during animations
                    imgElement.dataset.originalLeft = character.art.left;
                }
                if (character.art.top) {
                    imgElement.style.top = character.art.top;
                    // Store original top value to maintain position during animations
                    imgElement.dataset.originalTop = character.art.top;
                }
                if (character.art.width) imgElement.style.width = character.art.width;
                if (character.art.height) imgElement.style.height = character.art.height;
            }
            
            // Log to diagnose image loading issues
            imgElement.onload = function() {
                console.log(`SUCCESS: ${character.name} image loaded successfully`);
                // Remove the background completely once the image loads
                circle.style.backgroundColor = 'transparent';
                circle.style.borderColor = 'transparent';
            };
            
            imgElement.onerror = function(e) {
                console.error(`FAILED: Error loading ${character.name} image:`, e);
                console.log('Image path tried:', imgElement.src);
                // Keep the fallback color/letter if image fails to load
            };
            
            // Set a transparent background by default
            circle.style.backgroundColor = 'transparent';
            circle.style.border = 'none';
            
            // Set the src AFTER setting up event handlers
            imgElement.src = artPath;
            
            // Add the image to the wrapper, then wrapper to circle
            imageWrapper.appendChild(imgElement);
            circle.appendChild(imageWrapper);
        } else {
            // Standard circle for other characters
            circle.className = `character-circle bg-${character.type}`;
            if (character.type === 'light') {
                circle.classList.add('text-dark-on-light');
            }
            circle.id = `character-${character.uniqueId}`;
            circle.textContent = character.name.charAt(0).toUpperCase();
            circle.style.position = 'relative'; // Ensure relative positioning for the movement
        }
        
        // HP bar container
        const hpBarContainer = document.createElement('div');
        hpBarContainer.className = 'hp-bar-container';
        
        const hpBarBackground = document.createElement('div');
        hpBarBackground.className = 'hp-bar-background';
        
        const currentHp = character.currentHp !== undefined ? character.currentHp : character.stats.hp;
        const maxHp = character.stats.hp;
        const healthPercentage = (currentHp / maxHp) * 100;
        
        const hpBarCurrent = document.createElement('div');
        hpBarCurrent.className = 'hp-bar-current';
        hpBarCurrent.style.width = `${healthPercentage}%`;
        hpBarCurrent.id = `hp-bar-${character.uniqueId}`;
        
        hpBarBackground.appendChild(hpBarCurrent);
        hpBarContainer.appendChild(hpBarBackground);
        
        // Character name
        const nameDiv = document.createElement('div');
        nameDiv.className = 'text-sm font-semibold mt-1';
        nameDiv.textContent = character.name;
        
        // HP text
        const hpText = document.createElement('div');
        hpText.className = 'text-xs';
        hpText.textContent = `HP: ${currentHp} / ${maxHp}`;
        hpText.id = `hp-text-${character.uniqueId}`;
        
        // Status icons container
        const statusContainer = document.createElement('div');
        statusContainer.className = 'status-icons-container';
        statusContainer.id = `status-icons-${character.uniqueId}`;
        
        // Add elements to container
        container.appendChild(circle);
        container.appendChild(hpBarContainer);
        container.appendChild(nameDiv);
        container.appendChild(hpText);
        container.appendChild(statusContainer);
        
        return container;
    }
    
    /**
     * Set a character as the active character
     * @param {Object} character - Character data
     */
    setActiveCharacter(character) {
        // Remove active class from all character containers
        document.querySelectorAll('.active-character').forEach(el => {
            el.classList.remove('active-character');
            
            // Restore original position values for any character art if they exist
            const characterId = el.id.replace('character-container-', '');
            const artContainer = document.getElementById(`character-${characterId}`);
            if (artContainer && artContainer.dataset.hasArt === 'true') {
                const img = artContainer.querySelector('.character-art');
                if (img) {
                    // Restore original position values if available
                    if (img.dataset.originalLeft) {
                        img.style.left = img.dataset.originalLeft;
                    }
                    if (img.dataset.originalTop) {
                        img.style.top = img.dataset.originalTop;
                    }
                }
            }
        });
        
        this.activeCharacter = character;
        
        // Add active class to the character container
        // We need the uniqueId which includes team information
        const uniqueId = character.uniqueId || (character.team === 'player' ? `player_${character.id}` : `enemy_${character.id}`);
        const characterContainer = document.getElementById(`character-container-${uniqueId}`);
        if (characterContainer) {
            characterContainer.classList.add('active-character');
            
            // Make sure character art maintains its position when active
            const artContainer = document.getElementById(`character-${uniqueId}`);
            if (artContainer && artContainer.dataset.hasArt === 'true') {
                // If character has art, ensure position is maintained
                const img = artContainer.querySelector('.character-art');
                if (img && img.dataset.originalLeft && img.dataset.originalTop) {
                    // Re-apply the original position values
                    img.style.left = img.dataset.originalLeft;
                    img.style.top = img.dataset.originalTop;
                }
            }
        }
    }
    
    /**
     * Show an attack animation between characters
     * @param {Object} attacker - Attacking character
     * @param {Object} target - Target character
     * @param {Object} ability - Ability used
     */
    showAttackAnimation(attacker, target, ability) {
        // DEBUG MESSAGE FOR DEPRECATED DOM ANIMATIONS
        console.warn('âš ï¸ USING DEPRECATED DOM BATTLE ANIMATIONS: Please use Phaser-based battle scene for improved performance');

        // Disable DirectImageLoader during this animation to prevent art switching
        if (typeof window.disableDirectImageLoaderDuringAnimation === 'function') {
            window.disableDirectImageLoaderDuringAnimation();
        } else {
            // Fallback if function doesn't exist
            window.disableDirectImageLoader = true;
            setTimeout(() => { window.disableDirectImageLoader = false; }, 2000);
        }
        
        // Logging for debugging purposes
        console.log(`Animation: ${attacker.name} (${attacker.uniqueId}) attacking ${target.name} (${target.uniqueId})`);
        
        // Get the character elements using uniqueId
        const attackerContainer = document.getElementById(`character-container-${attacker.uniqueId}`);
        const targetContainer = document.getElementById(`character-container-${target.uniqueId}`);
        const attackerCircle = document.getElementById(`character-${attacker.uniqueId}`);
        const targetCircle = document.getElementById(`character-${target.uniqueId}`);
        
        // Add Action Text display above character head (to the container, not the circle)
        const actionType = ability ? (ability.isHealing ? 'heal' : 'ability') : 'attack';
        const actionText = ability ? ability.name : 'Auto-Attack';
        // Use the container instead of circle so text stays in place
        this.showActionText(attackerContainer, actionText, actionType);
        
        if (!attackerCircle || !targetCircle) {
            console.error('Could not find character elements for animation:', 
                        { attacker: attacker.name, target: target.name, 
                          attackerId: attacker.uniqueId, targetId: target.uniqueId });
            return;
        }
        
        // SIMPLIFIED ANIMATION: Just show the action text and update health
        // Store damage info
        const damage = ability ? ability.damage : attacker.stats.attack;
        const isHealing = ability && ability.isHealing;
        
        // Show simplified effect
        this.showBonkEffect(targetCircle, isHealing);
        
        // Show damage numbers
        this.showFloatingText(
            target.id,
            isHealing ? `+${damage}` : `-${damage}`,
            isHealing ? 'text-green-500' : 'text-red-500'
        );
        
        // Update target's health
        this.updateCharacterHealth(target, damage, isHealing);
        
        // Re-enable DirectImageLoader after animation is completely finished
        setTimeout(() => {
            window.disableDirectImageLoader = false;
            console.log('Animation complete, DirectImageLoader re-enabled');
        }, 500);
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Check if this character has artwork
        const hasArt = attackerCircle.dataset.hasArt === 'true';
        
        // Store attacker info in data attribute for secure identification
        // This helps prevent character art mix-ups during animations
        const attackerUniqueId = attacker.uniqueId;
        const attackerName = attacker.name;
        
        // Create a fresh clone of the attacker circle for the animation
        const animatedClone = attackerCircle.cloneNode(false); // Shallow clone first
        animatedClone.id = `clone-${attackerUniqueId}`;
        animatedClone.setAttribute('data-character-id', attacker.id);
        animatedClone.setAttribute('data-character-name', attackerName);
        animatedClone.setAttribute('data-character-unique-id', attackerUniqueId);
        animatedClone.style.position = 'fixed'; // Use fixed positioning for accurate placement
        animatedClone.style.zIndex = '200';
        animatedClone.style.margin = '0'; // Remove any margin
        animatedClone.style.opacity = '1'; 
        animatedClone.style.transition = 'none'; // Disable transitions initially
        animatedClone.classList.add('character-moving');
        
        // Special handling for characters with art
        if (hasArt) {
            // Make sure the container has correct styling
            animatedClone.style.backgroundColor = 'transparent';
            animatedClone.style.border = 'none';
            
            // Create a fresh wrapper instead of cloning to avoid potential reference issues
            const artWrapper = document.createElement('div');
            artWrapper.className = 'character-art-wrapper';
            animatedClone.appendChild(artWrapper);
            
            // Create a fresh image element
            const img = new Image();
            img.className = 'character-art';
            img.alt = attackerName;
            
            // IMPORTANT: Set character-specific data attributes to prevent misidentification
            img.dataset.characterName = attackerName;
            img.dataset.characterId = attacker.id;
            img.dataset.characterUniqueId = attackerUniqueId;
            
            // Ensure the image is set to a working path based on attacker name
            const imagePath = `assets/images/Character Art/${attackerName}.png`;
            img.src = imagePath;
            
            // Use a secure global reference if available
            if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[attackerName]) {
                console.log(`Using cached image for ${attackerName} during animation`);
                // Copy the src from the cache to ensure consistency
                const cachedSrc = window.CHARACTER_IMAGE_CACHE[attackerName].src;
                if (cachedSrc) img.src = cachedSrc;
            }
            
            // Copy over the custom positioning from original image
            const originalImg = attackerCircle.querySelector('.character-art');
            if (originalImg) {
                // Copy exact positioning from original image
                if (originalImg.dataset.originalLeft) {
                    img.style.left = originalImg.dataset.originalLeft;
                    img.dataset.originalLeft = originalImg.dataset.originalLeft;
                }
                if (originalImg.dataset.originalTop) {
                    img.style.top = originalImg.dataset.originalTop;
                    img.dataset.originalTop = originalImg.dataset.originalTop;
                }
                // Copy width/height from original if available
                if (originalImg.style.width) img.style.width = originalImg.style.width;
                if (originalImg.style.height) img.style.height = originalImg.style.height;
            }
            
            // Add the image to the wrapper
            artWrapper.appendChild(img);
            
            // Add a loaded class to the clone
            animatedClone.classList.add('art-loaded');
            
            // Log animation for debugging purposes
            console.log(`Created animation clone for ${attackerName} (${attackerUniqueId})`);
        }
        
        // Hide the original circle during animation
        attackerCircle.style.visibility = 'hidden';
        
        // Clean up any lingering clones before adding a new one
        // This helps prevent potential art mix-ups from earlier animations
        const existingClones = document.querySelectorAll('[id^="clone-"]');
        existingClones.forEach(clone => {
            if (clone.parentNode) {
                clone.parentNode.removeChild(clone);
                console.log('Removed lingering animation clone');
            }
        });
        
        // Add the clone to the battle area
        const battleArena = document.getElementById('battle-arena');
        battleArena.appendChild(animatedClone);
        
        // Calculate positions
        const attackerRect = attackerCircle.getBoundingClientRect();
        const targetRect = targetCircle.getBoundingClientRect();
        
        // Position the clone at the attacker's position
        animatedClone.style.left = `${attackerRect.left}px`;
        animatedClone.style.top = `${attackerRect.top}px`;
        animatedClone.style.width = `${attackerRect.width}px`;
        animatedClone.style.height = `${attackerRect.height}px`;
        
        // Calculate animation timing based on speed
        const speedMultiplier = this.battleManager ? this.battleManager.speedMultiplier || 1 : 1;
        const moveDuration = 400 / speedMultiplier;
        const returnDuration = 300 / speedMultiplier;
        
        // 1. Initial slight scale down
        requestAnimationFrame(() => {
            // Start with a small scale
            animatedClone.style.transform = 'scale(0.9)';
            
            // 2. Move to target with a slight delay
            setTimeout(() => {
                // Apply transition for movement
                animatedClone.style.transition = `left ${moveDuration}ms ease-out, top ${moveDuration}ms ease-out, transform 200ms ease-out`;
                
                // Calculate the target position (stop just short of the target)
                // For player team attacking enemy team, move to the left of the target
                // For enemy team attacking player team, move to the right of the target
                const attackerTeam = attackerContainer.dataset.team;
                const targetTeam = targetContainer.dataset.team;
                
                let moveToX, moveToY;
                if (attackerTeam === 'player' && targetTeam === 'enemy') {
                    // Player attacking enemy - move to the left side of the target
                    moveToX = targetRect.left - (attackerRect.width / 2);
                } else if (attackerTeam === 'enemy' && targetTeam === 'player') {
                    // Enemy attacking player - move to the right side of the target
                    moveToX = targetRect.right - (attackerRect.width / 2);
                } else {
                    // Same team (healing) - go to the center
                    moveToX = targetRect.left + (targetRect.width - attackerRect.width) / 2;
                }
                
                // Vertically align with the target
                moveToY = targetRect.top + (targetRect.height - attackerRect.height) / 2;
                
                // Move toward the target
                animatedClone.style.transform = 'scale(1.1)';
                animatedClone.style.left = `${moveToX}px`;
                animatedClone.style.top = `${moveToY}px`;
                
                // 3. When near target, show impact effect
                setTimeout(() => {
                    // Show bonk effect and shake target
                    this.showBonkEffect(targetCircle, isHealing);
                    targetCircle.style.animation = 'shake 0.5s';
                    
                    // Show damage numbers
                    this.showFloatingText(
                        target.id,
                        isHealing ? `+${damage}` : `-${damage}`,
                        isHealing ? 'text-green-500' : 'text-red-500'
                    );
                    
                    // Update target's health
                    this.updateCharacterHealth(target, damage, isHealing);
                    
                    // 4. Move back to original position
                    setTimeout(() => {
                        animatedClone.style.transition = `left ${returnDuration}ms ease-in, top ${returnDuration}ms ease-in, opacity 200ms ease-out`;
                        animatedClone.style.left = `${attackerRect.left}px`;
                        animatedClone.style.top = `${attackerRect.top}px`;
                        animatedClone.style.transform = 'scale(0.9)';
                        
                        // 5. Fade out clone and remove
                        setTimeout(() => {
                            // Begin fade out
                            animatedClone.style.opacity = '0';
                            
                            setTimeout(() => {
                                // Verify clone is the correct one for this character (safety check)
                                if (animatedClone.dataset.characterUniqueId !== attackerUniqueId) {
                                    console.warn(`Animation clone mismatch detected: ${animatedClone.dataset.characterUniqueId} vs expected ${attackerUniqueId}`);
                                }
                                
                                // Ensure the clone is properly removed
                                if (animatedClone.parentNode) {
                                    console.log(`Removing animation clone for ${attackerName}`);
                                    animatedClone.parentNode.removeChild(animatedClone);
                                }
                                
                                // Double check for any other clones that might be lingering
                                const otherClones = document.querySelectorAll(`[id="clone-${attackerUniqueId}"]`);
                                otherClones.forEach(clone => {
                                    if (clone.parentNode) {
                                        console.warn('Found additional clone to remove');
                                        clone.parentNode.removeChild(clone);
                                    }
                                });
                                
                                // Reset target animation
                                targetCircle.style.animation = '';
                                
                                // Show original attacker circle again
                                attackerCircle.style.visibility = 'visible';
                                
                                // Re-enable DirectImageLoader after animation is completely finished
                                // This ensures no injection happens during the animation
                                window.disableDirectImageLoader = false;
                                console.log('Animation complete, DirectImageLoader re-enabled');
                            }, 200);
                        }, returnDuration - 50);
                    }, 400 / speedMultiplier);
                }, moveDuration);
            }, 50);
        });
        */
    }
    
    /**
     * Show a bonk effect on the target
     * @param {HTMLElement} targetElement - The target element
     * @param {boolean} isHealing - Whether this is a healing effect
     */
    showBonkEffect(targetElement, isHealing = false) {
        // Create bonk element
        const bonk = document.createElement('div');
        bonk.className = 'attack-bonk';
        
        // Use different icon based on whether it's healing or attack
        if (isHealing) {
            bonk.textContent = 'âœ¨'; // Sparkle for healing
            bonk.style.color = '#48bb78'; // Green color
        } else {
            bonk.textContent = 'ðŸ’¥'; // Impact for attack
            bonk.style.color = '#f56565'; // Red color
        }
        
        // Add to target
        targetElement.appendChild(bonk);
        
        // Add animation class
        bonk.classList.add('animate-bonk');
        
        // Remove after animation completes
        setTimeout(() => {
            if (bonk.parentNode === targetElement) {
                targetElement.removeChild(bonk);
            }
        }, 500);
    }
    
    /**
     * Show action text above a character
     * @param {HTMLElement} characterElement - The character element
     * @param {string} actionText - Text to display
     * @param {string} actionType - Type of action ('attack', 'ability', or 'heal')
     */
    showActionText(characterElement, actionText, actionType = 'attack') {
        // Create the action text element
        const actionTextElement = document.createElement('div');
        actionTextElement.className = `action-text action-text-${actionType}`;
        actionTextElement.textContent = actionText;
        
        // Add to character element
        characterElement.appendChild(actionTextElement);
        
        // Remove after animation completes
        const duration = 1800 / (this.battleManager ? this.battleManager.speedMultiplier || 1 : 1);
        setTimeout(() => {
            if (actionTextElement.parentNode === characterElement) {
                characterElement.removeChild(actionTextElement);
            }
        }, duration); // Match the animation duration with battle speed adjustment
    }
    
    /**
     * Show passive effect visual feedback
     * @param {Object} character - Character with the passive ability
     * @param {string} effectName - Name of the passive effect
     */
    showPassiveEffect(character, effectName) {
        // Get character's unique ID
        const uniqueId = character.uniqueId || (character.team === 'player' ? `player_${character.id}` : `enemy_${character.id}`);
        
        // Find the character element
        const characterElement = document.getElementById(`character-${uniqueId}`);
        
        if (!characterElement) {
            console.error(`Could not find character element for ${character.name} (${uniqueId})`);
            return;
        }
        
        // Create passive effect element
        const passiveEffect = document.createElement('div');
        passiveEffect.className = 'passive-effect';
        passiveEffect.textContent = 'âœ¨ ' + effectName;
        
        // Add some custom styling for passive effects
        passiveEffect.style.position = 'absolute';
        passiveEffect.style.top = '-30px';
        passiveEffect.style.left = '50%';
        passiveEffect.style.transform = 'translateX(-50%)';
        passiveEffect.style.backgroundColor = 'rgba(75, 0, 130, 0.8)'; // Purple for passives
        passiveEffect.style.color = 'white';
        passiveEffect.style.padding = '3px 8px';
        passiveEffect.style.borderRadius = '4px';
        passiveEffect.style.fontSize = '12px';
        passiveEffect.style.fontWeight = 'bold';
        passiveEffect.style.whiteSpace = 'nowrap';
        passiveEffect.style.zIndex = '100';
        passiveEffect.style.animation = 'float-up-fade-out 1.5s forwards';
        passiveEffect.style.border = '1px solid rgba(128, 0, 255, 0.5)';
        
        // Add to character element
        characterElement.appendChild(passiveEffect);
        
        // Remove after animation completes
        setTimeout(() => {
            if (passiveEffect.parentNode === characterElement) {
                characterElement.removeChild(passiveEffect);
            }
        }, 1500);
        
        // Also add a glowing effect to the character
        const glowEffect = document.createElement('div');
        glowEffect.className = 'passive-glow';
        glowEffect.style.position = 'absolute';
        glowEffect.style.top = '0';
        glowEffect.style.left = '0';
        glowEffect.style.width = '100%';
        glowEffect.style.height = '100%';
        glowEffect.style.borderRadius = '50%';
        glowEffect.style.boxShadow = '0 0 15px 5px rgba(128, 0, 255, 0.6)';
        glowEffect.style.animation = 'passive-glow 1s ease-out';
        glowEffect.style.zIndex = '5';
        glowEffect.style.pointerEvents = 'none';
        
        // Add glow animation style if it doesn't exist
        if (!document.getElementById('passive-effect-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'passive-effect-styles';
            styleEl.textContent = `
                @keyframes passive-glow {
                    0% { opacity: 0.8; transform: scale(0.9); }
                    50% { opacity: 1; transform: scale(1.1); }
                    100% { opacity: 0; transform: scale(1.2); }
                }
            `;
            document.head.appendChild(styleEl);
        }
        
        // Add the glow element behind other content
        characterElement.insertBefore(glowEffect, characterElement.firstChild);
        
        // Remove glow after animation
        setTimeout(() => {
            if (glowEffect.parentNode === characterElement) {
                characterElement.removeChild(glowEffect);
            }
        }, 1000);
    }
    
    /**
     * Show floating text above a character
     * @param {string} characterId - ID of the character
     * @param {string} text - Text to display
     * @param {string} textColor - Color class for the text
     */
    showFloatingText(characterId, text, textColor) {
        // In case we're passed a regular ID, let's try to find the uniqueId first
        let characterElement = null;
        
        // Try to find the element with uniqueId (player_id or enemy_id)
        const possibleIds = [`player_${characterId}`, `enemy_${characterId}`];
        for (const id of possibleIds) {
            const element = document.getElementById(`character-${id}`);
            if (element) {
                characterElement = element;
                break;
            }
        }
        
        // If not found with uniqueId, fall back to regular id
        if (!characterElement) {
            characterElement = document.getElementById(`character-${characterId}`);
        }
        
        if (!characterElement) {
            console.error(`Could not find character element for ID: ${characterId}`);
            return;
        }
        
        const floatingText = document.createElement('div');
        floatingText.className = `floating-text ${textColor}`;
        floatingText.textContent = text;
        
        characterElement.appendChild(floatingText);
        
        // Remove after animation completes
        setTimeout(() => {
            if (floatingText.parentNode === characterElement) {
                characterElement.removeChild(floatingText);
            }
        }, 1200);
    }
    
    /**
     * Update character health display
     * @param {Object} character - Character data
     * @param {number} amount - Amount to change (damage or healing)
     * @param {boolean} isHealing - Whether this is healing
     */
    updateCharacterHealth(character, amount, isHealing = false) {
        // Update character object
        const newHealth = isHealing 
            ? Math.min(character.currentHp + amount, character.stats.hp)
            : Math.max(0, character.currentHp - amount);
        
        character.currentHp = newHealth;
        
        // Use uniqueId if available
        const uniqueId = character.uniqueId || character.id;
        
        // Update HP bar
        const hpBar = document.getElementById(`hp-bar-${uniqueId}`);
        const hpText = document.getElementById(`hp-text-${uniqueId}`);
        
        if (hpBar && hpText) {
            // Calculate health percentage
            const healthPercentage = (character.currentHp / character.stats.hp) * 100;
            
            // Update HP bar width with animation
            hpBar.style.width = `${healthPercentage}%`;
            
            // Update HP text
            hpText.textContent = `HP: ${character.currentHp} / ${character.stats.hp}`;
            
            // Change color based on health percentage
            if (healthPercentage <= 25) {
                hpBar.style.backgroundColor = '#f56565'; // Red for low health
            } else if (healthPercentage <= 50) {
                hpBar.style.backgroundColor = '#ed8936'; // Orange for medium health
            } else {
                hpBar.style.backgroundColor = '#48bb78'; // Green for good health
            }
        }
    }
    
    /**
     * Update the UI with current state
     */
    update() {
        if (this.battleManager) {
            const turnDisplay = this.elements.turnDisplay;
            if (turnDisplay) {
                turnDisplay.textContent = `Turn: ${this.battleManager.currentTurn}`;
            }
        }
    }
    
    /**
     * Add message to battle log
     * @param {string} message - Message text
     * @param {string} type - Message type
     */
    addLogMessage(message, type = 'default') {
        // Add to our log array
        this.logMessages.push({ message, type });
        
        // No longer limiting to most recent messages so we can copy the entire battle log
        // Previously: if (this.logMessages.length > 30) { this.logMessages.shift(); }
        
        // Update log display
        const logContent = this.elements.logContent;
        if (logContent) {
            const messageElement = document.createElement('p');
            
            // Format the message with colored spans based on content
            let formattedMessage = message;
            
            // Override formatting based on message type
            switch (type) {
                case 'success':
                    messageElement.style.color = '#48bb78'; // Green
                    break;
                case 'error':
                    messageElement.style.color = '#f56565'; // Red
                    break;
                case 'info':
                    messageElement.style.color = '#4299e1'; // Blue
                    break;
                case 'action':
                    messageElement.style.color = '#ed8936'; // Orange
                    break;
            }
            
            messageElement.innerHTML = formattedMessage
                .replace(/\[(.*?)\]/g, '<span style="color: #a0aec0">[$1]</span>') // Abilities in brackets
                .replace(/\+(\d+) HP/g, '<span style="color: #48bb78">+$1 HP</span>') // Healing
                .replace(/Miss!/g, '<span style="color: #a0aec0">Miss!</span>'); // Misses
                
            logContent.appendChild(messageElement);
            
            // Scroll to bottom
            logContent.scrollTop = logContent.scrollHeight;
        }
    }
    
    /**
     * Toggle pause state
     */
    togglePause() {
        if (this.battleManager) {
            const isPaused = this.battleManager.togglePause();
            const pauseButton = this.elements.pauseButton;
            if (pauseButton) {
                pauseButton.innerHTML = isPaused ? '&#9658;' : '&#10074;&#10074;'; // Play or pause symbol
            }
        }
    }
    
    /**
     * Set battle speed
     * @param {number} speed - Speed multiplier
     */
    setSpeed(speed) {
        if (this.battleManager) {
            this.battleManager.setSpeed(speed);
            
            // Update button styles
            Object.entries(this.elements.speedButtons).forEach(([btnSpeed, button]) => {
                if (button) {
                    if (btnSpeed === `${speed}x`) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                }
            });
        }
    }
    
    /**
     * Go to next turn
     */
    nextTurn() {
        if (this.battleManager) {
            this.battleManager.startNextTurn();
        }
    }
    
    /**
     * Show settings dialog
     */
    showSettings() {
        // Only offer backgrounds that actually exist
        const bgOptions = ['default', 'grassyfield'];
        const selectedBg = prompt(`Select arena background (${bgOptions.join(', ')}):`, this.arenaBackground);
        
        if (selectedBg && bgOptions.includes(selectedBg)) {
            this.setArenaBackground(this.elements.battleArena, selectedBg);
            
            // Special handling for grassyfield background
            if (selectedBg === 'grassyfield') {
                // Call our utility method that tries multiple paths
                setTimeout(() => {
                    this.setGrassyFieldDirect();
                }, 100);
            }
            
            // Add a visual notification to confirm the change
            const notification = document.createElement('div');
            notification.textContent = `Background changed to ${selectedBg}`;
            notification.style.position = 'fixed';
            notification.style.top = '60px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            notification.style.color = 'white';
            notification.style.padding = '8px 16px';
            notification.style.borderRadius = '4px';
            notification.style.zIndex = '1000';
            document.body.appendChild(notification);
            
            // Remove notification after 2 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
            
            console.log(`Background changed to ${selectedBg}`);
        }
    }
    
    /**
     * Set Grassy Field as background using direct URL
     * This is a utility method the user can call directly from console
     */
    setGrassyFieldDirect() {
        if (!this.elements || !this.elements.battleArena) {
            console.error('Battle arena element not found');
            return;
        }
        
        const arenaElement = this.elements.battleArena;
        
        // Remove any existing arena classes
        arenaElement.classList.remove('arena-default', 'arena-forest', 'arena-volcano', 'arena-glacier', 'arena-grassyfield');
        
        // Add the grassyfield class
        arenaElement.classList.add('arena-grassyfield');
        
        // Try multiple paths to ensure one works
        const paths = [
            'assets/images/Arena Art/Grassy Field.png',
            './assets/images/Arena Art/Grassy Field.png',
            '../assets/images/Arena Art/Grassy Field.png',
            '../../assets/images/Arena Art/Grassy Field.png',
            '/assets/images/Arena Art/Grassy Field.png',
            'C:/Personal/AutoBattler/assets/images/Arena Art/Grassy Field.png',
            // Try base64 encoded small green rectangle as absolute fallback
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFeQI7Z6j1AwAAAABJRU5ErkJggg=='
        ];
        
        // Try each path
        let currentPath = 0;
        const tryNextPath = () => {
            if (currentPath >= paths.length) {
                console.error('All paths failed, using default background');
                arenaElement.classList.remove('arena-grassyfield');
                arenaElement.classList.add('arena-default');
                arenaElement.style.backgroundImage = '';
                return;
            }
            
            const path = paths[currentPath];
            console.log(`Trying path ${currentPath + 1}/${paths.length}: ${path}`);
            
            // Set the background image
            arenaElement.style.backgroundImage = `url("${path}")`;
            arenaElement.style.backgroundSize = 'cover';
            arenaElement.style.backgroundPosition = 'center';
            
            // If it's the base64 fallback, we're done
            if (path.startsWith('data:')) {
                console.log('Using base64 fallback');
                return;
            }
            
            // Otherwise check if the image loaded
            const img = new Image();
            img.onload = () => {
                console.log(`Success! Path ${currentPath + 1} worked: ${path}`);
            };
            img.onerror = () => {
                console.error(`Path ${currentPath + 1} failed: ${path}`);
                currentPath++;
                tryNextPath();
            };
            img.src = path;
        };
        
        // Start trying paths
        tryNextPath();
        
        // Update background setting
        this.arenaBackground = 'grassyfield';
        
        // Add a notification
        const notification = document.createElement('div');
        notification.textContent = 'Setting Grassy Field background...';
        notification.style.position = 'fixed';
        notification.style.top = '60px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        notification.style.color = 'white';
        notification.style.padding = '8px 16px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '1000';
        document.body.appendChild(notification);
        
        // Remove notification after 3 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
        
        return 'Attempting to set Grassy Field background...';
    }
    
    /**
     * Show victory/defeat screen
     * @param {string} result - 'victory', 'defeat', or 'draw'
     */
    showBattleResult(result) {
        // DEBUG MESSAGE FOR DEPRECATED DOM BATTLE UI
        console.warn('âš ï¸ USING DEPRECATED DOM BATTLE RESULT SCREEN: Please use Phaser-based battle scene for improved performance');

        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'victory-overlay';
        
        const resultText = document.createElement('h2');
        resultText.className = 'victory-text';
        
        switch (result) {
            case 'victory':
                resultText.textContent = 'VICTORY!';
                resultText.style.color = '#48bb78'; // Green
                break;
            case 'defeat':
                resultText.textContent = 'DEFEAT!';
                resultText.style.color = '#f56565'; // Red
                break;
            case 'draw':
                resultText.textContent = 'DRAW!';
                resultText.style.color = '#a0aec0'; // Gray
                break;
        }
        
        const returnButton = document.createElement('button');
        returnButton.className = 'victory-button mb-4';
        returnButton.textContent = 'Return to Team Builder';
        returnButton.addEventListener('click', () => this.exitBattle());
        
        const logNote = document.createElement('div');
        logNote.className = 'text-sm text-gray-300 mt-2';
        logNote.textContent = 'Battle log is still accessible in the bottom-left corner';
        
        overlay.appendChild(resultText);
        overlay.appendChild(returnButton);
        overlay.appendChild(logNote);
        
        // Add to battle UI
        document.getElementById('battle-ui').appendChild(overlay);
        
        // Enhance battle log visibility
        const battleLog = document.querySelector('.battle-log');
        if (battleLog) {
            battleLog.style.backgroundColor = 'rgba(28, 33, 48, 0.98)'; // More opaque
            battleLog.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)'; // Add glow
        }
        
        // Show immediately instead of using animation delay
        overlay.style.opacity = '1';
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Animate in with delay
        setTimeout(() => {
            overlay.style.opacity = '1';
        }, 100);
        */
    }
    
    /**
     * Handle round end events
     * @param {Object} data - Round end data
     */
    handleRoundEnd(data) {
        // DEBUG MESSAGE FOR DEPRECATED DOM ROUND INDICATOR
        console.warn('âš ï¸ USING DEPRECATED DOM ROUND INDICATOR: Please use Phaser-based battle scene for improved performance');

        // Create round end visual indicator
        const roundIndicator = document.createElement('div');
        roundIndicator.className = 'round-end-indicator';
        roundIndicator.textContent = `Round ${data.roundNumber} Complete`;
        
        // Style it directly to make it visible without custom CSS
        roundIndicator.style.position = 'absolute';
        roundIndicator.style.top = '50%';
        roundIndicator.style.left = '50%';
        roundIndicator.style.transform = 'translate(-50%, -50%)';
        roundIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        roundIndicator.style.color = 'white';
        roundIndicator.style.padding = '15px 30px';
        roundIndicator.style.borderRadius = '8px';
        roundIndicator.style.fontWeight = 'bold';
        roundIndicator.style.fontSize = '24px';
        roundIndicator.style.zIndex = '100';
        
        // Add to battle arena if available
        const battleArena = document.getElementById('battle-arena');
        if (battleArena) {
            battleArena.appendChild(roundIndicator);
        } else {
            document.body.appendChild(roundIndicator);
        }
        
        // Remove immediately to avoid delays
        setTimeout(() => {
            if (roundIndicator.parentNode) {
                roundIndicator.parentNode.removeChild(roundIndicator);
            }
        }, 100);
        
        /* ANIMATION CODE COMMENTED OUT: Moving to Phaser-based system
        // Show for 2 seconds then fade out
        setTimeout(() => {
            roundIndicator.classList.add('fade-out');
            setTimeout(() => {
                roundIndicator.remove();
            }, 1000); // Fade out duration
        }, 2000); // Display duration
        */
    }

    /**
     * Exit battle
     */
    exitBattle() {
        // Remove our UI
        const battleUI = document.getElementById('battle-ui');
        if (battleUI) {
            document.body.removeChild(battleUI);
        }
        
        // Reset our setup flag
        this.isSetup = false;
        
        // Switch back to team builder
        document.getElementById('game-container').classList.remove('active');
        document.getElementById('team-builder-container').classList.add('active');
    }

    /**
     * Initialize tooltip manager for battle UI
     */
    initializeTooltipManager() {
        // Clean up any existing tooltips first
        this.cleanupTooltips();
        
        // If TooltipManager hasn't been initialized yet
        if (!window.tooltipManager) {
            console.log('BattleUI: Creating new TooltipManager instance');
            // Create a new instance
            window.tooltipManager = new TooltipManager();
        }
        
        // Add battle-specific CSS for tooltips
        this.addBattleTooltipStyles();
    }
    
    /**
     * Clean up all existing tooltips and event listeners
     */
    cleanupTooltips() {
        // Remove all existing tooltip event listeners
        const tooltipElements = document.querySelectorAll('.status-icon');
        tooltipElements.forEach(el => {
            // Clone element to remove all event listeners
            const newEl = el.cloneNode(true);
            if (el.parentNode) {
                el.parentNode.replaceChild(newEl, el);
            }
        });
        
        // Clear any existing tooltip containers
        const tooltipContainers = document.querySelectorAll('.battle-tooltip');
        tooltipContainers.forEach(container => {
            if (container.parentNode) {
                container.parentNode.removeChild(container);
            }
        });
        
        // Reset the battleTooltip property
        this.battleTooltip = null;
        
        console.log('BattleUI: Cleaned up existing tooltips');
    }

    /**
     * Add custom CSS for battle tooltips
     */
    addBattleTooltipStyles() {
        if (!document.getElementById('battle-tooltip-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'battle-tooltip-styles';
            styleEl.textContent = `
                /* Override the info icon for battle status icons */
                .status-icon.has-tooltip::after {
                    content: none; /* Remove the "i" icon */
                }
                
                /* Make status icons more interactive */
                .status-icon {
                    cursor: help;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                    position: relative;
                }
                
                .status-icon:hover {
                    transform: scale(1.2);
                    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
                    z-index: 50;
                }
                
                /* Custom styling for battle tooltips */
                .battle-tooltip {
                    position: fixed; /* Use fixed position */
                    background-color: rgba(20, 30, 46, 0.95); /* Darker blue */
                    color: #e2e8f0;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    max-width: 250px;
                    z-index: 9999; /* Very high z-index */
                    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), 0 0 5px rgba(66, 153, 225, 0.5); /* Blue glow */
                    pointer-events: none;
                    border: 1px solid rgba(66, 153, 225, 0.3); /* Subtle blue border */
                    display: none; /* Hide initially */
                    transition: opacity 0.2s ease;
                    text-align: left;
                }
                
                .battle-tooltip.visible {
                    display: block;
                }
                
                .tooltip-title {
                    font-weight: bold;
                    margin-bottom: 4px;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                    padding-bottom: 4px;
                    color: #90cdf4; /* Light blue for title */
                    font-size: 13px;
                }
                
                .tooltip-content {
                    font-size: 11px;
                    line-height: 1.4;
                }

                .tooltip-content div {
                    margin-bottom: 3px;
                }
            `;
            document.head.appendChild(styleEl);
        }
    }

    /**
     * Add a tooltip to a status icon
     * @param {HTMLElement} icon - The status icon element
     * @param {string} content - HTML content for the tooltip
     */
    addStatusTooltip(icon, content) {
        // Add custom class and cursor style
        icon.classList.add('battle-status-tooltip');
        icon.style.cursor = 'help';
        
        // Create the tooltip element if it doesn't exist
        if (!this.battleTooltip) {
            this.battleTooltip = document.createElement('div');
            this.battleTooltip.className = 'battle-tooltip';
            this.battleTooltip.style.position = 'fixed'; // Use fixed positioning
            this.battleTooltip.style.zIndex = '9999'; // Ensure high z-index
            document.body.appendChild(this.battleTooltip);
        }
        
        // Store content on the icon for easy access
        icon.dataset.tooltipContent = content;
        
        // Add event listeners for both hover and click
        icon.addEventListener('mouseenter', () => {
            this.showStatusTooltip(icon, content);
        });
        
        icon.addEventListener('mouseleave', () => {
            this.hideStatusTooltip();
        });
        
        // Also add click event as a fallback
        icon.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent battle UI click events
            this.showStatusTooltip(icon, content);
            
            // Hide tooltip when clicking elsewhere
            const hideOnOutsideClick = (event) => {
                if (!icon.contains(event.target)) {
                    this.hideStatusTooltip();
                    document.removeEventListener('click', hideOnOutsideClick);
                }
            };
            
            // Add a slight delay to avoid immediate trigger
            setTimeout(() => {
                document.addEventListener('click', hideOnOutsideClick);
            }, 10);
        });
    }

    /**
     * Show a status tooltip for an icon
     * @param {HTMLElement} icon - The status icon element
     * @param {string} content - HTML content for the tooltip
     */
    showStatusTooltip(icon, content) {
        // Get tooltip content from data attribute if not provided
        const tooltipContent = content || icon.dataset.tooltipContent; 
        if (!tooltipContent || !this.battleTooltip) return;

        // Set content first
        this.battleTooltip.innerHTML = tooltipContent;
        
        // Position the tooltip before making it visible
        const rect = icon.getBoundingClientRect();
        
        // First set it to a default position
        this.battleTooltip.style.left = `${rect.left + rect.width / 2 - 125}px`; // Center tooltip
        this.battleTooltip.style.top = `${rect.top - 10}px`; // Temporary position
        
        // Force layout recalculation to ensure offsetHeight is accurate
        this.battleTooltip.style.opacity = '0';
        this.battleTooltip.style.display = 'block';
        
        // Now use the correct height to position properly
        const tooltipHeight = this.battleTooltip.offsetHeight;
        this.battleTooltip.style.top = `${rect.top - tooltipHeight - 10}px`; // Position above icon
        
        // Check if tooltip would go offscreen and adjust if needed
        const tooltipRect = this.battleTooltip.getBoundingClientRect();
        if (tooltipRect.left < 10) {
            this.battleTooltip.style.left = '10px';
        }
        if (tooltipRect.right > window.innerWidth - 10) {
            this.battleTooltip.style.left = `${window.innerWidth - 250 - 10}px`;
        }
        if (tooltipRect.top < 10) {
            // If tooltip would go above the screen, position it below the icon instead
            this.battleTooltip.style.top = `${rect.bottom + 10}px`;
        }
        
        // Make visible
        this.battleTooltip.style.opacity = '1';
        this.battleTooltip.classList.add('visible');
    }
    
    /**
     * Hide the status tooltip
     */
    hideStatusTooltip() {
        if (this.battleTooltip) {
            this.battleTooltip.classList.remove('visible');
            this.battleTooltip.style.display = 'none';
        }
    }
    
    /**
     * Copy battle log to clipboard
     */
    copyBattleLog() {
        // Extract plain text from log messages
        const logText = this.logMessages.map(msg => msg.message).join('\n');
        
        // Copy to clipboard
        navigator.clipboard.writeText(logText)
            .then(() => {
                // Show feedback
                const copyButton = document.querySelector('.battle-log button');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#48bb78'; // Green
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                }, 2000);
            })
            .catch(err => {
                console.error('Failed to copy log:', err);
                alert('Failed to copy battle log to clipboard');
            });
    }
}

// Export for use in other modules
window.BattleUI = BattleUI;
// Also make available as a global variable
if (typeof BattleUI === 'undefined') {
    BattleUI = window.BattleUI;
}

console.log('BattleUI class loaded and available as window.BattleUI');

===== FILE: BattleUIDebug.js =====
/**
 * Battle UI Debug Helper
 * Provides debugging and troubleshooting for the BattleUI
 */

class BattleUIDebug {
    /**
     * Create a debug snapshot of the current state of the UI
     * @param {BattleUI} battleUI - The BattleUI instance to debug
     * @returns {Object} Debug information
     */
    static createSnapshot(battleUI) {
        const snapshot = {
            isSetup: battleUI.isSetup,
            playerTeamCount: battleUI.playerTeam.length,
            enemyTeamCount: battleUI.enemyTeam.length,
            domElements: {},
            tailwindStatus: {}
        };
        
        // Check if key elements exist in the DOM
        snapshot.domElements.battleUI = !!document.getElementById('battle-ui');
        snapshot.domElements.battleArena = !!document.getElementById('battle-arena');
        snapshot.domElements.turnDisplay = !!document.getElementById('turn-display');
        snapshot.domElements.logContent = !!document.getElementById('battle-log-content');
        
        // Check Tailwind CSS status
        snapshot.tailwindStatus.linkExists = !!document.getElementById('tailwind-css');
        snapshot.tailwindStatus.interFontExists = !!document.querySelector('link[href*="fonts.googleapis.com/css2?family=Inter"]');
        
        // Check for any CSS classes that are definitely from Tailwind
        const testElement = document.createElement('div');
        testElement.className = 'text-blue-500';
        document.body.appendChild(testElement);
        const computedStyle = window.getComputedStyle(testElement);
        snapshot.tailwindStatus.tailwindWorking = computedStyle.color !== 'rgb(0, 0, 0)'; // If not black, Tailwind might be working
        document.body.removeChild(testElement);
        
        // Create a log of all used colors
        snapshot.cssColors = {};
        document.querySelectorAll('.character-circle').forEach(el => {
            const style = window.getComputedStyle(el);
            const type = el.classList[1]?.replace('bg-', '') || 'unknown';
            snapshot.cssColors[type] = style.backgroundColor;
        });
        
        console.log('BattleUI Debug Snapshot:', snapshot);
        return snapshot;
    }
    
    /**
     * Fix common UI issues
     * @param {BattleUI} battleUI - The BattleUI instance to fix
     */
    static fixCommonIssues(battleUI) {
        console.log('BattleUIDebug: Attempting to fix common issues...');
        
        // Ensure Tailwind CSS is loaded directly
        if (!document.getElementById('tailwind-css')) {
            console.log('BattleUIDebug: Adding Tailwind CSS...');
            const tailwindScript = document.createElement('script');
            tailwindScript.id = 'tailwind-css';
            tailwindScript.src = 'https://cdn.tailwindcss.com';
            document.head.appendChild(tailwindScript);
            
            // Also add Inter font
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap';
            document.head.appendChild(fontLink);
        }
        
        // Force reinstall custom styles
        console.log('BattleUIDebug: Reinstalling custom styles...');
        const existingStyles = document.getElementById('battle-ui-styles');
        if (existingStyles) {
            document.head.removeChild(existingStyles);
        }
        battleUI.addCustomStyles();
        
        // Force update UI elements
        console.log('BattleUIDebug: Forcing UI update...');
        if (battleUI.isSetup && battleUI.playerTeam.length > 0) {
            battleUI.update();
            
            // Re-render characters
            battleUI.renderCharacters(battleUI.playerTeam, battleUI.enemyTeam);
            
            // Reset active character
            if (battleUI.playerTeam.length > 0) {
                battleUI.setActiveCharacter(battleUI.playerTeam[0]);
            }
        }
        
        console.log('BattleUIDebug: Fix attempts completed');
    }
    
    /**
     * Inject a simple fallback UI style if Tailwind CSS fails to load
     */
    static injectFallbackStyles() {
        console.log('BattleUIDebug: Injecting fallback styles...');
        
        const fallbackStyles = document.createElement('style');
        fallbackStyles.id = 'battle-ui-fallback-styles';
        fallbackStyles.textContent = `
            #battle-ui {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #141e2e;
                color: white;
                font-family: Arial, sans-serif;
                z-index: 9999;
                display: flex;
                flex-direction: column;
                padding: 20px;
            }
            
            header {
                background-color: #232a40;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            main {
                flex: 1;
                display: flex;
                gap: 20px;
                justify-content: center;
                align-items: flex-start;
                padding-top: 30px;
                background-color: #1a1a2e;
            }
            
            section {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 20px;
                width: 30%;
            }
            
            h2 {
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 10px;
            }
            
            footer {
                margin-top: 15px;
            }
            
            .character-circle {
                width: 64px;
                height: 64px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 10px;
                border: 2px solid rgba(255, 255, 255, 0.3);
            }
            
            .bg-fire { background-color: #ff4757; }
            .bg-water { background-color: #1e90ff; }
            .bg-nature { background-color: #2ed573; }
            .bg-dark { background-color: #9900cc; }
            .bg-light { background-color: #ffd700; }
            .bg-air { background-color: #70a1ff; }
            
            .hp-bar-container {
                width: 80px;
                margin: 0 auto;
            }
            
            .hp-bar-background {
                background-color: #4a5568;
                height: 8px;
                border-radius: 4px;
                overflow: hidden;
            }
            
            .hp-bar-current {
                background-color: #48bb78;
                height: 100%;
                border-radius: 4px 0 0 4px;
            }
            
            .battle-log {
                height: 150px;
                overflow-y: auto;
                background-color: #232a40;
                padding: 10px;
                border-radius: 8px;
            }
            
            .active-character .character-circle {
                box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6);
            }
            
            button {
                padding: 8px 15px;
                background-color: #3742fa;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                margin-right: 5px;
            }
            
            .control-button {
                background-color: #4a5568;
            }
            
            .control-button.active {
                background-color: #3742fa;
            }
            
            /* Simple floating text animation */
            .floating-text {
                position: absolute;
                top: -25px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 16px;
                font-weight: bold;
                white-space: nowrap;
                z-index: 10;
                animation: float-up-fade-out 1.2s forwards;
            }
            
            @keyframes float-up-fade-out {
                0% {
                    opacity: 0;
                    transform: translate(-50%, 0);
                }
                10% {
                    opacity: 1;
                }
                80% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                    transform: translate(-50%, -30px);
                }
            }
            
            /* Animation for when a character takes damage */
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-5px); }
            }
        `;
        
        document.head.appendChild(fallbackStyles);
        console.log('BattleUIDebug: Fallback styles injected');
    }
}

// Export for use in other modules
window.BattleUIDebug = BattleUIDebug;


===== FILE: SoundManager.js =====
/**
 * Sound Manager
 * Manages sound effects for the UI
 */

class SoundManager {
    /**
     * Create a new Sound Manager
     */
    constructor() {
        this.sounds = {};
        this.muted = false;
        this.volume = 0.5;
        this.audioContext = null;
        
        try {
            // Try to create audio context for generating sounds
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
            console.log('AudioContext initialized');
        } catch (e) {
            console.warn('Web Audio API not supported', e);
        }
        
        // Create DOM element for controlling sound
        this.createSoundControls();
        this.initialize();
    }

    /**
     * Initialize sound effects
     */
    initialize() {
        // Define sound effects - this will use the generated sounds
        // until actual sound files are available
        this.registerSound('click', 'assets/audio/click.mp3');
        this.registerSound('hover', 'assets/audio/hover.mp3');
        this.registerSound('select', 'assets/audio/select.mp3');
        this.registerSound('add', 'assets/audio/add.mp3');
        this.registerSound('remove', 'assets/audio/remove.mp3');
        this.registerSound('error', 'assets/audio/error.mp3');
        this.registerSound('battle_start', 'assets/audio/battle_start.mp3');
        
        console.log('Sound effects registered');
    }
    
    /**
     * Create sound control UI elements
     */
    createSoundControls() {
        // Create sound controls container
        const soundControls = document.createElement('div');
        soundControls.className = 'sound-controls';
        soundControls.style.position = 'fixed';
        soundControls.style.bottom = '20px';
        soundControls.style.right = '20px';
        soundControls.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        soundControls.style.padding = '10px';
        soundControls.style.borderRadius = '5px';
        soundControls.style.zIndex = '1000';
        
        // Create sound toggle button
        const soundToggle = document.createElement('button');
        soundToggle.textContent = 'ðŸ”Š';
        soundToggle.style.background = 'none';
        soundToggle.style.border = 'none';
        soundToggle.style.color = 'white';
        soundToggle.style.fontSize = '24px';
        soundToggle.style.cursor = 'pointer';
        soundToggle.title = 'Toggle Sound';
        
        // Add click event
        soundToggle.addEventListener('click', () => {
            this.toggleMute();
            soundToggle.textContent = this.muted ? 'ðŸ”‡' : 'ðŸ”Š';
        });
        
        // Add to container
        soundControls.appendChild(soundToggle);
        
        // Add volume slider
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.min = '0';
        volumeSlider.max = '100';
        volumeSlider.value = this.volume * 100;
        volumeSlider.style.width = '100px';
        volumeSlider.style.marginLeft = '10px';
        volumeSlider.title = 'Volume';
        
        // Add change event
        volumeSlider.addEventListener('input', (e) => {
            this.setVolume(e.target.value / 100);
        });
        
        // Add to container
        soundControls.appendChild(volumeSlider);
        
        // Add to document
        document.body.appendChild(soundControls);
    }

    /**
     * Register a sound with both file and generated fallback
     * @param {string} id - Sound identifier
     * @param {string} path - Path to sound file
     */
    registerSound(id, path) {
        this.sounds[id] = {
            path: path,
            loaded: false,
            audio: null
        };
        
        // Try to load the sound file
        this.loadSoundFile(id, path);
    }
    
    /**
     * Try to load an actual sound file
     * @param {string} id - Sound identifier
     * @param {string} path - Path to sound file
     */
    loadSoundFile(id, path) {
        // Create an audio element
        const audio = new Audio();
        
        // Set up event listeners
        audio.oncanplaythrough = () => {
            console.log(`Sound loaded: ${id}`);
            this.sounds[id].loaded = true;
            this.sounds[id].audio = audio;
        };
        
        audio.onerror = () => {
            console.log(`Could not load sound file: ${path}. Will use generated sound instead.`);
        };
        
        // Load the file
        try {
            audio.src = path;
            audio.load();
        } catch (e) {
            console.warn(`Error loading sound file ${path}:`, e);
        }
    }

    /**
     * Play a sound effect
     * @param {string} id - Sound identifier
     */
    play(id) {
        if (this.muted || !this.sounds[id]) return;
        
        try {
            // If the sound file is loaded, play it
            if (this.sounds[id].loaded && this.sounds[id].audio) {
                const soundInstance = this.sounds[id].audio.cloneNode();
                soundInstance.volume = this.volume;
                soundInstance.play();
            } else {
                // Otherwise, generate a sound
                this.generateSound(id);
            }
        } catch (e) {
            console.warn(`Error playing sound ${id}:`, e);
        }
    }
    
    /**
     * Generate a sound using Web Audio API
     * @param {string} id - Sound identifier
     */
    generateSound(id) {
        if (!this.audioContext) return;
        
        try {
            // Create oscillator
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            // Set volume
            gainNode.gain.value = this.volume * 0.3; // Lower volume for generated sounds
            
            // Configure sound based on type
            switch (id) {
                case 'click':
                    oscillator.type = 'square';
                    oscillator.frequency.value = 800;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                    break;
                    
                case 'hover':
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 600;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.08);
                    break;
                    
                case 'select':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                    break;
                    
                case 'add':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'remove':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(300, this.audioContext.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'error':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(180, this.audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                    break;
                    
                case 'battle_start':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                    oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.3);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.7);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.7);
                    break;
                    
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            console.log(`Generated sound: ${id}`);
            
        } catch (e) {
            console.warn(`Error generating sound ${id}:`, e);
        }
    }

    /**
     * Set sound volume
     * @param {number} volume - Volume level (0-1)
     */
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        console.log(`Volume set to ${this.volume}`);
    }

    /**
     * Toggle mute state
     * @returns {boolean} - New mute state
     */
    toggleMute() {
        this.muted = !this.muted;
        console.log(`Sound ${this.muted ? 'muted' : 'unmuted'}`);
        return this.muted;
    }

    /**
     * Add hover sound to an element
     * @param {HTMLElement} element - Element to add sound to
     */
    addHoverSound(element) {
        // Hover sounds disabled - too distracting
        // Previously: element.addEventListener('mouseenter', () => this.play('hover'));
    }

    /**
     * Add click sound to an element
     * @param {HTMLElement} element - Element to add sound to
     */
    addClickSound(element) {
        element.addEventListener('click', () => {
            this.play('click');
        });
    }
    
    /**
     * Add sounds to common UI elements
     */
    addSoundsToUI() {
        // Add sounds to all buttons
        document.querySelectorAll('button').forEach(button => {
            this.addHoverSound(button);
            this.addClickSound(button);
        });
        
        // Add sounds to battle mode selectors
        document.querySelectorAll('.battle-mode').forEach(mode => {
            this.addHoverSound(mode);
            mode.addEventListener('click', () => {
                this.play('select');
            });
        });
        
        // Add sounds to hero cards
        document.querySelectorAll('.hero-card').forEach(card => {
            this.addHoverSound(card);
            card.addEventListener('click', () => {
                this.play('select');
            });
        });
        
        // Add sounds to team slots
        document.querySelectorAll('.slot-empty').forEach(slot => {
            this.addHoverSound(slot);
            slot.addEventListener('click', () => {
                this.play('add');
            });
        });
        
        // Add sounds to remove buttons
        document.querySelectorAll('.remove-hero').forEach(button => {
            this.addHoverSound(button);
            button.addEventListener('click', () => {
                this.play('remove');
            });
        });
        
        // Start battle button
        const startButton = document.getElementById('start-battle');
        if (startButton) {
            this.addHoverSound(startButton);
            startButton.addEventListener('click', () => {
                if (!startButton.disabled) {
                    this.play('battle_start');
                } else {
                    this.play('error');
                }
            });
        }
        
        console.log('Added sounds to UI elements');
    }
}

// Create a singleton instance
const soundManager = new SoundManager();

// Make it available globally
window.soundManager = soundManager;

// Add sound effects to UI elements once the page is fully loaded
window.addEventListener('load', () => {
    // Wait a moment for all UI elements to be created
    setTimeout(() => {
        window.soundManager.addSoundsToUI();
    }, 1000);
});


===== FILE: TeamBuilderUI.js =====
/**
 * Team Builder UI
 * Manages the user interface for team selection
 * Based on the React mockup concept
 */

class TeamBuilderUI {
    /**
     * Create a new Team Builder UI
     * @param {TeamManager} teamManager - Reference to the team manager
     */
    constructor(teamManager) {
        this.teamManager = teamManager || null;
        this.availableHeroes = [];
        this.selectedHeroes = [null, null, null];
        this.enemySelectedHeroes = [null, null, null];
        this.selectedHeroDetails = null;
        this.battleMode = 'random';
        this.activeFilters = {
            types: [],
            roles: []
        };
        this.isSelectingEnemyTeam = false; // Flag to track if we're selecting enemy team
        this.imageLoader = null; // Will hold the TeamBuilderImageLoader
        this.typeColors = {
            fire: '#ff4757',
            water: '#1e90ff',
            nature: '#2ed573',
            dark: '#9900cc',
            light: '#ffd700',
            air: '#70a1ff'
        };
        this.rarityColors = {
            Common: '#aaaaaa',
            Uncommon: '#2ed573',
            Rare: '#1e90ff',
            Epic: '#9900cc',
            Legendary: '#ffd700'
        };
    }

    /**
     * Initialize the team builder UI
     */
    async initialize() {
        console.log('TeamBuilderUI: Initializing...');
        // Fetch available heroes from data file
        try {
            // Try both relative and absolute paths
            let response;
            try {
                response = await fetch('data/characters.json');
            } catch (err) {
                console.log('Trying with alternate path...');
                response = await fetch('./data/characters.json');
            }
            const data = await response.json();
            this.availableHeroes = data.characters;
            console.log('TeamBuilderUI: Loaded', this.availableHeroes.length, 'heroes');
            
            // Initialize the image loader
            await this.initializeImageLoader();
            
            this.renderFilters();
            this.renderHeroGrid();
            this.renderTeamSlots();
            this.renderBattleModes();
            this.setupEventListeners();
        } catch (error) {
            console.error('Error loading characters data:', error);
            
            // Display error on the page for debugging
            const heroesGrid = document.getElementById('heroes-grid');
            if (heroesGrid) {
                heroesGrid.innerHTML = `<div style="color: red; padding: 20px;">Error loading heroes data: ${error.message}</div>`;
            }
        }
    }

    /**
     * Render filter options for types and roles
     */
    renderFilters() {
        const heroesSection = document.getElementById('available-heroes');
        
        // Check if filter section already exists
        let filterSection = document.getElementById('hero-filters');
        if (!filterSection) {
            filterSection = document.createElement('div');
            filterSection.id = 'hero-filters';
            
            // Insert filters before the heroes grid
            const heroesGrid = document.getElementById('heroes-grid');
            heroesSection.insertBefore(filterSection, heroesGrid);
        } else {
            filterSection.innerHTML = '';
        }

        // Create type filters
        const typeFilters = document.createElement('div');
        typeFilters.className = 'filter-group';
        
        const typeLabel = document.createElement('div');
        typeLabel.className = 'filter-label';
        typeLabel.textContent = 'Filter by Type:';
        typeFilters.appendChild(typeLabel);
        
        // Get unique types from heroes
        const types = [...new Set(this.availableHeroes.map(hero => hero.type))];
        
        const typeButtonsContainer = document.createElement('div');
        typeButtonsContainer.className = 'filter-buttons';
        
        types.forEach(type => {
            const typeButton = document.createElement('button');
            typeButton.className = `filter-button ${this.activeFilters.types.includes(type) ? 'active' : ''}`;
            typeButton.dataset.type = type;
            typeButton.style.backgroundColor = `${this.typeColors[type]}88`;
            typeButton.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            
            // Add event listener
            typeButton.addEventListener('click', () => {
                const index = this.activeFilters.types.indexOf(type);
                if (index === -1) {
                    // Add filter
                    this.activeFilters.types.push(type);
                    typeButton.classList.add('active');
                } else {
                    // Remove filter
                    this.activeFilters.types.splice(index, 1);
                    typeButton.classList.remove('active');
                }
                
                // Re-render heroes grid
                this.renderHeroGrid();
                
                // Play sound
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            });
            
            // Add hover sound
            if (window.soundManager) {
                window.soundManager.addHoverSound(typeButton);
            }
            
            typeButtonsContainer.appendChild(typeButton);
        });
        
        typeFilters.appendChild(typeButtonsContainer);
        filterSection.appendChild(typeFilters);
        
        // Create role filters
        const roleFilters = document.createElement('div');
        roleFilters.className = 'filter-group';
        
        const roleLabel = document.createElement('div');
        roleLabel.className = 'filter-label';
        roleLabel.textContent = 'Filter by Role:';
        roleFilters.appendChild(roleLabel);
        
        // Get unique roles from heroes
        const roles = [...new Set(this.availableHeroes.map(hero => hero.role))];
        
        const roleButtonsContainer = document.createElement('div');
        roleButtonsContainer.className = 'filter-buttons';
        
        roles.forEach(role => {
            const roleButton = document.createElement('button');
            roleButton.className = `filter-button ${this.activeFilters.roles.includes(role) ? 'active' : ''}`;
            roleButton.dataset.role = role;
            roleButton.textContent = role;
            
            // Add event listener
            roleButton.addEventListener('click', () => {
                const index = this.activeFilters.roles.indexOf(role);
                if (index === -1) {
                    // Add filter
                    this.activeFilters.roles.push(role);
                    roleButton.classList.add('active');
                } else {
                    // Remove filter
                    this.activeFilters.roles.splice(index, 1);
                    roleButton.classList.remove('active');
                }
                
                // Re-render heroes grid
                this.renderHeroGrid();
                
                // Play sound
                if (window.soundManager) {
                    window.soundManager.play('click');
                }
            });
            
            // Add hover sound
            if (window.soundManager) {
                window.soundManager.addHoverSound(roleButton);
            }
            
            roleButtonsContainer.appendChild(roleButton);
        });
        
        roleFilters.appendChild(roleButtonsContainer);
        filterSection.appendChild(roleFilters);
        
        // Add clear filters button
        const clearButton = document.createElement('button');
        clearButton.className = 'clear-filters-btn';
        clearButton.textContent = 'Clear Filters';
        clearButton.addEventListener('click', () => {
            this.activeFilters.types = [];
            this.activeFilters.roles = [];
            this.renderFilters();
            this.renderHeroGrid();
            
            // Play sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
        });
        
        // Add hover sound
        if (window.soundManager) {
            window.soundManager.addHoverSound(clearButton);
        }
        
        filterSection.appendChild(clearButton);
    }

    /**
     * Render the available heroes grid
     */
    renderHeroGrid() {
        const heroesGrid = document.getElementById('heroes-grid');
        heroesGrid.innerHTML = '';

        // Filter heroes based on active filters
        let filteredHeroes = [...this.availableHeroes];
        
        // Apply type filters
        if (this.activeFilters.types.length > 0) {
            filteredHeroes = filteredHeroes.filter(hero => 
                this.activeFilters.types.includes(hero.type)
            );
        }
        
        // Apply role filters
        if (this.activeFilters.roles.length > 0) {
            filteredHeroes = filteredHeroes.filter(hero => 
                this.activeFilters.roles.includes(hero.role)
            );
        }

        // Display message if no heroes match filters
        if (filteredHeroes.length === 0) {
            const noHeroes = document.createElement('div');
            noHeroes.className = 'no-heroes-message';
            noHeroes.textContent = 'No heroes match your filters';
            heroesGrid.appendChild(noHeroes);
            return;
        }

        filteredHeroes.forEach(hero => {
            const heroCard = document.createElement('div');
            heroCard.className = 'hero-card';
            heroCard.style.backgroundColor = `${this.typeColors[hero.type]}22`;
            heroCard.dataset.heroId = hero.id;

            if (this.selectedHeroDetails && this.selectedHeroDetails.id === hero.id) {
                heroCard.classList.add('selected');
            }

            const heroContent = document.createElement('div');
            heroContent.className = 'hero-card-content';

            // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
            const heroIconContainer = document.createElement('div');
            heroIconContainer.className = 'hero-avatar-container';
            heroIconContainer.dataset.characterId = hero.id;
            heroIconContainer.dataset.characterName = hero.name;
            heroIconContainer.dataset.artSynced = '0';
            // No background color set - will only be visible if character art exists
            
            // Create art wrapper for character images - this is all we need now
            const artWrapper = document.createElement('div');
            artWrapper.className = 'hero-art-wrapper';
            
            // Assemble the icon structure
            heroIconContainer.appendChild(artWrapper);

            const heroText = document.createElement('div');
            heroText.className = 'hero-card-text';

            const heroName = document.createElement('div');
            heroName.className = 'hero-name';
            heroName.textContent = hero.name;

            const heroType = document.createElement('div');
            heroType.className = 'hero-type';
            
            const typeText = document.createElement('span');
            typeText.style.color = this.typeColors[hero.type];
            typeText.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);
            
            const separator = document.createElement('span');
            separator.textContent = ' â€¢ ';
            
            const roleText = document.createElement('span');
            roleText.textContent = hero.role;

            heroType.appendChild(typeText);
            heroType.appendChild(separator);
            heroType.appendChild(roleText);

            heroText.appendChild(heroName);
            heroText.appendChild(heroType);

            heroContent.appendChild(heroIconContainer);
            heroContent.appendChild(heroText);

            heroCard.appendChild(heroContent);
            heroesGrid.appendChild(heroCard);

            // Add event listener
            heroCard.addEventListener('click', () => this.selectHeroDetails(hero));
        });
        
        // Force image loader to check for new images
        if (this.imageLoader) {
            this.imageLoader.forceCheck();
        }
    }

    /**
     * Render the team slots
     */
    renderTeamSlots() {
        const teamSlots = document.getElementById('team-slots');
        teamSlots.innerHTML = '';
        
        // Add team heading that shows which team we're building
        const teamHeading = document.createElement('div');
        teamHeading.className = 'team-heading team-heading-change';
        teamHeading.id = 'team-heading';
        teamHeading.textContent = this.isSelectingEnemyTeam ? 'Enemy Team' : 'Your Team';
        teamHeading.style.color = this.isSelectingEnemyTeam ? '#ff4757' : '#1e90ff';
        teamSlots.appendChild(teamHeading);
        
        // Add class to container if selecting enemy team
        if (this.isSelectingEnemyTeam) {
            teamSlots.classList.add('is-selecting-enemy');
        } else {
            teamSlots.classList.remove('is-selecting-enemy');
        }
        
        // Get the right array based on what we're selecting
        const currentTeam = this.isSelectingEnemyTeam ? this.enemySelectedHeroes : this.selectedHeroes;

        // Create 3 team slots
        for (let i = 0; i < 3; i++) {
            const slotElement = document.createElement('div');
            slotElement.className = 'team-slot';

            const slotLabel = document.createElement('div');
            slotLabel.className = 'slot-label';
            slotLabel.textContent = `${i + 1}${this.getOrdinalSuffix(i + 1)} Pick`;

            const slotContent = document.createElement('div');
            slotContent.className = 'slot-content';
            
            // Enemy team styling is handled by CSS via the is-selecting-enemy class

            if (currentTeam[i]) {
                // Slot is filled
                slotContent.classList.add('slot-filled');
                slotContent.style.backgroundColor = `${this.typeColors[currentTeam[i].type]}33`;

                const heroDetails = document.createElement('div');
                heroDetails.className = 'hero-details';
                
                // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
                const heroIconContainer = document.createElement('div');
                heroIconContainer.className = 'hero-avatar-container';
                heroIconContainer.dataset.characterId = currentTeam[i].id;
                heroIconContainer.dataset.characterName = currentTeam[i].name;
                heroIconContainer.dataset.artSynced = '0';
                // No background color set - will only be visible if character art exists
                
                // Create art wrapper for character images
                const artWrapper = document.createElement('div');
                artWrapper.className = 'hero-art-wrapper';
                
                // Assemble the icon structure
                heroIconContainer.appendChild(artWrapper);

                const heroInfo = document.createElement('div');
                heroInfo.className = 'hero-info';

                const heroName = document.createElement('div');
                heroName.className = 'hero-name';
                heroName.style.fontWeight = 'bold';
                heroName.textContent = currentTeam[i].name;

                const heroType = document.createElement('div');
                heroType.className = 'hero-type';
                heroType.style.fontSize = '12px';
                heroType.innerHTML = `<span style="color: ${this.typeColors[currentTeam[i].type]}">${currentTeam[i].type.charAt(0).toUpperCase() + currentTeam[i].type.slice(1)}</span> â€¢ ${currentTeam[i].role}`;

                // Basic stats
                const heroStats = document.createElement('div');
                heroStats.className = 'hero-stats';
                heroStats.style.fontSize = '12px';
                heroStats.style.color = '#a4b0be';
                heroStats.textContent = `HP: ${currentTeam[i].stats.hp} | ATK: ${currentTeam[i].stats.attack} | DEF: ${currentTeam[i].stats.defense}`;
                
                // Add advanced stats in condensed format
                const heroAdvStats = document.createElement('div');
                heroAdvStats.className = 'hero-adv-stats';
                heroAdvStats.style.fontSize = '11px';
                heroAdvStats.style.color = '#a4b0be';
                
                // Check if expanded stats exist before displaying them
                if (currentTeam[i].stats.strength && currentTeam[i].stats.intellect && currentTeam[i].stats.spirit) {
                    heroAdvStats.textContent = `STR: ${currentTeam[i].stats.strength} | INT: ${currentTeam[i].stats.intellect} | SPI: ${currentTeam[i].stats.spirit}`;
                    heroInfo.appendChild(heroAdvStats);
                }

                heroInfo.appendChild(heroName);
                heroInfo.appendChild(heroType);
                heroInfo.appendChild(heroStats);

                heroDetails.appendChild(heroIconContainer);
                heroDetails.appendChild(heroInfo);

                const removeButton = document.createElement('button');
                removeButton.className = 'remove-hero';
                removeButton.textContent = 'Ã—';
                removeButton.dataset.slotIndex = i;
                removeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeHeroFromTeam(i);
                });

                slotContent.appendChild(heroDetails);
                slotContent.appendChild(removeButton);
            } else {
                // Slot is empty
                slotContent.classList.add('slot-empty');

                const emptyText = document.createElement('span');
                if (this.selectedHeroDetails) {
                    emptyText.textContent = `Click to place ${this.selectedHeroDetails.name} here`;
                } else {
                    emptyText.textContent = 'Select a hero first';
                    emptyText.style.color = '#a4b0be';
                }

                slotContent.appendChild(emptyText);
                slotContent.dataset.slotIndex = i;
                slotContent.addEventListener('click', () => this.addHeroToTeam(i));
            }

            slotElement.appendChild(slotLabel);
            slotElement.appendChild(slotContent);
            teamSlots.appendChild(slotElement);
        }
        
        // If we're in enemy selection mode, add a Back button to return to player team
        if (this.isSelectingEnemyTeam) {
            const backButton = document.createElement('button');
            backButton.className = 'enemy-team-control-btn';
            backButton.textContent = 'Back to Your Team';
            backButton.addEventListener('click', () => {
                this.isSelectingEnemyTeam = false;
                this.renderTeamSlots();
                this.renderTeamSynergies();
                this.updateStartBattleButton();
            });
            teamSlots.appendChild(backButton);
        }

        // Update synergies - only show for player team
        if (!this.isSelectingEnemyTeam) {
            this.renderTeamSynergies();
        }
        
        // Update the start battle button
        this.updateStartBattleButton();
        
        // Force image loader to check for new images
        if (this.imageLoader) {
            this.imageLoader.forceCheck();
        }
    }

    /**
     * Render the team synergies
     */
    renderTeamSynergies() {
        const synergiesList = document.getElementById('synergies-list');
        synergiesList.innerHTML = '';

        const synergies = this.calculateSynergies();

        if (synergies.length > 0) {
            synergies.forEach(synergy => {
                const synergyItem = document.createElement('li');
                synergyItem.textContent = synergy;
                synergiesList.appendChild(synergyItem);
            });
        } else {
            const noSynergies = document.createElement('li');
            noSynergies.textContent = 'No active synergies yet';
            noSynergies.style.color = '#a4b0be';
            synergiesList.appendChild(noSynergies);
        }
    }

    /**
     * Render the hero details panel
     */
    renderHeroDetails() {
        const detailContent = document.getElementById('detail-content');
        
        // Keep track of previous hero name for intelligent comparison
        const previousHeroId = this.previousHeroId || null;
        this.previousHeroId = this.selectedHeroDetails ? this.selectedHeroDetails.id : null;
        
        // CRITICAL: Disable art observer during detail panel updates
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            // OPTIMIZATION: Instead of clearing all content, preserve the wrapper structure
            const existingDetail = detailContent.querySelector('.detail-hero');
            const existingWrapper = detailContent.querySelector('.hero-avatar-container.detail-icon-container');
            
            // Only clear content if either:
            // 1. No hero is selected (show empty state) OR
            // 2. No existing detail content exists
            if (!this.selectedHeroDetails) {
                // Just emptying content for "no hero selected" state
                detailContent.innerHTML = '';
                
                // No hero selected - show empty state and exit
                const detailEmpty = document.createElement('div');
                detailEmpty.className = 'detail-empty';
                detailEmpty.textContent = 'Select a hero to view details';
                detailContent.appendChild(detailEmpty);
                return;
            }
            
            // If details already exist with a wrapper, update the existing details
            // This preserves the image container for ALL heroes, not just Aqualia
            if (existingDetail && existingWrapper) {
                console.log(`Preserving art wrapper while updating details for ${this.selectedHeroDetails.name}`);
                this.updateExistingHeroDetails(existingDetail);
                return;
            }
        
        // Regular rendering for other heroes or first-time rendering
        const hero = this.selectedHeroDetails;
        const detailHero = document.createElement('div');
        detailHero.className = 'detail-hero';
        detailHero.style.backgroundColor = `${this.typeColors[hero.type]}22`;

        // Header section
        const detailHeader = document.createElement('div');
        detailHeader.className = 'detail-header';

        // Create avatar container structure for character art - NO VISIBLE BACKGROUNDS
        const detailIconContainer = document.createElement('div');
        detailIconContainer.className = 'hero-avatar-container detail-icon-container';
        detailIconContainer.dataset.characterId = hero.id;
        detailIconContainer.dataset.characterName = hero.name;
        // No background color set - will only be visible if character art exists
        
        // Create art wrapper for character images
        const artWrapper = document.createElement('div');
        artWrapper.className = 'hero-art-wrapper';
        
        // Assemble the icon structure
        detailIconContainer.appendChild(artWrapper);

        const detailNameType = document.createElement('div');
        detailNameType.className = 'detail-name-type';

        const heroName = document.createElement('h3');
        heroName.textContent = hero.name;

        const detailTags = document.createElement('div');
        detailTags.className = 'detail-tags';

        const typeTag = document.createElement('span');
        typeTag.className = 'detail-tag';
        typeTag.style.backgroundColor = this.typeColors[hero.type];
        typeTag.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);

        const roleTag = document.createElement('span');
        roleTag.className = 'detail-tag';
        roleTag.style.backgroundColor = '#2f3542';
        roleTag.textContent = hero.role;

        const rarityTag = document.createElement('span');
        rarityTag.className = 'detail-tag';
        rarityTag.style.backgroundColor = this.rarityColors[hero.rarity];
        rarityTag.textContent = hero.rarity;

        detailTags.appendChild(typeTag);
        detailTags.appendChild(roleTag);
        detailTags.appendChild(rarityTag);

        detailNameType.appendChild(heroName);
        detailNameType.appendChild(detailTags);

        detailHeader.appendChild(detailIconContainer);
        detailHeader.appendChild(detailNameType);

        // Stats section
        const detailStats = document.createElement('div');
        detailStats.className = 'detail-stats';

        // Add CSS to detail-stats to use flex-column
        detailStats.style.display = 'flex';
        detailStats.style.flexDirection = 'column';
        detailStats.style.gap = '8px';

        // First row of stats (existing)
        const statsRow1 = document.createElement('div');
        statsRow1.className = 'stats-row';
        statsRow1.style.display = 'flex';
        statsRow1.style.justifyContent = 'space-between';
        statsRow1.style.gap = '8px';

        const hpStat = this.createStatBox('HP', hero.stats.hp, 'Health Points - How much damage a character can take before being defeated');
        const atkStat = this.createStatBox('ATK', hero.stats.attack, 'Attack Power - Determines basic attack damage');
        const defStat = this.createStatBox('DEF', hero.stats.defense, 'Defense - Reduces damage taken from attacks');
        const spdStat = this.createStatBox('SPD', hero.stats.speed, 'Speed - Determines turn order in battle (higher goes first)');

        statsRow1.appendChild(hpStat);
        statsRow1.appendChild(atkStat);
        statsRow1.appendChild(defStat);
        statsRow1.appendChild(spdStat);

        // Only add second row if expanded stats exist
        if (hero.stats.strength && hero.stats.intellect && hero.stats.spirit) {
            // Second row of stats (new)
            const statsRow2 = document.createElement('div');
            statsRow2.className = 'stats-row';
            statsRow2.style.display = 'flex';
            statsRow2.style.justifyContent = 'space-between';
            statsRow2.style.gap = '8px';

            const strStat = this.createStatBox('STR', hero.stats.strength, 'Strength - Increases physical ability damage');
            const intStat = this.createStatBox('INT', hero.stats.intellect, 'Intellect - Increases spell ability damage');
            const spiStat = this.createStatBox('SPI', hero.stats.spirit, 'Spirit - Increases healing effectiveness');

            statsRow2.appendChild(strStat);
            statsRow2.appendChild(intStat);
            statsRow2.appendChild(spiStat);

            // Add both rows
            detailStats.appendChild(statsRow1);
            detailStats.appendChild(statsRow2);
        } else {
            // Just add the first row if no expanded stats
            detailStats.appendChild(statsRow1);
        }

        // Abilities section
        const detailAbilities = document.createElement('div');
        detailAbilities.className = 'detail-abilities';

        const abilitiesTitle = document.createElement('h4');
        abilitiesTitle.textContent = 'Abilities';

        detailAbilities.appendChild(abilitiesTitle);

        hero.abilities.forEach(ability => {
            const abilityBox = document.createElement('div');
            abilityBox.className = 'ability-box';

            const abilityName = document.createElement('div');
            abilityName.className = 'ability-name';
            abilityName.textContent = ability.name;

            const abilityDesc = document.createElement('div');
            abilityDesc.className = 'ability-desc';
            abilityDesc.textContent = ability.description;

            abilityBox.appendChild(abilityName);
            abilityBox.appendChild(abilityDesc);
            detailAbilities.appendChild(abilityBox);
            
            // Add tooltip with more detailed info
            if (window.tooltipManager) {
                const cooldownText = ability.cooldown > 0 ? `Cooldown: ${ability.cooldown} turns` : 'No cooldown';
                
                // Get detailed scaling information with formula
                const detailedScaling = this.getDetailedScalingText(ability, hero);
                
                const tooltipContent = `
                    <div class="tooltip-title">${ability.name}</div>
                    <div>${ability.description}</div>
                    <div class="tooltip-content">
                        ${detailedScaling.damageText}
                        <div>${cooldownText}</div>
                        <div>Type: ${ability.damageType || (ability.isHealing ? 'Healing' : 'Damage')}</div>
                        <div>${detailedScaling.scalingText}</div>
                    </div>
                `;
                
                window.tooltipManager.addTooltip(abilityBox, tooltipContent);
                abilityBox.classList.add('has-tooltip');
            }
        });

        // Advantages section
        const detailAdvantages = document.createElement('div');
        detailAdvantages.className = 'detail-advantages';

        const advantagesTitle = document.createElement('h4');
        advantagesTitle.textContent = 'Advantages';

        const advantagesList = document.createElement('div');
        advantagesList.className = 'advantage-list';
        
        let advantageHTML = '';
        let tooltipContent = `<div class="tooltip-title">Type Advantages</div><div class="tooltip-content">`;

        // Add type advantages based on hero type
        switch (hero.type) {
            case 'fire':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.nature}">Nature</span>`;
                tooltipContent += 'Fire does 50% more damage to Nature types.<br>Fire takes 50% more damage from Water types.';
                break;
            case 'water':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.fire}">Fire</span>`;
                tooltipContent += 'Water does 50% more damage to Fire types.<br>Water takes 50% more damage from Nature types.';
                break;
            case 'nature':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.water}">Water</span>`;
                tooltipContent += 'Nature does 50% more damage to Water types.<br>Nature takes 50% more damage from Fire types.';
                break;
            case 'light':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.dark}">Dark</span>`;
                tooltipContent += 'Light does 50% more damage to Dark types.<br>Light takes 50% more damage from Dark types.';
                break;
            case 'dark':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.light}">Light</span>`;
                tooltipContent += 'Dark does 50% more damage to Light types.<br>Dark takes 50% more damage from Light types.';
                break;
            case 'air':
                advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.earth || '#8B4513'}">Earth</span>`;
                tooltipContent += 'Air does 50% more damage to Earth types.<br>Air takes 50% more damage from Electric types.';
                break;
        }
        
        tooltipContent += '</div>';
        advantagesList.innerHTML = advantageHTML;
        
        // Add tooltip to advantages section
        if (window.tooltipManager) {
            window.tooltipManager.addTooltip(advantagesList, tooltipContent);
            advantagesList.classList.add('has-tooltip');
        }

        detailAdvantages.appendChild(advantagesTitle);
        detailAdvantages.appendChild(advantagesList);

        // Add all sections to the detail content
        detailHero.appendChild(detailHeader);
        detailHero.appendChild(detailStats);
        detailHero.appendChild(detailAbilities);
        detailHero.appendChild(detailAdvantages);

        detailContent.appendChild(detailHero);
        
        // If this character has art, add it directly without relying on the observer
        if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[hero.name]) {
            this.addArtToDetailPanel(hero, detailIconContainer);
        }
        } finally {
            // Re-enable art observer after all detail panel updates are complete
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }
    
    /**
     * Get detailed scaling text with formula for ability tooltips
     * @param {Object} ability - The ability object
     * @param {Object} hero - The hero object for stat reference
     * @returns {Object} Object with damageText and scalingText
     */
    getDetailedScalingText(ability, hero) {
        let scalingText = '';
        let damageText = '';
        let statValue = 0;
        
        if (ability.isHealing || ability.damageType === 'healing') {
            // Healing ability scaling with Spirit
            statValue = hero.stats.spirit || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalHealing = ability.damage + scalingAmount;
            
            damageText = `<div>Healing: ${ability.damage} + (50% of Spirit) = ${totalHealing} HP</div>`;
            scalingText = `${ability.name} restores ${ability.damage} + (50% of Spirit) health`;
        } 
        else if (ability.damageType === 'physical') {
            // Physical ability scaling with Strength
            statValue = hero.stats.strength || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalDamage = ability.damage + scalingAmount;
            
            damageText = `<div>Damage: ${ability.damage} + (50% of Strength) = ${totalDamage} pre-defense</div>`;
            scalingText = `${ability.name} deals ${ability.damage} + (50% of Strength) damage`;
        } 
        else if (ability.damageType === 'spell') {
            // Spell ability scaling with Intellect
            statValue = hero.stats.intellect || 0;
            const scalingAmount = Math.floor(statValue * 0.5);
            const totalDamage = ability.damage + scalingAmount;
            
            damageText = `<div>Damage: ${ability.damage} + (50% of Intellect) = ${totalDamage} pre-defense</div>`;
            scalingText = `${ability.name} deals ${ability.damage} + (50% of Intellect) damage`;
        }
        else if (ability.damageType === 'utility') {
            // Utility ability scaling with Spirit
            damageText = `<div>Effect scales with Spirit</div>`;
            scalingText = `${ability.name}'s effectiveness scales with Spirit`;
        }
        else {
            // Default case (no scaling)
            damageText = ability.isHealing ? 
                `<div>Healing: ${ability.damage} HP</div>` : 
                `<div>Damage: ${ability.damage} points</div>`;
            scalingText = "No scaling";
        }
        
        return { damageText, scalingText };
    }
    
    /**
     * Add character art directly to a detail panel without using the observer
     */
    addArtToDetailPanel(hero, detailIconContainer) {
        // Find art wrapper or create one
        let artWrapper = detailIconContainer.querySelector('.hero-art-wrapper');
        if (!artWrapper) {
            artWrapper = document.createElement('div');
            artWrapper.className = 'hero-art-wrapper';
            artWrapper.style.display = 'block';
            detailIconContainer.appendChild(artWrapper);
        }
        
        // Clear any existing art
        while (artWrapper.firstChild) {
            artWrapper.removeChild(artWrapper.firstChild);
        }
        
        // Clone image from cache
        const newImg = window.CHARACTER_IMAGE_CACHE[hero.name].cloneNode(true);
        
        // Set styling for detail view
        newImg.className = 'character-art team-builder-art';
        newImg.alt = hero.name;
        newImg.style.position = 'absolute';
        
        // Get character positioning data
        const character = this.availableHeroes.find(c => c.id == hero.id);
        const artSettings = character?.detailArt || character?.teamBuilderArt || character?.art || {};
        
        // Apply custom positioning for this character
        newImg.style.left = artSettings.left || '-30px';
        newImg.style.top = artSettings.top || '-45px';
        newImg.style.width = artSettings.width || '140px';
        newImg.style.height = artSettings.height || '140px';
        newImg.style.visibility = 'visible';
        newImg.style.display = 'block';
        newImg.style.zIndex = '100';
        
        // Add the image to the wrapper
        artWrapper.appendChild(newImg);
        
        // Add relevant classes
        detailIconContainer.classList.add('has-art');
        const detailHero = detailIconContainer.closest('.detail-hero');
        if (detailHero) detailHero.classList.add('has-art');
    }
    
    /**
     * Update an existing hero details panel without rebuilding the entire DOM structure
     * This applies to all heroes to preserve character art in the details panel
     */
    updateExistingHeroDetails(detailHero) {
        const hero = this.selectedHeroDetails;
        
        // Disable observer while updating
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            // Important: Update the data attributes on the wrapper to match the new hero
            const detailIconContainer = detailHero.querySelector('.hero-avatar-container.detail-icon-container');
            if (detailIconContainer) {
                // Update the container to reflect the new character
                detailIconContainer.dataset.characterId = hero.id;
                detailIconContainer.dataset.characterName = hero.name;
                
                // Add art directly if available, bypassing observer
                if (window.CHARACTER_IMAGE_CACHE && window.CHARACTER_IMAGE_CACHE[hero.name]) {
                    this.addArtToDetailPanel(hero, detailIconContainer);
                }
            }
            
            // Update background color for the detail hero container
            if (detailHero) {
                detailHero.style.backgroundColor = `${this.typeColors[hero.type]}22`;
            }
        
            // Update the hero name and tags
            const heroNameEl = detailHero.querySelector('.detail-name-type h3');
            if (heroNameEl) heroNameEl.textContent = hero.name;
            
            // Update the type, role, and rarity tags
            const typeTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(1)');
            if (typeTag) {
                typeTag.style.backgroundColor = this.typeColors[hero.type];
                typeTag.textContent = hero.type.charAt(0).toUpperCase() + hero.type.slice(1);
            }
            
            const roleTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(2)');
            if (roleTag) roleTag.textContent = hero.role;
            
            const rarityTag = detailHero.querySelector('.detail-tags .detail-tag:nth-child(3)');
            if (rarityTag) {
                rarityTag.style.backgroundColor = this.rarityColors[hero.rarity];
                rarityTag.textContent = hero.rarity;
            }
            
            // Get or create stats container
            const detailStats = detailHero.querySelector('.detail-stats');
            if (detailStats) {
                // Clear existing stat rows
                detailStats.innerHTML = '';

                // First row of stats (existing)
                const statsRow1 = document.createElement('div');
                statsRow1.className = 'stats-row';
                statsRow1.style.display = 'flex';
                statsRow1.style.justifyContent = 'space-between';
                statsRow1.style.gap = '8px';

                const hpStat = this.createStatBox('HP', hero.stats.hp, 'Health Points - How much damage a character can take before being defeated');
                const atkStat = this.createStatBox('ATK', hero.stats.attack, 'Attack Power - Determines basic attack damage');
                const defStat = this.createStatBox('DEF', hero.stats.defense, 'Defense - Reduces damage taken from attacks');
                const spdStat = this.createStatBox('SPD', hero.stats.speed, 'Speed - Determines turn order in battle (higher goes first)');
                
                statsRow1.appendChild(hpStat);
                statsRow1.appendChild(atkStat);
                statsRow1.appendChild(defStat);
                statsRow1.appendChild(spdStat);
                
                // Only add second row if expanded stats exist
                if (hero.stats.strength && hero.stats.intellect && hero.stats.spirit) {
                    // Second row of stats (new)
                    const statsRow2 = document.createElement('div');
                    statsRow2.className = 'stats-row';
                    statsRow2.style.display = 'flex';
                    statsRow2.style.justifyContent = 'space-between';
                    statsRow2.style.gap = '8px';

                    const strStat = this.createStatBox('STR', hero.stats.strength, 'Strength - Increases physical ability damage');
                    const intStat = this.createStatBox('INT', hero.stats.intellect, 'Intellect - Increases spell ability damage');
                    const spiStat = this.createStatBox('SPI', hero.stats.spirit, 'Spirit - Increases healing effectiveness');

                    statsRow2.appendChild(strStat);
                    statsRow2.appendChild(intStat);
                    statsRow2.appendChild(spiStat);

                    // Add rows to stats container
                    detailStats.appendChild(statsRow1);
                    detailStats.appendChild(statsRow2);
                } else {
                    // Just add the first row if no expanded stats
                    detailStats.appendChild(statsRow1);
                }
            }
            
            // Update abilities (a bit more complex - might need to rebuild this section)
            const abilitiesContainer = detailHero.querySelector('.detail-abilities');
            if (abilitiesContainer) {
                // Keep the title but replace all ability boxes
                const abilitiesTitle = abilitiesContainer.querySelector('h4');
                abilitiesContainer.innerHTML = '';
                abilitiesContainer.appendChild(abilitiesTitle);
                
                // Re-add all abilities
                hero.abilities.forEach(ability => {
                    const abilityBox = document.createElement('div');
                    abilityBox.className = 'ability-box';

                    const abilityName = document.createElement('div');
                    abilityName.className = 'ability-name';
                    abilityName.textContent = ability.name;

                    const abilityDesc = document.createElement('div');
                    abilityDesc.className = 'ability-desc';
                    abilityDesc.textContent = ability.description;

                    abilityBox.appendChild(abilityName);
                    abilityBox.appendChild(abilityDesc);
                    abilitiesContainer.appendChild(abilityBox);
                    
                    // Re-add tooltips
                    if (window.tooltipManager) {
                        const cooldownText = ability.cooldown > 0 ? `Cooldown: ${ability.cooldown} turns` : 'No cooldown';
                        
                        // Get detailed scaling information with formula
                        const detailedScaling = this.getDetailedScalingText(ability, hero);
                        
                        const tooltipContent = `
                            <div class="tooltip-title">${ability.name}</div>
                            <div>${ability.description}</div>
                            <div class="tooltip-content">
                                ${detailedScaling.damageText}
                                <div>${cooldownText}</div>
                                <div>Type: ${ability.damageType || (ability.isHealing ? 'Healing' : 'Damage')}</div>
                                <div>${detailedScaling.scalingText}</div>
                            </div>
                        `;
                        
                        window.tooltipManager.addTooltip(abilityBox, tooltipContent);
                        abilityBox.classList.add('has-tooltip');
                    }
                });
            }
            
            // Update advantages section
            const advantagesList = detailHero.querySelector('.advantage-list');
            if (advantagesList) {
                let advantageHTML = '';
                let tooltipContent = `<div class="tooltip-title">Type Advantages</div><div class="tooltip-content">`;

                // Update type advantages based on hero type
                switch (hero.type) {
                    case 'fire':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.nature}">Nature</span>`;
                        tooltipContent += 'Fire does 50% more damage to Nature types.<br>Fire takes 50% more damage from Water types.';
                        break;
                    case 'water':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.fire}">Fire</span>`;
                        tooltipContent += 'Water does 50% more damage to Fire types.<br>Water takes 50% more damage from Nature types.';
                        break;
                    case 'nature':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.water}">Water</span>`;
                        tooltipContent += 'Nature does 50% more damage to Water types.<br>Nature takes 50% more damage from Fire types.';
                        break;
                    case 'light':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.dark}">Dark</span>`;
                        tooltipContent += 'Light does 50% more damage to Dark types.<br>Light takes 50% more damage from Dark types.';
                        break;
                    case 'dark':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.light}">Light</span>`;
                        tooltipContent += 'Dark does 50% more damage to Light types.<br>Dark takes 50% more damage from Light types.';
                        break;
                    case 'air':
                        advantageHTML = `â€¢ Strong against: <span style="color: ${this.typeColors.earth || '#8B4513'}">Earth</span>`;
                        tooltipContent += 'Air does 50% more damage to Earth types.<br>Air takes 50% more damage from Electric types.';
                        break;
                }
                
                tooltipContent += '</div>';
                advantagesList.innerHTML = advantageHTML;
                
                // Update tooltip for advantages section
                if (window.tooltipManager) {
                    window.tooltipManager.addTooltip(advantagesList, tooltipContent);
                    if (!advantagesList.classList.contains('has-tooltip')) {
                        advantagesList.classList.add('has-tooltip');
                    }
                }
            }
        
        } finally {
            // Re-enable the observer when done
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }

    /**
     * Render battle mode options
     */
    renderBattleModes() {
        const battleModes = document.getElementById('battle-modes');
        battleModes.innerHTML = '';

        const modes = [
            {
                id: 'random',
                name: 'Random Opponent',
                description: 'Battle against a randomly generated team'
            },
            {
                id: 'custom',
                name: 'Custom Battle',
                description: 'Choose your opponent\'s team composition'
            },
            {
                id: 'campaign',
                name: 'Campaign Mode',
                description: 'Fight through increasingly difficult encounters'
            }
        ];

        modes.forEach(mode => {
            const modeElement = document.createElement('div');
            
            // Add special class for custom mode when selecting enemy team
            let selectedClass = mode.id === this.battleMode ? 'selected' : '';
            if (mode.id === 'custom' && this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                selectedClass = 'selected enemy-selection-active';
            }
            
            modeElement.className = `battle-mode ${selectedClass}`;
            modeElement.dataset.modeId = mode.id;

            const modeName = document.createElement('div');
            modeName.className = 'battle-mode-name';
            modeName.textContent = mode.name;
            
            // Add indicator for enemy team selection
            if (mode.id === 'custom' && this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                modeName.innerHTML = `${mode.name} <span style="color: #ff4757; font-size: 12px;">(Selecting Enemy)</span>`;
            }

            const modeDesc = document.createElement('div');
            modeDesc.className = 'battle-mode-desc';
            modeDesc.textContent = mode.description;

            modeElement.appendChild(modeName);
            modeElement.appendChild(modeDesc);
            battleModes.appendChild(modeElement);

            // Add event listener
            modeElement.addEventListener('click', () => {
                // Only allow changing battle mode if not in enemy selection mode
                if (!this.isSelectingEnemyTeam || mode.id === this.battleMode) {
                    this.battleMode = mode.id;
                    this.renderBattleModes();
                    
                    // Reset enemy selection when changing modes
                    if (this.isSelectingEnemyTeam && mode.id !== 'custom') {
                        this.isSelectingEnemyTeam = false;
                        this.renderTeamSlots();
                    }
                } else {
                    // If in enemy selection, show a message that they should complete or cancel enemy selection first
                    if (window.soundManager) {
                        window.soundManager.play('error');
                    }
                    alert('Please complete enemy team selection or click "Back to Your Team" before changing battle mode');
                }
            });
        });
    }

    /**
     * Update the start battle button state
     */
    updateStartBattleButton() {
        const startButton = document.getElementById('start-battle');
        const hasTeamMembers = this.selectedHeroes.some(hero => hero !== null);
        
        // For Custom Battle mode, we need to check if we're ready to select enemy team
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // If we have team members but haven't begun enemy team selection
            if (hasTeamMembers) {
                startButton.textContent = 'Choose Enemy Team';
                startButton.disabled = false;
            } else {
                startButton.textContent = 'Start Battle';
                startButton.disabled = true;
            }
        } else {
            // For Random and Campaign modes, or if we're already selecting enemy team
            startButton.textContent = 'Start Battle';
            
            if (this.isSelectingEnemyTeam) {
                // When selecting enemy team, we need at least one enemy
                startButton.disabled = !this.enemySelectedHeroes.some(hero => hero !== null);
            } else {
                // For Random or Campaign, just check player team
                startButton.disabled = !hasTeamMembers;
            }
        }
    }

    /**
     * Helper function to create a stat box
     * @param {string} label - Stat label
     * @param {number} value - Stat value
     * @param {string} tooltip - Tooltip text
     * @returns {HTMLElement} The stat box element
     */
    createStatBox(label, value, tooltip) {
        const statBox = document.createElement('div');
        statBox.className = 'stat-box';
        statBox.style.flex = '1';
        statBox.style.padding = '5px';
        statBox.style.backgroundColor = '#1e272e';
        statBox.style.borderRadius = '5px';
        statBox.style.textAlign = 'center';

        const statLabel = document.createElement('div');
        statLabel.className = 'stat-label';
        statLabel.textContent = label;

        const statValue = document.createElement('div');
        statValue.className = 'stat-value';
        statValue.textContent = value;

        statBox.appendChild(statLabel);
        statBox.appendChild(statValue);

        // Add tooltip if provided
        if (tooltip && window.tooltipManager) {
            window.tooltipManager.addTooltip(statBox, tooltip);
            statBox.classList.add('has-tooltip');
        }

        return statBox;
    }

    /**
     * Calculate team synergies
     * @returns {string[]} An array of synergy descriptions
     */
    calculateSynergies() {
        const heroes = this.selectedHeroes.filter(hero => hero !== null);
        if (heroes.length < 2) return [];

        const types = heroes.map(hero => hero.type);
        const roles = heroes.map(hero => hero.role);
        
        const typeCounts = {};
        types.forEach(type => {
            typeCounts[type] = (typeCounts[type] || 0) + 1;
        });
        
        const roleCounts = {};
        roles.forEach(role => {
            roleCounts[role] = (roleCounts[role] || 0) + 1;
        });
        
        const synergies = [];
        
        // Check for type synergies
        Object.entries(typeCounts).forEach(([type, count]) => {
            if (count >= 2) {
                synergies.push(`${type.charAt(0).toUpperCase() + type.slice(1)} Alliance (${count}): +${count * 10}% ${type} damage`);
            }
        });
        
        // Check for role synergies
        if (roleCounts['Warrior'] >= 2) synergies.push('Warrior (2): +20% defense');
        if (roleCounts['Mage'] >= 2) synergies.push('Mage (2): +20% ability power');
        if (roleCounts['Ranger'] >= 2) synergies.push('Ranger (2): +15% attack speed');
        if (roleCounts['Knight'] >= 2) synergies.push('Knight (2): +25% max health');
        if (roleCounts['Assassin'] >= 2) synergies.push('Assassin (2): +30% critical hit chance');
        if (roleCounts['Cleric'] >= 2) synergies.push('Cleric (2): +40% healing effectiveness');
        
        return synergies;
    }

    /**
     * Select a hero to view details
     * @param {Object} hero - The hero to select
     */
    selectHeroDetails(hero) {
        // Disable observer during hero selection to prevent excessive log messages
        if (window.disableArtObserver) {
            window.disableArtObserver();
        }
        
        try {
            this.selectedHeroDetails = hero;
            this.renderHeroGrid();
            this.renderHeroDetails();
            this.renderTeamSlots();
            
            // Play select sound
            if (window.soundManager) {
                window.soundManager.play('select');
            }
        } finally {
            // Re-enable observer when done
            // Note: this is redundant with the one in renderHeroDetails, but ensures
            // it happens even if renderHeroDetails fails
            if (window.enableArtObserver) {
                window.enableArtObserver();
            }
        }
    }

    /**
     * Add the selected hero to a team slot
     * @param {number} position - The slot position (0-2)
     */
    addHeroToTeam(position) {
        if (!this.selectedHeroDetails) return;
        
        // Determine which team we're modifying
        const targetTeam = this.isSelectingEnemyTeam ? this.enemySelectedHeroes : this.selectedHeroes;

        // Check if hero is already in team
        const existingIndex = targetTeam.findIndex(h => h && h.id === this.selectedHeroDetails.id);
        if (existingIndex !== -1) {
            targetTeam[existingIndex] = null;
        }

        // Update the correct team
        if (this.isSelectingEnemyTeam) {
            this.enemySelectedHeroes[position] = this.selectedHeroDetails;
        } else {
            this.selectedHeroes[position] = this.selectedHeroDetails;
        }
        
        this.renderTeamSlots();
        
        // Play add sound
        if (window.soundManager) {
            window.soundManager.play('add');
        }
    }

    /**
     * Remove a hero from a team slot
     * @param {number} position - The slot position (0-2)
     */
    removeHeroFromTeam(position) {
        // Remove from the appropriate team
        if (this.isSelectingEnemyTeam) {
            this.enemySelectedHeroes[position] = null;
        } else {
            this.selectedHeroes[position] = null;
        }
        
        this.renderTeamSlots();
        
        // Play remove sound
        if (window.soundManager) {
            window.soundManager.play('remove');
        }
    }

    /**
     * Initialize event listeners for the start battle button
     */
    setupEventListeners() {
        const startButton = document.getElementById('start-battle');
        startButton.addEventListener('click', () => {
            if (!startButton.disabled) {
                this.startBattle();
            }
        });
    }
    
    /**
     * Initialize the character art image loader
     */
    async initializeImageLoader() {
        try {
            // Check if window.TeamBuilderImageLoader is available (using window explicitly)
            if (typeof window.TeamBuilderImageLoader === 'undefined') {
                console.warn('TeamBuilderImageLoader not found, skipping image loading');
                return;
            }
            
            // Create the image loader
            this.imageLoader = new window.TeamBuilderImageLoader();
            
            // Initialize it
            await this.imageLoader.initialize();
            
            console.log('TeamBuilderUI: Image loader initialized');
        } catch (error) {
            console.error('Error initializing image loader:', error);
        }
    }

    /**
     * Start a battle with the selected team
     */
    startBattle() {
        // For Custom Battle mode, we need to switch to enemy team selection if not done yet
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // Filter out empty slots
            const team = this.selectedHeroes.filter(hero => hero !== null);
            
            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }
            
            // Switch to enemy team selection mode
            this.isSelectingEnemyTeam = true;
            this.renderTeamSlots();
            this.updateStartBattleButton();
            
            // Play selection sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
            
            return; // Exit without starting battle
        }
        
        // Filter out empty slots
        const team = this.selectedHeroes.filter(hero => hero !== null);
        
        if (team.length === 0) {
            alert('Please select at least one hero for your team!');
            // Play error sound
            if (window.soundManager) {
                window.soundManager.play('error');
            }
            return;
        }
        
        // Play battle start sound
        if (window.soundManager) {
            window.soundManager.play('battle_start');
        }

        console.log('Starting battle with team:', team);
        console.log('Battle mode:', this.battleMode);

        // Remove any existing battle UI elements
        const existingBattleUI = document.getElementById('battle-ui');
        if (existingBattleUI) {
            document.body.removeChild(existingBattleUI);
        }
        
        // Switch to battle scene
        document.getElementById('team-builder-container').classList.remove('active');
        
        // Clear the game container and make it active
        const gameContainer = document.getElementById('game-container');
        gameContainer.innerHTML = ''; // Clear any previous content
        gameContainer.classList.add('active');

        // Initialize the battle manager and start the battle
        if (this.teamManager) {
            this.teamManager.setPlayerTeam(team);
            
            // For Custom battle, use the selected enemy team
            if (this.battleMode === 'custom' && this.isSelectingEnemyTeam) {
                const enemyTeam = this.enemySelectedHeroes.filter(hero => hero !== null);
                if (enemyTeam.length > 0) {
                    this.teamManager.setCustomEnemyTeam(enemyTeam);
                } else {
                    // Fallback if somehow no enemies were selected
                    this.teamManager.generateEnemyTeam('random');
                }
            } else {
                // For other modes, generate enemy team as usual
                this.teamManager.generateEnemyTeam(this.battleMode);
            }
            
            // Start the battle with our teams
            if (window.battleManager) {
                // We need to ensure BattleUI is available before starting the battle
                if (typeof window.BattleUI === 'undefined') {
                    console.error('BattleUI class not found, attempting to load it');
                    
                    // Dynamically load the BattleUI script
                    const loadBattleUI = new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'js/ui/BattleUI.js';
                        script.onload = () => {
                            console.log('BattleUI script loaded successfully');
                            resolve();
                        };
                        script.onerror = () => {
                            console.error('Failed to load BattleUI script');
                            reject(new Error('Failed to load BattleUI script'));
                        };
                        document.head.appendChild(script);
                    });
                    
                    // Try to load the script before continuing
                    loadBattleUI.then(() => {
                        this.startBattleWithDelay();
                    }).catch(error => {
                        console.error('Error loading BattleUI:', error);
                        alert('Failed to load battle system. Please refresh and try again.');
                    });
                    
                    return; // Exit and wait for script to load
                }
                
                // BattleUI is available, proceed with starting the battle
                this.startBattleWithDelay();
            }
        }
    }

    /**
     * Get ordinal suffix for a number
     * @param {number} n - The number
     * @returns {string} The ordinal suffix (st, nd, rd, th)
     */
    getOrdinalSuffix(n) {
        const s = ['th', 'st', 'nd', 'rd'];
        const v = n % 100;
        return (s[(v - 20) % 10] || s[v] || s[0]);
    }
    
    /**
     * Start the battle with a delay to ensure scripts are loaded
     */
    startBattleWithDelay() {
        // Make sure the battleManager is initialized with BattleUI
        setTimeout(() => {
            try {
                // Initialize BattleUI first if needed
                if (!window.battleManager.battleUI) {
                    window.battleManager.initialize();
                }
                
                // Then start the battle
                window.battleManager.startBattle(
                    this.teamManager.playerTeam,
                    this.teamManager.enemyTeam
                );
            } catch (error) {
                console.error('Error starting battle:', error);
                alert('Error starting battle. See console for details.');
            }
        }, 500); // Increased delay to ensure script loading
    }
}


===== FILE: TeamBuilderUIUpdates.js =====
/**
 * TeamBuilderUIUpdates.js
 * Updates to the TeamBuilderUI class to support Phaser Battle Scene transition
 *
 * @version 0.5.0.3 (with added diagnostics)
 */

// Wait for DOM content to be loaded
document.addEventListener('DOMContentLoaded', function() {
    // Check if TeamBuilderUI exists
    if (typeof TeamBuilderUI !== 'function') {
        console.error('TeamBuilderUIUpdates: TeamBuilderUI class not found!');
        return;
    }

    /**
     * Start a battle with Phaser instead of DOM-based battle UI
     * @param {Array} team - The player's team
     * @param {string} battleMode - The battle mode (random, custom, campaign)
     */
    TeamBuilderUI.prototype.startBattleWithPhaser = async function(team, battleMode) {

        // --- BEGIN DIAGNOSTIC LOGS ---
        console.log(`[DEBUG] startBattleWithPhaser called at ${new Date().toLocaleTimeString()}`);
        console.log(`[DEBUG] window.game exists? `, !!window.game);
        if (window.game) {
            console.log(`[DEBUG] window.game.isRunning? `, window.game.isRunning); // Check if Phaser game loop is running
            console.log(`[DEBUG] window.game.scene exists? `, !!window.game.scene); // Check if scene manager exists
            if (window.game.scene) {
                 // Use Object.keys on the keys object provided by Phaser's scene manager
                 console.log(`[DEBUG] Scene keys known to Phaser: `, Object.keys(window.game.scene.keys));
                 // Check if the key 'BattleScene' exists within the keys object
                 console.log(`[DEBUG] BattleScene registered? `, window.game.scene.keys.hasOwnProperty('BattleScene'));
                 // Attempt to retrieve the scene instance; will be null if not added or inactive
                 console.log(`[DEBUG] Attempting to get BattleScene instance: `, window.game.scene.getScene('BattleScene'));
            } else {
                console.error("[DEBUG] window.game.scene is NOT defined!");
            }
        } else {
             console.error("[DEBUG] window.game is NOT defined when startBattleWithPhaser is called!");
        }
        // Log the data *before* preparing it, ensuring window.battleManager is checked
        console.log(`[DEBUG] Battle data prerequisites:`, { team, battleMode, battleManager: window.battleManager });
        // --- END DIAGNOSTIC LOGS ---


        try {
            // If no team is provided, use the selected heroes
            if (!team) {
                team = this.selectedHeroes.filter(hero => hero !== null);
            }

            // If no battle mode is provided, use the current mode
            if (!battleMode) {
                battleMode = this.battleMode;
            }

            console.log('Starting Phaser battle with team:', team);
            console.log('Battle mode:', battleMode);

            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }

            // Play battle start sound
            if (window.soundManager) {
                window.soundManager.play('battle_start');
            }

            // Initialize the team manager
            if (this.teamManager) {
                this.teamManager.setPlayerTeam(team);

                // For Custom battle, use the selected enemy team
                let teamGenerationPromise;
                if (battleMode === 'custom' && this.isSelectingEnemyTeam) {
                    const enemyTeam = this.enemySelectedHeroes.filter(hero => hero !== null);
                    if (enemyTeam.length > 0) {
                        this.teamManager.setCustomEnemyTeam(enemyTeam);
                        teamGenerationPromise = Promise.resolve(); // No async work needed
                    } else {
                        // Fallback if somehow no enemies were selected
                        teamGenerationPromise = this.teamManager.generateEnemyTeam('random');
                    }
                } else {
                    // For other modes, generate enemy team as usual
                    teamGenerationPromise = this.teamManager.generateEnemyTeam(battleMode);
                }
                
                // Wait for team generation to complete before proceeding
                console.log('Waiting for enemy team generation to complete...');
                try {
                    await teamGenerationPromise;
                    console.log('Enemy team generation complete, proceeding with battle');
                } catch (error) {
                    console.error('Error during enemy team generation:', error);
                    alert('Error generating enemy team. Please try again.');
                    return;
                }

                // Check if Phaser is properly initialized using the utility function
                if (!window.isPhaserReady || !window.isPhaserReady()) {
                    console.error('Phaser game or scene manager not ready, falling back to original battle UI');
                    // Fallback to old battle UI, but only if not already in a fallback loop
                    if (!this._fallingBack) {
                        this._fallingBack = true;
                        this.startBattleWithOriginalUI(team, battleMode);
                        setTimeout(() => { this._fallingBack = false; }, 500); // Reset fallback flag after a delay
                    }
                    return;
                }

                // Hide the team builder UI
                const teamBuilderContainer = document.getElementById('team-builder-container');
                if (teamBuilderContainer) {
                    teamBuilderContainer.style.display = 'none';
                }

                // Show Phaser container
                const gameContainer = document.getElementById('game-container');
                if (gameContainer) {
                    gameContainer.style.display = 'block';
                }

                // Get Phaser canvas and ensure it's visible
                const canvas = document.querySelector('#game-container canvas'); // More specific selector
                if (canvas) {
                    canvas.style.display = 'block';
                } else {
                    console.warn("Phaser canvas element not found inside #game-container.");
                }

                // --- Ensure BattleScene is Added Before Starting ---
                if (!window.game.scene.getScene('BattleScene')) {
                     if (window.BattleScene) {
                         try {
                             window.game.scene.add('BattleScene', window.BattleScene);
                             console.log('[startBattleWithPhaser] BattleScene added dynamically.');
                         } catch (sceneAddError) {
                              console.error("Error dynamically adding BattleScene:", sceneAddError);
                              alert("Failed to prepare BattleScene. Cannot start battle.");
                              // Attempt to revert UI state
                              if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                              if (gameContainer) gameContainer.style.display = 'none';
                              return;
                         }
                     } else {
                         console.error("BattleScene class not available when trying to start battle!");
                         alert("BattleScene is not loaded. Cannot start battle.");
                          // Attempt to revert UI state
                         if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                         if (gameContainer) gameContainer.style.display = 'none';
                         return;
                     }
                 }
                 // --- End Scene Add Check ---


                try {
                    // Prepare battle data for the scene
                    const battleData = {
                        playerTeam: this.teamManager.playerTeam,
                        enemyTeam: this.teamManager.enemyTeam,
                        battleMode: battleMode,
                        battleManager: window.battleManager // Ensure this uses the correct global instance
                    };

                    // Check battleManager just before starting scene
                    if(!battleData.battleManager) {
                        console.error("CRITICAL: battleManager is undefined just before starting BattleScene!");
                        alert("Battle logic manager is missing. Cannot start battle.");
                         // Attempt to revert UI state
                         if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                         if (gameContainer) gameContainer.style.display = 'none';
                        return;
                    }

                    // Implement polling mechanism to wait for scene to be fully registered
                    const checkSceneReadyAndStart = (sceneKey, data, maxAttempts = 20, attempt = 1) => {
                        const sceneInstance = window.game.scene.getScene(sceneKey);
                        // Also check if the key is known, as getScene might return null even if added but not fully ready
                        const sceneKeyExists = window.game.scene.keys.hasOwnProperty(sceneKey); 

                        if (sceneInstance && sceneKeyExists) {
                            console.log(`[DEBUG] BattleScene is ready on attempt ${attempt}. Starting scene...`);
                            try {
                                window.game.scene.start(sceneKey, data);
                                console.log('Phaser BattleScene started successfully via check.');
                            } catch (startError) {
                                console.error(`[DEBUG] Error during scene.start('${sceneKey}'):`, startError);
                                alert(`Failed to start BattleScene even after it seemed ready. Error: ${startError.message}`);
                                // Revert UI state
                                if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                                if (gameContainer) gameContainer.style.display = 'none';
                            }
                        } else if (attempt < maxAttempts) {
                            console.log(`[DEBUG] BattleScene not ready yet (Attempt ${attempt}/${maxAttempts}). Waiting 100ms...`);
                            setTimeout(() => checkSceneReadyAndStart(sceneKey, data, maxAttempts, attempt + 1), 100);
                        } else {
                            console.error(`[DEBUG] BattleScene failed to become ready after ${maxAttempts} attempts.`);
                            alert("Error: Battle scene did not become ready in time. Cannot start battle.");
                            // Revert UI state
                            if (teamBuilderContainer) teamBuilderContainer.style.display = 'block';
                            if (gameContainer) gameContainer.style.display = 'none';
                        }
                    };

                    // Use the polling check instead of directly starting the scene
                    checkSceneReadyAndStart('BattleScene', battleData);
                    console.log('Initiated polling for BattleScene readiness');

                } catch (error) {
                    console.error('Error starting Phaser BattleScene:', error);
                    // Show error message to user
                    alert('There was an error starting the battle. Falling back to original battle UI.');

                    // Fallback to old battle UI
                    if (!this._fallingBack) {
                        this._fallingBack = true;
                        this.startBattleWithOriginalUI(team, battleMode);
                        setTimeout(() => { this._fallingBack = false; }, 500);
                    }
                }
            } else {
                 console.error("TeamManager not available in startBattleWithPhaser!");
                 alert("Team Manager error. Cannot start battle.");
            }
        } catch (error) {
            console.error('Error in startBattleWithPhaser:', error);
            // Attempt emergency fallback to original battle UI
            if (!this._fallingBack) {
                this._fallingBack = true;
                 // Ensure team is defined for fallback
                 const fallbackTeam = team || this.selectedHeroes.filter(hero => hero !== null);
                 const fallbackMode = battleMode || this.battleMode;
                this.startBattleWithOriginalUI(fallbackTeam, fallbackMode);
                setTimeout(() => { this._fallingBack = false; }, 500);
            }
        }
    };

    /**
     * Start a battle with the original DOM-based battle UI
     * This is used as a fallback when Phaser initialization fails
     * @param {Array} team - The player's team
     * @param {string} battleMode - The battle mode (random, custom, campaign)
     */
    TeamBuilderUI.prototype.startBattleWithOriginalUI = function(team, battleMode) {
        // Use the original startBattle method that was saved
        if (typeof this.startBattleOriginal === 'function') {
            console.log('Falling back to original battle UI');
            // Call the original function which handles its own logic
            this.startBattleOriginal();
        } else {
            console.error('Original startBattle method not found, cannot fallback');
            // Show error message to user
            alert('There was an error starting the battle. Please refresh the page and try again.');
        }
    };

    /**
     * Handle return from Phaser battle scene
     */
    TeamBuilderUI.prototype.onReturnFromPhaserBattle = function() {
        try {
            console.log('Returned from Phaser battle');

            // Show the team builder UI
            const teamBuilderContainer = document.getElementById('team-builder-container');
            if (teamBuilderContainer) {
                teamBuilderContainer.style.display = 'block'; // Or 'flex', check your CSS
            }

            // Hide Phaser container
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                gameContainer.style.display = 'none';
            }

            // Hide canvas specifically
            const canvas = document.querySelector('#game-container canvas');
            if (canvas) {
                canvas.style.display = 'none';
            }

            // Reset enemy team selection if needed
            if (this.isSelectingEnemyTeam) {
                this.isSelectingEnemyTeam = false;
                this.renderTeamSlots();
            }

            // Update battle modes display
            this.renderBattleModes();

            // Play UI sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }
        } catch (error) {
            console.error('Error in onReturnFromPhaserBattle:', error);
            // Try showing the team builder UI anyway as a fallback
             const teamBuilderContainer = document.getElementById('team-builder-container');
             if(teamBuilderContainer) teamBuilderContainer.style.display = 'block'; // Or 'flex'
        }
    };

    /**
     * Legacy method name for backward compatibility
     */
    TeamBuilderUI.prototype.onReturnFromBattle = TeamBuilderUI.prototype.onReturnFromPhaserBattle;

    /**
     * Override the original startBattle to use Phaser version
     * Original method will be kept as fallback
     */
    // Ensure startBattleOriginal actually exists before trying to assign it
    if (typeof TeamBuilderUI.prototype.startBattle === 'function') {
         TeamBuilderUI.prototype.startBattleOriginal = TeamBuilderUI.prototype.startBattle;
    } else {
         console.error("Original TeamBuilderUI.prototype.startBattle not found for backup!");
         // Define a dummy original if needed to prevent errors later, though this indicates a bigger problem
         TeamBuilderUI.prototype.startBattleOriginal = function() { console.error("startBattleOriginal fallback called - original missing!"); };
    }


    TeamBuilderUI.prototype.startBattle = async function() {
        // For Custom Battle mode, we need to switch to enemy team selection if not done yet
        if (this.battleMode === 'custom' && !this.isSelectingEnemyTeam) {
            // Filter out empty slots
            const team = this.selectedHeroes.filter(hero => hero !== null);

            if (team.length === 0) {
                alert('Please select at least one hero for your team!');
                // Play error sound
                if (window.soundManager) {
                    window.soundManager.play('error');
                }
                return;
            }

            // Switch to enemy team selection mode
            this.isSelectingEnemyTeam = true;
            this.renderTeamSlots();
            this.updateStartBattleButton();

            // Play selection sound
            if (window.soundManager) {
                window.soundManager.play('click');
            }

            return; // Exit without starting battle
        }

        // Get the selected team
        const team = this.selectedHeroes.filter(hero => hero !== null);

        // Check if we should use Phaser battle scene or fallback to original
        const usePhaser = true; // Set to true to always use Phaser, false to use original

        if (usePhaser) {
            // Call the Phaser-specific method
            await this.startBattleWithPhaser(team, this.battleMode);
        } else {
            // Call the original DOM-based method (if it was correctly backed up)
             if (typeof this.startBattleOriginal === 'function') {
                 this.startBattleOriginal();
             } else {
                  console.error("Cannot call original startBattle - backup failed.");
                  alert("Error initiating battle.");
             }
        }
    };

    console.log('TeamBuilderUIUpdates: Successfully added methods and diagnostics to TeamBuilderUI prototype');
});

===== FILE: TooltipManager.js =====
/**
 * Tooltip Manager
 * Manages tooltip display for UI elements
 */

class TooltipManager {
    /**
     * Create a new Tooltip Manager
     */
    constructor() {
        this.tooltip = null;
        this.initialize();
    }

    /**
     * Initialize the tooltip element
     */
    initialize() {
        // Create tooltip element if it doesn't exist
        if (!this.tooltip) {
            this.tooltip = document.createElement('div');
            this.tooltip.className = 'tooltip';
            this.tooltip.style.display = 'none';
            document.body.appendChild(this.tooltip);

            // Add mousemove event to move tooltip with cursor
            document.addEventListener('mousemove', (e) => {
                if (this.tooltip.style.display === 'block') {
                    const offset = 15; // Distance from cursor
                    
                    // Position tooltip based on cursor position
                    this.tooltip.style.left = (e.pageX + offset) + 'px';

                    // Make sure tooltip doesn't go off-screen
                    const tooltipRect = this.tooltip.getBoundingClientRect();
                    if (e.pageY + offset + tooltipRect.height > window.innerHeight) {
                        this.tooltip.style.top = (e.pageY - tooltipRect.height - offset) + 'px';
                    } else {
                        this.tooltip.style.top = (e.pageY + offset) + 'px';
                    }
                }
            });
        }
    }

    /**
     * Show tooltip with content
     * @param {string} content - HTML content for the tooltip
     */
    show(content) {
        this.tooltip.innerHTML = content;
        this.tooltip.style.display = 'block';
    }

    /**
     * Hide tooltip
     */
    hide() {
        this.tooltip.style.display = 'none';
    }

    /**
     * Add tooltip to an element
     * @param {HTMLElement} element - Element to add tooltip to
     * @param {string|Function} content - Content for tooltip or function returning content
     */
    addTooltip(element, content) {
        element.addEventListener('mouseenter', () => {
            const tooltipContent = typeof content === 'function' ? content() : content;
            this.show(tooltipContent);
        });

        element.addEventListener('mouseleave', () => {
            this.hide();
        });
    }
}

// Create a singleton instance
const tooltipManager = new TooltipManager();

// Make it available globally
window.tooltipManager = tooltipManager;

