# AutoBattler Code Compendium

## Purpose
A complete reference guide to every JavaScript file in the AutoBattler game, explaining what each one does and how it fits into the overall architecture. This document serves as a comprehensive catalog of all code components for both developer reference and AI context restoration.

## How to Use This Document
- **For Developers**: Quick reference to understand what each file does and where to find specific functionality
- **For AI Context**: Provides detailed context about the codebase when starting new conversations
- **For Architecture Understanding**: Shows how different components relate to each other

---

## Battle Logic Components

### Core Systems
- **BattleFlowController.js**: A core orchestration component responsible for managing the complete battle sequence lifecycle in the AutoBattler game, serving as the central conductor for turn-based combat flow. BattleFlowController emerged from a systematic refactoring effort (Stage 3 of the BattleManager component-based migration) where battle flow logic was extracted from the monolithic BattleManager into a specialized, focused component. The controller handles the entire battle progression from initialization through turn management to completion, including battle startup (loading status effects, initializing behavior systems, preparing teams), turn sequencing (turn advancement, passive ability triggers, status effect processing), action orchestration (generating character actions, managing action queues, validating alive characters), effect application (delegating to specialized processors like DamageCalculator and HealingProcessor), and battle conclusion (checking end conditions, processing defeat/victory). Key architectural features include sophisticated multi-target action handling with individual damage calculations, comprehensive event dispatching through BattleEventDispatcher and BattleBridge for UI synchronization, defensive programming with extensive validation and fallback mechanisms, and deep integration with the passive ability system through triggers like onBattleStart, onTurnStart, and onBattleEnd. The component implements complex logic for retargeting when original targets are defeated, proper team identification for battle log clarity (ally/enemy designations), and robust error handling throughout the battle flow. BattleFlowController coordinates with over 10 specialized components including BattleInitializer for setup, DamageCalculator and HealingProcessor for damage/healing logic, PassiveAbilityManager for passive abilities, and ActionGenerator for character actions. The component has undergone multiple iterations, with significant fixes including proper battle action declaration formatting, correct script path resolution, and comprehensive method implementation. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and component facade), BattleInitializer.js (team preparation and character setup), DamageCalculator.js (damage computation and application), HealingProcessor.js (healing calculations and revival logic), StatusEffectManager.js (status effect processing each turn), PassiveAbilityManager.js (passive ability triggers), ActionGenerator.js (character action creation), TargetingSystem.js (target selection and validation), AbilityProcessor.js (ability effect processing), BattleEventDispatcher.js (event coordination), BattleLogManager.js (battle message logging), TypeEffectivenessCalculator.js (type advantage calculations), window.battleBridge (UI event communication), window.BattleBehaviors (AI decision making), DOM BattleUI.js (legacy UI updates), and provides global access through window.BattleFlowController for debugging and cross-system coordination.

- **BattleInitializer.js**: A core preparation component responsible for transforming raw character data into fully battle-ready entities, ensuring proper initialization and validation of all team and character properties before combat begins. BattleInitializer emerged from the BattleManager refactoring effort (Phase 1) where all team and character initialization logic was extracted into a focused, dedicated component. The initializer handles comprehensive character preparation including deep cloning of team data to prevent reference conflicts, complete character property validation with default value assignment, unique ID generation for battle tracking, team type assignment, ability initialization and passive ability identification, and stats validation with fallback values. Key architectural features include robust data transformation through JSON parse/stringify for team independence, extensive defensive programming with validation and detailed error handling, sophisticated character validation ensuring all required properties exist, and passive ability preprocessing for quick reference during battle. The component implements two-phase initialization with `initializeTeamsAndCharacters()` for complete team setup followed by `prepareTeamForBattle()` for battle-specific preparation, handles edge cases gracefully, and provides comprehensive diagnostic logging. BattleInitializer integrates with PassiveTriggerTracker to reset battle tracking and coordinates with BattleManager through a facade pattern, significantly reducing BattleManager's complexity by approximately 104 lines while improving error handling and code organization. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation), PassiveTriggerTracker.js (resets battle-level tracking), BattleFlowController.js (receives initialized teams for battle startup), window.battleManager (accesses global reference), JSON processing system (deep cloning for team independence), character data structures (transforms raw data into battle entities), ability system (identifies and preprocesses passive abilities), stats validation system (ensures complete character properties), and provides global access through window.BattleInitializer for debugging and cross-system coordination.



### Status & Effects
- **StatusEffectManager.js**: A core battle logic component responsible for managing all status effect application, processing, and lifecycle management during combat. StatusEffectManager emerged from the Stage 2 BattleManager refactoring effort (v0.5.24.2-0.5.24.4) where status effect logic was extracted from the monolithic BattleManager into a specialized component. The manager handles the complete status effect lifecycle including application with sophisticated stacking and duration logic, turn-based processing with per-turn effect triggers (damage over time, healing over time, stat modifications), source attribution through the "Source ID Linking" pattern to prevent circular references, effect removal and expiration management, and comprehensive status icon updates through event dispatching. Key architectural features include robust parameter validation with intelligent fallback handling for misaligned parameters, integration with StatusEffectDefinitionLoader for comprehensive effect definitions with smart fallback generation, sophisticated multi-target validation (v0.5.27.2_Hotfix8) ensuring invalid targets don't break entire actions, and extensive integration with BattleUtilities (v0.6.0.3) for source character resolution from stored unique IDs. The component implements multiple effect types (damage, healing, statModifier, shield, control) with appropriate processing logic for each, maintains character original stats for proper stat modifier removal, and provides rich query interfaces for checking effect presence, stacks, and values. StatusEffectManager underwent significant parameter order fixes and source resolution improvements, transitioning from direct battleManager method calls to BattleUtilities integration, and includes comprehensive event dispatching through BattleEventDispatcher for UI synchronization. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and primary integration point), StatusEffectDefinitionLoader.js (effect definitions and fallback generation), BattleUtilities.js (source character resolution from unique IDs), BattleEventDispatcher.js (comprehensive event dispatching for UI updates via dispatchStatusEffectAppliedEvent), DamageCalculator.js (through battleManager facade for damage application), HealingProcessor.js (through battleManager facade for healing application), window.battleBridge (direct event dispatching and fallback communication), window.BattleUtilities (global utility access for character lookups), AbilityProcessor.js (receives delegated effect application calls), PassiveAbilityManager.js (coordinates status effects from passive triggers), and character data structures (maintains statusEffects arrays, originalStats tracking for stat modifiers).

- **StatusEffectDefinitionLoader.js**: A specialized component responsible for loading, normalizing, and managing status effect definitions from multiple sources, serving as the authoritative registry for all status effect metadata in the AutoBattler game. StatusEffectDefinitionLoader emerged from Phase 2 of the BattleManager refactoring effort (v0.5.30.0-0.5.30.1) where all status effect definition handling was extracted from BattleManager to achieve true separation of concerns. The loader handles multi-source definition loading including primary JSON file loading from 'data/status_effects.json' with fallback to root directory, comprehensive error handling with graceful degradation to fallback definitions, and intelligent definition normalization supporting multiple JSON formats and property naming conventions (defaultDuration vs duration, maxStacks vs stackable, icon vs iconPath, behavior objects vs direct effectType). Key architectural features include sophisticated format detection and normalization (v0.5.27.9) that translates behavior-based effects into standard effectType formats, smart fallback generation that creates meaningful definitions based on effect ID patterns, comprehensive validation with detailed error reporting, and definition caching using Map for efficient lookups. The component implements a dual initialization strategy with immediate fallback setup followed by JSON loading attempts, handles various JSON structures including nested status_effects arrays and effect ID-keyed objects, and provides intelligent autodetection for effect types (damage, healing, control, shield, statModifier) based on ID naming patterns. StatusEffectDefinitionLoader fully encapsulates status effect definition concerns, eliminating BattleManager's knowledge of definition sources and enabling complete architectural separation between orchestration and data management components. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (receives delegation for definition loading initialization), StatusEffectManager.js (primary consumer for effect definitions via getDefinition method), data/status_effects.json (primary data source with fetch API), browser Fetch API (for JSON loading with primary/fallback path handling), window scope (global exposure for debugging and cross-system access), Map data structure (internal definition storage and caching), console logging system (comprehensive diagnostic and error reporting), and provides fallback definition services for unknown effect IDs through generateFallbackDefinition method with intelligent type detection.



### Damage & Healing
- **DamageCalculator.js**: 
- **HealingProcessor.js**: 
- **TypeEffectivenessCalculator.js**: 

### Abilities & Actions
- **AbilityProcessor.js**: 
- **TargetingSystem.js**: 
- **ActionGenerator.js**: 

### Passive Systems
- **PassiveAbilityManager.js**: 
- **PassiveTriggerTracker.js**: 

### Events & Communication
- **BattleEventDispatcher.js**: 
- **BattleLogManager.js**: 

### Utilities & Behaviors
- **BattleUtilities.js**: 
- **BattleBehaviors.js**: 
- **BehaviorRegistry.js**: 
- **ActionDecisionBehaviors.js**: 
- **TargetingBehaviors.js**: 
- **PassiveBehaviors.js**: 

---

## Managers (High-Level Orchestrators)
- **BattleManager.js**: The central orchestrator for all battle-related systems in the AutoBattler game. Rather than handling battle logic directly, BattleManager acts as a sophisticated "conductor" that coordinates over 10 specialized component managers (like BattleFlowController, DamageCalculator, StatusEffectManager, etc.). It serves as a unified interface where other parts of the game can request battle operations - such as starting a battle, applying damage, or processing abilities - and BattleManager delegates these requests to the appropriate specialist component. The manager follows a facade pattern, providing simple method calls that hide the complexity of the underlying component system. It also handles initialization of all battle components in proper dependency order, manages global battle state (like teams, turn counts, speed settings), and acts as the communication bridge to the UI through event dispatching. *(Accurate as of v0.7.5.14)*

Talks to: BattleInitializer.js (team setup), BattleFlowController.js (turn management), BattleEventDispatcher.js (event communication), DamageCalculator.js (damage logic), HealingProcessor.js (healing logic), StatusEffectManager.js (status effects), PassiveAbilityManager.js (passive abilities), AbilityProcessor.js (ability execution), ActionGenerator.js (action creation), TargetingSystem.js (target selection), TypeEffectivenessCalculator.js (type advantages), BattleLogManager.js (logging), game.js (initialization), Phaser BattleScene.js (UI events), TeamManager.js (team data), and window.battleBridge (event system).

- **TeamManager.js**: The central component responsible for team composition management and character selection coordination in the AutoBattler game. TeamManager maintains the authoritative state for both player and enemy teams throughout the game lifecycle, handling character pool loading from JSON data, player team selection storage, and enemy team generation across multiple battle modes. The component provides three distinct enemy generation strategies: random teams with 20% stat variance for unpredictable encounters, custom teams with 10% stat variance for player-designed opponents, and planned campaign teams for future story mode implementation. TeamManager performs deep copying of character data to prevent reference conflicts, applies statistical variance to create battle variety, and serves as the primary data provider for team-related operations. It acts as the essential state bridge between the Team Builder UI selection phase and the Battle Manager combat initialization, ensuring team data integrity and proper initialization throughout the battle workflow. The component includes comprehensive fallback mechanisms with hardcoded character data to maintain functionality even when JSON loading fails. *(Accurate as of v0.7.5.14)*

Talks to: TeamBuilderUI.js (receives team selections and battle mode choices), BattleInitiator.js (provides finalized teams for battle start), BattleManager.js (supplies teams for combat initialization), data/characters.json (loads character pool), BattleInitializer.js (provides teams for battle setup), game.js (instantiated at startup), and window global scope (exposed for debugging and cross-system access).



---

## Phaser Implementation

### Core Phaser Systems
- **BattleAssetLoader.js**: 
- **BattleEventManager.js**: A core Phaser event orchestration component responsible for managing all battle-related event listening and handling within the Battle Scene, serving as the central dispatcher for UI updates and visual feedback. BattleEventManager emerged from Phase 1 of the BattleScene refactoring effort (v0.6.1.1-0.6.1.4) where event management logic was extracted from the monolithic BattleScene into a specialized, focused component to reduce complexity and improve maintainability. The manager handles comprehensive event registration including core battle flow events (turn started, battle ended), status effect lifecycle events (applied, removed, updated), health and damage events (character damaged, healed), and action indicator events (character action, ability used). Key architectural features include sophisticated event handler binding with proper 'this' context preservation, comprehensive character sprite resolution through multiple fallback strategies (TeamDisplayManager delegation, direct team container access), intelligent dependency injection with setTeamManager, setBattleLog, and setFXManager methods, and robust event dispatcher integration with BattleBridge for seamless communication between battle logic and visual systems. The component implements extensive error handling with graceful degradation when dependencies are unavailable, Map-based tracking of bound handlers for proper cleanup, and dual visual effect routing supporting both direct scene methods and BattleFXManager integration. BattleEventManager underwent critical fixes including character sprite resolution improvements (v0.6.1.2) to properly interface with TeamContainer methods, game over event handling enhancements (v0.6.1.3), and complete cleanup (v0.6.1.4) removing all legacy event code from BattleScene, achieving a 27% reduction in BattleScene complexity. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (parent scene providing initialization and component references), BattleBridge.js (primary event source through comprehensive event type registration), TeamDisplayManager.js (character sprite resolution and active visual updates via setTeamManager), BattleFXManager.js (visual effects delegation via setFXManager), DirectBattleLog.js (battle message display via setBattleLog), CharacterSprite.js (health updates, status effects, action indicators), TeamContainer.js (character sprite resolution fallback through findCharacterSprite method), window scope (global component exposure for debugging), console logging system (comprehensive diagnostic and error reporting), and Phaser event system (event listener lifecycle management through addEventListener/removeEventListener patterns).



### Specialized Phaser Managers
- **BattleUIManager.js**: A specialized Phaser manager responsible for creating and managing all UI elements within the Battle Scene, serving as the centralized coordinator for user interface components during battle visualization. BattleUIManager emerged from a systematic refactoring effort (Phase 2 of BattleScene modularization) that extracted approximately 750 lines of UI-related code from the monolithic BattleScene into a focused, maintainable component. The manager handles the complete lifecycle of battle UI elements including gradient background with grid patterns, scene titles and welcome messages, battle control panels (start/pause/speed controls), the battle log panel for event display, turn and action text indicators, battle outcome screens (victory/defeat/draw), and comprehensive error message display. Key architectural features include component tracking through a standardized `components` object for proper cleanup, robust error handling with try/catch blocks around each UI creation method, safe text object management via `safeGetTextObject()` utility preventing Phaser object lifecycle issues, and comprehensive resource cleanup in the `destroy()` method. The component implements sophisticated delegation patterns allowing BattleScene to focus solely on battle coordination while BattleUIManager handles all visual presentation concerns. BattleUIManager integrates seamlessly with other Phaser components including BattleControlPanel and DirectBattleLog, maintains team-specific UI styling (blue for player team, red for enemy team), and provides graceful fallbacks with user-facing error messages when dependent components are unavailable. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (parent scene and initialization), BattleControlPanel (battle control interface creation), DirectBattleLog (battle log panel creation), Phaser Scene API (UI object creation and management), Phaser Tweens (animations for text indicators and outcome screens), team-builder-container and game-container DOM elements (scene transitions), window.battleBridge (cleanup coordination), window.teamBuilderUI (return navigation callbacks), and provides error handling services for other battle components through centralized error message display.

- **BattleFXManager.js**: 
- **TeamDisplayManager.js**: 

### Bridge Systems
- **BattleBridge.js**: 
- **BattleBridgeInit.js**: 
- **BattleLogTester.js**: 

### Scenes
- **BattleScene.js**: 
- **BootScene.js**: 
- **TeamBuilderScene.js**: 

### Audio Systems
- **PhaserSoundManager.js**: 

### Debug Tools
- **CoordinateDisplay.js**: 
- **DebugManager.js**: 
- **PhaserDebugManager.js**: 
- **ObjectIdentifier.js**: 

---

## UI Components

### Battle-Specific Components
- **ActionIndicator.js**: 
- **BattleControlPanel.js**: 
- **BattleLogPanel.js**: 
- **CharacterSprite.js**: A comprehensive Phaser component responsible for rendering individual characters within the battle scene, serving as the primary visual representation for battling units with support for both traditional circle-based and modern card-based presentations. CharacterSprite acts as the visual facade for character entities, handling all aspects of character visualization including dual representation support (traditional circles with character images vs. professional card frames using the CardFrame system), health management with animated health bars and dynamic visual feedback, action indication through integration with ActionIndicator for displaying ability names and auto-attacks, status effect visualization via StatusEffectContainer, and interactive capabilities with hover effects and selection handling. Key architectural features include sophisticated attack animations with proper collision detection and team-aware movement calculations, comprehensive health visualization with color-coded health bars and floating damage/healing numbers, turn-based highlighting integration connecting to the card frame turn indicator system with team-specific colors (blue for player, red for enemy), and robust error handling with extensive try-catch blocks and fallback mechanisms. The component implements character positioning through customizable art offsets and scaling, supports both interactive and non-interactive modes, and provides comprehensive cleanup methods to prevent memory leaks. CharacterSprite integrates closely with ActionIndicator for action text display, StatusEffectContainer for status visualization, CardFrame/CardFrameManager for modern card representation, and TeamContainer for team management. The component underwent significant evolution with the turn indicator integration (v0.7.5.2) where it transitioned from the deprecated TurnIndicator system to the new card frame highlighting approach via highlight()/unhighlight() methods. *(Accurate as of v0.7.5.15)*

Talks to: TeamContainer.js (parent container and positioning), BattleScene.js (scene management and global positioning), CardFrame.js and CardFrameManager.js (card-based representation), ActionIndicator.js (ability and action text display), StatusEffectContainer.js (status effect visualization), Phaser.Scene (scene events and character selection), BattleEventManager.js (indirectly via scene events), window.characterSprites (global registry for debugging), window.CHARACTER_IMAGE_CACHE (image caching system), character art system (texture loading and positioning), and provides visual feedback for battle events including damage, healing, highlighting, and action indication.


- **DirectBattleLog.js**: 
- **StatusEffectContainer.js**: 
- **StatusEffectTooltip.js**: 
- **TeamContainer.js**: 
- **TurnIndicator.js**: 

### Card Frame System
- **CardFrame.js**: 
- **CardFrameManager.js**: 
- **CardFrameVisualComponent.js**: 
- **CardFrameHealthComponent.js**: 
- **CardFrameContentComponent.js**: 
- **CardFrameInteractionComponent.js**: 

### General UI Components
- **Button.js**: 
- **Panel.js**: 

---

## DOM-Based UI Systems

### Team Builder
- **TeamBuilderUI.js**: The primary orchestrator for the character selection interface in the AutoBattler game, functioning as the central hub for team composition before battle. TeamBuilderUI has been refactored from a monolithic class into a sophisticated component-based architecture, where it serves as the coordinator for seven specialized manager components that handle distinct aspects of the team-building experience. The system manages character data loading from JSON, user interaction with available heroes, filter controls for types and roles, team slot management, hero detail display, battle mode selection, and battle initiation workflows. TeamBuilderUI maintains compatibility with legacy systems while delegating specific responsibilities to specialized components: FilterManager (type/role filtering), HeroGridManager (character display and selection), TeamSlotsManager (team composition), HeroDetailPanelManager (detailed character information), BattleModeManager (battle type selection), BattleInitiator (transition to battle), and TeamBuilderUtils (shared utility functions). The architecture follows an Extract-Verify-Remove refactoring pattern, allowing gradual migration from monolithic methods to specialized components while maintaining fallback functionality. TeamBuilderUI interfaces with the image loading system for character art display, manages global UI state including view modes, and provides comprehensive error handling for missing components. *(Accurate as of v0.7.5.14)*

Talks to: TeamManager.js (team state management), FilterManager.js (filter state updates), HeroGridManager.js (character selection events), TeamSlotsManager.js (team composition changes), HeroDetailPanelManager.js (character detail rendering), BattleModeManager.js (battle mode changes), BattleInitiator.js (battle start coordination), TeamBuilderImageLoader.js (character art loading), TeamBuilderUtils.js (shared utility functions), data/characters.json (character data loading), window.soundManager (audio feedback), window.tooltipManager (UI tooltips), and game.js (initialization and global state).

- **TeamBuilderUtils.js**: A utility class providing shared static functions for the TeamBuilder component architecture. Serves as a centralized location for common operations that are needed across multiple TeamBuilder components including type string parsing, multi-type UI rendering, stat box creation, ability scaling calculations, and general formatting utilities. Created during the Extract-Verify-Remove refactoring process (v0.6.6.0), this class was extracted from TeamBuilderUI.js to eliminate code duplication and support the component-based architecture transition. Contains five key static methods: `splitTypes()` for handling multi-type characters (e.g., "water/ice"), `renderMultiTypeSpans()` for creating colored type tags in the UI, `getOrdinalSuffix()` for generating ordinal numbers (1st, 2nd, etc.), `createStatBox()` for consistent stat display elements, and `getDetailedScalingText()` for detailed ability tooltip information with scaling formulas. As a pure utility class with no state, it follows the Single Responsibility Principle and provides clean interfaces for UI rendering tasks across the TeamBuilder ecosystem. *(Accurate as of v0.7.5.15)*

Talks to: HeroDetailPanelManager.js (type parsing, stat boxes, ability scaling), TeamSlotsManager.js (type parsing for team slots and synergies), window.tooltipManager (tooltip integration for stat boxes), global type colors configuration (from parent UI components), and serves as a dependency for all TeamBuilder UI components that need consistent formatting and parsing utilities.

- **HeroDetailPanelManager.js**: A specialized component responsible for rendering and managing the detailed hero information panel in the TeamBuilder UI. This component handles the complex display of character statistics, abilities, type relationships, and character art within the hero details section. Created during the TeamBuilder refactoring process as part of the component-based architecture transition, it manages both initial rendering and intelligent updates to preserve DOM structures and improve performance. The component features sophisticated multi-type character support, detailed ability tooltips with scaling formulas, comprehensive type advantage/disadvantage visualization, and integration with the character art system. Key responsibilities include rendering character stats (both basic HP/ATK/DEF/SPD and expanded STR/INT/SPI), displaying abilities with type-specific styling and detailed tooltips, creating interactive type relationship sections with icons and colors, and managing character portrait integration. The component implements performance optimizations such as preserving existing DOM wrappers during updates and disabling art observers during rendering to prevent conflicts. It heavily utilizes TeamBuilderUtils for type parsing, stat box creation, and scaling calculations, ensuring consistency across the TeamBuilder interface. The component follows defensive programming principles with comprehensive error handling and fallback mechanisms for missing elements or failed operations. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamBuilderUtils.js (type parsing, stat boxes, scaling calculations), TeamBuilderImageLoader.js (character art rendering via drawArt method), window.tooltipManager (enhanced ability and stat tooltips), window.disableArtObserver/enableArtObserver (performance optimization during DOM updates), DOM elements (detail-content container), data/characters.json (indirectly via parent's availableHeroes), and integrates with the global type colors and image caching systems.

- **FilterManager.js**: A specialized component responsible for managing all type and role filtering functionality within the TeamBuilder interface. Created during the TeamBuilder component-based refactoring process (v0.6.6.4), FilterManager handles the complete lifecycle of filter interactions including UI rendering, state management, user interactions, and parent notification. The component creates collapsible filter sections for all 22 types and 22 roles from the game specification, with each section starting collapsed by default and expanding through smooth CSS transitions when clicked. Filter buttons provide immediate visual feedback with active/inactive states, hover effects, and sound integration through the global SoundManager. The component maintains independent filter state for types and roles, automatically displays active filter count badges on section headers, and provides a dynamic "Clear Filters" button that appears only when filters are active. FilterManager includes special handling for the Ethereal type with enhanced opacity and black text for better contrast, and automatically injects required CSS styles for the collapsible functionality to avoid external dependencies. The component follows the established delegation pattern where TeamBuilderUI can initialize it with existing filter state and receives notifications of filter changes through the `onFiltersChanged()` callback, enabling seamless integration with the hero grid filtering system. FilterManager demonstrates mature UX design with smooth animations, comprehensive error handling, and self-contained styling that maintains visual consistency across the TeamBuilder interface. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and callback receiver), window.soundManager (audio feedback for hover and click events), DOM elements (filter sections, buttons, and containers), HeroGridManager.js (indirectly via parent's onFiltersChanged callback), global typeColors configuration (accessed via parent reference), CSS style injection system (for collapsible filter animations), and serves as the authoritative source for filter state accessible through the window.FilterManager global reference.
- **HeroGridManager.js**: A specialized component responsible for managing the hero selection grid within the TeamBuilder interface, serving as the central hub for hero display, filtering, and selection interactions. Created during the TeamBuilder component-based refactoring process (v0.6.6.6), HeroGridManager handles the complete lifecycle of hero grid operations including rendering filtered character cards, managing view modes, applying filter criteria, and facilitating hero selection. The component creates individual hero cards with proper type-specific styling, handles multi-type character display using TeamBuilderUtils for type parsing and rendering, and integrates seamlessly with the FilterManager through filter state updates. A key feature is the dual view mode system with persistent localStorage storage - users can toggle between "full view" (vertical layout with art above text) and "compact view" (horizontal layout with smaller cards), accessible through a dynamically created toggle button in the section header. The component maintains selection state independently while notifying the parent through callback mechanisms, applies filtered display based on both type and role criteria with proper no-results messaging, and explicitly manages character art loading through integration with TeamBuilderImageLoader. HeroGridManager demonstrates sophisticated UI patterns including responsive design considerations, persistent user preferences, and comprehensive error handling with fallback mechanisms when dependencies are unavailable. The component follows the established delegation pattern where hero selection triggers parent notification via `onHeroSelected()` callback, ensuring seamless integration with the broader TeamBuilder ecosystem for hero detail display and team composition workflows. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamBuilderUtils.js (type parsing and multi-type rendering), TeamBuilderImageLoader.js (character art rendering via explicit drawArt calls), FilterManager.js (indirectly via parent's onFiltersChanged callback for filter state updates), window.soundManager (audio feedback for view toggle button), DOM elements (heroes-grid container, hero cards, view toggle button), localStorage (view mode persistence as 'heroGridViewMode'), global typeColors configuration (accessed via parent reference), and serves as the primary hero selection interface accessible through window.HeroGridManager global reference.
- **TeamSlotsManager.js**: A specialized component responsible for managing the complete team composition interface within the TeamBuilder, handling both player and enemy team slot rendering, hero placement, and team synergy calculations. Created during the TeamBuilder component-based refactoring process (v0.6.6.8), TeamSlotsManager orchestrates all aspects of team building including slot visualization, hero addition and removal workflows, real-time synergy calculation, and dual-team selection functionality for custom battles. The component maintains independent state for both player and enemy teams while providing a unified interface that dynamically switches between team selection modes with visual indicators and appropriate styling. A key innovation is the comprehensive team synergy system that calculates both type-based alliances and role-based bonuses, properly handling multi-type characters through TeamBuilderUtils integration and displaying real-time feedback as players build their teams. The component features sophisticated slot rendering with character art integration via TeamBuilderImageLoader, detailed hero information displays including both basic and advanced stats, and intuitive empty slot guidance that adapts based on current hero selection. TeamSlotsManager integrates seamlessly with the broader TeamBuilder ecosystem through callback mechanisms, notifying the parent of team selection changes for battle mode handling and triggering battle button updates based on team completion status. The component demonstrates advanced UI patterns including dynamic team heading coloring, contextual control buttons for team switching, and proper event handling with sound feedback integration. Team state management includes accessor methods for external systems to retrieve team compositions, support for hero validation and duplicate checking, and comprehensive rendering cycles that preserve state while updating visual elements. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamSlotsManager.js manages bidirectional communication through callbacks like onTeamSelectionChanged and notifyBattleButtonUpdate), TeamBuilderUtils.js (type parsing for multi-type heroes, ordinal suffix generation, and synergy calculations), TeamBuilderImageLoader.js (character art rendering via explicit drawArt calls with view mode support), TeamManager.js (indirectly via parent's teamManager reference for team operations), HeroGridManager.js (indirectly via viewMode retrieval for consistent art rendering), window.soundManager (audio feedback for hero addition and removal actions), DOM elements (team-slots container, slot elements, synergies-list), global typeColors configuration (accessed via parent reference), and serves as the authoritative source for team composition data accessible through window.TeamSlotsManager global reference.
- **BattleModeManager.js**: A specialized component responsible for managing battle mode selection and battle button state within the TeamBuilder interface. Created during the final phase of the TeamBuilder component-based refactoring process (v0.6.6.10), BattleModeManager encapsulates all functionality related to the three distinct battle modes: Random Opponent (generates a random enemy team), Custom Battle (allows player selection of both teams), and Campaign Mode (future story encounters). The component handles the complete lifecycle of battle mode interactions including rendering mode selection UI with proper visual states, managing mode toggling with validation against current selection context, and dynamically updating the start battle button's text and enabled state based on team composition and mode requirements. A key feature is the intelligent button state management that adapts to different contexts - displaying "Choose Enemy Team" when Custom mode is selected with a player team ready, "Start Battle" for Random/Campaign modes, and appropriate disabled states when team requirements aren't met. The component includes sophisticated integration with TeamSlotsManager to track enemy team selection progress, providing visual indicators like "Selecting Enemy" labels and preventing mode changes during enemy selection workflows. BattleModeManager follows the established delegation pattern with comprehensive validation, fallback mechanisms, and sound integration for user feedback. The component maintains state synchronization through dedicated callback methods, ensuring the broader TeamBuilder system remains aware of mode changes for appropriate UI updates and battle initiation workflows. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source, receives mode changes via onBattleModeChanged callback), TeamSlotsManager.js (integrates for team selection state tracking and battle button updates), BattleInitiator.js (indirectly via TeamBuilderUI for battle initiation coordination), window.soundManager (audio feedback for mode selection interactions), DOM elements (battle-modes container, mode selection elements, start-battle button), and serves as the authoritative source for battle mode state accessible through the BattleModeManager instance and delegation methods in TeamBuilderUI.


- **BattleInitiator.js**: A specialized component responsible for orchestrating battle initiation, team validation, UI transitions, and battle system initialization within the TeamBuilder architecture. BattleInitiator encapsulates the complex workflow of transitioning from team selection to active combat, handling multiple battle start scenarios and providing robust fallback mechanisms for different UI modes. The component manages sophisticated battle mode logic including Custom Battle enemy team selection workflows (detecting when players need to select enemy teams before battle can start), team validation with user feedback, and dynamic enemy team generation through TeamManager integration. A critical responsibility is managing the transition between UI systems - primarily coordinating the switch from DOM-based TeamBuilder interface to Phaser-based Battle Scene, with comprehensive fallback support to the legacy DOM-based BattleUI when Phaser initialization fails. The component includes advanced Phaser integration features such as scene readiness polling, battle data preparation and passing, UI state management (hiding/showing containers), and proper canvas visibility handling. BattleInitiator maintains state synchronization across multiple systems, handles return-from-battle workflows to restore TeamBuilder state, and provides global function exposure for backward compatibility with existing battle management systems. The component implements comprehensive error handling with user-friendly alerts, sound integration for feedback, and defensive programming patterns to ensure battle initiation succeeds even when some dependencies are unavailable. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamManager.js (team data management, player/enemy team setting, and team generation), BattleModeManager.js (battle mode retrieval and validation), TeamSlotsManager.js (team composition data and enemy selection state), window.battleManager (battle logic initialization and DOM fallback), window.game (Phaser game instance, scene management, and BattleScene coordination), window.soundManager (audio feedback for battle transitions and errors), DOM elements (team-builder-container, game-container, canvas visibility), BattleScene.js (Phaser scene initialization with battle data), and provides global functions (window.onReturnFromPhaserBattle, window.onReturnFromBattle) for battle completion callbacks accessible across the application.



### Legacy Battle UI
- **BattleUI.js**: 
- **BattleUIDebug.js**: 

### General UI Systems
- **SoundManager.js**: A comprehensive audio management system responsible for providing sound effects and feedback within the TeamBuilder interface. The component creates a singleton SoundManager instance that handles both file-based audio (when available in the assets/audio/ directory) and generated Web Audio API sounds as fallbacks when audio files are missing. The system manages seven distinct sound types including click, hover, select, add, remove, error, and battle_start sounds, each with unique oscillator configurations for generated audio (square waves for clicks, triangles for selections, sawtooth for removals). SoundManager provides a complete audio control interface with a fixed-position UI overlay featuring volume controls and mute toggles, allowing players to customize their audio experience. The component automatically attaches itself to UI elements via addSoundsToUI(), applying sounds to buttons, battle mode selectors, hero cards, team slots, and the start battle button. Each sound type has a specific purpose within the TeamBuilder workflow - clicks for general interactions, selects for hero choices, add/remove for team composition, error for validation failures, and battle_start for major transitions. Currently focused on TeamBuilder functionality with no integration into the Phaser-based Battle Scene system, as indicated by the user context. The component implements robust error handling for audio initialization failures and provides graceful degradation when the Web Audio API is unavailable. *(Accurate as of v0.7.5.15)*

Talks to: Web Audio API (oscillator creation and audio context management), DOM elements (buttons, battle modes, hero cards, team slots, start battle button), TeamBuilder components (FilterManager.js adds hover sounds to buttons, BattleInitiator.js triggers battle_start sound), window scope (global singleton access as window.soundManager), asset files (attempts to load from assets/audio/ directory with fallbacks), and UI control elements (sound toggle button, volume slider) for real-time audio management.

- **TooltipManager.js**: A lightweight tooltip management system responsible for providing contextual information and enhanced user experience across the TeamBuilder interface. The component creates a singleton TooltipManager instance that handles dynamic tooltip creation, positioning, and content management through a simple yet effective API. The system creates a single reusable tooltip element that follows the mouse cursor with intelligent positioning logic to prevent tooltips from extending beyond viewport boundaries, automatically adjusting to display above or below the cursor based on available screen space. TooltipManager provides two primary integration methods: direct content tooltips for static information and function-based tooltips for dynamic content generation, allowing components to provide contextual information that updates based on current state. The component handles all event management internally, automatically attaching mouseenter and mouseleave listeners to elements and managing tooltip visibility states. The system is extensively utilized by HeroDetailPanelManager for providing detailed ability information including damage formulas, cooldown details, scaling text, and type advantage explanations, significantly enhancing the information density and usability of the TeamBuilder interface. TooltipManager supports HTML content rendering, enabling rich formatting for complex information displays while maintaining a clean and consistent visual style. The implementation focuses on performance and simplicity, using a single DOM element that's reused for all tooltips to minimize memory overhead. *(Accurate as of v0.7.5.15)*

Talks to: DOM event system (mousemove, mouseenter, mouseleave events), HTML elements (receives tooltip content and attaches to target elements), HeroDetailPanelManager.js (extensive integration for ability tooltips, stat descriptions, and type advantage information), TeamBuilderUtils.js (indirectly via components that use tooltipManager for stat box descriptions), window scope (global singleton access as window.tooltipManager), and CSS styling system (tooltip positioning and visual styling).

---

## Utilities & Helpers
- **DirectImageLoader.js**: A specialized utility component responsible for injecting character artwork into the DOM-based Battle UI system, serving as a critical bridge between character data and visual representation during battle. DirectImageLoader operates as a fallback system that automatically replaces placeholder character circles with actual character images through direct DOM manipulation, ensuring character artwork appears even when other loading mechanisms fail. The component maintains a hardcoded lookup table mapping character names to image paths, loads character data from JSON to apply custom positioning settings, and implements sophisticated animation protection systems to prevent art interference during battle animations. Key features include global image caching integration (utilizing window.CHARACTER_IMAGE_CACHE), custom positioning support for each character through their `art` property in characters.json, automatic periodic scanning for new character elements, and automatic disabling during animations to prevent visual artifacts. The system includes comprehensive error handling with image loading verification, multiple fallback mechanisms when images fail to load, and defensive programming patterns to prevent interference with the animation system. DirectImageLoader specifically targets the DOM-based BattleUI system (not the Phaser-based Battle Scene), making it essential for the legacy battle visualization while being bypassed in the modern Phaser implementation. The component demonstrates careful integration with the broader character art ecosystem, including storage of original positioning data for animation systems and sophisticated filtering to avoid processing animation clones or already-processed elements. *(Accurate as of v0.7.5.15)*

Talks to: DOM-based BattleUI.js (primary consumer for character art injection), window.CHARACTER_IMAGE_CACHE (global image caching system), data/characters.json (character data and custom art positioning), window event system (load event for initialization), BattleUI.js showAttackAnimation() (disabling via window.disableDirectImageLoaderDuringAnimation function), DOM elements (.character-circle containers and #battle-ui), browser Image API (for image loading and verification), character containers with team identifiers (player/enemy), and provides global utilities (window.disableDirectImageLoader flag) for animation system coordination.

- **ImageDebugger.js**: A lightweight diagnostic utility designed to troubleshoot image loading issues within the AutoBattler game, providing interactive tools for validating character artwork paths and identifying loading failures. ImageDebugger tests multiple potential image paths systematically, helping developers resolve artwork display problems during development and deployment. The component features an asynchronous path testing system that attempts to load images from various locations (relative paths, absolute paths, different directory structures), displays real-time loading results with visual feedback including success/failure indicators and image thumbnails, and creates a temporary debugging UI overlay with detailed status information. The utility implements comprehensive error handling with timeout protection (5-second limit per image) and graceful cleanup of debugging interface elements. Originally designed to address complex character art loading challenges during development, ImageDebugger has been streamlined as the character art system matured and stabilized. The component represents a crucial development tool for ensuring character artwork displays correctly across different environments and deployment scenarios. *(Accurate as of v0.7.5.15)*

Talks to: Browser Image API (for testing image loading from various paths), DOM manipulation (creates temporary debugging UI overlay), global window object (exposes ImageDebugger namespace), character art file system (tests asset paths for Character Art directory), setTimeout API (for loading timeouts), and serves as a standalone diagnostic tool accessible through browser console for development troubleshooting.

- **TeamBuilderImageLoader.js**: A sophisticated image management system responsible for handling character artwork within the TeamBuilder UI, providing centralized preloading, caching, and on-demand rendering across multiple contexts. TeamBuilderImageLoader implements Promise-based image preloading to ensure all character images are loaded before UI initialization, preventing race conditions that previously caused "not found in image cache" errors. The component features intelligent context-aware rendering supporting multiple view modes (full/compact), applies different sizing based on usage context (hero grid vs. detail panel), and utilizes character-specific art configurations from characters.json including custom positioning and separate settings for different UI contexts (art, teamBuilderArt, detailArt). Key features include a dual caching system using both instance-level cache and global cache (window.CHARACTER_IMAGE_CACHE), WeakSet-based tracking to prevent reprocessing, view mode scaling that applies 1.4x magnification in full view while maintaining original sizes in compact view, and explicit art rendering through the drawArt() method replacing the deprecated observer-based approach. The component implements comprehensive error handling with loading placeholders, fallback mechanisms for failed image loads, and defensive programming patterns. TeamBuilderImageLoader integrates seamlessly with the component-based TeamBuilder architecture, providing art services to HeroGridManager, HeroDetailPanelManager, and TeamSlotsManager while maintaining separation of concerns through delegation patterns. *(Accurate as of v0.7.5.15)*

Talks to: HeroGridManager.js (art rendering with view mode support), HeroDetailPanelManager.js (detail panel art with context-specific sizing), TeamSlotsManager.js (team slot art rendering), TeamBuilderUI.js (parent orchestrator and initialization), window.CHARACTER_IMAGE_CACHE (global image caching), data/characters.json (character data and art configuration), Promise-based initialization system, DOM elements (.hero-avatar-container, .hero-art-wrapper), browser Image API (loading and error handling), and provides utility functions for image validation and user feedback.

---

## Configuration & Initialization
- **game.js**: The main entry point and orchestrator for the entire AutoBattler application. This file handles the complete initialization sequence when the game loads, including creating the TeamManager, TeamBuilderUI, BattleManager, and the Phaser game instance. It also manages the loading of configuration files and serves as the central coordinator that connects all major systems together. The file includes comprehensive error handling and fallback mechanisms to ensure the game can start even if some components fail to load. It exposes all major managers globally for debugging and cross-system communication. *(Accurate as of v0.7.5.14)*

Talks to: TeamManager.js, TeamBuilderUI.js, BattleManager.js, PhaserConfig.js, project.config file, and window/global scope for system-wide access.


- **assets.js**: A comprehensive asset management system that catalogs and organizes all game resources including character images, UI elements, arena backgrounds, and effects. The AssetsManager class provides a centralized way to locate and preload assets for the Phaser engine, with methods for cataloging different asset types and loading them into Phaser scenes. It integrates with existing image loaders and provides fallback mechanisms for missing assets. This system ensures consistent asset paths and enables efficient preloading strategies. *(Accurate as of v0.7.5.14)*

Talks to: TeamBuilderImageLoader.js (for character image paths), Phaser scenes (for asset preloading), and the assets folder structure directly.


- **config.js**: A duplicate/alternative Phaser configuration class that appears to provide similar functionality to PhaserConfig.js but with different default settings and container management. This version uses more basic configuration settings and seems designed for standard HD resolution rather than 4K. It creates Phaser containers dynamically and provides static methods for configuration creation. This may be an older version or alternative implementation that's maintained for compatibility. *(Accurate as of v0.7.5.14)*

Talks to: Similar to PhaserConfig.js - interfaces with the DOM for container creation and provides configuration to Phaser.Game constructor.


- **PhaserConfig.js**: A utility module that handles the technical configuration and container setup for the Phaser game engine. It creates and styles the DOM container where Phaser renders, configures rendering options for optimal performance (including 4K support), and provides helper functions for checking if Phaser is properly initialized. The configuration includes specific settings for anti-aliasing, pixel art handling, and canvas context optimization. This module encapsulates all the technical details needed to get Phaser running correctly. *(Accurate as of v0.7.5.14)*

Talks to: game.js (called during Phaser initialization), the DOM (creates and styles containers), and provides configuration objects to the Phaser.Game constructor.


- **uiManager.js**: A sophisticated system for managing transitions between different UI modes in the game - specifically between DOM-based interfaces (like the Team Builder) and Phaser-based scenes (like the Battle Scene). It handles showing/hiding appropriate containers, managing scene transitions within Phaser, and provides toggle buttons for users to switch between UI modes. The UIManager acts as a bridge between the traditional HTML/CSS interface and the Phaser-powered game scenes, enabling seamless transitions during gameplay. *(Accurate as of v0.7.5.14)*

Talks to: game.js (receives Phaser game instance), DOM elements (team-builder-container, game-container, phaser-container), Phaser scenes (BattleScene, TeamBuilderScene), and manages scene lifecycle within the Phaser framework.



---

## Notes on Component Categories

### What Makes a "Component"?
Components are reusable, focused pieces of functionality that can be combined to create larger systems. In this codebase, they typically:
- Have a single, clear responsibility
- Can be instantiated multiple times
- Provide clean interfaces for interaction
- Handle their own lifecycle (creation, updates, destruction)

### Manager vs. Component vs. Utility
- **Managers**: Orchestrate multiple systems (BattleManager coordinates all battle logic)
- **Components**: Focused, reusable pieces (CharacterSprite handles one character's visuals)
- **Utilities**: Helper functions and tools (BattleUtilities provides common calculations)

### Refactoring History
Many of these files were created by refactoring larger, monolithic files into smaller, focused components. This makes the code:
- Easier to understand and maintain
- More testable in isolation
- More reusable across different parts of the game
- Less likely to create conflicts when multiple developers work on it

---

*Last Updated: [Date] - This document should be updated whenever new files are added or the architecture significantly changes.*
