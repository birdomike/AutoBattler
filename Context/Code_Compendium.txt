# AutoBattler Code Compendium

## Purpose
A complete reference guide to every JavaScript file in the AutoBattler game, explaining what each one does and how it fits into the overall architecture. This document serves as a comprehensive catalog of all code components for both developer reference and AI context restoration.

## How to Use This Document
- **For Developers**: Quick reference to understand what each file does and where to find specific functionality
- **For AI Context**: Provides detailed context about the codebase when starting new conversations
- **For Architecture Understanding**: Shows how different components relate to each other

---

## Battle Logic Components

### Core Systems
- **BattleFlowController.js**: A core orchestration component responsible for managing the complete battle sequence lifecycle in the AutoBattler game, serving as the central conductor for turn-based combat flow. BattleFlowController emerged from a systematic refactoring effort (Stage 3 of the BattleManager component-based migration) where battle flow logic was extracted from the monolithic BattleManager into a specialized, focused component. The controller handles the entire battle progression from initialization through turn management to completion, including battle startup (loading status effects, initializing behavior systems, preparing teams), turn sequencing (turn advancement, passive ability triggers, status effect processing), action orchestration (generating character actions, managing action queues, validating alive characters), effect application (delegating to specialized processors like DamageCalculator and HealingProcessor), and battle conclusion (checking end conditions, processing defeat/victory). Key architectural features include sophisticated multi-target action handling with individual damage calculations, comprehensive event dispatching through BattleEventDispatcher and BattleBridge for UI synchronization, defensive programming with extensive validation and fallback mechanisms, and deep integration with the passive ability system through triggers like onBattleStart, onTurnStart, and onBattleEnd. The component implements complex logic for retargeting when original targets are defeated, proper team identification for battle log clarity (ally/enemy designations), and robust error handling throughout the battle flow. BattleFlowController coordinates with over 10 specialized components including BattleInitializer for setup, DamageCalculator and HealingProcessor for damage/healing logic, PassiveAbilityManager for passive abilities, and ActionGenerator for character actions. The component has undergone multiple iterations, with significant fixes including proper battle action declaration formatting, correct script path resolution, and comprehensive method implementation. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and component facade), BattleInitializer.js (team preparation and character setup), DamageCalculator.js (damage computation and application), HealingProcessor.js (healing calculations and revival logic), StatusEffectManager.js (status effect processing each turn), PassiveAbilityManager.js (passive ability triggers), ActionGenerator.js (character action creation), TargetingSystem.js (target selection and validation), AbilityProcessor.js (ability effect processing), BattleEventDispatcher.js (event coordination), BattleLogManager.js (battle message logging), TypeEffectivenessCalculator.js (type advantage calculations), window.battleBridge (UI event communication), window.BattleBehaviors (AI decision making), DOM BattleUI.js (legacy UI updates), and provides global access through window.BattleFlowController for debugging and cross-system coordination.

- **BattleInitializer.js**: A core preparation component responsible for transforming raw character data into fully battle-ready entities, ensuring proper initialization and validation of all team and character properties before combat begins. BattleInitializer emerged from the BattleManager refactoring effort (Phase 1) where all team and character initialization logic was extracted into a focused, dedicated component. The initializer handles comprehensive character preparation including deep cloning of team data to prevent reference conflicts, complete character property validation with default value assignment, unique ID generation for battle tracking, team type assignment, ability initialization and passive ability identification, and stats validation with fallback values. Key architectural features include robust data transformation through JSON parse/stringify for team independence, extensive defensive programming with validation and detailed error handling, sophisticated character validation ensuring all required properties exist, and passive ability preprocessing for quick reference during battle. The component implements two-phase initialization with `initializeTeamsAndCharacters()` for complete team setup followed by `prepareTeamForBattle()` for battle-specific preparation, handles edge cases gracefully, and provides comprehensive diagnostic logging. BattleInitializer integrates with PassiveTriggerTracker to reset battle tracking and coordinates with BattleManager through a facade pattern, significantly reducing BattleManager's complexity by approximately 104 lines while improving error handling and code organization. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation), PassiveTriggerTracker.js (resets battle-level tracking), BattleFlowController.js (receives initialized teams for battle startup), window.battleManager (accesses global reference), JSON processing system (deep cloning for team independence), character data structures (transforms raw data into battle entities), ability system (identifies and preprocesses passive abilities), stats validation system (ensures complete character properties), and provides global access through window.BattleInitializer for debugging and cross-system coordination.



### Status & Effects
- **StatusEffectManager.js**: A core battle logic component responsible for managing all status effect application, processing, and lifecycle management during combat. StatusEffectManager emerged from the Stage 2 BattleManager refactoring effort (v0.5.24.2-0.5.24.4) where status effect logic was extracted from the monolithic BattleManager into a specialized component. The manager handles the complete status effect lifecycle including application with sophisticated stacking and duration logic, turn-based processing with per-turn effect triggers (damage over time, healing over time, stat modifications), source attribution through the "Source ID Linking" pattern to prevent circular references, effect removal and expiration management, and comprehensive status icon updates through event dispatching. Key architectural features include robust parameter validation with intelligent fallback handling for misaligned parameters, integration with StatusEffectDefinitionLoader for comprehensive effect definitions with smart fallback generation, sophisticated multi-target validation (v0.5.27.2_Hotfix8) ensuring invalid targets don't break entire actions, and extensive integration with BattleUtilities (v0.6.0.3) for source character resolution from stored unique IDs. The component implements multiple effect types (damage, healing, statModifier, shield, control) with appropriate processing logic for each, maintains character original stats for proper stat modifier removal, and provides rich query interfaces for checking effect presence, stacks, and values. StatusEffectManager underwent significant parameter order fixes and source resolution improvements, transitioning from direct battleManager method calls to BattleUtilities integration, and includes comprehensive event dispatching through BattleEventDispatcher for UI synchronization. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and primary integration point), StatusEffectDefinitionLoader.js (effect definitions and fallback generation), BattleUtilities.js (source character resolution from unique IDs), BattleEventDispatcher.js (comprehensive event dispatching for UI updates via dispatchStatusEffectAppliedEvent), DamageCalculator.js (through battleManager facade for damage application), HealingProcessor.js (through battleManager facade for healing application), window.battleBridge (direct event dispatching and fallback communication), window.BattleUtilities (global utility access for character lookups), AbilityProcessor.js (receives delegated effect application calls), PassiveAbilityManager.js (coordinates status effects from passive triggers), and character data structures (maintains statusEffects arrays, originalStats tracking for stat modifiers).

- **StatusEffectDefinitionLoader.js**: A specialized component responsible for loading, normalizing, and managing status effect definitions from multiple sources, serving as the authoritative registry for all status effect metadata in the AutoBattler game. StatusEffectDefinitionLoader emerged from Phase 2 of the BattleManager refactoring effort (v0.5.30.0-0.5.30.1) where all status effect definition handling was extracted from BattleManager to achieve true separation of concerns. The loader handles multi-source definition loading including primary JSON file loading from 'data/status_effects.json' with fallback to root directory, comprehensive error handling with graceful degradation to fallback definitions, and intelligent definition normalization supporting multiple JSON formats and property naming conventions (defaultDuration vs duration, maxStacks vs stackable, icon vs iconPath, behavior objects vs direct effectType). Key architectural features include sophisticated format detection and normalization (v0.5.27.9) that translates behavior-based effects into standard effectType formats, smart fallback generation that creates meaningful definitions based on effect ID patterns, comprehensive validation with detailed error reporting, and definition caching using Map for efficient lookups. The component implements a dual initialization strategy with immediate fallback setup followed by JSON loading attempts, handles various JSON structures including nested status_effects arrays and effect ID-keyed objects, and provides intelligent autodetection for effect types (damage, healing, control, shield, statModifier) based on ID naming patterns. StatusEffectDefinitionLoader fully encapsulates status effect definition concerns, eliminating BattleManager's knowledge of definition sources and enabling complete architectural separation between orchestration and data management components. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (receives delegation for definition loading initialization), StatusEffectManager.js (primary consumer for effect definitions via getDefinition method), data/status_effects.json (primary data source with fetch API), browser Fetch API (for JSON loading with primary/fallback path handling), window scope (global exposure for debugging and cross-system access), Map data structure (internal definition storage and caching), console logging system (comprehensive diagnostic and error reporting), and provides fallback definition services for unknown effect IDs through generateFallbackDefinition method with intelligent type detection.



### Damage & Healing
- **DamageCalculator.js**: A specialized battle logic component responsible for all damage calculation and application mechanics within the combat system, serving as the authoritative source for determining damage amounts, stat scaling, and damage delivery effects. The calculator handles comprehensive damage mechanics including base damage determination from abilities or auto-attacks, sophisticated stat scaling with configurable factors (50% Strength for physical, 50% Intellect for spell damage), type effectiveness integration via TypeEffectivenessCalculator, defense reduction using diminishing returns formula, random variance (±20% for combat unpredictability), and critical hit system (10% chance for 50% bonus damage). Key architectural features include a comprehensive metadata return system providing damage amounts, scaling text, critical hit flags, and type multipliers for enhanced battle log integration, sophisticated parameter validation with defensive programming patterns including stats object verification, dual-phase damage processing with calculation followed by application and character state management, and extensive error handling with informative console logging for debugging problematic character data. The component implements intelligent stat resolution with case-insensitive fallbacks for property access, multi-effect ability support allowing different damage values within single abilities, and proper integration with the battle event system for UI synchronization. DamageCalculator provides detailed damage calculations that include scaling contributions, critical hit indicators, and type effectiveness results, enabling rich battle log messages and comprehensive damage metadata for other systems. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation for damage operations), TypeEffectivenessCalculator.js (type advantage/disadvantage calculations via calculateTypeMultiplier), window.battleBridge (event dispatching for CHARACTER_DAMAGED events), Character entities (stats access for damage calculations and health management including currentHp, isDefeated state), ability system (damage values, scaling factors, damageType properties for calculation parameters), console logging system (comprehensive error reporting and debugging information for invalid characters or stats), and battle log system (damage text formatting with scaling information and critical hit indicators for combat feedback).

- **HealingProcessor.js**: A specialized battle logic component responsible for all healing calculations, application, and resurrection mechanics within the combat system, serving as the counterpart to DamageCalculator for positive health modifications. The processor handles comprehensive healing mechanics including healing amount validation and application with automatic HP capping at maximum values, resurrection detection and state management for characters revived from defeat, dual-phase processing separating healing application from death state reset, and comprehensive event dispatching through the battle event system for UI synchronization. Key architectural features include a structured return system providing actual healing amounts and revival status flags for upstream processing, intelligent character state tracking to identify when defeated characters should be resurrected, team-aware logging with ally/enemy identifiers for clear battle messages, and extensive error handling with fallback mechanisms for missing dependencies. The component implements two primary operations: applyHealing() for direct health modification with event dispatch and checkAndResetDeathStatus() for managing character resurrection logic separately. HealingProcessor integrates seamlessly with the battle event system, dispatching CHARACTER_HEALED events with complete metadata including healing amounts, source attribution, and character state information for UI updates and visual effects. The component maintains the same architectural patterns as other battle logic components with defensive programming, comprehensive parameter validation, and dual event dispatch paths supporting both facade methods and direct battleBridge integration. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation for healing operations via dispatchHealingEvent facade), window.battleBridge (direct event dispatching for CHARACTER_HEALED events), Character entities (health state management including currentHp modification and isDefeated flag reset), ability system (healing values and healing type properties from healing abilities), console logging system (error reporting and resurrection messages), battle log system (revival notifications with team identifiers), and provides structured healing results including actual healing amounts and revival status for integration with BattleFlowController and other battle logic components.

- **TypeEffectivenessCalculator.js**: A specialized battle logic component responsible for calculating type advantage multipliers and managing the comprehensive 22-type effectiveness system within the combat mechanics. TypeEffectivenessCalculator emerged from Stage 4 of the BattleManager refactoring effort (v0.5.21) where type effectiveness logic was extracted from the monolithic BattleManager into a dedicated component to enable data-driven type relationships and enhanced battle complexity. The calculator handles sophisticated type interaction calculations including standard advantages (+50% damage) and disadvantages (-50% damage), special immunities (0x damage, such as Metal immune to Poison and Ethereal immune to Physical), unique special cases (Light deals 3x damage to Ethereal), and multi-type character support with optimal advantage selection. Key architectural features include comprehensive data loading from `data/type_effectiveness.json` with robust fallback mechanisms when JSON loading fails, intelligent string parsing to handle multi-type characters using "/" delimiters, battle log integration providing descriptive type relationship messages with appropriate color coding (success for advantages, info for disadvantages, warning for immunities), and dual-function API supporting both multiplier calculation and descriptive text generation for UI tooltips. The component implements extensive error handling with graceful degradation to minimal fallback type relationships, case-insensitive type processing for consistent behavior, and sophisticated multi-type evaluation that returns the most advantageous multiplier when characters have dual types. TypeEffectivenessCalculator supports the complete 22-type system including Fire, Water, Nature, Electric, Ice, Rock, Air, Light, Dark, Metal, Psychic, Poison, Physical, Arcane, Mechanical, Void, Crystal, Storm, Ethereal, Blood, Plague, and Gravity, each with distinct advantage/disadvantage relationships based on thematic and strategic considerations. The component provides both computational services for damage calculation and descriptive services for UI enhancement through methods like `getTypeAdvantageText()` for generating tooltip content and ability descriptions. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation and providing battle log access), DamageCalculator.js (primary consumer for damage multiplier calculations), data/type_effectiveness.json (comprehensive type relationship data source), window scope (global exposure as window.TypeEffectivenessCalculator), console logging system (initialization status and fallback warnings), battle log system (descriptive type relationship messages through battleManager.logMessage), JSON processing system (async data loading with fetch API), Character entities (indirectly via type property access in damage calculations), ability system (descriptive text generation for ability tooltips), and UI components (type advantage text for character details and battle feedback). 

### Abilities & Actions
- **AbilityProcessor.js**: A specialized battle logic component responsible for processing and executing all ability effects within the combat system, serving as the centralized authority for translating ability data into actual gameplay mechanics. The processor handles comprehensive ability execution including both legacy action processing with simple ability structures and modern effects-based abilities with complex effect arrays, multi-target action processing with individual effect application to each target, differentiated processing for damage, healing, and utility abilities, and sophisticated effect routing through specialized components (DamageCalculator for damage, HealingProcessor for healing, StatusEffectManager for status effects). Key architectural features include extensive defensive programming with component availability checks and parameter validation, intelligent effect filtering based on team relationships (ally/enemy targeting rules), comprehensive event dispatching for UI synchronization (CHARACTER_DAMAGED, CHARACTER_HEALED events), and deep integration with the passive ability system for triggering onDamageTaken, onDamageDealt, onHealed, onHealingDone, onKill, and onDefeat passive behaviors. The component implements a sophisticated effect processing system supporting multiple effect types (Damage, Healing, ApplyStatus, StatBuff) with conditional application based on chance, team affiliation, and targeting restrictions. AbilityProcessor processes both simple abilities with direct damage/healing values and complex abilities with structured effects arrays containing detailed scaling factors, targeting rules, and conditional probability, while providing comprehensive team-aware logging with ally/enemy identifiers for clear battle messages. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation for ability processing operations), DamageCalculator.js (damage calculation and application for damage effects), HealingProcessor.js (healing calculation and application for healing effects), StatusEffectManager.js (status effect application for ApplyStatus effects), PassiveAbilityManager.js (triggering passive abilities through battleManager.processPassiveAbilities), window.battleBridge (direct event dispatching for CHARACTER_DAMAGED and CHARACTER_HEALED events), window.BattleUI (visual passive effect feedback through showPassiveEffect), character entities (health modification, defeat status management), ability system (effect arrays, scaling factors, targeting rules), battle log system (detailed combat messages with team identifiers), and console logging system (comprehensive debug information and error reporting for ability processing workflows).

- **TargetingSystem.js**: A specialized battle logic component responsible for centralized target selection for all abilities and attacks within the combat system, serving as the authoritative bridge between ability intent and actual target determination. The system handles sophisticated target selection through intelligent behavior resolution, determining appropriate targeting strategies based on ability properties (explicit targetingLogic, targetType mappings, or smart defaults), integrating with the BattleBehaviors system for actual target evaluation, and providing comprehensive fallback mechanisms for edge cases and system failures. Key architectural features include defensive parameter validation with comprehensive null checking and error handling, multi-target support for abilities affecting multiple characters, sophisticated behavior resolution using layered targeting logic (explicit → type-based → property-based → default), and intelligent context creation filtering for valid targets (living characters only). The component implements smart targeting logic that automatically selects appropriate behaviors: healing abilities target lowest HP allies, utility abilities target self, AoE abilities use multi-target behaviors, and damage abilities default to enemy targeting. The component provides extensive verbose logging support for debugging targeting decisions and includes fallback targeting that ensures battles can proceed even when the behavior system is unavailable. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and initialization), window.BattleBehaviors (behavior system integration via selectTarget method), ActionGenerator.js (receives targeting service delegation), BattleFlowController.js (indirectly via action processing workflow), window.VERBOSE_LOGGING (detailed debug logging support), character entities (team validation, health state checking), ability system (targetingLogic property processing, targetType evaluation, damage type analysis), potentialTargets arrays (living character filtering), and console logging system (comprehensive error reporting and debugging information).

- **ActionGenerator.js**: A specialized battle logic component responsible for generating character actions during combat, serving as the central authority for translating character decisions into executable action objects for the battle system. The component handles the complete action generation pipeline including comprehensive character state validation (ensuring all required properties like stats, health, and abilities exist), sophisticated ability selection through BattleBehaviors integration with fallback mechanisms, target determination via TargetingSystem delegation with multi-target support, and damage calculation using DamageCalculator with proper effect-specific scaling factors. Key architectural features include robust character validation at multiple points to prevent invalid data propagation, intelligent ability selection using layered decision logic (character-specific actionDecisionLogic → BattleBehaviors system → weighted random fallback), comprehensive multi-target action support with individual damage calculations for each target in AoE abilities, and extensive defensive programming with graceful degradation when dependencies are unavailable. The component implements sophisticated action object creation with proper metadata including actionType/abilityName properties for event dispatching, multi-target data for AoE abilities, and complete damage information with scaling text and type effectiveness details. ActionGenerator underwent multiple refinements including character validation improvements, multi-target action handling, friendly fire prevention for auto-attacks, and critical scaling factor fixes ensuring abilities use their intended effect-specific scaling instead of default values. The component serves as the final stage of action preparation before execution, creating complete action objects that contain all necessary data for BattleFlowController to process during combat. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and facade methods), TargetingSystem.js (target selection delegation via selectTarget method), DamageCalculator.js (damage calculation with effect-specific scaling factor support), window.BattleBehaviors (action decision making via decideAction method), BattleFlowController.js (receives generated actions for combat execution), window.VERBOSE_LOGGING (detailed debug logging for ability selection), character entities (state validation, ability filtering, cooldown management), ability system (ability selection, effect extraction, passive filtering), team data structures (multi-team action generation, team-based targeting), statusEffects system (stun status checking), and console logging system (comprehensive validation errors, action generation debugging, and component availability warnings). 

### Passive Systems
- **PassiveAbilityManager.js**: A specialized battle logic component responsible for managing and executing passive abilities throughout combat, serving as the central orchestrator for passive trigger detection, validation, and behavior execution. The component handles comprehensive passive ability lifecycle management including sophisticated trigger matching for various event types (onBattleStart, onTurnStart, onDamageTaken, onDamageDealt, onHealed, onHealingDone, onKill, onDefeat), rigorous character validation ensuring all required properties exist before processing, global trigger support for battle-wide events affecting all living characters, and intelligent stack tracking integration with PassiveTriggerTracker to prevent duplicate triggers and enforce maximum stack limits. Key architectural features include extensive defensive programming with comprehensive character validation checks (name, stats, health properties, passive abilities array), sophisticated trigger evaluation using multiple criteria (trigger type matching, behavior availability, max stacks checking), multi-character processing for global triggers iterating through both player and enemy teams, and detailed execution context creation for passive behaviors with proper team management integration. The component implements robust error handling with graceful degradation when dependencies are unavailable, team-aware logging with ally/enemy identifiers for clear battle messages, and sophisticated passive execution through the BattleBehaviors system. PassiveAbilityManager underwent significant refinements including enhanced character validation to prevent cascade errors in other components like ActionGenerator, comprehensive defensive checks for all dependencies, and removal of toggle mechanisms after successful validation. The component serves as a critical bridge between passive ability definitions and their actual execution during battle, ensuring proper trigger timing and preventing duplicate executions. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator and facade delegation), PassiveTriggerTracker.js (trigger state tracking via hasFiredThisTurn, hasFiredThisBattle, recordTrigger methods), window.BattleBehaviors (passive behavior execution via executePassiveBehavior method), character entities (passive ability validation, trigger matching, team identification), battle log system (passive activation messages with team identifiers), AbilityProcessor.js (indirectly via passive trigger events like onDamageDealt, onDamageTaken during ability execution), BattleFlowController.js (integration points for onTurnStart, onBattleStart, onBattleEnd triggers), team data structures (global trigger processing across playerTeam and enemyTeam arrays), ability system (passive ability definitions, trigger types, behavior names), and console logging system (comprehensive validation errors, execution debugging, and component availability warnings).

- **PassiveTriggerTracker.js**: A specialized tracking component responsible for managing passive ability trigger history during battle, serving as the authoritative state manager for preventing duplicate passive executions and enforcing trigger limitations. The tracker manages dual-scope tracking including turn-based restrictions preventing the same passive from triggering multiple times per turn, and battle-wide counting enabling passives with maximum trigger limits across entire battles. Key architectural features include a sophisticated key generation system using character unique IDs, passive ability IDs, and trigger types for precise tracking, dual Map-based storage with turnTriggers for boolean turn tracking and battleTriggers for integer battle-wide counts, comprehensive validation and defensive programming with fallback key generation for invalid parameters, and intelligent stack management supporting configurable maximum trigger limits per passive ability. The component implements methods for checking trigger states (hasFiredThisTurn, hasFiredThisBattle), recording new triggers with automatic count incrementing, and stack limit validation (hasReachedMaxStacks). PassiveTriggerTracker integrates seamlessly with the passive ability system through automatic reset mechanisms at turn and battle boundaries, providing turn tracking reset (resetTurnTracking) and battle tracking reset (resetBattleTracking) called by BattleManager and BattleInitializer respectively. The component includes robust error handling with graceful degradation when invalid parameters are provided, ensuring the passive ability system remains stable even with malformed data. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator, component initialization, and reset delegation), PassiveAbilityManager.js (primary consumer for trigger state checking via hasFiredThisTurn, hasFiredThisBattle, and trigger recording via recordTrigger), BattleInitializer.js (triggers battle tracking reset via resetBattleTracking when battles start), BattleFlowController.js (indirectly coordinates turn tracking resets via BattleManager.startNextTurn), window scope (global exposure for debugging), console logging system (comprehensive debug and warning logging), passive ability data structures (extracts maxTriggers configuration from passiveData and ability properties), Map data structures (internal turnTriggers and battleTriggers storage), and character entities (uniqueId extraction for consistent trigger key generation).

### Events & Communication
- **BattleEventDispatcher.js**: A specialized event orchestration component responsible for centralizing and standardizing all battle event dispatching within the combat system, serving as the authoritative communication bridge between battle logic and UI components. The dispatcher handles comprehensive event standardization including parameter validation with intelligent fallbacks for invalid data, dual property naming patterns for backward compatibility (both 'character' and 'target' properties), comprehensive error handling with graceful degradation when dependencies are unavailable, and intelligent fallback event types when battleBridge is not available. Key architectural features include a sophisticated dispatching system supporting both battleBridge integration and custom event listeners, specialized methods for each event type with dedicated validation and formatting, type-safe event data structures ensuring consistent property naming across the system, and defensive programming patterns preventing silent failures. The component implements a dual-channel dispatch system routing events through both the primary battleBridge system and local custom listeners, supports all major battle event types (CHARACTER_DAMAGED, CHARACTER_HEALED, CHARACTER_ACTION, STATUS_EFFECT_APPLIED, PASSIVE_TRIGGERED, BATTLE_ENDED, TURN_STARTED), and provides detailed error messages with component and method context for debugging. BattleEventDispatcher integrates seamlessly with the facade pattern in BattleManager, which delegates all event dispatching operations to this specialized component through methods like dispatchDamageEvent, dispatchHealingEvent, and dispatchBattleEndEvent. The component includes comprehensive validation for critical battle events, standardized data formatting across different event types, and maintains backward compatibility while establishing consistent property naming conventions throughout the event system. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation for all event dispatch operations), window.battleBridge (primary event routing system via dispatchEvent method), BattleLogManager.js (direct integration as constructor dependency and delegation target), custom event listeners (registered via addEventHandler and removeEventHandler methods), window scope (global exposure for debugging and cross-system coordination), console logging system (comprehensive validation warnings and error reporting), character entities (event data extraction for character properties), ability system (event data for action and ability-related events), and provides standardized event data structures consumed by UI components including Phaser BattleScene, DOM BattleUI, and various visual effect systems.
- **BattleLogManager.js**: A specialized log management component responsible for formatting, validating, and dispatching battle log messages throughout the combat system, serving as the centralized authority for all battle-related text output and turn summaries. The manager handles comprehensive message processing including parameter validation with type checking against a predefined whitelist (default, info, success, action, error, player, enemy, status, healing), sophisticated message formatting with team identifiers for character-based messages, detailed turn summary generation displaying team health statuses with color-coded indicators, and event dispatching through BattleEventDispatcher integration or direct battleBridge fallback. Key architectural features include defensive programming with graceful degradation when dependencies are unavailable, team-aware message formatting automatically adding ally/enemy identifiers to character names, color-coded health status determination based on character health percentages, and comprehensive error handling for invalid message types and missing battle data. The component implements sophisticated turn summary functionality generating detailed health reports for all characters across both teams, supports structured message types for UI styling and categorization, and provides fallback mechanisms when EventDispatcher is not available. BattleLogManager underwent a critical fix (v0.6.3.38) resolving console warnings for 'healing' type messages by adding 'healing' to the valid types array, maintaining semantic intent while eliminating validation errors. The component integrates seamlessly with BattleManager's facade pattern through direct delegation methods like logMessage and displayTurnSummary, eliminating toggle mechanisms for streamlined operation. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (parent coordinator receiving delegation for all log operations via logMessage and displayTurnSummary), BattleEventDispatcher.js (constructor dependency and primary routing for log events via dispatchBattleLogEvent), window.battleBridge (fallback event routing when EventDispatcher unavailable), character entities (team identification and health status extraction), team data structures (playerTeam and enemyTeam arrays for turn summaries), console logging system (debug output and fallback logging), window scope (global exposure for debugging), battle state data (health percentages, defeat status, team composition), and provides structured log messages consumed by UI components for display formatting and visual styling.

### Utilities & Behaviors
- **BattleUtilities.js**: A specialized static utility class providing essential helper functions for battle operations, serving as the centralized repository for common functionality that was extracted from BattleManager during the systematic component-based refactoring effort. BattleUtilities emerged from Phase 3 of the BattleManager refactoring initiative (v0.5.31.0) where approximately 37 lines of utility logic were extracted from the monolithic BattleManager into a focused, reusable static class to improve separation of concerns and eliminate code duplication across battle components. The class handles four core categories of functionality including character management operations for combining teams and resolving character objects from unique identifiers, data manipulation utilities for array randomization and object serialization, defensive programming with comprehensive parameter validation and error handling, and global accessibility through window exposure for cross-system integration. Key architectural features include a pure static implementation requiring no instantiation, enhanced parameter validation with intelligent fallback handling compared to the original BattleManager implementations, sophisticated circular reference handling for safe object serialization, and integration with the "Source ID Linking" pattern critical for status effect source attribution without creating circular references. The component implements four primary static methods: `getAllCharacters()` for combining player and enemy teams into unified arrays, `getCharacterByUniqueId()` for resolving character objects from stored unique IDs across teams with comprehensive team validation and detailed warning messages when characters are not found, `shuffleArray()` for randomizing array elements using defensive array validation, and `safeBattleStringify()` for secure object serialization with WeakSet-based circular reference detection. BattleUtilities underwent critical integration fixes including v0.6.0.2 addressing ActionDecisionBehaviors.js usage with comprehensive fallback mechanisms, and v0.6.0.3 resolving StatusEffectManager integration for proper source character resolution in the Source ID Linking pattern. The class demonstrates the architectural transition from embedded utility methods to dedicated static services, enabling clean separation between core battle orchestration and utility functionality while maintaining global accessibility for all battle system components. *(Accurate as of v0.7.5.15)*

Talks to: ActionDecisionBehaviors.js (team health analysis via getAllCharacters method for healing priority decisions), StatusEffectManager.js (source character resolution via getCharacterByUniqueId method for Source ID Linking pattern), window scope (global exposure for debugging and cross-system access), console logging system (comprehensive parameter validation warnings and character lookup failure messages), team data structures (playerTeam and enemyTeam arrays for character management operations), character entities (uniqueId-based lookups and validation), JSON processing system (circular reference handling in safeBattleStringify), Array data structures (Fisher-Yates shuffling algorithm implementation), and provides utility services accessible to any battle logic component requiring character management, data manipulation, or safe serialization functionality.


- **BattleBehaviors.js**: A central orchestration class serving as the unified interface for the battle behavior system, providing centralized access to all behavioral decision-making functions for AI combat logic throughout the AutoBattler game. BattleBehaviors acts as the main entry point that imports and re-exports all behavior functionality while providing a clean API facade for executing different types of behavioral decisions. The component encompasses three primary behavioral domains including targeting behaviors for selecting appropriate targets for abilities and attacks, action decision behaviors for determining which abilities characters should use versus basic attacks, and passive behaviors for executing passive ability effects in response to various game events. Key architectural features include a singleton pattern providing unified access through a single instance, ES6 module integration with proper import/export patterns for ActionDecisionBehaviors, TargetingBehaviors, and PassiveBehaviors modules, comprehensive behavior registry integration acting as a wrapper around BehaviorRegistry for centralized behavior management, and sophisticated fallback mechanisms with a complete fallback version in the fallback directory providing non-ES module compatibility. The component implements a clean interface with three primary methods: `selectTarget()` for ability and action targeting through delegation to registry's executeTargetingBehavior, `decideAction()` for ability selection AI through delegation to registry's executeActionDecisionBehavior, and `executePassiveBehavior()` for passive ability processing with comprehensive context creation. BattleBehaviors provides essential utility functions including behavior existence checking via `hasBehavior()`, default behavior retrieval through `getDefaultTargetingBehavior()` and `getDefaultActionDecisionBehavior()`, and targetType-to-behavior mapping through `getTargetingBehaviorFromType()` enabling automatic targeting logic resolution from ability data. The system maintains a dual implementation approach with a modern ES6 module version in the main battle_logic directory and a comprehensive fallback version providing simplified implementations of core targeting and action decision logic for environments where the full module system is unavailable. The fallback implementation includes essential behaviors such as targetLowestHpEnemy, targetLowestHpAlly, targetSelf, prioritizeHealing action decision logic, and basic passive ability processing with hardcoded passive behaviors for common effects like damage reflection, status application, and team buffs. *(Accurate as of v0.7.5.15)*

Talks to: BehaviorRegistry.js (primary dependency providing executeTargetingBehavior, executeActionDecisionBehavior, and executePassiveBehavior delegation), TargetingBehaviors.js (imports targeting logic and ensures registration), ActionDecisionBehaviors.js (imports action decision logic and ensures registration), PassiveBehaviors.js (imports passive ability logic and ensures registration), ActionGenerator.js (primary consumer via decideAction method for ability selection), TargetingSystem.js (primary consumer via selectTarget method for target selection), PassiveAbilityManager.js (primary consumer via executePassiveBehavior method for passive processing), window scope (global exposure as window.BattleBehaviors and window.battleBehaviors for cross-system compatibility), console logging system (initialization and error reporting), BattleManager.js (indirectly via component delegation and battleBehaviors property), and provides behavioral decision-making services accessible throughout the battle system for AI-driven character actions, targeting decisions, and passive ability executions.


- **BehaviorRegistry.js**: A centralized registry managing all behavior functions for the battle system's AI-driven combat logic through a flexible behavior delegation pattern. BehaviorRegistry serves as the core infrastructure enabling modular, name-based behavior registration and execution across three distinct categories: targeting behaviors for combat target selection, action decision behaviors for AI ability selection, and passive behaviors for automated passive ability effects. Key architectural features include singleton pattern for single-point behavior management, method chaining through fluent interface design, intelligent fallback mechanisms with default behavior support, and comprehensive error handling with graceful degradation. The component implements three primary registration methods (`registerTargetingBehavior()`, `registerActionDecisionBehavior()`, `registerPassiveBehavior()`) with optional default designation, and corresponding execution methods (`executeTargetingBehavior()`, `executeActionDecisionBehavior()`, `executePassiveBehavior()`) featuring built-in error handling and automatic fallback to defaults when specific behaviors fail. BehaviorRegistry provides sophisticated behavior resolution through getter methods that automatically fall back to defaults when behaviors are not found, centralized behavior tracking via the allBehaviors object with type categorization, and debugging capabilities through `listAllBehaviors()` for comprehensive behavior inventory. The architecture enables highly flexible AI customization where individual behavior modules register functions during loading, consumer components access behaviors through standardized interfaces, and new behaviors can be added without modifying core systems. Characters can reference custom behavior logic by name, enabling complex behavioral decision trees through modular behavior composition. The system demonstrates clear separation of concerns between behavior definition (in specialized modules) and behavior management (in the registry), supporting dynamic behavior execution throughout the battle AI ecosystem. *(Accurate as of v0.7.5.15)*

Talks to: TargetingBehaviors.js, ActionDecisionBehaviors.js, PassiveBehaviors.js (behavior registration sources), BattleBehaviors.js (primary consumer providing unified interface), BehaviorRegistryTest.js (testing utility), TargetingSystem.js, ActionGenerator.js, PassiveAbilityManager.js (indirect consumers via BattleBehaviors), console logging system (error handling and debugging), window scope (singleton exposure), and provides centralized behavior repository services for dynamic AI behavior execution throughout the battle system.


- **ActionDecisionBehaviors.js**: A collection of AI decision-making functions responsible for determining which abilities characters use during combat, serving as the strategic brain of the battle AI system. The module provides six distinct decision strategies: `decideAction_Random50Percent` (default 50% ability usage), `decideAction_WeightedRandomAbility` (sophisticated weighted random selection using ability selectionWeight and character abilityAffinity), `decideAction_PrioritizeHeal` (intelligent healing prioritization analyzing team health with 50% injury threshold), `decideAction_PrioritizeOffense` (aggressive non-healing ability selection), `decideAction_Defensive` (health-conscious strategy with 90% ability affinity when below 50% health), and `decideAction_AlwaysUseAbilities` (maximum aggression always selecting highest-weighted abilities). Key architectural features include sophisticated context analysis utilizing actor state, available abilities, and team data, intelligent ability filtering by type (offensive/defensive/healing/utility), adaptive decision logic responding to health states and team conditions, and BattleUtilities integration for team health analysis with fallback compatibility. The module implements complex behavioral logic including ability affinity respect, selection weight consideration, team health assessment, defensive ability detection through effects analysis, and multi-factor decision trees combining health state, ability type, team conditions, and variance. Each behavior function receives a context object containing the acting character, available abilities array, battleManager reference, and teamManager for comprehensive decision-making. The component integrates seamlessly through automatic registration with BehaviorRegistry, ES6 module exports, and delegation through BattleBehaviors for unified interface access. The system enables characters to exhibit distinct behavioral patterns from aggressive offense-focused strategies to careful healing-prioritizing approaches to adaptive defensive responses based on battlefield conditions. *(Accurate as of v0.7.5.15)*

Talks to: BehaviorRegistry.js (automatic behavior registration with 'decideAction_Random50Percent' as default), BattleBehaviors.js (primary consumer through decideAction delegation), ActionGenerator.js (primary caller for character action selection), window.BattleUtilities (team analysis via getAllCharacters), teamManager and battleManager references (team identification and battle state access), character entities (stats, health, abilityAffinity, team assignments), ability system (selectionWeight, damageType, isHealing flags, effects arrays), fallback/BattleBehaviors.js (simplified fallback implementations), and provides strategic decision-making services for all combat AI including character-specific behavioral patterns and sophisticated ability selection algorithms.


- **TargetingBehaviors.js**: A comprehensive collection of target selection functions responsible for determining which characters abilities and attacks should target during combat, serving as the tactical foundation of the battle AI system. The module provides thirteen distinct targeting strategies including enemy-focused behaviors (`targetRandomEnemy` as default, `targetLowestHpEnemy`, `targetHighestHpEnemy`, `targetAllEnemies`, `targetHighestAttackEnemy`, `targetHighestIntellectEnemy`, `targetAdjacentEnemies`), ally-focused behaviors (`targetLowestHpAlly`, `targetAllAllies`, `targetRandomAlly`, `targetMostInjuredAlly`), utility behaviors (`targetSelf`, `targetAllCharacters` with team relationship marking), and specialized multi-target logic for area-of-effect abilities. Key architectural features include sophisticated filtering logic ensuring only living, valid targets are selected, team relationship analysis using TeamManager integration to distinguish allies from enemies, flexible context processing accepting actor, potentialTargets array, teamManager, ability, and battleManager references, and robust error handling with diagnostic logging for debugging team assignment issues. The module implements intelligent target evaluation including HP-based prioritization for healing and finishing strategies, stat-based targeting for tactical advantage (highest attack/intellect enemies), position-aware targeting for adjacent enemy selection with up to 3-target groupings, and percentage-based health calculations for most injured ally identification. Each targeting function receives a standardized context object and returns either a single Character, Character array for multi-target abilities, or null when no valid targets exist. The component integrates seamlessly through automatic registration with BehaviorRegistry, ES6 module exports for direct usage, and delegation through BattleBehaviors and TargetingSystem for unified combat coordination. TargetingBehaviors includes temporary diagnostic logging to assist with team relationship debugging and supports both single-target and multi-target return patterns based on ability requirements. *(Accurate as of v0.7.5.15)*

Talks to: BehaviorRegistry.js (automatic behavior registration with 'targetRandomEnemy' as default), BattleBehaviors.js (primary consumer through selectTarget delegation), TargetingSystem.js (primary caller for ability target selection with resolveTargetingBehavior logic), teamManager reference (team identification via getCharacterTeam for ally/enemy distinction), character entities (currentHp, stats access, defeated status, team properties), ability system (targetType and targetingLogic properties for behavior selection), potentialTargets arrays (living character filtering and validation), fallback/BattleBehaviors.js (simplified implementations for non-ES environments including targetLowestHpEnemy, targetLowestHpAlly, targetSelf), console logging system (diagnostic output for team relationship debugging), and provides tactical targeting services for all combat scenarios including single-target precision, multi-target area effects, and strategic priority-based selection algorithms.


- **PassiveBehaviors.js**: A comprehensive collection of passive ability implementations responsible for executing automatic character responses to battle events, serving as the reactive foundation of the combat system. The module provides thirteen distinct passive behaviors including regenerative effects (`passive_ApplyRegenOnTurnStart`), defensive reactions (`passive_DamageReflectOnHit`, `passive_ApplyStatusOnHit`, `passive_LastStand`, `passive_Counterattack`), team support abilities (`passive_TeamBuffOnBattleStart`, `passive_ProtectiveInstinct`), offensive enhancements (`passive_CriticalMomentum`, `passive_KillBuff`, `passive_OnKillEffect`, `passive_CriticalHitBoost`, `passive_StatusOnHit`), and battlefield control (`passive_Intimidate`). Key architectural features include sophisticated trigger system supporting fifteen trigger types (onBattleStart, onTurnStart, onDamageTaken, onDamageDealt, onKill, etc.), intelligent status effect routing through StatusEffectManager via centralized helper function to ensure proper event enrichment, complex conditional logic with health thresholds, team relationships, and probability-based execution, and extensive configuration support through passiveData objects enabling customizable durations, chances, and effect values. The module implements advanced passive mechanics including reflection depth tracking to prevent infinite damage chains, team buff application with BattleUtilities integration for character enumeration, multi-effect capabilities (healing, buffing, AoE damage) in single passives, threshold-based triggers for last stand effects, and protective instincts targeting low-health allies. Each passive function receives a standardized context object containing actor, ability, battleManager, teamManager, trigger type, and additionalData for comprehensive decision-making. The component integrates seamlessly through automatic registration with BehaviorRegistry, ES6 module exports for direct usage, specialized applyStatusEffect helper routing through StatusEffectManager (v0.6.3.37 fix), and delegation through BattleBehaviors and PassiveAbilityManager for unified execution coordination. PassiveBehaviors underwent critical architectural improvements including status effect routing fixes, BattleUtilities integration for team analysis, reflection depth tracking for damage chains, and comprehensive parameter validation with defensive programming patterns. *(Accurate as of v0.7.5.15)*

Talks to: BehaviorRegistry.js (automatic behavior registration for all thirteen passive behaviors), BattleBehaviors.js (primary consumer through executePassiveBehavior delegation), PassiveAbilityManager.js (primary caller for passive execution with trigger context), StatusEffectManager.js (status effect application via applyStatusEffect helper function ensuring proper event enrichment), battleManager reference (damage/healing application, team access, status effect fallback), teamManager reference (team identification for ally/enemy distinction), window.BattleUtilities (team character enumeration with v0.6.0.4 integration and fallback compatibility), character entities (currentHp, stats access, team properties, defeated status), ability system (passiveData configurations, trigger types, effect parameters), status effect system (statusId application with duration and stacks), fallback/BattleBehaviors.js (simplified passive implementations including passive_ApplyRegenOnTurnStart, passive_DamageReflectOnHit, passive_ApplyStatusOnHit, passive_TeamBuffOnBattleStart), console logging system (execution messages, parameter validation warnings), and provides reactive battle mechanics for all passive ability types including defensive reactions, offensive enhancements, team support, and battlefield control effects.

---

## Managers (High-Level Orchestrators)
- **BattleManager.js**: The central orchestrator for all battle-related systems in the AutoBattler game. Rather than handling battle logic directly, BattleManager acts as a sophisticated "conductor" that coordinates over 10 specialized component managers (like BattleFlowController, DamageCalculator, StatusEffectManager, etc.). It serves as a unified interface where other parts of the game can request battle operations - such as starting a battle, applying damage, or processing abilities - and BattleManager delegates these requests to the appropriate specialist component. The manager follows a facade pattern, providing simple method calls that hide the complexity of the underlying component system. It also handles initialization of all battle components in proper dependency order, manages global battle state (like teams, turn counts, speed settings), and acts as the communication bridge to the UI through event dispatching. *(Accurate as of v0.7.5.14)*

Talks to: BattleInitializer.js (team setup), BattleFlowController.js (turn management), BattleEventDispatcher.js (event communication), DamageCalculator.js (damage logic), HealingProcessor.js (healing logic), StatusEffectManager.js (status effects), PassiveAbilityManager.js (passive abilities), AbilityProcessor.js (ability execution), ActionGenerator.js (action creation), TargetingSystem.js (target selection), TypeEffectivenessCalculator.js (type advantages), BattleLogManager.js (logging), game.js (initialization), Phaser BattleScene.js (UI events), TeamManager.js (team data), and window.battleBridge (event system).

- **TeamManager.js**: The central component responsible for team composition management and character selection coordination in the AutoBattler game. TeamManager maintains the authoritative state for both player and enemy teams throughout the game lifecycle, handling character pool loading from JSON data, player team selection storage, and enemy team generation across multiple battle modes. The component provides three distinct enemy generation strategies: random teams with 20% stat variance for unpredictable encounters, custom teams with 10% stat variance for player-designed opponents, and planned campaign teams for future story mode implementation. TeamManager performs deep copying of character data to prevent reference conflicts, applies statistical variance to create battle variety, and serves as the primary data provider for team-related operations. It acts as the essential state bridge between the Team Builder UI selection phase and the Battle Manager combat initialization, ensuring team data integrity and proper initialization throughout the battle workflow. The component includes comprehensive fallback mechanisms with hardcoded character data to maintain functionality even when JSON loading fails. *(Accurate as of v0.7.5.14)*

Talks to: TeamBuilderUI.js (receives team selections and battle mode choices), BattleInitiator.js (provides finalized teams for battle start), BattleManager.js (supplies teams for combat initialization), data/characters.json (loads character pool), BattleInitializer.js (provides teams for battle setup), game.js (instantiated at startup), and window global scope (exposed for debugging and cross-system access).



---

## Phaser Implementation

### Core Phaser Systems
- **BattleAssetLoader.js**: A specialized Phaser asset management component responsible for centralizing all asset loading operations for the Battle Scene, serving as the unified interface for UI elements, character sprites, and status effect icons. BattleAssetLoader emerged from Phase 4 of the BattleScene refactoring effort (v0.6.4.0-0.6.4.5) where asset loading logic was extracted from the monolithic BattleScene.preload() method into a focused component to improve separation of concerns and reduce scene complexity. The loader manages three asset categories: UI assets (battle controls, health bars, turn indicators), character assets (optimized Combat_Version folder sprites with special handling for edge cases like "Caste"), and status effect icons (25-icon library with StatusIconMapper integration). Key architectural features include a unified loadAssets() interface providing comprehensive error tracking with detailed success/failure reporting for each category, independent try/catch blocks enabling partial success when some assets fail, sophisticated status icon mapping with fallback generation, and extensive defensive programming with scene validation and graceful degradation. The component implements intelligent loading strategies with primary/fallback path handling, comprehensive validation of mapping structures, and consistent return objects with detailed error information for debugging. BattleAssetLoader evolved through iterative development, transitioning from individual loading methods to a unified interface (v0.6.4.5) that simplified BattleScene integration to a single method call while maintaining robust error handling and user feedback capabilities. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (primary consumer via unified loadAssets() method in preload()), window.StatusIconMapper (status icon mapping with fallback handling), Phaser scene.load API (all asset loading operations), assets/images/ file system (UI icons, character Combat_Version sprites, status-icons directory), console logging system (comprehensive progress and error reporting), global window scope (exposed as window.BattleAssetLoader), Character Art system (optimized 80x120px combat sprites), and provides structured asset data including success states, mappings, and error details for BattleScene coordination and error display.

- **BattleEventManager.js**: A core Phaser event orchestration component responsible for managing all battle-related event listening and handling within the Battle Scene, serving as the central dispatcher for UI updates and visual feedback. BattleEventManager emerged from Phase 1 of the BattleScene refactoring effort (v0.6.1.1-0.6.1.4) where event management logic was extracted from the monolithic BattleScene into a specialized, focused component to reduce complexity and improve maintainability. The manager handles comprehensive event registration including core battle flow events (turn started, battle ended), status effect lifecycle events (applied, removed, updated), health and damage events (character damaged, healed), and action indicator events (character action, ability used). Key architectural features include sophisticated event handler binding with proper 'this' context preservation, comprehensive character sprite resolution through multiple fallback strategies (TeamDisplayManager delegation, direct team container access), intelligent dependency injection with setTeamManager, setBattleLog, and setFXManager methods, and robust event dispatcher integration with BattleBridge for seamless communication between battle logic and visual systems. The component implements extensive error handling with graceful degradation when dependencies are unavailable, Map-based tracking of bound handlers for proper cleanup, and dual visual effect routing supporting both direct scene methods and BattleFXManager integration. BattleEventManager underwent critical fixes including character sprite resolution improvements (v0.6.1.2) to properly interface with TeamContainer methods, game over event handling enhancements (v0.6.1.3), and complete cleanup (v0.6.1.4) removing all legacy event code from BattleScene, achieving a 27% reduction in BattleScene complexity. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (parent scene providing initialization and component references), BattleBridge.js (primary event source through comprehensive event type registration), TeamDisplayManager.js (character sprite resolution and active visual updates via setTeamManager), BattleFXManager.js (visual effects delegation via setFXManager), DirectBattleLog.js (battle message display via setBattleLog), CharacterSprite.js (health updates, status effects, action indicators), TeamContainer.js (character sprite resolution fallback through findCharacterSprite method), window scope (global component exposure for debugging), console logging system (comprehensive diagnostic and error reporting), and Phaser event system (event listener lifecycle management through addEventListener/removeEventListener patterns).



### Specialized Phaser Managers
- **BattleUIManager.js**: A specialized Phaser manager responsible for creating and managing all UI elements within the Battle Scene, serving as the centralized coordinator for user interface components during battle visualization. BattleUIManager emerged from a systematic refactoring effort (Phase 2 of BattleScene modularization) that extracted approximately 750 lines of UI-related code from the monolithic BattleScene into a focused, maintainable component. The manager handles the complete lifecycle of battle UI elements including gradient background with grid patterns, scene titles and welcome messages, battle control panels (start/pause/speed controls), the battle log panel for event display, turn and action text indicators, battle outcome screens (victory/defeat/draw), and comprehensive error message display. Key architectural features include component tracking through a standardized `components` object for proper cleanup, robust error handling with try/catch blocks around each UI creation method, safe text object management via `safeGetTextObject()` utility preventing Phaser object lifecycle issues, and comprehensive resource cleanup in the `destroy()` method. The component implements sophisticated delegation patterns allowing BattleScene to focus solely on battle coordination while BattleUIManager handles all visual presentation concerns. BattleUIManager integrates seamlessly with other Phaser components including BattleControlPanel and DirectBattleLog, maintains team-specific UI styling (blue for player team, red for enemy team), and provides graceful fallbacks with user-facing error messages when dependent components are unavailable. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (parent scene and initialization), BattleControlPanel (battle control interface creation), DirectBattleLog (battle log panel creation), Phaser Scene API (UI object creation and management), Phaser Tweens (animations for text indicators and outcome screens), team-builder-container and game-container DOM elements (scene transitions), window.battleBridge (cleanup coordination), window.teamBuilderUI (return navigation callbacks), and provides error handling services for other battle components through centralized error message display.

- **BattleFXManager.js**: A specialized Phaser manager responsible for coordinating visual effects like floating text and attack animations within the battle scene, serving as a centralized hub for non-sprite-specific visual effects. BattleFXManager acts as a bridge between battle events and visual feedback systems, delegating actual rendering to character sprites while managing the coordination logic. The manager handles two primary visual effects: floating text above characters (damage numbers, status notifications, healing amounts) with customizable styling and positioning, and attack animations between characters with proper team validation and action context handling. Key architectural features include sophisticated character sprite resolution through multiple fallback strategies (TeamDisplayManager delegation followed by direct team container access), intelligent action context inference when not provided (determining ability vs auto-attack), comprehensive team validation to prevent same-team attacks, and extensive error handling with graceful degradation when dependencies are unavailable. The component implements dual delegation patterns supporting both TeamDisplayManager integration for modern character sprite access and legacy team container fallback for backward compatibility. BattleFXManager provides optional TeamDisplayManager reference management, allowing late initialization and dependency injection after scene setup. The component integrates seamlessly with BattleEventManager for automated visual feedback triggered by battle events, coordinates with CharacterSprite instances for actual visual effect rendering, and supports both legacy team container access patterns and modern component-based architecture. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (parent scene providing initialization and team references), BattleEventManager.js (direct integration via setFXManager for automated visual effects), TeamDisplayManager.js (primary character sprite resolution strategy via getCharacterSprite method), CharacterSprite.js (delegates floating text and attack animations via showFloatingText and showAttackAnimation methods), TeamContainer.js (fallback character sprite resolution via getCharacterSpriteByName), console logging system (comprehensive error reporting and delegation diagnostics), character entities (team validation, action context inference), and window scope (global component exposure for debugging and cross-system coordination).
- **TeamDisplayManager.js**: A specialized Phaser manager responsible for orchestrating team visualization and active character indicators within the battle scene, serving as the central coordinator for team-related visual elements and character highlighting. TeamDisplayManager acts as the primary interface between battle logic and team-specific visual components, managing the complete lifecycle of team containers and character sprite access. The manager handles two primary responsibilities: team container creation and management (instantiating TeamContainer objects for both player and enemy teams with proper positioning via `createTeams()`), and active character visualization (coordinating turn-based highlighting through `updateActiveCharacterVisuals()` and character sprite resolution via `getCharacterSprite()`). Key architectural features include sophisticated character sprite resolution through `getCharacterSprite()` with multiple fallback strategies (direct team property checking followed by cross-team searching by name, ID, or uniqueId), comprehensive team data management with deep copying via `getTeamData()` for external access, extensive error handling with graceful degradation when components fail, and legacy system compatibility through deprecated method preservation. The component implements a centralized access pattern where other systems request character sprites through `getCharacterSprite()` rather than directly accessing team containers. TeamDisplayManager underwent a significant transition where the deprecated TurnIndicator system was removed in favor of card frame turn highlighting, with all related methods marked as deprecated but maintained for backward compatibility. The manager provides essential services through its key methods: `getCharacterSprite()` for character sprite resolution, `updateActiveCharacterVisuals()` for turn-based highlighting coordination, and `getTeamData()` for safe team data access. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (parent scene providing initialization and team data), TeamContainer.js (creates and manages player/enemy team containers via constructor delegation), CharacterSprite.js (coordinates highlighting through sprite.highlight() and sprite.unhighlight() methods), BattleEventManager.js (provides character sprite resolution via setTeamManager integration), BattleFXManager.js (provides character sprite resolution via setTeamManager integration), window.TeamContainer (validates component availability before instantiation), console logging system (comprehensive initialization and error reporting), character data structures (team assignment and sprite resolution), team data objects (playerTeam and enemyTeam arrays), and window scope (global component exposure for debugging and cross-system coordination).

### Bridge Systems
- **BattleBridge.js**: The critical communication bridge between the core battle logic and Phaser-based visual systems, serving as the central event orchestration hub that enables real-time synchronization between BattleManager and the Phaser Battle Scene. BattleBridge acts as the architectural linchpin that enables the AutoBattler's dual-UI system, allowing the same battle logic to drive both DOM-based and Phaser-based presentations through a sophisticated event-driven communication pattern. The bridge handles comprehensive event management including battle lifecycle events (BATTLE_STARTED, BATTLE_ENDED, TURN_STARTED), character action events (CHARACTER_ACTION, CHARACTER_DAMAGED, CHARACTER_HEALED), status effect notifications (STATUS_EFFECT_APPLIED, STATUS_EFFECT_REMOVED), and UI interaction events (speed changes, pause/resume commands). Key architectural features include sophisticated BattleManager method patching to intercept and re-dispatch battle events for UI consumption, comprehensive fallback event system ensuring continued operation when battleBridge is unavailable, dual property naming patterns for backward compatibility (character/target, source/actor), and extensive parameter validation with intelligent defaults for malformed data. The component implements a complex initialization system through BattleBridgeInit.js providing global instance access, emergency fallback implementations, and protected restoration functions. BattleBridge serves as the foundation for all battle visualization by transforming internal battle operations into standardized events consumed by BattleEventManager, BattleEventDispatcher, and Phaser UI components. The bridge underwent significant evolution from simple event dispatch to sophisticated method patching with BattleFlowController integration, enabling seamless communication between the component-based battle logic and visual presentation layers. *(Accurate as of v0.7.5.15)*

Talks to: BattleManager.js (primary integration target via method patching for applyActionEffect, addStatusEffect, removeStatusEffect), BattleFlowController.js (coordinates with battle flow events for TURN_STARTED, BATTLE_ENDED, CHARACTER_ACTION dispatch), BattleScene.js (primary consumer via initialization and global access patterns), BattleEventManager.js (event distribution channel via addEventListener registration), BattleEventDispatcher.js (backup event system with shared event type constants), BattleUIManager.js (indirect UI updates via event propagation), TeamDisplayManager.js (active character highlighting via updateActiveCharacterVisuals events), BattleFXManager.js (visual effects coordination via CHARACTER_DAMAGED, CHARACTER_HEALED events), StatusEffectManager.js (status effect communication via STATUS_EFFECT_APPLIED/REMOVED events), PassiveAbilityManager.js (passive trigger notifications via PASSIVE_TRIGGERED events), window scope (global bridge instance as window.battleBridge and accessor functions), and BattleBridgeInit.js (initialization coordination with fallback management and protected global access).
- **BattleBridgeInit.js**: 
- **BattleLogTester.js**: 

### Scenes
- **BattleScene.js**: High-level orchestrator for the battle visualization system in Phaser, serving as the central coordinator that delegates functionality to specialized manager components rather than implementing visualization logic directly. BattleScene emerged from extensive refactoring (9 stages documented across changelogs) transforming from a monolithic class into a clean component-based orchestrator. The scene handles complex sequential initialization including deep team data copying with validation, multi-tier asset loading via BattleAssetLoader with comprehensive fallback strategies, and component initialization in proper dependency order (UIManager → TeamManager → BattleBridge → EventManager → FXManager). Key architectural features include sophisticated BattleBridge initialization with multiple fallback approaches ensuring battle logic connection, robust error handling with user-facing messaging through BattleUIManager, canvas smoothing configuration for optimal visual quality, and comprehensive lifecycle management from scene creation through shutdown cleanup. The component delegates all functionality to five specialized managers: BattleUIManager (UI elements, error messages), TeamDisplayManager (team visualization, character indicators), BattleEventManager (battle events, system communications), BattleFXManager (visual effects, animations), and BattleAssetLoader (centralized asset loading). BattleScene maintains battle state tracking (started, paused, speed, active character) and provides facade methods like `updateActiveCharacterVisuals()`, `showAttackAnimation()`, `showBattleOutcome()`, and `getTeamData()` that delegate to appropriate managers. The scene underwent comprehensive refactoring achieving clean separation of concerns, consistent error handling patterns, and standardized component lifecycle management, resulting in a highly maintainable and extensible architecture. *(Accurate as of v0.6.4.20)*

Talks to: BattleUIManager.js (UI creation and error messaging), TeamDisplayManager.js (team visualization and character highlighting), BattleEventManager.js (battle event listening and handling), BattleFXManager.js (visual effects coordination), BattleAssetLoader.js (asset loading operations), BattleBridge.js (battle logic connection and event communication), BattleManager.js (battle initialization and state management), PhaserDebugManager.js (debug tools), PhaserConfig.js (Phaser initialization), Phaser Scene API (scene lifecycle and rendering), game.js (scene registration and global access), and provides global reference as window.BattleScene for debugging and cross-system coordination.

- **BootScene.js**: Initial loading scene in the Phaser implementation designed as the entry point for game initialization, though currently unused in the main application flow. BootScene serves as a preparatory component for potential future Phaser-first architecture, providing essential asset loading and initialization setup before transitioning to the main game interface. The scene implements a basic loading screen with animated progress bar, loading essential UI assets (button.png, panel.png), and initialization of global game settings. Key features include visual loading feedback with progress updates, automatic scene transition to TeamBuilderScene upon completion, and standardized asset preloading patterns. Currently bypassed in the actual game flow where game.js initializes DOM-based TeamBuilderUI directly and Phaser is only activated for battle scenes via BattleScene. The component represents a placeholder for future unified Phaser UI implementation, maintaining compatibility patterns for when the game might transition from DOM-first to Phaser-first architecture. BootScene demonstrates basic Phaser scene patterns including preload/create lifecycle, loading bar implementation, and scene management, serving as a foundation for potential future expansion of Phaser-based UI components beyond just battles. *(Accurate as of current version)*

Talks to: TeamBuilderScene.js (automatic transition target), Phaser Scene API (loading and lifecycle management), assets/images/ui/ (button.png, panel.png loading), game.js (indirectly as potential entry point), DOM elements (loading visual elements), and Phaser Game instance (scene management and transitions).


- **TeamBuilderScene.js**: Placeholder Phaser scene intended for future implementation of a Phaser-based team builder interface, currently serving as a proof-of-concept for potential migration from DOM-based to Phaser-based team building functionality. TeamBuilderScene provides a minimal interactive demonstration scene with toggle capabilities to switch back to the existing DOM-based TeamBuilderUI, representing the groundwork for potential future unified Phaser UI architecture. The scene implements basic team management state structure with selectedHeroes array and teamManager reference, asset loading for team builder UI elements (grid-bg, slot-bg), and a simple placeholder interface demonstrating Phaser scene patterns. Key features include an interactive toggle button with hover effects that switches between Phaser and DOM UI modes via UIManager integration, placeholder visual elements styled with game typography (Bebas Neue, Open Sans), and fallback mechanisms for returning to DOM UI when UIManager is unavailable. The component maintains proper Phaser scene lifecycle with preload/create/update methods and establishes event communication patterns for future expansion. Currently unused in the main application flow where DOM-based TeamBuilderUI handles all team selection functionality, but serves as architectural foundation for potential future implementation of a fully Phaser-based team building experience with enhanced visual effects and animations. The scene demonstrates integration patterns with existing systems including direct access to window.teamManager and coordination with DOM element visibility management. *(Accurate as of current version)*

Talks to: TeamManager.js (global window.teamManager reference), UIManager.js (DOM/Phaser UI switching via showDomUI method), BootScene.js (transition source from automatic scene change), Phaser Scene API (scene lifecycle and UI elements), DOM elements (team-builder-container, game-container, phaser-container visibility management), assets/images/ui/ (grid-bg.png, slot-bg.png loading), window scope (global manager access), and provides placeholder architecture for future Phaser-based team building implementation. 

### Audio Systems
- **PhaserSoundManager.js**: Skeleton implementation for managing audio in the Phaser battle system that defines basic structure including sound categories (attack, ability, movement, UI), volume configuration with master and category-specific controls, and initialization framework. Currently incomplete with unfinished method implementations, representing an unimplemented placeholder that has not been integrated into the battle system, which explains the absence of audio in Phaser battles compared to the DOM TeamBuilder section.

  Talks to: Phaser Scene (constructor parameter), planned integration with BattleScene and other Phaser components for event-driven audio playback, designed to complement existing DOM-based SoundManager.js but currently non-functional. 

### Debug Tools
- **CoordinateDisplay.js**: 
- **DebugManager.js**: 
- **PhaserDebugManager.js**: 
- **ObjectIdentifier.js**: 

---

## UI Components

### CardFrame Components
- **CardFrame.js**: A reusable card frame container serving as the primary interface for character card representation in both battle and team builder contexts. The component provides a comprehensive facade that delegates functionality to either a modern component-based architecture (CardFrameManager) or maintains backward compatibility with direct implementation. CardFrame handles dual representation modes (traditional circles vs. professional card frames), manages card state (selection, highlighting, health), and provides unified access to card operations through methods like `setSelected()`, `setHighlighted()`, and `updateHealth()`. Key architectural features include intelligent component system detection with automatic fallback mechanisms, sophisticated configuration management through `getConfig()` and `updateConfig()` methods, and comprehensive delegation patterns that route method calls to appropriate specialized components when available. The component implements defensive programming with extensive error handling, maintains state synchronization between local and manager-based storage, and provides complete lifecycle management from initialization through destruction. CardFrame serves as the architectural bridge enabling the transition from monolithic card implementation to modular component-based design while preserving full backward compatibility.

Talks to: CardFrameManager.js (primary delegation target when component system enabled), Phaser Scene API (container management and lifecycle), character entities (health values, character properties), window scope (global component availability checking), and provides unified card interface for CharacterSprite.js, TeamBuilderUI.js, and other systems requiring card-based character representation.

- **CardFrameManager.js**: A specialized orchestration container that coordinates four distinct card frame components to create comprehensive card-based character representation in Phaser battle scenes. CardFrameManager emerged from the CardFrame refactoring initiative to establish clear separation of concerns across visual, health, content, and interaction domains. The manager handles component lifecycle coordination including initialization in proper dependency order, unified configuration distribution to specialized components, state management for selection and highlighting through delegation patterns, and comprehensive cleanup during destruction. Key architectural features include strict adherence to single source of truth principles where each component owns its specific domain configuration, intelligent component availability checking with graceful degradation when dependencies are missing, sophisticated delegation patterns routing method calls to appropriate specialized components, and extensive error handling ensuring continued operation even when individual components fail. The manager implements a minimal configuration approach passing only relevant data to each component while avoiding duplication of component-specific settings, maintains type color centralization for cross-component consistency, and provides facade methods like `updateHealth()`, `setSelected()`, and `showActiveTurnHighlight()` that coordinate multiple components simultaneously. CardFrameManager represents the central coordinator in the component-based architecture, enabling complex card behaviors through composition of focused, single-responsibility components.

Talks to: CardFrameVisualComponent.js (frame, backdrop, visual effects delegation), CardFrameHealthComponent.js (health bar creation and updates), CardFrameContentComponent.js (character portraits and nameplate management), CardFrameInteractionComponent.js (hover, selection, and turn highlighting), Phaser Scene API (container management and tween systems), CardFrame.js (receives delegation from primary interface), and window scope (component class availability checking and registration).

- **CardFrameVisualComponent.js**: A specialized visual component responsible for the card frame's structural visual elements including frame borders, backdrop, inner glow effects, and edge depth enhancements. The component serves as the single source of truth for all card frame dimensions, visual styling, and decorative effects through comprehensive configuration management in `VISUAL_DEFAULTS`. CardFrameVisualComponent handles sophisticated visual layer composition including semi-transparent backdrop creation, multi-layer inner glow effects using the card's type color, professional frame border graphics with proper corner radius handling, and enhanced depth perception through edge highlights and shadows. Key architectural features include comprehensive depth effects system with configurable inner glow layers and edge lighting simulation, intelligent fallback mechanisms creating basic rectangular frames when advanced graphics fail, debug visualization capabilities for development and troubleshooting, and precise color management supporting type-themed visual consistency. The component implements advanced rendering techniques including concentric glow layers for smooth light effects, directional edge highlighting with bright top/left edges and dark bottom/right shadows for 3D appearance, and sophisticated color manipulation brightening/darkening type colors for highlight/shadow effects. The visual component provides essential infrastructure services through methods like `getFrameBase()` for interaction component integration and `setFrameWhiteHighlight()` for turn indicator visual feedback with smooth fade animations.

Talks to: CardFrameManager.js (parent container receiving delegation), Phaser Scene API (graphics creation, container management), Phaser.Display.Color (advanced color manipulation for edge effects), Phaser Tweens system (white highlight fade animations), and provides visual foundation services for CardFrameInteractionComponent.js interaction behaviors and CardFrameHealthComponent.js health bar positioning.

- **CardFrameHealthComponent.js**: A focused component responsible for all health-related visual elements and animations within card frame representations, serving as the authoritative manager for health bar display, health text indicators, and health state transitions. The component handles comprehensive health visualization including dynamic health bar creation with proper positioning and layering, animated health transitions with smooth bar resizing and color changes, team-aware health text styling with appropriate color coding, and responsive health color management reflecting current health percentages. Key architectural features include sophisticated health bar construction using backdrop, fill, and border graphics for professional appearance, intelligent health color progression from green (healthy) through orange (injured) to red (critical), comprehensive animation system supporting smooth health changes with configurable duration, and extensive error handling ensuring health bars display correctly even when scene contexts change. The component implements advanced health feedback through floating damage/healing numbers, health bar shake effects during damage, health bar glow effects during healing, and proper cleanup during character destruction to prevent memory leaks. The health system provides essential integration points including percentage-based health calculation for color determination, team-specific text styling for ally/enemy distinction, and event-driven health updates synchronized with battle system changes.

Talks to: CardFrameManager.js (parent coordinator and configuration source), Phaser Scene API (graphics creation, text objects, animation systems), Phaser Tweens system (health bar animations, shake effects, glow effects), character entities (currentHealth and maxHealth properties), and provides health visualization services consumed by BattleEventManager.js, CharacterSprite.js, and other battle visualization components.

- **CardFrameContentComponent.js**: A specialized component managing character-specific content display within card frames including portrait windows, character sprites, and decorative nameplate banners. The component serves as the content authority handling character image positioning, name display formatting, and portrait masking for clean visual presentation. CardFrameContentComponent manages sophisticated content layout including masked portrait windows for clean character image display, intelligent character sprite loading with fallback text when images unavailable, decorative nameplate banner creation with type-themed styling and scrollwork effects, and flexible art positioning accommodating character-specific image adjustments. Key architectural features include comprehensive portrait masking using Phaser geometric masks for precise image boundaries, advanced nameplate design with beveled graphics and ornamental flourishes, intelligent character image loading with graceful degradation to text-based fallbacks, and extensive art positioning flexibility supporting character-specific offsets and scaling. The component implements sophisticated content management through portrait container systems organizing character images within defined boundaries, name text formatting with appropriate typography and color schemes, character sprite positioning respecting custom art offset configurations, and complete content lifecycle management from creation through updates and destruction.

Talks to: CardFrameManager.js (parent container and configuration provider), Phaser Scene API (graphics creation, text objects, image sprites, masking systems), window.CHARACTER_IMAGE_CACHE (character image loading and caching), character entities (art positioning data, character names, sprite keys), and provides content display services for CharacterSprite.js integration and BattleScene.js character visualization.

- **CardFrameInteractionComponent.js**: A comprehensive interaction management component controlling all user input behaviors, animations, and turn-based visual feedback for card frame representations. The component handles sophisticated interaction patterns including hover effects with scaling and glow animations, selection state management with visual feedback, turn highlighting systems using team-specific colors and effects, and comprehensive mouse/touch event processing. Key architectural features include advanced animation systems supporting smooth scaling transitions, glow effects, and color changes, intelligent turn indicator logic providing distinct visual cues for active characters with team-specific color coding, sophisticated event handling supporting pointer events, hover states, and click interactions, and extensive state management tracking selection, highlighting, and interaction states consistently. The component implements complex visual feedback mechanisms including multi-layer glow effects for selection and hover states, size pulsing animations for active turn indication, team-colored external glow effects (blue for player, red for enemy), and smooth transitions between different interaction states preventing jarring visual changes. The interaction system provides essential turn-based visualization through `showActiveTurnHighlight()` and `hideActiveTurnHighlight()` methods coordinating with the battle system for clear active character indication, plus comprehensive interactivity setup enabling cards to respond appropriately to user input with proper cursor management and event propagation.

Talks to: CardFrameManager.js (parent container and state coordination), CardFrameVisualComponent.js (frame base reference for interaction hit areas), Phaser Scene API (pointer events, animation systems, cursor management), Phaser Tweens system (scaling animations, glow effects, color transitions), BattleScene.js (turn highlighting integration), window scope (global configuration access), and provides interaction services consumed by CharacterSprite.js for battle character input handling and TeamBuilderUI.js for character selection workflows.

### Battle-Specific Components
- **ActionIndicator.js**: A specialized Phaser visual feedback component responsible for displaying animated floating text above characters during battle actions, serving as a clear communication tool that enhances visual clarity of combat sequences through color-coded action indicators. The component handles comprehensive action visualization including auto attacks (light grey), ability usage (light green), and status effects (gold) with smooth fade-in/hold/fade-out animations that rise above character sprites. Key architectural features include sophisticated positioning logic that adapts to both container-relative and scene-absolute coordinate systems, configurable animation parameters through a centralized ACTION_INDICATOR_CONFIG object controlling timing, colors, positioning, and text styling, timeline-based animation system using Phaser's tween engine with proper cleanup and cancellation mechanisms, and smart parent container integration that automatically positions text relative to CharacterSprite containers. The component implements flexible text rendering with comprehensive styling including stroke, shadow, and multiple resolution options, provides specialized methods for common battle actions (showAutoAttack, showAbility, showStatusEffect), and includes robust resource management with explicit destroy methods and animation timeline cleanup to prevent memory leaks. ActionIndicator integrates seamlessly with CharacterSprite through constructor dependency injection and supports verbose logging for debugging positioning and animation behavior, representing a mature solution for battle action feedback that enhances player understanding of combat flow.

  Talks to: CharacterSprite.js (parent dependency via constructor injection and container integration), Phaser Scene API (text object creation, tween timeline management), Phaser Tweens system (animation sequences and timeline coordination), parent character container (positioning and coordinate system management), window.VERBOSE_LOGGING (diagnostic logging system), character entities (indirectly via parent.character.name for logging), console logging system (debugging and diagnostic output), and provides visual action feedback services consumed by battle visualization systems for enhanced combat clarity. 
- **BattleControlPanel.js**: A comprehensive Phaser UI component responsible for providing players with essential battle flow management capabilities through a polished, tooltip-style control interface that handles battle initiation, pause/resume functionality, and speed control during combat. The component extends Phaser.GameObjects.Container and implements a professional control panel with dark navy background, bright blue borders, and smooth interactive effects including hover states, scaling animations, and sound integration. Key architectural features include sophisticated battle state tracking (started, paused, current speed), dynamic start/pause button with icon switching (play/pause), speed control system with three configurable speeds (1x, 2x, 3x) and visual highlighting of active selection, and deep integration with BattleBridge for battle system communication with fallback mechanisms for direct BattleManager access. The component provides comprehensive visual feedback through floating messages above the panel, real-time button state updates, and error handling with graceful degradation when dependencies are unavailable. BattleControlPanel underwent architectural evolution where copy battle log functionality was moved to DirectBattleLog following the control proximity principle, demonstrating clean separation between battle control and log management concerns. The component implements robust error handling with fallback panel creation, multiple communication pathways for battle system integration, and team data management with deep copying for battle initialization, representing a mature user interface that successfully bridges player input with complex battle system management. *(Accurate as of v0.5.4.0)*

  Talks to: BattleScene.js (parent scene providing initialization and team data access), BattleBridge.js (primary integration via window.getBattleBridge for battle commands like startBattle, requestPause, requestResume, requestSpeedChange), BattleManager.js (fallback direct access via window.battleManager for pause/resume operations), Phaser.GameObjects.Container (extends container for UI organization), Phaser Scene API (graphics creation, text objects, tween animations), Phaser Tweens system (floating message animations), window.soundManager (audio feedback for button interactions), battle state management (playerTeam and enemyTeam data from scene), console logging system (error reporting and battle control debugging), and provides centralized battle flow control interface accessible to players for managing combat progression and speed.  

- **CharacterSprite.js**: A comprehensive Phaser component responsible for rendering individual characters within the battle scene, serving as the primary visual representation for battling units with support for both traditional circle-based and modern card-based presentations. CharacterSprite acts as the visual facade for character entities, handling all aspects of character visualization including dual representation support (traditional circles with character images vs. professional card frames using the CardFrame system), health management with animated health bars and dynamic visual feedback, action indication through integration with ActionIndicator for displaying ability names and auto-attacks, status effect visualization via StatusEffectContainer, and interactive capabilities with hover effects and selection handling. Key architectural features include sophisticated attack animations with proper collision detection and team-aware movement calculations, comprehensive health visualization with color-coded health bars and floating damage/healing numbers, turn-based highlighting integration connecting to the card frame turn indicator system with team-specific colors (blue for player, red for enemy), and robust error handling with extensive try-catch blocks and fallback mechanisms. The component implements character positioning through customizable art offsets and scaling, supports both interactive and non-interactive modes, and provides comprehensive cleanup methods to prevent memory leaks. CharacterSprite integrates closely with ActionIndicator for action text display, StatusEffectContainer for status visualization, CardFrame/CardFrameManager for modern card representation, and TeamContainer for team management. The component underwent significant evolution with the turn indicator integration (v0.7.5.2) where it transitioned from the deprecated TurnIndicator system to the new card frame highlighting approach via highlight()/unhighlight() methods. *(Accurate as of v0.7.5.15)*

Talks to: TeamContainer.js (parent container and positioning), BattleScene.js (scene management and global positioning), CardFrame.js and CardFrameManager.js (card-based representation), ActionIndicator.js (ability and action text display), StatusEffectContainer.js (status effect visualization), Phaser.Scene (scene events and character selection), BattleEventManager.js (indirectly via scene events), window.characterSprites (global registry for debugging), window.CHARACTER_IMAGE_CACHE (image caching system), character art system (texture loading and positioning), and provides visual feedback for battle events including damage, healing, highlighting, and action indication.


- **DirectBattleLog.js**: A comprehensive Phaser UI component responsible for displaying real-time battle events in a styled, scrolling text log with advanced user controls and message management. DirectBattleLog emerged from the need for a more sophisticated battle logging solution than simple text overlays, implementing a card frame design system with professional styling, animated message flow, and integrated control features. The component handles complex battle event visualization including comprehensive event listening through BattleBridge for battle events (turns, damage, healing, status effects, abilities, passives), sophisticated message queuing with customizable processing speed and pause/resume functionality, team-aware message formatting with color-coded text based on character teams and action types, and complete message history management for log copying and reference. Key architectural features include elegant card frame presentation with white borders, nameplates, and semi-transparent backgrounds matching the game's visual design language, advanced message flow control through pause/resume buttons and copy functionality positioned above the log frame, intelligent animation and timing systems with message speed synchronization to battle speed and smooth fade-in effects for new messages, and comprehensive error handling with container management during message rendering and graceful degradation when dependencies are unavailable. The component implements a sophisticated control interface featuring pause/resume button for message flow management with toggle states and tooltips, copy button for exporting battle log to clipboard with fallback support for older browsers, floating message feedback for user actions, and speed synchronization with battle manager settings. DirectBattleLog underwent significant evolution including the transition from embedded controls to external control buttons (v0.7.5.11) following the control proximity principle, implementation of fixed-size card frame rendering (v0.7.5.10) preventing visual growth as messages are added, and card frame styling adoption (v0.7.5.9) creating visual consistency with character cards. The component processes seven categories of battle events: turn progression with character identification and turn numbers, damage and healing events with amount display and health updates, ability usage with ability names and target information, status effect application and removal with effect descriptions, passive ability triggers with character attribution, character defeats with team-specific styling, and battle outcomes with victory/defeat/draw messaging. *(Accurate as of v0.7.5.15)*

  Talks to: BattleBridge.js (primary event source via comprehensive event listeners for BATTLE_LOG, TURN_STARTED, CHARACTER_DAMAGED, CHARACTER_HEALED, STATUS_EFFECT_APPLIED, STATUS_EFFECT_REMOVED, CHARACTER_ACTION, ABILITY_USED, PASSIVE_TRIGGERED, BATTLE_ENDED events), BattleEventManager.js (receives setBattleLog reference for direct message forwarding), BattleUIManager.js (created and managed as scene component via createBattleLogPanel method), BattleScene.js (scene integration as this.scene.battleLog for global access), window.getBattleBridge (global bridge accessor for initialization), window.battleManager (fallback access for turn numbering), window.soundManager (audio feedback for button interactions), Phaser Scene API (text objects, containers, graphics for UI rendering), Phaser Tweens system (message animations, button feedback, floating messages), and browser Clipboard API (log copying functionality with document.execCommand fallback). 

- **StatusEffectContainer.js**: A sophisticated Phaser UI component responsible for displaying and managing visual representations of status effects on characters during battle, providing an intuitive icon-based interface that shows effect duration, stacks, and detailed tooltips. StatusEffectContainer emerged from the need to visualize the complex status effect system (v0.5.3.0) as part of the transition from abstract battle mechanics to rich visual feedback, implementing a comprehensive status visualization framework that transforms raw status data into meaningful visual indicators positioned below character sprites. The component handles complex status effect lifecycle management including real-time event listening through BattleBridge for status application, removal, and updates, sophisticated icon rendering with type-specific color coding (buffs=blue, debuffs=orange, DoT=red, HoT=green, control=purple, shields=gray), intelligent layout management with configurable maximum visible icons and "+N" overflow indicators, and comprehensive character identification using multiple fallback strategies (uniqueId, id, name+team combinations). Key architectural features include advanced animation systems with smooth fade-in/out transitions for status changes, detailed counter displays showing duration (turns remaining) and stack counts for stackable effects, interactive icon system with hover effects, click-to-lock tooltips, and scaling animations, and intelligent positioning below character health bars with automatic depth management. The component implements sophisticated event filtering to ensure status effects are only processed for the correct character, comprehensive error handling with graceful degradation when sprites or containers become invalid, and a shared tooltip system using StatusEffectTooltip for detailed effect information. StatusEffectContainer supports bulk status effect updates through STATUS_EFFECTS_CHANGED events, handles icon overflow scenarios elegantly with summary tooltips for hidden effects, and integrates seamlessly with the status icon mapping system for consistent visual representation. The component includes advanced features such as multi-effect tooltip support for overflow indicators, persistent tooltip interaction through click-locking mechanisms, and proper resource cleanup to prevent memory leaks during character destruction. *(Accurate as of v0.7.5.15)*

  Talks to: CharacterSprite.js (parent container and character data source via constructor injection), BattleBridge.js (comprehensive event listeners for STATUS_EFFECT_APPLIED, STATUS_EFFECT_REMOVED, STATUS_EFFECT_UPDATED, STATUS_EFFECTS_CHANGED), StatusEffectTooltip.js (shared singleton tooltip for detailed status information via constructor and show/hide methods), window.StatusIconMapper (icon mapping reference for AI icon scaling detection), Phaser Scene API (container creation, graphics rendering, text objects for counters), Phaser Tweens system (fade animations, scale effects, hover feedback), console logging system (initialization and error reporting), unique character identification system (uniqueId, id, and name+team fallback patterns), and provides visual status effect feedback consumed by the battle visualization system for enhanced combat clarity.

- **TeamContainer.js**: A specialized Phaser component responsible for organizing and managing collections of character sprites within battle scenes, serving as the foundational visual unit that transforms team data into interactive battlefield representations. TeamContainer emerged as a core component of the Phaser battle visualization system, handling the complete lifecycle of team-based character display from initialization through dynamic positioning to interactive management. The container manages sophisticated character organization including intelligent positioning algorithms with special 3-character triangle formations and customizable vertical spacing (configurable via spacing parameter, currently set to 350px for card frame compatibility), comprehensive character sprite initialization with robust error handling and validation, health update coordination through delegation to individual CharacterSprite instances, and team-wide highlighting management for turn-based visual feedback. Key architectural features include advanced character identification systems supporting multiple lookup strategies (unique IDs, names, team-prefixed identifiers, direct object references), defensive programming with extensive try-catch blocks and parameter validation throughout initialization and operation, team-based visual organization with configurable positioning (player team traditionally at x=600, enemy team at x=1400), and seamless integration with the deprecated TurnIndicator system transition to modern card frame highlighting. The component implements sophisticated character sprite management through the `findCharacterSprite()` method supporting fuzzy matching across multiple identification patterns, individual character health updates via `updateCharacterHealth()` with comprehensive logging and validation, team-wide animation coordination through `showTurnIndicator()` and `clearTurnIndicators()` methods (deprecated in v0.7.5.4), and bulk operations for clearing highlights and managing sprite collections. TeamContainer underwent significant architectural evolution during the turn indicator system transition, moving from the old floor-ellipse TurnIndicator system to the new card frame highlighting approach while maintaining backward compatibility and providing clear deprecation warnings. The component integrates closely with CharacterSprite instances for individual character management, coordinates with TeamDisplayManager for battle-wide team coordination, supports both traditional circle and modern card-based character representations, and provides debugging utilities through the `debugCharacterIdMapping()` method for troubleshooting character identification issues. TeamContainer serves as the essential visual foundation linking raw team data from TeamManager to the interactive battle experience, transforming JSON character arrays into living, animated battlefield participants through careful positioning, error handling, and state management. *(Accurate as of v0.7.5.15)*

Talks to: BattleScene.js (indirectly via TeamDisplayManager.js for scene integration and team positioning), TeamDisplayManager.js (parent coordinator managing team containers with explicit positioning at x=600 for player team and x=1400 for enemy team), CharacterSprite.js (creates and manages individual character sprites via constructor with comprehensive error handling), window.TeamContainer (global class availability and fallback patterns), window.teamContainers (global debugging registry storing player and enemy team references), TurnIndicator.js (deprecated integration removed in v0.7.5.4, replaced with card frame highlighting), ActionIndicator.js (indirectly via CharacterSprite delegation for action text display above characters), StatusEffectContainer.js (indirectly via CharacterSprite delegation for status visualization), character data structures (team arrays, character objects with stats, abilities, and positioning data), Phaser Container system (extends Phaser container functionality with specialized team management), console logging system (comprehensive initialization, error reporting, and operation debugging), and team data validation (ensures character arrays, stats integrity, and proper team assignment through defensive programming patterns).
  
- **StatusEffectTooltip.js**: A singleton Phaser UI component responsible for providing detailed, interactive tooltips for status effects throughout the battle interface, featuring elegant visual design, intelligent positioning, and comprehensive status information display. StatusEffectTooltip implements the singleton pattern to ensure consistent tooltip behavior across all status effect interactions, serving as the centralized authority for status effect information presentation with sophisticated error handling to prevent common Phaser text rendering crashes (v0.6.3.34 fix). The component handles comprehensive tooltip content management including status effect name formatting with intelligent text transformation (removing prefixes, handling abbreviations, capitalizing properly), detailed descriptions with duration and stack information, type-based visual theming with colored borders matching effect categories, and multi-line information display with proper text wrapping and alignment. Key architectural features include advanced positioning logic with intelligent screen edge detection and automatic repositioning to prevent off-screen tooltips, elegant visual design with gradient backgrounds, rounded corners, colored borders based on effect types, and subtle animation effects, and robust lifecycle management with proper resource cleanup and singleton state management across scene transitions. The component implements sophisticated interaction modes supporting hover-triggered tooltips with automatic hide on mouse out, click-to-lock functionality for persistent tooltip viewing with visual feedback, and dynamic positioning updates for moving elements or cursor tracking. StatusEffectTooltip underwent critical stability improvements including comprehensive null checks for all text objects to prevent Phaser rendering errors, scene validity verification before operations to handle scene transitions gracefully, and enhanced resource management with explicit object nullification during destruction. The component provides specialized multi-effect tooltip support for displaying summaries of multiple status effects in overflow scenarios, intelligent text formatting for various status effect naming conventions, and comprehensive error handling with detailed logging for debugging tooltip-related issues. *(Accurate as of v0.7.5.15)*

  Talks to: StatusEffectContainer.js (primary consumer via constructor injection and showTooltip/hideTooltip method calls), Phaser Scene API (container creation, graphics rendering, text objects with advanced styling), Phaser Tweens system (fade-in/out animations, positioning transitions), Phaser.Display.Color (gradient background calculations, border color theming), window singleton pattern (global instance management via window.statusEffectTooltip), scene transition system (validity checks via scene.sys.isActive()), console logging system (comprehensive debugging and error reporting), status effect definition system (name formatting, description parsing, type categorization), and provides detailed status information display services for all status effect visualization throughout the battle interface. 

- **TurnIndicator.js**:  A deprecated Phaser visual component that provided floor-based turn indication through animated elliptical markers positioned beneath active characters during battle, serving as the original turn highlighting system before transitioning to the modern card frame approach in v0.7.5.4. TurnIndicator emerged as a dedicated component during the Phase 1 battle scene refactoring (v0.6.3.5) when turn indication logic was extracted from CharacterSprite highlighting into a specialized visual component to improve code organization and visual consistency. The component implemented sophisticated turn visualization including flattened elliptical floor markers with team-specific coloring (blue for player team, red for enemy team), advanced animation systems with sequential fade-in/fade-out transitions and infinite pulsing effects, customizable positioning with vertical offset calculations for proper placement at character feet, and intelligent positioning logic accounting for character sprite dimensions and battle layout. Key architectural features included extending Phaser.GameObjects.Graphics for direct drawing capabilities, comprehensive animation lifecycle management with overlapping tween protection and proper cleanup, configurable appearance parameters including radius sizing (56px with 0.27 aspect ratio for flattened appearance), and defensive programming with scene validation and resource management. The component provided smooth visual feedback through a two-phase animation system: initial fade-in from alpha 0 to 0.3 followed by continuous pulsing between 0.3 and 0.7 alpha values, creating a breathing effect that clearly identified the active character without being visually distracting. TurnIndicator underwent significant evolution including optimization for reduced size while maintaining proportions (25% reduction from original 75px radius), enhanced animation smoothness with sequential tweening, improved resource cleanup with proper tween management, and comprehensive integration with TeamContainer and TeamDisplayManager for centralized turn indication control. The component was systematically deprecated in v0.7.5.4 when the new card frame highlighting system became fully operational, with all references disabled across TeamContainer, TeamDisplayManager, and index.html while preserving the code for historical reference and potential future use. The deprecation transition demonstrated clean architectural evolution, with methods redirected to the new highlight/unhighlight system while maintaining backward compatibility and comprehensive deprecation warnings throughout the codebase. (Accurate as of v0.7.5.15 - Deprecated and disabled)

Talks to: TeamContainer.js (deprecated integration removed in v0.7.5.4, previously managed TurnIndicator instances for each team via constructor and provided showAt/hide delegation), TeamDisplayManager.js (deprecated integration removed in v0.7.5.4, previously coordinated turn indicator positioning and color selection via updateTurnIndicator method), Phaser.GameObjects.Graphics (extends for direct ellipse drawing and visual rendering capabilities), Phaser Tweens system (complex animation sequences including fade-in, infinite pulsing, and fade-out transitions with proper overlap management), Phaser Scene API (scene integration, depth management, coordinate positioning, and lifecycle management), window.TurnIndicator (global class registration for component availability checking), console logging system (component loading confirmation and animation debugging), deprecated integration points including CharacterSprite.js (indirect connection via TeamContainer delegation for position calculation) and BattleScene.js (indirect scene coordination via TeamDisplayManager), and provides legacy turn visualization services that were replaced by the CardFrame highlighting system for improved visual integration and architectural consistency.


### General UI Components
- **Button.js**: A reusable Phaser button component providing standardized interactive functionality with customization options and built-in animations. The component extends Phaser.GameObjects.Container creating buttons with background rectangles, text labels, and comprehensive styling through configurable style objects controlling colors, dimensions, fonts, and corner radius. Key features include sophisticated state management with enabled/disabled states affecting appearance and interactivity, smooth animation system using Phaser tweens for hover scaling (1.05x), click effects (0.95x with yoyo), and cursor feedback, event handling with callback execution on clicks, and sound integration through global sound manager. The component provides chainable methods (setText, setEnabled), defensive programming with default styles, and seamless integration across UI systems requiring interactive buttons.
Talks to: Phaser Scene API (container management, graphics creation), Phaser Tweens system (animations), window.soundManager (click audio), callback functions (user interactions), and provides button services for battle controls, team builder interfaces, and other interactive UI elements.
- **Panel.js**: A sophisticated Phaser container component providing structured layouts with professional styling including shadows, borders, and animations for cohesive interface designs. The component extends Phaser.GameObjects.Container delivering layered visual composition with configurable shadow effects (offset, blur, color), main background rectangles with customizable colors and transparency, optional borders, and corner radius support for modern rounded designs. Key features include advanced shadow system with post-processing blur effects, comprehensive styling through style objects, animation capabilities (fade-in, slide-in from any direction), utility methods for adding titles and interactive callbacks, and chainable methods for dynamic appearance changes.
Talks to: Phaser Scene API (container management, graphics), Phaser Tweens system (animations), Phaser postFX system (shadow blur), callback functions (interactive handlers), and provides foundational panel services for battle interfaces, team builder layouts, and complex UI requiring organized visual sections. 

---

## DOM-Based UI Systems

### Team Builder
- **TeamBuilderUI.js**: The primary orchestrator for the character selection interface in the AutoBattler game, functioning as the central hub for team composition before battle. TeamBuilderUI has been refactored from a monolithic class into a sophisticated component-based architecture, where it serves as the coordinator for seven specialized manager components that handle distinct aspects of the team-building experience. The system manages character data loading from JSON, user interaction with available heroes, filter controls for types and roles, team slot management, hero detail display, battle mode selection, and battle initiation workflows. TeamBuilderUI maintains compatibility with legacy systems while delegating specific responsibilities to specialized components: FilterManager (type/role filtering), HeroGridManager (character display and selection), TeamSlotsManager (team composition), HeroDetailPanelManager (detailed character information), BattleModeManager (battle type selection), BattleInitiator (transition to battle), and TeamBuilderUtils (shared utility functions). The architecture follows an Extract-Verify-Remove refactoring pattern, allowing gradual migration from monolithic methods to specialized components while maintaining fallback functionality. TeamBuilderUI interfaces with the image loading system for character art display, manages global UI state including view modes, and provides comprehensive error handling for missing components. *(Accurate as of v0.7.5.14)*

Talks to: TeamManager.js (team state management), FilterManager.js (filter state updates), HeroGridManager.js (character selection events), TeamSlotsManager.js (team composition changes), HeroDetailPanelManager.js (character detail rendering), BattleModeManager.js (battle mode changes), BattleInitiator.js (battle start coordination), TeamBuilderImageLoader.js (character art loading), TeamBuilderUtils.js (shared utility functions), data/characters.json (character data loading), window.soundManager (audio feedback), window.tooltipManager (UI tooltips), and game.js (initialization and global state).

- **TeamBuilderUtils.js**: A utility class providing shared static functions for the TeamBuilder component architecture. Serves as a centralized location for common operations that are needed across multiple TeamBuilder components including type string parsing, multi-type UI rendering, stat box creation, ability scaling calculations, and general formatting utilities. Created during the Extract-Verify-Remove refactoring process (v0.6.6.0), this class was extracted from TeamBuilderUI.js to eliminate code duplication and support the component-based architecture transition. Contains five key static methods: `splitTypes()` for handling multi-type characters (e.g., "water/ice"), `renderMultiTypeSpans()` for creating colored type tags in the UI, `getOrdinalSuffix()` for generating ordinal numbers (1st, 2nd, etc.), `createStatBox()` for consistent stat display elements, and `getDetailedScalingText()` for detailed ability tooltip information with scaling formulas. As a pure utility class with no state, it follows the Single Responsibility Principle and provides clean interfaces for UI rendering tasks across the TeamBuilder ecosystem. *(Accurate as of v0.7.5.15)*

Talks to: HeroDetailPanelManager.js (type parsing, stat boxes, ability scaling), TeamSlotsManager.js (type parsing for team slots and synergies), window.tooltipManager (tooltip integration for stat boxes), global type colors configuration (from parent UI components), and serves as a dependency for all TeamBuilder UI components that need consistent formatting and parsing utilities.

- **HeroDetailPanelManager.js**: A specialized component responsible for rendering and managing the detailed hero information panel in the TeamBuilder UI. This component handles the complex display of character statistics, abilities, type relationships, and character art within the hero details section. Created during the TeamBuilder refactoring process as part of the component-based architecture transition, it manages both initial rendering and intelligent updates to preserve DOM structures and improve performance. The component features sophisticated multi-type character support, detailed ability tooltips with scaling formulas, comprehensive type advantage/disadvantage visualization, and integration with the character art system. Key responsibilities include rendering character stats (both basic HP/ATK/DEF/SPD and expanded STR/INT/SPI), displaying abilities with type-specific styling and detailed tooltips, creating interactive type relationship sections with icons and colors, and managing character portrait integration. The component implements performance optimizations such as preserving existing DOM wrappers during updates and disabling art observers during rendering to prevent conflicts. It heavily utilizes TeamBuilderUtils for type parsing, stat box creation, and scaling calculations, ensuring consistency across the TeamBuilder interface. The component follows defensive programming principles with comprehensive error handling and fallback mechanisms for missing elements or failed operations. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamBuilderUtils.js (type parsing, stat boxes, scaling calculations), TeamBuilderImageLoader.js (character art rendering via drawArt method), window.tooltipManager (enhanced ability and stat tooltips), window.disableArtObserver/enableArtObserver (performance optimization during DOM updates), DOM elements (detail-content container), data/characters.json (indirectly via parent's availableHeroes), and integrates with the global type colors and image caching systems.

- **FilterManager.js**: A specialized component responsible for managing all type and role filtering functionality within the TeamBuilder interface. Created during the TeamBuilder component-based refactoring process (v0.6.6.4), FilterManager handles the complete lifecycle of filter interactions including UI rendering, state management, user interactions, and parent notification. The component creates collapsible filter sections for all 22 types and 22 roles from the game specification, with each section starting collapsed by default and expanding through smooth CSS transitions when clicked. Filter buttons provide immediate visual feedback with active/inactive states, hover effects, and sound integration through the global SoundManager. The component maintains independent filter state for types and roles, automatically displays active filter count badges on section headers, and provides a dynamic "Clear Filters" button that appears only when filters are active. FilterManager includes special handling for the Ethereal type with enhanced opacity and black text for better contrast, and automatically injects required CSS styles for the collapsible functionality to avoid external dependencies. The component follows the established delegation pattern where TeamBuilderUI can initialize it with existing filter state and receives notifications of filter changes through the `onFiltersChanged()` callback, enabling seamless integration with the hero grid filtering system. FilterManager demonstrates mature UX design with smooth animations, comprehensive error handling, and self-contained styling that maintains visual consistency across the TeamBuilder interface. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and callback receiver), window.soundManager (audio feedback for hover and click events), DOM elements (filter sections, buttons, and containers), HeroGridManager.js (indirectly via parent's onFiltersChanged callback), global typeColors configuration (accessed via parent reference), CSS style injection system (for collapsible filter animations), and serves as the authoritative source for filter state accessible through the window.FilterManager global reference.
- **HeroGridManager.js**: A specialized component responsible for managing the hero selection grid within the TeamBuilder interface, serving as the central hub for hero display, filtering, and selection interactions. Created during the TeamBuilder component-based refactoring process (v0.6.6.6), HeroGridManager handles the complete lifecycle of hero grid operations including rendering filtered character cards, managing view modes, applying filter criteria, and facilitating hero selection. The component creates individual hero cards with proper type-specific styling, handles multi-type character display using TeamBuilderUtils for type parsing and rendering, and integrates seamlessly with the FilterManager through filter state updates. A key feature is the dual view mode system with persistent localStorage storage - users can toggle between "full view" (vertical layout with art above text) and "compact view" (horizontal layout with smaller cards), accessible through a dynamically created toggle button in the section header. The component maintains selection state independently while notifying the parent through callback mechanisms, applies filtered display based on both type and role criteria with proper no-results messaging, and explicitly manages character art loading through integration with TeamBuilderImageLoader. HeroGridManager demonstrates sophisticated UI patterns including responsive design considerations, persistent user preferences, and comprehensive error handling with fallback mechanisms when dependencies are unavailable. The component follows the established delegation pattern where hero selection triggers parent notification via `onHeroSelected()` callback, ensuring seamless integration with the broader TeamBuilder ecosystem for hero detail display and team composition workflows. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamBuilderUtils.js (type parsing and multi-type rendering), TeamBuilderImageLoader.js (character art rendering via explicit drawArt calls), FilterManager.js (indirectly via parent's onFiltersChanged callback for filter state updates), window.soundManager (audio feedback for view toggle button), DOM elements (heroes-grid container, hero cards, view toggle button), localStorage (view mode persistence as 'heroGridViewMode'), global typeColors configuration (accessed via parent reference), and serves as the primary hero selection interface accessible through window.HeroGridManager global reference.
- **TeamSlotsManager.js**: A specialized component responsible for managing the complete team composition interface within the TeamBuilder, handling both player and enemy team slot rendering, hero placement, and team synergy calculations. Created during the TeamBuilder component-based refactoring process (v0.6.6.8), TeamSlotsManager orchestrates all aspects of team building including slot visualization, hero addition and removal workflows, real-time synergy calculation, and dual-team selection functionality for custom battles. The component maintains independent state for both player and enemy teams while providing a unified interface that dynamically switches between team selection modes with visual indicators and appropriate styling. A key innovation is the comprehensive team synergy system that calculates both type-based alliances and role-based bonuses, properly handling multi-type characters through TeamBuilderUtils integration and displaying real-time feedback as players build their teams. The component features sophisticated slot rendering with character art integration via TeamBuilderImageLoader, detailed hero information displays including both basic and advanced stats, and intuitive empty slot guidance that adapts based on current hero selection. TeamSlotsManager integrates seamlessly with the broader TeamBuilder ecosystem through callback mechanisms, notifying the parent of team selection changes for battle mode handling and triggering battle button updates based on team completion status. The component demonstrates advanced UI patterns including dynamic team heading coloring, contextual control buttons for team switching, and proper event handling with sound feedback integration. Team state management includes accessor methods for external systems to retrieve team compositions, support for hero validation and duplicate checking, and comprehensive rendering cycles that preserve state while updating visual elements. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamSlotsManager.js manages bidirectional communication through callbacks like onTeamSelectionChanged and notifyBattleButtonUpdate), TeamBuilderUtils.js (type parsing for multi-type heroes, ordinal suffix generation, and synergy calculations), TeamBuilderImageLoader.js (character art rendering via explicit drawArt calls with view mode support), TeamManager.js (indirectly via parent's teamManager reference for team operations), HeroGridManager.js (indirectly via viewMode retrieval for consistent art rendering), window.soundManager (audio feedback for hero addition and removal actions), DOM elements (team-slots container, slot elements, synergies-list), global typeColors configuration (accessed via parent reference), and serves as the authoritative source for team composition data accessible through window.TeamSlotsManager global reference.
- **BattleModeManager.js**: A specialized component responsible for managing battle mode selection and battle button state within the TeamBuilder interface. Created during the final phase of the TeamBuilder component-based refactoring process (v0.6.6.10), BattleModeManager encapsulates all functionality related to the three distinct battle modes: Random Opponent (generates a random enemy team), Custom Battle (allows player selection of both teams), and Campaign Mode (future story encounters). The component handles the complete lifecycle of battle mode interactions including rendering mode selection UI with proper visual states, managing mode toggling with validation against current selection context, and dynamically updating the start battle button's text and enabled state based on team composition and mode requirements. A key feature is the intelligent button state management that adapts to different contexts - displaying "Choose Enemy Team" when Custom mode is selected with a player team ready, "Start Battle" for Random/Campaign modes, and appropriate disabled states when team requirements aren't met. The component includes sophisticated integration with TeamSlotsManager to track enemy team selection progress, providing visual indicators like "Selecting Enemy" labels and preventing mode changes during enemy selection workflows. BattleModeManager follows the established delegation pattern with comprehensive validation, fallback mechanisms, and sound integration for user feedback. The component maintains state synchronization through dedicated callback methods, ensuring the broader TeamBuilder system remains aware of mode changes for appropriate UI updates and battle initiation workflows. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source, receives mode changes via onBattleModeChanged callback), TeamSlotsManager.js (integrates for team selection state tracking and battle button updates), BattleInitiator.js (indirectly via TeamBuilderUI for battle initiation coordination), window.soundManager (audio feedback for mode selection interactions), DOM elements (battle-modes container, mode selection elements, start-battle button), and serves as the authoritative source for battle mode state accessible through the BattleModeManager instance and delegation methods in TeamBuilderUI.


- **BattleInitiator.js**: A specialized component responsible for orchestrating battle initiation, team validation, UI transitions, and battle system initialization within the TeamBuilder architecture. BattleInitiator encapsulates the complex workflow of transitioning from team selection to active combat, handling multiple battle start scenarios and providing robust fallback mechanisms for different UI modes. The component manages sophisticated battle mode logic including Custom Battle enemy team selection workflows (detecting when players need to select enemy teams before battle can start), team validation with user feedback, and dynamic enemy team generation through TeamManager integration. A critical responsibility is managing the transition between UI systems - primarily coordinating the switch from DOM-based TeamBuilder interface to Phaser-based Battle Scene, with comprehensive fallback support to the legacy DOM-based BattleUI when Phaser initialization fails. The component includes advanced Phaser integration features such as scene readiness polling, battle data preparation and passing, UI state management (hiding/showing containers), and proper canvas visibility handling. BattleInitiator maintains state synchronization across multiple systems, handles return-from-battle workflows to restore TeamBuilder state, and provides global function exposure for backward compatibility with existing battle management systems. The component implements comprehensive error handling with user-friendly alerts, sound integration for feedback, and defensive programming patterns to ensure battle initiation succeeds even when some dependencies are unavailable. *(Accurate as of v0.7.5.15)*

Talks to: TeamBuilderUI.js (parent orchestrator and configuration source), TeamManager.js (team data management, player/enemy team setting, and team generation), BattleModeManager.js (battle mode retrieval and validation), TeamSlotsManager.js (team composition data and enemy selection state), window.battleManager (battle logic initialization and DOM fallback), window.game (Phaser game instance, scene management, and BattleScene coordination), window.soundManager (audio feedback for battle transitions and errors), DOM elements (team-builder-container, game-container, canvas visibility), BattleScene.js (Phaser scene initialization with battle data), and provides global functions (window.onReturnFromPhaserBattle, window.onReturnFromBattle) for battle completion callbacks accessible across the application.



### Legacy Battle UI
- **BattleUI.js**: 
- **BattleUIDebug.js**: 

### General UI Systems
- **SoundManager.js**: A comprehensive audio management system responsible for providing sound effects and feedback within the TeamBuilder interface. The component creates a singleton SoundManager instance that handles both file-based audio (when available in the assets/audio/ directory) and generated Web Audio API sounds as fallbacks when audio files are missing. The system manages seven distinct sound types including click, hover, select, add, remove, error, and battle_start sounds, each with unique oscillator configurations for generated audio (square waves for clicks, triangles for selections, sawtooth for removals). SoundManager provides a complete audio control interface with a fixed-position UI overlay featuring volume controls and mute toggles, allowing players to customize their audio experience. The component automatically attaches itself to UI elements via addSoundsToUI(), applying sounds to buttons, battle mode selectors, hero cards, team slots, and the start battle button. Each sound type has a specific purpose within the TeamBuilder workflow - clicks for general interactions, selects for hero choices, add/remove for team composition, error for validation failures, and battle_start for major transitions. Currently focused on TeamBuilder functionality with no integration into the Phaser-based Battle Scene system, as indicated by the user context. The component implements robust error handling for audio initialization failures and provides graceful degradation when the Web Audio API is unavailable. *(Accurate as of v0.7.5.15)*

Talks to: Web Audio API (oscillator creation and audio context management), DOM elements (buttons, battle modes, hero cards, team slots, start battle button), TeamBuilder components (FilterManager.js adds hover sounds to buttons, BattleInitiator.js triggers battle_start sound), window scope (global singleton access as window.soundManager), asset files (attempts to load from assets/audio/ directory with fallbacks), and UI control elements (sound toggle button, volume slider) for real-time audio management.

- **TooltipManager.js**: A lightweight tooltip management system responsible for providing contextual information and enhanced user experience across the TeamBuilder interface. The component creates a singleton TooltipManager instance that handles dynamic tooltip creation, positioning, and content management through a simple yet effective API. The system creates a single reusable tooltip element that follows the mouse cursor with intelligent positioning logic to prevent tooltips from extending beyond viewport boundaries, automatically adjusting to display above or below the cursor based on available screen space. TooltipManager provides two primary integration methods: direct content tooltips for static information and function-based tooltips for dynamic content generation, allowing components to provide contextual information that updates based on current state. The component handles all event management internally, automatically attaching mouseenter and mouseleave listeners to elements and managing tooltip visibility states. The system is extensively utilized by HeroDetailPanelManager for providing detailed ability information including damage formulas, cooldown details, scaling text, and type advantage explanations, significantly enhancing the information density and usability of the TeamBuilder interface. TooltipManager supports HTML content rendering, enabling rich formatting for complex information displays while maintaining a clean and consistent visual style. The implementation focuses on performance and simplicity, using a single DOM element that's reused for all tooltips to minimize memory overhead. *(Accurate as of v0.7.5.15)*

Talks to: DOM event system (mousemove, mouseenter, mouseleave events), HTML elements (receives tooltip content and attaches to target elements), HeroDetailPanelManager.js (extensive integration for ability tooltips, stat descriptions, and type advantage information), TeamBuilderUtils.js (indirectly via components that use tooltipManager for stat box descriptions), window scope (global singleton access as window.tooltipManager), and CSS styling system (tooltip positioning and visual styling).

---

## Utilities & Helpers
- **DirectImageLoader.js**: A specialized utility component responsible for injecting character artwork into the DOM-based Battle UI system, serving as a critical bridge between character data and visual representation during battle. DirectImageLoader operates as a fallback system that automatically replaces placeholder character circles with actual character images through direct DOM manipulation, ensuring character artwork appears even when other loading mechanisms fail. The component maintains a hardcoded lookup table mapping character names to image paths, loads character data from JSON to apply custom positioning settings, and implements sophisticated animation protection systems to prevent art interference during battle animations. Key features include global image caching integration (utilizing window.CHARACTER_IMAGE_CACHE), custom positioning support for each character through their `art` property in characters.json, automatic periodic scanning for new character elements, and automatic disabling during animations to prevent visual artifacts. The system includes comprehensive error handling with image loading verification, multiple fallback mechanisms when images fail to load, and defensive programming patterns to prevent interference with the animation system. DirectImageLoader specifically targets the DOM-based BattleUI system (not the Phaser-based Battle Scene), making it essential for the legacy battle visualization while being bypassed in the modern Phaser implementation. The component demonstrates careful integration with the broader character art ecosystem, including storage of original positioning data for animation systems and sophisticated filtering to avoid processing animation clones or already-processed elements. *(Accurate as of v0.7.5.15)*

Talks to: DOM-based BattleUI.js (primary consumer for character art injection), window.CHARACTER_IMAGE_CACHE (global image caching system), data/characters.json (character data and custom art positioning), window event system (load event for initialization), BattleUI.js showAttackAnimation() (disabling via window.disableDirectImageLoaderDuringAnimation function), DOM elements (.character-circle containers and #battle-ui), browser Image API (for image loading and verification), character containers with team identifiers (player/enemy), and provides global utilities (window.disableDirectImageLoader flag) for animation system coordination.

- **ImageDebugger.js**: A lightweight diagnostic utility designed to troubleshoot image loading issues within the AutoBattler game, providing interactive tools for validating character artwork paths and identifying loading failures. ImageDebugger tests multiple potential image paths systematically, helping developers resolve artwork display problems during development and deployment. The component features an asynchronous path testing system that attempts to load images from various locations (relative paths, absolute paths, different directory structures), displays real-time loading results with visual feedback including success/failure indicators and image thumbnails, and creates a temporary debugging UI overlay with detailed status information. The utility implements comprehensive error handling with timeout protection (5-second limit per image) and graceful cleanup of debugging interface elements. Originally designed to address complex character art loading challenges during development, ImageDebugger has been streamlined as the character art system matured and stabilized. The component represents a crucial development tool for ensuring character artwork displays correctly across different environments and deployment scenarios. *(Accurate as of v0.7.5.15)*

Talks to: Browser Image API (for testing image loading from various paths), DOM manipulation (creates temporary debugging UI overlay), global window object (exposes ImageDebugger namespace), character art file system (tests asset paths for Character Art directory), setTimeout API (for loading timeouts), and serves as a standalone diagnostic tool accessible through browser console for development troubleshooting.

- **TeamBuilderImageLoader.js**: A sophisticated image management system responsible for handling character artwork within the TeamBuilder UI, providing centralized preloading, caching, and on-demand rendering across multiple contexts. TeamBuilderImageLoader implements Promise-based image preloading to ensure all character images are loaded before UI initialization, preventing race conditions that previously caused "not found in image cache" errors. The component features intelligent context-aware rendering supporting multiple view modes (full/compact), applies different sizing based on usage context (hero grid vs. detail panel), and utilizes character-specific art configurations from characters.json including custom positioning and separate settings for different UI contexts (art, teamBuilderArt, detailArt). Key features include a dual caching system using both instance-level cache and global cache (window.CHARACTER_IMAGE_CACHE), WeakSet-based tracking to prevent reprocessing, view mode scaling that applies 1.4x magnification in full view while maintaining original sizes in compact view, and explicit art rendering through the drawArt() method replacing the deprecated observer-based approach. The component implements comprehensive error handling with loading placeholders, fallback mechanisms for failed image loads, and defensive programming patterns. TeamBuilderImageLoader integrates seamlessly with the component-based TeamBuilder architecture, providing art services to HeroGridManager, HeroDetailPanelManager, and TeamSlotsManager while maintaining separation of concerns through delegation patterns. *(Accurate as of v0.7.5.15)*

Talks to: HeroGridManager.js (art rendering with view mode support), HeroDetailPanelManager.js (detail panel art with context-specific sizing), TeamSlotsManager.js (team slot art rendering), TeamBuilderUI.js (parent orchestrator and initialization), window.CHARACTER_IMAGE_CACHE (global image caching), data/characters.json (character data and art configuration), Promise-based initialization system, DOM elements (.hero-avatar-container, .hero-art-wrapper), browser Image API (loading and error handling), and provides utility functions for image validation and user feedback.

---

## Configuration & Initialization
- **game.js**: The main entry point and orchestrator for the entire AutoBattler application. This file handles the complete initialization sequence when the game loads, including creating the TeamManager, TeamBuilderUI, BattleManager, and the Phaser game instance. It also manages the loading of configuration files and serves as the central coordinator that connects all major systems together. The file includes comprehensive error handling and fallback mechanisms to ensure the game can start even if some components fail to load. It exposes all major managers globally for debugging and cross-system communication. *(Accurate as of v0.7.5.14)*

Talks to: TeamManager.js, TeamBuilderUI.js, BattleManager.js, PhaserConfig.js, project.config file, and window/global scope for system-wide access.


- **assets.js**: A comprehensive asset management system that catalogs and organizes all game resources including character images, UI elements, arena backgrounds, and effects. The AssetsManager class provides a centralized way to locate and preload assets for the Phaser engine, with methods for cataloging different asset types and loading them into Phaser scenes. It integrates with existing image loaders and provides fallback mechanisms for missing assets. This system ensures consistent asset paths and enables efficient preloading strategies. *(Accurate as of v0.7.5.14)*

Talks to: TeamBuilderImageLoader.js (for character image paths), Phaser scenes (for asset preloading), and the assets folder structure directly.


- **config.js**: A duplicate/alternative Phaser configuration class that appears to provide similar functionality to PhaserConfig.js but with different default settings and container management. This version uses more basic configuration settings and seems designed for standard HD resolution rather than 4K. It creates Phaser containers dynamically and provides static methods for configuration creation. This may be an older version or alternative implementation that's maintained for compatibility. *(Accurate as of v0.7.5.14)*

Talks to: Similar to PhaserConfig.js - interfaces with the DOM for container creation and provides configuration to Phaser.Game constructor.


- **PhaserConfig.js**: A utility module that handles the technical configuration and container setup for the Phaser game engine. It creates and styles the DOM container where Phaser renders, configures rendering options for optimal performance (including 4K support), and provides helper functions for checking if Phaser is properly initialized. The configuration includes specific settings for anti-aliasing, pixel art handling, and canvas context optimization. This module encapsulates all the technical details needed to get Phaser running correctly. *(Accurate as of v0.7.5.14)*

Talks to: game.js (called during Phaser initialization), the DOM (creates and styles containers), and provides configuration objects to the Phaser.Game constructor.


- **uiManager.js**: A sophisticated system for managing transitions between different UI modes in the game - specifically between DOM-based interfaces (like the Team Builder) and Phaser-based scenes (like the Battle Scene). It handles showing/hiding appropriate containers, managing scene transitions within Phaser, and provides toggle buttons for users to switch between UI modes. The UIManager acts as a bridge between the traditional HTML/CSS interface and the Phaser-powered game scenes, enabling seamless transitions during gameplay. *(Accurate as of v0.7.5.14)*

Talks to: game.js (receives Phaser game instance), DOM elements (team-builder-container, game-container, phaser-container), Phaser scenes (BattleScene, TeamBuilderScene), and manages scene lifecycle within the Phaser framework.



---

## Notes on Component Categories

### What Makes a "Component"?
Components are reusable, focused pieces of functionality that can be combined to create larger systems. In this codebase, they typically:
- Have a single, clear responsibility
- Can be instantiated multiple times
- Provide clean interfaces for interaction
- Handle their own lifecycle (creation, updates, destruction)

### Manager vs. Component vs. Utility
- **Managers**: Orchestrate multiple systems (BattleManager coordinates all battle logic)
- **Components**: Focused, reusable pieces (CharacterSprite handles one character's visuals)
- **Utilities**: Helper functions and tools (BattleUtilities provides common calculations)

### Refactoring History
Many of these files were created by refactoring larger, monolithic files into smaller, focused components. This makes the code:
- Easier to understand and maintain
- More testable in isolation
- More reusable across different parts of the game
- Less likely to create conflicts when multiple developers work on it

---

*Last Updated: [Date] - This document should be updated whenever new files are added or the architecture significantly changes.*
