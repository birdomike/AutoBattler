Combined Technical Changelog  (generated 2025-05-10 21:06)

===== CHANGELOG_0.6.3.37_PassiveBehaviorsStatusEffectRoutingFix =====

# CHANGELOG 0.6.3.37 - PassiveBehaviors Status Effect Routing Fix

## Issue Description

When passive abilities applied status effects, BattleBridge.js displayed console warnings: "BattleBridge: Creating minimal fallback for status effect [status_id]". This indicated that while the effects were being applied, their full definitions weren't being properly propagated to the UI, resulting in potential visual issues with tooltips and icons.

The issue primarily manifested with Lumina's team buff passive at the start of battle (passive_TeamBuffOnBattleStart) and affected all 11 passive behaviors that directly called battleManager.addStatusEffect().

## Root Cause Analysis

The root cause was identified as a disconnect between the v0.6.3.35 fix in StatusEffectManager.js and the way passive abilities applied status effects:

1. **Direct BattleManager Calls**: PassiveBehaviors.js was making direct calls to battleManager.addStatusEffect() instead of routing through StatusEffectManager:
   ```javascript
   // Example from passive_TeamBuffOnBattleStart
   battleManager.addStatusEffect(ally, statusId, actor, effectDuration, 1);
   ```

2. **Architectural Gap**: While the StatusEffectManager had been enhanced in v0.6.3.35 to include full definitions in events (via the dispatchStatusEffectApplied method), this improvement only worked when StatusEffectManager.addStatusEffect() was called directly. The BattleManager.addStatusEffect() method didn't have the same enhancement.

3. **Different Event Paths**: This created two separate event paths:
   - **Proper Path**: Game logic â†’ StatusEffectManager.addStatusEffect â†’ StatusEffectManager.dispatchStatusEffectApplied â†’ BattleBridge (with full definition)
   - **Incomplete Path**: PassiveBehaviors â†’ BattleManager.addStatusEffect â†’ BattleBridge (without definition, requiring fallback)

## Technical Solution

The solution implemented follows the architectural principle that StatusEffectManager should be the consistent point of entry for applying status effects:

1. **Helper Function Creation**: Created a central helper function in PassiveBehaviors.js that routes all status effect applications through StatusEffectManager when available:

```javascript
/**
 * Helper function to apply status effects through StatusEffectManager
 * Falls back to BattleManager.addStatusEffect if StatusEffectManager isn't accessible
 */
function applyStatusEffect(battleManager, character, effectId, source, duration, stacks = 1) {
    // Parameter validation
    if (!battleManager || !character || !effectId) {
        console.warn('[PassiveBehaviors.applyStatusEffect] Missing required parameters', { 
            hasBattleManager: !!battleManager, 
            hasCharacter: !!character, 
            effectId 
        });
        return false;
    }
    
    // Ensure duration is a number
    if (typeof duration !== 'number') {
        console.warn(`[PassiveBehaviors.applyStatusEffect] Invalid duration (${typeof duration}) for ${effectId} - using default 3`);
        duration = 3;
    }
    
    // Try to use StatusEffectManager first
    if (battleManager.statusEffectManager) {
        console.log(`[PassiveBehaviors] Using StatusEffectManager.addStatusEffect for ${effectId}`);
        return battleManager.statusEffectManager.addStatusEffect(character, effectId, source, duration, stacks);
    } else if (typeof battleManager.getStatusEffectManager === 'function') {
        const statusEffectManager = battleManager.getStatusEffectManager();
        if (statusEffectManager) {
            console.log(`[PassiveBehaviors] Using getStatusEffectManager().addStatusEffect for ${effectId}`);
            return statusEffectManager.addStatusEffect(character, effectId, source, duration, stacks);
        }
    }
    
    // Fall back to BattleManager.addStatusEffect
    console.log(`[PassiveBehaviors] StatusEffectManager not accessible, falling back to BattleManager.addStatusEffect for ${effectId}`);
    return battleManager.addStatusEffect(character, effectId, source, duration, stacks);
}
```

2. **Modifying All Direct Calls**: Updated all 11 instances of direct battleManager.addStatusEffect calls in PassiveBehaviors.js to use the new helper function:

```javascript
// Before:
battleManager.addStatusEffect(actor, 'status_crit_up', actor, 2, 1);

// After:
applyStatusEffect(battleManager, actor, 'status_crit_up', actor, 2, 1);
```

3. **Multiple Access Methods**: Implemented fallback mechanisms to handle different ways BattleManager might expose its StatusEffectManager:
   - Direct property access: `battleManager.statusEffectManager`
   - Getter method: `battleManager.getStatusEffectManager()`
   - Fallback to original method if StatusEffectManager isn't accessible

4. **Parameter Validation**: Added comprehensive parameter validation to catch potential issues early and provide helpful error messages.

## Implementation Benefits

1. **Architectural Alignment**: Solution follows the principle that StatusEffectManager should be the single point of entry for status effect management, aligning with the component-based architecture.

2. **Elimination of Warnings**: The "Creating minimal fallback for status effect" warnings no longer appear since all status effects now flow through the proper channel that includes their definitions.

3. **Improved Tooltip Display**: Status effects applied by passive abilities now display proper tooltips with accurate information when hovered over.

4. **Robust Error Handling**: The helper function includes comprehensive parameter validation and fallbacks to prevent errors.

5. **Defensive Programming**: The implementation follows defensive programming patterns with proper validation and graceful degradation.

6. **Backward Compatibility**: The solution maintains backward compatibility through its fallback mechanisms.

## Testing Verification

Testing should verify:
1. No "Creating minimal fallback" warnings appear in the console during battles
2. Status effect tooltips display properly for effects applied by passive abilities
3. Passive abilities that apply status effects continue to function correctly
4. Existing battle mechanics and interactions remain unchanged

## Lessons Learned

1. **Centralized Control Points**: Components like StatusEffectManager should be the sole gateway for their respective domain operations to ensure consistent behavior.

2. **Facade Pattern Value**: The helper function demonstrates the value of facade patterns in ensuring consistent access to subsystems.

3. **Defensive Programming**: Comprehensive validation and fallbacks protect against architectural changes and ensure robust operation.

4. **Event Payload Enrichment**: Components should enrich event payloads with all necessary data before dispatching to avoid downstream workarounds.

5. **Breaking Change Awareness**: The v0.6.3.35 fix created an implicit requirement that StatusEffectManager be used directly, which this change addresses explicitly.

This fix ensures all status effects, regardless of their source, are properly processed and have complete definitions available throughout the system.


===== CHANGELOG_0.6.3.36_DebuggingCleanup =====

# CHANGELOG 0.6.3.36 - Debugging Cleanup

## Issue Description

The game was displaying numerous verbose debugging messages in the console that were tagged as `[DETAILED DEBUG]`. These messages were not causing any functional issues but created unnecessary console spam and potentially impacted performance during battle animations. The debugging outputs were remnants from an unauthorized debugging session (v0.6.3.24) that helped identify and fix the AoE ability text bug, but they were never removed after the fix was implemented.

## Root Cause Analysis

These debug statements were added in v0.6.3.24 as part of an investigation into the AoE ability text display bug, where abilities like "Tidal Wave" or "Frost Chain" were incorrectly showing "Auto Attack" instead of their proper names. While the issue was successfully diagnosed and fixed in v0.6.3.25 and further improved in v0.6.3.26, the debugging code was inadvertently left in the codebase.

The specific debugging statements in question:

1. In `CharacterSprite.js`:
   - Call stack logging in `showActionText()`
   - Detailed ability information logging in `showAttackAnimation()`

2. In `ActionIndicator.js`:
   - Call stack logging in `showAction()`
   - Debug messages in `showAutoAttack()` and `showAbility()`

These statements were marked for removal in the v0.6.3.24 changelog, which stated: "All unauthorized debugging changes should be removed after the investigation is complete."

## Technical Solution

All identified debugging statements were removed from both files:

1. From `CharacterSprite.js`:
   ```javascript
   // Removed from showActionText()
   console.log(`[DETAILED DEBUG] CharacterSprite.showActionText called for ${this.character?.name} with text '${actionText}'`);
   console.log(`[DETAILED DEBUG] Call stack:`, new Error().stack);
   
   // Removed from showAttackAnimation()
   console.log(`[DETAILED DEBUG] CharacterSprite.showAttackAnimation called for ${this.character?.name} targeting ${targetSprite?.character?.name}`);
   console.log(`[DETAILED DEBUG] Character ability info:`, {
       lastUsedAbility: this.character?.lastUsedAbility || 'unknown',
       isAoE: this.character?.lastUsedAbility?.isAoE || false,
       targetType: this.character?.lastUsedAbility?.targetType || 'unknown',
       abilityName: this.character?.lastUsedAbility?.name || 'unknown'
   });
   ```

2. From `ActionIndicator.js`:
   ```javascript
   // Removed from showAction()
   console.log(`[DETAILED DEBUG] ActionIndicator.showAction called with text '${actionText}' for ${this.parent?.character?.name}`);
   console.log(`[DETAILED DEBUG] Call stack:`, new Error().stack);
   
   // Removed from showAutoAttack()
   console.log(`[DETAILED DEBUG] ActionIndicator.showAutoAttack called for ${this.parent?.character?.name}`);
   
   // Removed from showAbility()
   console.log(`[DETAILED DEBUG] ActionIndicator.showAbility called with name '${abilityName}' for ${this.parent?.character?.name}`);
   ```

We kept the normal logging statements (e.g., those prefixed with `CS.showActionText` or controlled by the `window.VERBOSE_LOGGING` flag) as these are part of the standard logging infrastructure.

## Implementation Benefits

1. **Cleaner Console Output**: Removed verbose and redundant debugging messages that were cluttering the console.

2. **Potential Performance Improvement**: Eliminated unnecessary string concatenation and Error stack trace generation that could impact performance during battle animations.

3. **Code Clarity**: Removed code that was specifically marked for removal, bringing the codebase in line with its intended state.

4. **Reduced Network Traffic**: For deployments using remote logging or telemetry, this reduces unnecessary data transmission.

## Testing

Testing should focus on verifying that:

1. The game functions normally after the change
2. The previously noisy `[DETAILED DEBUG]` messages no longer appear in the console
3. Battle animations and action indicators continue to work as expected
4. Standard logging (non-debug) still works correctly

## Lessons Learned

1. **Complete Post-Debugging Cleanup**: After using temporary debugging, ensure all debugging code is removed once the issue is resolved.

2. **Code Review Importance**: Having a code review process that specifically looks for debugging artifacts can prevent them from persisting.

3. **Consistent Logging Strategy**: A well-defined logging strategy with different levels (debug, info, warn, error) can help manage console output more effectively.

4. **Consider Debug Flags**: For future intensive debugging, consider using feature flags (e.g., `window.DEBUG_ACTION_INDICATORS = false`) that can easily disable all related debugging at once.

This cleanup helps maintain code quality and ensures the console remains useful for detecting actual issues rather than being overwhelmed with debugging information from previously resolved issues.


===== CHANGELOG_0.6.3.35_StatusDefinitionPropagationFix =====

# CHANGELOG 0.6.3.35 - Status Effect Definition Propagation Fix

## Issue Description

When passive abilities apply status effects, BattleBridge.js displays console warnings: "BattleBridge: Creating minimal fallback for status effect [status_id]". This indicates that full status effect definitions aren't being propagated properly through the event chain.

## Root Cause Analysis

The issue was identified in how status effect data flows through the component chain:

1. **Data Loss at Source**:
   - Passive behaviors in `PassiveBehaviors.js` call `battleManager.addStatusEffect(ally, statusId, actor, duration, stacks)` with just a status ID but no definition.
   - `StatusEffectManager.addStatusEffect()` correctly retrieves the full definition using `this.definitionLoader.getDefinition(effectId)`.
   - However, it never includes this full definition when dispatching status effect events, causing the definition to be lost in the event flow.

2. **Event Communication Gap**:
   - Events pass through `BattleManager â†’ StatusEffectManager â†’ BattleEventDispatcher â†’ BattleBridge`.
   - While the `BattleEventDispatcher.dispatchStatusEffectAppliedEvent()` method has a parameter for the status definition, it's rarely populated since StatusEffectManager doesn't pass it along.

3. **Fallback Creation in BattleBridge**:
   - When BattleBridge receives a STATUS_EFFECT_APPLIED event without a definition, it attempts multiple fallbacks.
   - When all fallbacks fail, it creates a minimal definition, resulting in the warning messages.

## Technical Solution

The solution directly addresses the root cause by modifying `StatusEffectManager.js` to properly propagate the full status definition it already retrieves:

1. **Added a New Method**: `dispatchStatusEffectApplied(character, statusId, duration, definition, stacks, source)`
   - Specifically designed to dispatch STATUS_EFFECT_APPLIED events with complete status definition data
   - Includes multiple dispatch strategies for maximum compatibility:
     - Direct BattleBridge dispatching
     - BattleManager.dispatchUIEvent fallback
     - BattleEventDispatcher fallback if available

2. **Modified StatusEffectManager.addStatusEffect()**:
   - After successfully creating or updating a status effect, it now calls the new dispatch method
   - Passes the full status definition that was already retrieved earlier in the method
   - Uses appropriate context data (character, stacks, duration, source) for complete event information
   - **Bug Fix**: Fixed variable scope issue for new effects by using conditional dispatch to handle different code paths correctly

## Implementation Details

Added to StatusEffectManager.js:

```javascript
dispatchStatusEffectApplied(character, statusId, duration, definition, stacks = 1, source = null) {
    if (!character || !statusId || !definition) {
        console.warn('[StatusEffectManager] Cannot dispatch STATUS_EFFECT_APPLIED: missing required parameters');
        return;
    }
    
    try {
        // Get bridge instance using correct accessor pattern
        const battleBridge = window.getBattleBridge ? window.getBattleBridge() : window.battleBridge;
        
        if (battleBridge && typeof battleBridge.dispatchEvent === 'function') {
            // Use STATUS_EFFECT_APPLIED event type
            const eventType = battleBridge.eventTypes.STATUS_EFFECT_APPLIED || 'status_effect_applied';
            
            // Dispatch event with full definition included
            battleBridge.dispatchEvent(eventType, {
                character: character,
                statusId: statusId,
                duration: duration,
                stacks: stacks,
                source: source,
                statusDefinition: definition // Include the full definition
            });
            console.log(`[StatusEffectManager] Dispatched STATUS_EFFECT_APPLIED for ${statusId} with full definition`); 
        } else {
            // Fallbacks for other architectural patterns...
        }
    } catch (err) {
        console.error('[StatusEffectManager] Error dispatching STATUS_EFFECT_APPLIED event:', err);
    }
}
```

Modified the existing `addStatusEffect` method to properly handle both existing and new effect code paths:

```javascript
// MODIFIED v0.6.3.35_StatusDefinitionPropagationFix: Dispatch STATUS_EFFECT_APPLIED event with full definition
// Use the appropriate effect object based on which code path was taken
if (existingEffect) {
    // For existing effects, use existingEffect with updated properties
    this.dispatchStatusEffectApplied(character, effectId, existingEffect.duration, definition, existingEffect.stacks || 1, source);
} else {
    // For new effects, we can use duration and stacks directly since we just created it
    // The newEffect variable is scoped inside the else block above and not accessible here
    this.dispatchStatusEffectApplied(character, effectId, duration, definition, stacks, source);
}
```

## Implementation Benefits

1. **Follows Component Responsibility Principle**: The StatusEffectManager, which owns and understands status effects, now properly enriches its events with complete definition data.

2. **No Changes to Callers Required**: Passive behaviors and other code that calls addStatusEffect can continue with their existing parameter pattern - enrichment happens automatically.

3. **Maintains Architectural Integrity**: The fix aligns with the project's event-driven architecture pattern and separation of concerns.

4. **Provides Compatibility**: The implementation includes multiple fallback mechanisms to accommodate different architectural patterns.

5. **Improves UI Integrity**: UI components like tooltips now receive complete status effect data, improving visual feedback.

6. **Eliminates Console Warnings**: The fix removes the "Creating minimal fallback" console warnings by providing proper definitions.

7. **Addresses Variable Scope**: The final implementation correctly handles code path differences without causing variable scope issues.

## Testing Verification

Testing involved:

1. Starting a battle with characters that have passive abilities applying status effects
2. Verifying that no "Creating minimal fallback for status effect" warnings appear in the console
3. Checking that status effect tooltips display properly with complete information
4. Validating that this fix doesn't break existing status effect application logic
5. Testing with different status effect code paths (existing effects vs. new effects)

## Lessons Learned

1. **Component Data Enrichment**: Components should fully enrich data they own before dispatching events.

2. **Event Data Completeness**: Events should include all necessary context data to prevent downstream components from needing to re-acquire information.

3. **Architectural Clarity**: Component responsibilities should be clearly defined - StatusEffectManager should handle all aspects of status effect data, including event payload preparation.

4. **Defensive Coding**: Including thorough validation and multiple fallback mechanisms creates more resilient event-driven systems.

5. **Variable Scope Management**: When working with conditionally created variables in complex methods, always ensure references are valid in all code paths.

6. **Separate Code Paths**: Handle each code path independently to avoid assuming variables defined in one path are available in another.

This fix demonstrates how respecting the architectural principle that "components should enrich data they own before propagating it" leads to more robust and maintainable code.


===== CHANGELOG_0.6.3.34_StatusEffectTooltipFix =====

# CHANGELOG 0.6.3.34 - StatusEffectTooltip Error Fix

## Issue Description

The game was experiencing an intermittent runtime error in the Phaser UI: 
```
Uncaught TypeError: Cannot read properties of null (reading 'cut')
```

The error originated within Phaser's text rendering system but was triggered by our StatusEffectTooltip component when attempting to set text on potentially null text objects. This occurred most frequently during:
- Rapid mouse movements over status effect icons
- Scene transitions or changes that invalidated Phaser text objects
- Status effect application/removal while tooltips were being shown/hidden

## Root Cause Analysis

1. **Missing Null Checks**: The `clearContent()` and `createTooltipContent()` methods were directly operating on Phaser text objects without validating their existence first.

2. **Singleton Pattern Concerns**: As a singleton, the StatusEffectTooltip persisted across operations, but its internal references to scene-specific objects became invalid in certain scenarios.

3. **Invalid Text Objects**: When Phaser tried to access properties (like 'cut' in the minified code) on null text objects, the error occurred.

4. **Scene Transition Vulnerability**: The component had no validation to ensure the scene was still active before attempting operations.

## Technical Solution

### 1. Scene Validity Check in showTooltip()

Added a check at the beginning of the method to verify the scene is valid and active:

```javascript
showTooltip(statusId, definition, position, duration, stacks) {
    // Check if scene is still valid
    if (!this.scene || !this.scene.sys || !this.scene.sys.isActive()) {
        console.warn('[StatusEffectTooltip] Cannot show tooltip, scene is invalid or inactive.');
        return;
    }
    // Rest of method...
}
```

### 2. Robust Null Checks in clearContent()

Added null checks for all object references before attempting operations:

```javascript
clearContent() {
    if (this.titleText) {
        this.titleText.setText('');
    }
    if (this.descText) {
        this.descText.setText('');
    }
    if (this.infoText) {
        this.infoText.setText('');
    }
    if (this.graphics) {
        this.graphics.clear();
    }
}
```

### 3. Defensive Programming in createTooltipContent()

Added comprehensive null checks and fallbacks throughout the method:

```javascript
// Before: this.titleText.setText(formattedTitle);
// After:
if (this.titleText) {
    this.titleText.setText(formattedTitle);
} else {
    console.warn(`[StatusEffectTooltip] Attempted to set text on a null titleText object for statusId: ${title}`);
}
```

Similar checks were added for all text objects and graphics operations.

### 4. Enhanced Lifecycle Management in destroy()

Explicitly nullified references to prevent operations on stale objects:

```javascript
destroy() {
    if (this.currentTween) {
        this.scene.tweens.remove(this.currentTween);
        this.currentTween = null;
    }
    
    if (this.container) {
        this.container.destroy();
        this.container = null;
    }
    
    // Explicitly null out references to child objects
    this.titleText = null;
    this.descText = null;
    this.infoText = null;
    this.graphics = null;
    
    // Remove singleton reference
    if (window.statusEffectTooltip === this) {
        window.statusEffectTooltip = null;
    }
}
```

## Implementation Benefits

1. **Error Prevention**: The code now gracefully handles cases where text objects become null or invalid.

2. **Improved Stability**: Players will no longer encounter the disruptive "Cannot read properties of null" error.

3. **Better Error Diagnostics**: The code now logs specific warnings when it encounters null objects, making debugging easier.

4. **Scene Awareness**: The tooltip now verifies scene validity before attempting operations.

5. **Cleaner Resource Management**: Explicit nullification in destroy() prevents stale references.

## Testing

Testing should focus on scenarios that previously triggered the error:

1. Rapidly moving the mouse over multiple status icons
2. Performing battle actions while hovering over status icons
3. Status effect applications during tooltip display

## Lessons Learned

1. **Defensive Programming is Critical in UI**: User interactions can create unpredictable timing issues, making defensive null checks essential.

2. **Singletons Require Special Care**: When using the singleton pattern, extra attention must be paid to object lifecycle and scene transitions.

3. **Minification Complicates Debugging**: The error referenced 'cut', a minified property name in Phaser, highlighting how minification can obscure the actual issue.

4. **Expect the Unexpected**: Even carefully designed components need to handle edge cases like rapidly triggered events or scene transitions.

5. **Error Logs Provide Clues**: The stack trace revealing StatusEffectTooltip.clearContent was crucial in identifying the source of the issue.

## Future Improvements

Later enhancements could include:

1. A proactive tooltip recreation system that detects and rebuilds missing text objects
2. A formal scene transition handling mechanism for the singleton pattern
3. Event debouncing to prevent rapid tooltip show/hide cycles
4. A more robust approach to singleton management across different scenes


===== CHANGELOG_0.6.3.33_AoEStatResolutionDebugging =====

# CHANGELOG 0.6.3.33 - AoE Stat Resolution Debugging

## Issue Description

After implementing the fix in ActionGenerator.js (v0.6.3.32) to correctly pass damage effects to DamageCalculator, a new issue was revealed: when processing individual targets of AoE abilities like Tidal Wave, the attacker's stats (e.g., Intellect) are resolving to 0 inside DamageCalculator.calculateDamage. This results in the battle log showing correct damage without any stat scaling contribution.

Specifically:

- When DamageCalculator.calculateDamage is called for individual AoE targets, the debug logs show:
  - `[DEBUG-SCALING] PRE-CALCULATION - attackerStat: 0, scaleFactor: 0.5, ability: Tidal Wave, character: Aqualia`
  - `[DEBUG-SCALING] CALCULATION RESULT - statScaling: 0, rounded: 0`

- Despite having the correct:
  - scaling factor (0.5 for Tidal Wave)
  - scaling stat name ("Intellect")
  - character name (Aqualia)

The stat value itself (attackerStat) is 0, which means no additional damage is being added from Aqualia's Intellect.

## Investigation Approach

To diagnose this issue, we've implemented comprehensive debugging in three key areas:

### 1. DamageCalculator.calculateDamage

Enhanced the stat resolution logic with detailed debugging to:
- Log the full attacker object structure
- Check for stat property existence with direct property access
- Try both exact case and case-insensitive matching
- Add detailed warnings when a stat resolves to 0

```javascript
// ADDED DEBUG: Examine attacker object to diagnose stat resolution issues
console.log(`[DamageCalculator DEBUG] Attacker object received:`, JSON.parse(JSON.stringify(attacker)));
console.log(`[DamageCalculator DEBUG] Attacker stats:`, attacker.stats);
console.log(`[DamageCalculator DEBUG] Looking for ${scalingStat} (exact case), and lowercase: ${scalingStat.toLowerCase()}`);

// Check if stat name case sensitivity is causing issues
if (attacker.stats) {
    console.log(`[DamageCalculator DEBUG] Direct property check - attacker.stats.intellect: ${attacker.stats.intellect}`);
    console.log(`[DamageCalculator DEBUG] Direct property check - attacker.stats.strength: ${attacker.stats.strength}`);
    console.log(`[DamageCalculator DEBUG] Direct property check - attacker.stats.spirit: ${attacker.stats.spirit}`);
}
```

### 2. AbilityProcessor.processEffect

Added detailed inspection of the actor object before passing it to DamageCalculator:

```javascript
// Add detailed logging of actor object to diagnose stats issue
console.log(`[AbilityProcessor.processEffect DEBUG] Actor object details:`);
if (actor.stats) {
    console.log(`  - Stats available: true`);
    console.log(`  - Actor.stats.intellect: ${actor.stats.intellect}`);
    console.log(`  - Actor.stats.strength: ${actor.stats.strength}`);
    console.log(`  - Actor.stats.spirit: ${actor.stats.spirit}`);
} else {
    console.log(`  - Stats available: false`);
}
// Check for any team or uniqueId issues
console.log(`  - Actor.team: ${actor.team}`);
console.log(`  - Actor.uniqueId: ${actor.uniqueId}`);
```

### 3. AbilityProcessor.applyActionEffect - AoE Target Processing

Added inspection of the singleAction objects created for individual AoE targets:

```javascript
// DEBUG: Check the actor object in singleAction to diagnose why stats might be missing
console.log(`[AbilityProcessor.applyActionEffect DEBUG] AoE singleAction created:`);
console.log(`  - Actor: ${singleAction.actor?.name}`);
console.log(`  - Actor has stats object: ${!!singleAction.actor?.stats}`);
if (singleAction.actor?.stats) {
    console.log(`  - Actor.stats.intellect: ${singleAction.actor.stats.intellect}`);
    console.log(`  - Actor.stats.strength: ${singleAction.actor.stats.strength}`);
}
console.log(`  - Ability: ${singleAction.ability?.name}`);
console.log(`  - Ability has effects: ${!!singleAction.ability?.effects}`);
```

## Key Improvements

1. **Case-Insensitive Stat Resolution**: 
   - Added case-insensitive matching for stat names
   - Now handles both "Intellect" and "intellect" consistently

2. **Enhanced Object Inspection**:
   - Added full attacker object debugging
   - Explicit property checks rather than just dynamic lookups
   - Chain of verification to pinpoint where data is lost

3. **Clear Warning Messages**:
   - Added explicit warnings when stat resolution fails
   - Shows both the stat name being looked for and the attacker name

4. **AoE Action Object Verification**:
   - Added detailed logging of singleAction objects for AoE targets
   - Verifies both actor stats and ability effects are properly preserved

## Expected Findings

This enhanced debugging should reveal:

1. Whether the actor object passed to DamageCalculator is missing its stats property
2. If there's a case sensitivity issue (e.g., looking for "Intellect" but property is "intellect")
3. If the actor object is somehow different between:
   - Initial action creation in ActionGenerator
   - Individual target processing in AbilityProcessor.applyActionEffect
   - Effect processing in AbilityProcessor.processEffect

Once we identify exactly where and why the attacker's stat information is lost, we can implement a targeted fix to ensure proper stat resolution for all AoE abilities.

## Next Steps After Diagnosis

Based on the debugging results, potential fixes may include:

1. Ensuring proper deep copying of the actor object and its stats when creating singleAction objects
2. Adding normalization of stat names to handle case sensitivity consistently
3. Modifying how actor objects are passed through the ability processing chain

This debugging release is focused on gathering precise diagnostic information to guide the implementation of a permanent fix in the next version.


===== CHANGELOG_0.6.3.32_ActionGeneratorScalingFactorFix =====

# CHANGELOG 0.6.3.32 - ActionGenerator Scaling Factor Fix

## Issue Description

Despite previous fixes to the `DamageCalculator` (v0.6.3.28) to properly handle effect-specific scaling factors, Area of Effect (AoE) abilities like Aqualia's "Frost Chain" were still showing incorrect damage scaling in the battle log. Specifically:

- Frost Chain (which should scale at 40% of Intellect, i.e., `effect.scaleFactor: 0.4`) was showing "(+73 from Intellect)" in the battle log.
- For Aqualia with Intellect 146, this indicated that a 0.5 scaling factor was being used (146 Ã— 0.5 = 73) instead of the intended 0.4 factor (146 Ã— 0.4 = 58.4, rounded to 58).

Despite implementing a proper hierarchical check in DamageCalculator for effect-specific scaling factors, the battle log continued to show incorrect scaling text for AoE abilities.

## Root Cause Analysis

After extensive investigation, the root cause was identified in the `ActionGenerator.js` file:

1. When `ActionGenerator.calculateDamageForAction()` calls `DamageCalculator.calculateDamage()`, it was **only passing three parameters** (attacker, target, ability) and **omitting the crucial fourth parameter** (`effect`):

```javascript
// Before fix - ActionGenerator.calculateDamageForAction()
if (this.damageCalculator) {
    return this.damageCalculator.calculateDamage(attacker, target, ability);
    // Missing fourth 'effect' parameter!
}
```

2. This meant that when initial damage was calculated for an action, the DamageCalculator had no access to the effect-specific scaling factor information and fell back to the default 0.5 scaling factor for spell abilities.

3. The resulting `action.scalingText` property (e.g., "+73 from Intellect") was then propagated throughout the action execution process and ultimately displayed in the battle log, even when processing individual targets of AoE abilities.

4. This issue was particularly problematic for AoE abilities since the initial action's pre-calculated values were being reused for each individual target, causing all targets to display the incorrect scaling factor results.

## Technical Solution

The solution was to modify `ActionGenerator.calculateDamageForAction()` to extract the relevant damage effect from the ability's effects array and pass it as the fourth parameter to DamageCalculator:

```javascript
// Added damage effect extraction
let damageEffect = null;
if (ability && ability.effects && Array.isArray(ability.effects)) {
    // Find the first damage effect in the array
    damageEffect = ability.effects.find(effect => 
        (effect.type === 'Damage' || effect.type === 'damage'));
        
    if (damageEffect) {
        console.log(`[ActionGenerator] Found damage effect for ${ability.name} with scaleFactor: ${damageEffect.scaleFactor}`);
    }
}

// Modified DamageCalculator call to pass the damage effect
if (this.damageCalculator) {
    return this.damageCalculator.calculateDamage(attacker, target, ability, damageEffect);
}
```

This change:
1. Extracts the specific damage effect from the ability's effects array
2. Adds logging to verify the correct scaling factor is found
3. Passes this damage effect to DamageCalculator, allowing it to access the effect-specific scaling factor

## Implementation Benefits

1. **Correct Ability Scaling**: Abilities now use their intended effect-specific scaling factors for damage calculation, ensuring proper balance.

2. **Accurate Battle Log**: The battle log now correctly displays stat contributions (e.g., "+58 from Intellect" for Frost Chain instead of "+73").

3. **Consistent Damage Calculation**: The damage calculation is now consistent with the ability definitions in the character data files.

4. **Maintains Backward Compatibility**: The solution maintains backward compatibility, as the `damageEffect` parameter defaults to `null` in DamageCalculator if no damage effect is found.

5. **Enhanced Debugging Information**: Added helpful logs to verify that damage effects are correctly identified and their scaling factors are properly applied.

## Testing

The changes should be tested by:

1. Starting a battle with Aqualia using "Frost Chain" and "Tidal Wave"
2. Verifying that the battle log shows the correct scaling text:
   - For Frost Chain (with Aqualia's Intellect 146): "+58 from Intellect" instead of "+73"
   - For Tidal Wave (with the same Intellect): "+73 from Intellect" (unchanged, as it should use 0.5 scaling)
3. Confirming that the damage values are calculated accordingly, affecting game balance
4. Testing other AoE abilities to ensure similar accurate scaling

## Lessons Learned

1. **Complete Parameter Chain**: When extracting components and refactoring, ensure all parameters are properly passed through the full call chain.

2. **Effect-Specific Data Propagation**: The AoE ability issue revealed how important it is for effect-specific data to be preserved at each stage of the ability processing pipeline.

3. **Initial Action Creation Impact**: In event-driven systems, data calculated during initial action creation can propagate through the entire system, making upstream errors particularly impactful.

4. **Debugging Technique Value**: The strategic placement of debug logs in earlier versions (0.6.3.29-30) was crucial in identifying this root cause by revealing what was missing from the damage calculation function call.

This fix ensures AoE abilities like Frost Chain now properly respect their defined scaling factors both in actual damage calculation and in the battle log display, improving gameplay balance as originally designed.


===== CHANGELOG_0.6.3.31_TeamBuilderLayoutEnhancement =====

# CHANGELOG 0.6.3.31 - TeamBuilder Layout Enhancement

## Issue Description

The TeamBuilder UI had two significant layout issues:

1. **Overlap between Hero Details and Battle Options**:
   - The hero details section (specifically the abilities display) would overlap with the battle options section when a hero had more than 2 abilities
   - This created a poor visual experience and made it difficult to view all ability information

2. **Unwanted Vertical Scrollbar**:
   - The main UI had a small vertical scrollbar appearing on the right side of the screen
   - This was visually distracting and indicated layout issues in the core UI structure

## Root Cause Analysis

### Overlap Issue Root Causes:
1. **Vertical Layout**: Abilities were being displayed in a single vertical column, consuming too much vertical space
2. **No Defined Boundaries**: There was no clear separation between the hero details and battle options sections
3. **Overflow Handling**: The `#detail-content` div had `overflow-y: hidden` which caused content to be clipped rather than properly accommodated

### Scrollbar Issue Root Causes:
1. **Overflow Settings**: The `.screen` class had `overflow: auto` which allowed scrolling
2. **Height Calculations**: Using `min-height` instead of fixed heights on key containers
3. **Content Overflow**: Content slightly exceeding the viewport height in some cases

## Technical Solution

The solution was implemented in multiple phases:

### Phase 1: Implement 2x2 Grid Layout for Abilities

```css
.detail-abilities {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Create 2 columns */
    grid-gap: 10px; /* Add spacing between grid items */
    margin-bottom: 15px;
}

/* Make the Abilities title span the full grid width */
.detail-abilities h4 {
    grid-column: 1 / -1; /* Span all columns */
}

.ability-box {
    background-color: var(--darker-bg);
    padding: 8px;
    border-radius: 4px;
    margin-bottom: 0; /* Remove bottom margin since grid handles spacing */
    height: 100%; /* Ensure consistent height */
    display: flex;
    flex-direction: column;
}
```

This transformed the abilities display from a single column to a 2x2 grid, significantly reducing the vertical space required.

### Phase 2: Visual Separation Between Sections

```css
#battle-options {
    flex-shrink: 0;
    border-top: 2px solid var(--border);
    padding-top: 15px;
    margin-top: 0;
    background-color: rgba(15, 21, 35, 0.7);
    border-radius: 0 0 8px 8px;
    box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
    overflow-y: visible;
}

/* Add a visible separator between sections */
#battle-options::before {
    content: '';
    display: block;
    width: 90%;
    height: 4px;
    background: linear-gradient(to right, transparent, var(--highlight), transparent);
    margin: -15px auto 15px auto;
    border-radius: 2px;
}
```

These changes added a visual gradient separator and slight background color difference to clearly distinguish the battle options section.

### Phase 3: Battle Options Grid Layout

```css
#battle-modes {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Match the abilities grid */
    grid-gap: 10px;
    margin-bottom: 16px;
}

.battle-mode {
    padding: 10px;
    border-radius: 8px;
    background-color: var(--darker-bg);
    cursor: pointer;
    transition: all 0.3s;
    border: 2px solid transparent;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
```

This made the battle options section use the same grid layout for visual consistency.

### Phase 4: Fix Scrollbar Issue

```css
body {
    margin: 0;
    padding: 0;
    height: 100vh; /* Fixed height instead of min-height */
    width: 100vw;
    background-color: var(--dark-bg);
    color: var(--text);
    font-family: Arial, sans-serif;
    overflow: hidden; /* Prevent scrolling at body level */
}

.screen {
    display: none;
    width: 100%;
    height: 100vh;
    overflow: hidden; /* Prevent scrolling */
}

.main-content {
    display: flex;
    gap: 20px;
    width: 98%;
    max-width: 2000px;
    margin: 0 auto;
    flex: 1;
    height: calc(100vh - 150px); /* Use fixed height instead of min-height */
}
```

These changes fixed the scrollbar by:
1. Using fixed heights instead of minimum heights
2. Setting `overflow: hidden` on key containers
3. Ensuring the layout stays within viewport dimensions

### Phase 5: Add Height Constraint for Detail Content

```css
#detail-content {
    flex-grow: 1;
    max-height: 55vh; /* Constraint for detail content height */
    overflow-y: visible;
    overflow-x: hidden;
    margin-bottom: 15px;
}
```

This final adjustment added a maximum height constraint to the detail content section to ensure it doesn't push the battle options too far down, allowing better balance between sections.

## Implementation Benefits

1. **Efficient Space Usage**: The 2x2 grid layout uses horizontal space more efficiently, allowing display of 4 abilities without overflow
2. **Clear Visual Hierarchy**: The new layout provides clear visual separation between different UI sections
3. **Consistent Design Language**: Grid layouts are used consistently for both abilities and battle options
4. **Eliminated Scrollbar**: Fixed the unwanted scrollbar by properly managing container heights and overflow
5. **Better Balance**: Achieved better vertical balance between hero details and battle options sections

## Testing

Testing the solution involved:
1. Verifying that all 4 abilities are displayed in a 2x2 grid without overlap
2. Confirming no scrollbar appears in the main UI
3. Checking that all battle modes are properly displayed in a matching grid layout
4. Ensuring tooltips and interactive elements still function correctly
5. Testing different heroes to ensure consistent layout across all characters

## Lessons Learned

1. **Grid Layouts for Density**: CSS Grid is excellent for displaying dense information in limited space
2. **Visual Separation**: Clear visual boundaries between functionally different sections improves usability
3. **Fixed vs. Minimum Heights**: Using fixed heights instead of minimum heights provides more predictable layouts
4. **Overflow Control**: Carefully managing overflow at all container levels is critical for preventing unwanted scrollbars
5. **Consistent Patterns**: Using similar layout patterns (like grids) across related UI sections creates visual harmony

This UI enhancement provides a more polished user experience while accommodating the game's expanding content needs, particularly the addition of up to 4 abilities per character.


===== CHANGELOG_0.6.3.30_AbilityProcessorDebugLogging =====

# CHANGELOG 0.6.3.30 - AbilityProcessor Debug Logging

## Issue Investigation

Following our attempts to trace the scaling factor issue with abilities like Frost Chain and Tidal Wave, we've identified a potential problem in how effect-specific scaling factors are handled during AoE ability processing. The original debugging in DamageCalculator.js didn't appear for all targets of AoE abilities, suggesting that the effect object with its specific scaleFactor might not be correctly preserved when processing each target.

## Debugging Approach

We've added targeted debug logging in the `AbilityProcessor.processEffect()` method, specifically in the damage case, to capture what data is being passed to the DamageCalculator for each target of an AoE ability. This will help us trace exactly what's happening with the effect object and its properties when multi-target abilities are processed.

## Implementation Details

The following debug logging was added to `AbilityProcessor.js` within the `processEffect` method's 'Damage' case, right before the call to calculateDamage:

```javascript
// ***** START NEW TEMPORARY LOGGING *****
console.log(`[AbilityProcessor.processEffect DEBUG] Calling calculateDamage for:
        Actor: ${actor.name} (${actor.id})
        Target: ${target.name} (${target.id})
        Ability: ${ability.name}
        Effect Type: ${effect.type}
        Effect Value (Base Damage): ${effect.value}
        Effect scaleFactor: ${effect.scaleFactor}
        Effect scalingStat: ${effect.scalingStat}`);
// ***** END NEW TEMPORARY LOGGING *****
```

This logging captures:
- The actor and target names and IDs
- The ability name
- The effect details including type, base value (damage), and most importantly, the scaling factor and scaling stat

## Expected Insights

This debug logging will help determine:

1. **Whether the effect object is complete**: Does each target of an AoE ability receive a complete effect object with all properties intact?
2. **Scaling factor consistency**: Is the correct scaling factor (0.4 for Frost Chain, 0.5 for Tidal Wave) being passed to the damage calculator for each target?
3. **Object reference integrity**: Are there any inconsistencies between how the original action is processed and how the individual target actions are processed?

## Testing Instructions

1. Start a battle with Aqualia in either player or enemy team
2. Wait for Aqualia to use either Frost Chain or Tidal Wave
3. Observe the console logs with the `[AbilityProcessor.processEffect DEBUG]` prefix
4. Check that each target of the AoE ability shows the expected scaling factor in the logs

## Removal Plan

This logging is clearly marked as temporary with START/END comments. It should be removed once the scaling factor issue is identified and fixed.

## Next Steps

After reviewing the debug logs, we'll potentially need to fix how multi-target actions are processed to ensure that effect-specific properties like scaleFactor are properly preserved when splitting an AoE ability into individual target actions.


===== CHANGELOG_0.6.3.29_ScalingFactorDebugging =====

# CHANGELOG 0.6.3.29 - Scaling Factor Debugging Implementation

## Issue Description

Despite adding a fix for abilities with effect-specific scaling factors in version 0.6.3.28, there appears to be a discrepancy between the logged scaling factor and the actual calculation result. Specifically, for Aqualia's "Frost Chain" ability, the battle log shows "+73 from Intellect" damage contribution, which implies a 0.5 scaling factor is being used rather than the intended 0.4 scaling factor (which would result in approximately "+58 from Intellect").

We need to trace exactly how the scaleFactor is flowing through the damage calculation process to identify where the issue might be occurring.

## Debugging Approach

Strategic debug logging has been added at key points in the `DamageCalculator.js` file to trace the scaling factor from assignment through calculation to final display:

1. **Assignment Verification**: Logging immediately after the scaleFactor is set from effect, ability, or default source.
2. **Pre-Calculation Check**: Logging the inputs (attackerStat and scaleFactor) right before the statScaling calculation occurs.
3. **Calculation Verification**: Logging the actual result of the statScaling calculation and its rounded value.
4. **Scaling Text Verification**: Logging the final values used to generate the scaling text in the battle log.

All debugging logs use a consistent `[DEBUG-SCALING]` prefix for easy filtering in the console.

## Implementation Details

### 1. Verifying scaleFactor Assignment

Added console logging to confirm the scaleFactor value immediately after it's assigned:

```javascript
// Check effect for scale factor first (higher priority)
if (effect && effect.scaleFactor !== undefined) {
    console.log(`[DamageCalculator] Using effect-specific scaleFactor: ${effect.scaleFactor} (from effect)`);
    scaleFactor = effect.scaleFactor;
    // TEMPORARY DEBUG: Verify scaleFactor was correctly set after assignment
    console.log(`[DEBUG-SCALING] After effect assignment, scaleFactor = ${scaleFactor}`);
}
```

Similar logging was added for ability-level and default scaleFactor values.

### 2. Pre-Calculation Verification

Added logging right before the stat scaling calculation to verify the inputs:

```javascript
// TEMPORARY DEBUG: Log values right before calculation to verify inputs
console.log(`[DEBUG-SCALING] PRE-CALCULATION - attackerStat: ${attackerStat}, scaleFactor: ${scaleFactor}, ability: ${ability?.name}, character: ${attacker?.name}`);

// Apply stat scaling to base damage
const statScaling = attackerStat * scaleFactor;
```

### 3. Calculation Result Verification

Added logging right after the calculation to confirm the actual result:

```javascript
// Apply stat scaling to base damage
const statScaling = attackerStat * scaleFactor;

// TEMPORARY DEBUG: Log the actual calculation result
console.log(`[DEBUG-SCALING] CALCULATION RESULT - statScaling: ${statScaling}, rounded: ${Math.round(statScaling)}`);
```

### 4. Scaling Text Verification

Added logging when generating the final text that appears in the battle log:

```javascript
// TEMPORARY DEBUG: Verify the final scaling text values
console.log(`[DEBUG-SCALING] SCALING TEXT - using roundedScaling: ${roundedScaling} for ${scalingStatName} with ability: ${ability?.name}`);

scalingText = `(+${roundedScaling} from ${scalingStatName})`;
```

## Expected Debug Output Pattern

For Aqualia's "Frost Chain" ability with Intellect 146, we should see the following pattern:

1. `[DEBUG-SCALING] After effect assignment, scaleFactor = 0.4`
2. `[DEBUG-SCALING] PRE-CALCULATION - attackerStat: 146, scaleFactor: 0.4, ability: Frost Chain, character: Aqualia`
3. `[DEBUG-SCALING] CALCULATION RESULT - statScaling: 58.4, rounded: 58`
4. `[DEBUG-SCALING] SCALING TEXT - using roundedScaling: 58 for Intellect with ability: Frost Chain`

If we see 0.4 in steps 1-2 but then observe inconsistent values in steps 3-4, we'll know exactly where the issue is occurring.

## Testing Instructions

1. Start a battle with Aqualia in the player team
2. Wait for Aqualia to use Frost Chain
3. Observe the console log for the `[DEBUG-SCALING]` prefix messages
4. Compare the values to identify any inconsistencies in the calculation flow

## Removal Plan

This debugging code is clearly marked as temporary throughout the codebase. Once the issue is identified and fixed, all `[DEBUG-SCALING]` logging statements should be removed in a future update to keep the codebase clean.

## Lessons Learned

When debugging subtle calculation issues, having a complete trace of values through the entire process is invaluable. This approach allows us to:

1. Verify that initial assignments are working correctly
2. Confirm that values persist properly between methods
3. Check for any unintended side effects or overrides
4. Validate that final outputs match what we expect based on inputs

By adding a clear prefix to all debug messages, we make it easier to filter and analyze the specific information we need among other console output.


===== CHANGELOG_0.6.3.28_AbilityScalingFactorFix =====

# CHANGELOG 0.6.3.28 - Ability Scaling Factor Fix

## Issue Description

The battle log showed AoE abilities like Frost Chain dealing more damage than intended: "Aqualia (ally) takes 91 damage (+73 from Intellect)!" 

The damage scaling from Intellect was higher than it should be according to the ability's design. Specifically, the battle log showed "+73 from Intellect" when it should have shown approximately "+58 from Intellect" for Aqualia using Frost Chain.

## Root Cause Analysis

The issue was traced to a missing check in `DamageCalculator.calculateDamage()` for effect-specific scaling factors:

1. **Nested Scaling Factors**: Abilities like Frost Chain define their scaling factor (0.4) within the `effects` array rather than directly on the ability object.

2. **Missing Priority Check**: The damage calculator only checked for `ability.scaleFactor` at the top level of the ability object, not within the effects:

```javascript
// Original Code
// Set scaling factor based on ability type
if (damageType === "spell") {
    scalingStat = "intellect";
    scaleFactor = 0.5; // 50% of intellect adds to damage
}

// Only checked ability-level scaling, missed effect-level scaling
if (ability.scaleFactor !== undefined) {
    scaleFactor = ability.scaleFactor;
}
```

3. **Parameter Ignored**: The function already had an `effect` parameter which was passed correctly from `AbilityProcessor.processEffect()`, but this parameter's scaling data wasn't being checked.

## Technical Solution

The solution was to implement a hierarchical check in `DamageCalculator.calculateDamage()` that prioritizes effect-level scaling factors before falling back to ability-level and finally to defaults:

```javascript
// Set default scaling factor based on ability type
if (damageType === "spell") {
    scalingStat = "intellect";
    scaleFactor = 0.5; // 50% of intellect adds to damage
}

// NEW CODE: Check effect for scale factor first (higher priority)
if (effect && effect.scaleFactor !== undefined) {
    console.log(`[DamageCalculator] Using effect-specific scaleFactor: ${effect.scaleFactor} (from effect)`);
    scaleFactor = effect.scaleFactor;
}
// Use ability's specific scale factor if defined and no effect override
else if (ability.scaleFactor !== undefined) {
    console.log(`[DamageCalculator] Using ability-level scaleFactor: ${ability.scaleFactor} (from ability)`);
    scaleFactor = ability.scaleFactor;
} else {
    console.log(`[DamageCalculator] Using default scaleFactor: ${scaleFactor}`);
}
```

The same hierarchical approach was applied to the `scalingStat` property to ensure consistent handling of all scaling properties.

## Implementation Benefits

1. **Correct Scaling**: Abilities now correctly use their effect-specific scaling factors, ensuring damage is in line with design intentions.

2. **Proper Hierarchical Precedence**: Established a clear hierarchy (effect > ability > default) for all scaling properties.

3. **Diagnostic Visibility**: Added detailed logging to show where scaling values come from, making future debugging easier.

4. **Consistency**: The approach maintains the existing ability data structure while making the calculator properly check all levels.

5. **Better Balance**: Frost Chain now correctly uses 0.4 scaling for Intellect, resulting in approximately 25% less damage from this stat.

## Testing

The changes should be tested by:

1. Starting a battle with Aqualia using Frost Chain
2. Monitoring the console for the correct scaling factor logs
3. Verifying that the battle log shows a reduced contribution from Intellect (around "+58 from Intellect" instead of "+73 from Intellect")
4. Testing other abilities with effect-specific scaling factors to ensure they are also correctly applied

## Lessons Learned

1. **Data Hierarchy Consideration**: When a system uses nested data structures, all levels of the hierarchy should be properly checked.

2. **Parameter Utilization**: Function parameters should be fully utilized for their intended purpose; the `effect` parameter was being passed but not fully leveraged.

3. **Diagnostic Logging**: Adding detailed logging during development helps verify the system is using the correct values.

4. **Change Verification**: Watch for unexpected high/low numbers in battle logs as potential indicators of calculation issues.

This fix ensures all abilities properly follow their defined scaling factors, resulting in more balanced gameplay as originally designed.


===== CHANGELOG_0.6.3.27_PassiveAbilityManagerErrorFix =====

# CHANGELOG 0.6.3.27 - PassiveAbilityManager Error Fix

## Issue Description

An error was occurring at the end of battles when trying to process passive abilities:

```
PassiveAbilityManager.js:35 [PassiveAbilityManager] Invalid character: missing name property
```

The error appeared after the battle victory/defeat was declared, when the system attempted to process the 'onBattleEnd' passive trigger. The error occurred in the `validateCharacter()` method of PassiveAbilityManager, which was receiving an object that did not have a `name` property.

## Root Cause Analysis

The issue had two related causes:

1. **Incorrect Parameter Order**: In `BattleFlowController.endBattle()`, the code was incorrectly passing an object `{ result }` as the character parameter instead of the third (additionalData) parameter:

   ```javascript
   // Incorrect code:
   this.battleManager.processPassiveAbilities('onBattleEnd', { result });
   ```

   When this object reached `PassiveAbilityManager.validateCharacter()`, it failed validation because `{ result: 'victory' }` does not have a `name` property.

2. **Missing Global Trigger**: The 'onBattleEnd' trigger was not included in the `globalTriggers` array in PassiveAbilityManager, which meant the manager wouldn't know to use the `processGlobalPassiveTrigger()` method for this trigger type.

   ```javascript
   // Global triggers list was missing 'onBattleEnd':
   const globalTriggers = ['onTurnStart', 'onTurnEnd'];
   ```

This contrasted with the correct pattern used for other global events, such as turn start and end:

```javascript
// Correct pattern for global triggers:
this.battleManager.processPassiveAbilities('onTurnStart', null, { turnNumber: this.battleManager.currentTurn });
this.battleManager.processPassiveAbilities('onTurnEnd', null, { controller: this });
```

## Technical Solution

The solution involved two changes:

1. **Fixed Parameter Order in BattleFlowController.endBattle()**:
   ```javascript
   // Changed to:
   this.battleManager.processPassiveAbilities('onBattleEnd', null, { result });
   ```
   
   This passes `null` as the character parameter (indicating it's a global trigger) and moves the battle result to the additionalData parameter where it belongs.

2. **Added 'onBattleEnd' to the globalTriggers Array in PassiveAbilityManager**:
   ```javascript
   // Added 'onBattleEnd' to the array:
   const globalTriggers = ['onTurnStart', 'onTurnEnd', 'onBattleEnd'];
   ```
   
   This ensures that when the trigger type is 'onBattleEnd' and the character is null, the manager will use the `processGlobalPassiveTrigger()` method to process the event for all eligible characters.

## Implementation Benefits

1. **Consistent Pattern**: This solution follows the same pattern as other global triggers like 'onTurnStart' and 'onTurnEnd'
2. **Properly Structured Data**: The battle result is now passed in the appropriate additionalData parameter
3. **Global Trigger Support**: The 'onBattleEnd' trigger will now be properly processed for all characters
4. **Error Prevention**: The PassiveAbilityManager no longer tries to validate a non-character object

## Testing

Testing should verify:
1. Battles complete successfully without the error in the console
2. Passive abilities that trigger on battle end are properly executed
3. The battle outcome (victory/defeat/draw) is correctly displayed

## Lessons Learned

1. **Consistent Parameter Order**: Maintain consistent parameter order in method calls to avoid validation errors
2. **Global Trigger Registration**: When adding new global trigger types, ensure they are registered in the appropriate arrays
3. **Pattern Matching**: Follow established patterns for similar operations (like the pattern used in turn-based events)

This fix ensures proper end-of-battle passive ability processing, maintaining consistency across all global trigger events in the game.


===== CHANGELOG_0.6.3.26_ActionIndicatorContextAwareFix =====

# CHANGELOG 0.6.3.26 - ActionIndicator Context-Aware Text Fix

## Issue Description

Area of Effect (AoE) abilities like "Tidal Wave" or "Frost Chain" were displaying "Auto Attack" in the ActionIndicator text instead of the actual ability name due to a hardcoded text override. A temporary fix was implemented in v0.6.3.25 by commenting out the problematic line, but a more robust, context-aware solution was needed.

## Root Cause Recap

The root cause identified in v0.6.3.25 was a hardcoded line in `CharacterSprite.showAttackAnimation()` that explicitly set the action text to "Auto Attack" regardless of the actual action being performed:

```javascript
// This line was causing AoE abilities to display 'Auto Attack' instead of their actual name
this.showActionText('Auto Attack');
```

This line unconditionally overwrote the action text that had been properly set by the CHARACTER_ACTION event in BattleEventManager.onCharacterAction, causing all actions to display as "Auto Attack" during animations.

## Technical Solution

A comprehensive solution was implemented with the following improvements:

1. **Action Context Parameter**: Added an `actionContext` parameter to `CharacterSprite.showAttackAnimation()` to provide explicit information about the action being animated:
   ```javascript
   showAttackAnimation(targetSprite, onComplete, actionContext)
   ```

2. **Conditional Text Display**: Implemented context-aware logic to only set the action text when appropriate:
   ```javascript
   if (actionContext) {
       if (actionContext.actionType === 'autoAttack') {
           this.showActionText('Auto Attack');
       } else if (actionContext.actionType === 'ability') {
           // For abilities, BattleEventManager should have already set the text
           // via the CHARACTER_ACTION event, so we don't override it here
       }
   }
   ```

3. **Parameter Propagation**: Modified the call chain to pass the appropriate action context:
   - `BattleEventManager.onCharacterDamaged` â†’ Creates actionContext based on ability data
   - `BattleScene.showAttackAnimation` â†’ Passes actionContext to CharacterSprite
   - `CharacterSprite.showAttackAnimation` â†’ Uses actionContext to make decisions

4. **Fallback Inference**: Added fallback logic in BattleScene to infer the action type when context isn't provided:
   ```javascript
   if (!actionContext) {
       // Try to infer the action type
       const inferredActionType = attacker.lastUsedAbility ? 'ability' : 'autoAttack';
       const inferredAbilityName = attacker.lastUsedAbility?.name || 'Unknown Ability';
       
       actionContext = {
           actionType: inferredActionType,
           abilityName: inferredAbilityName
       };
   }
   ```

## Implementation Details

### 1. CharacterSprite.js Changes

- Modified signature of `showAttackAnimation` to accept actionContext parameter
- Replaced commented-out line with intelligent context-aware logic
- Added detailed logging for action text decisions
- Implemented warnings for missing context

### 2. BattleScene.js Changes

- Updated `showAttackAnimation` method to accept and propagate the actionContext
- Implemented fallback context generation when not provided
- Added logging for context inference

### 3. BattleEventManager.js Changes

- Enhanced `onCharacterDamaged` to create and pass actionContext
- Added different contexts for abilities vs. auto-attacks
- Improved logging for debugging

## Rationale for this Approach

This solution offers several advantages over the previous fix:

1. **Intentionality**: Makes decisions explicitly based on action type rather than silently omitting code
2. **Correctness**: Ensures "Auto Attack" appears for actual auto-attacks, while preserving ability names
3. **Defensive Programming**: Includes multiple fallback mechanisms and detailed logging
4. **Future Compatibility**: Creates a extensible framework for handling different action types
5. **Architecture Alignment**: Respects the event-driven design where CHARACTER_ACTION events set initial text

## Testing Points

The changes should be tested with:

1. **Auto-Attacks**: Verify "Auto Attack" appears correctly
2. **Single-Target Abilities**: Verify the ability name appears correctly
3. **AoE Abilities**: Verify the ability name appears correctly for all targets
4. **Mixed Scenarios**: Verify correct behavior in sequences of different action types
5. **Edge Cases**: Test behavior when context is missing or incomplete

## Future Improvements

While this implementation resolves the current issue, further enhancements could include:

1. Standardizing the actionContext structure across the entire battle system
2. Adding more action types beyond 'ability' and 'autoAttack' (e.g., 'passive', 'counterattack')
3. Creating a unified ActionContext class with validation and helper methods
4. Adding visual differentiation between different action types

## Lessons Learned

1. **Parameter Enrichment**: Adding context parameters to methods enables more intelligent decisions
2. **Event-Driven Coordination**: The character of an action should be driven by events, not hardcoded
3. **Defensive Fallbacks**: Multiple layers of fallback logic provide resilience
4. **Explicit over Implicit**: Making decisions based on explicit context improves maintainability

This fix addresses a specific issue while laying groundwork for more robust action indication in future development.


