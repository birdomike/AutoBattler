Combined Technical Changelog  (generated 2025-05-10 23:43)

===== CHANGELOG_0.6.3.42_AbilityTypeVisualization =====

# CHANGELOG 0.6.3.42 - Ability Type Visualization Enhancement

## Implementation Goal

The goal of this enhancement was to improve the visual representation of abilities in the hero details panel by coloring each ability box based on its elemental type rather than using a uniform dark background for all abilities. This creates visual consistency between a character's type and their abilities, making it easier for players to identify ability types at a glance.

## Technical Implementation

### Ability Type Detection

The implementation uses a two-step process to determine the appropriate type for each ability:

1. **Effect-Level Type Extraction**: First, we look for a specific damage type in the ability's effects array:

```javascript
// If this is an active ability with effects, try to find a damage type
if (ability.effects && Array.isArray(ability.effects)) {
    // Look for the first damage effect with a damageType
    const damageEffect = ability.effects.find(effect => 
        effect.type === 'Damage' && effect.damageType);
    
    if (damageEffect && damageEffect.damageType) {
        abilityType = damageEffect.damageType;
    }
}
```

2. **Fallback to Character Type**: If no specific damage type is found in the ability's effects (such as for healing or utility abilities), we default to the character's type for visual consistency:

```javascript
let abilityType = hero.type; // Default to character's type
```

### Visual Styling

For each ability box, we apply:

1. **Background Color**: A light tint of the appropriate type color (13% opacity) for subtle differentiation:

```javascript
abilityBox.style.backgroundColor = `${this.typeColors[abilityType]}22`;
```

2. **Left Border**: A slightly more opaque accent (40% opacity) of the same color for better visual distinction:

```javascript
abilityBox.style.borderLeft = `3px solid ${this.typeColors[abilityType]}66`;
```

### Implementation Locations

The changes were made in two locations in TeamBuilderUI.js:

1. The primary `renderHeroDetails()` method for initial character selection
2. The `updateExistingHeroDetails()` method, ensuring the styling persists when switching between characters

## Design Considerations

### Color Intensity

We chose a subtle color implementation with low opacity (13% for background, 40% for border) to:
- Maintain readability of the ability text
- Create visual distinction without overwhelming the UI
- Ensure consistency with the existing UI design language

### Fallback Mechanism

The fallback to character type ensures:
- All abilities have appropriate styling, even utility abilities
- Visual consistency within a character's ability set
- No default dark backgrounds that would disrupt the visual flow

### Left Border Accent

The left border was added to:
- Provide stronger visual differentiation between adjacent abilities
- Create a clear hierarchical structure in the ability grid
- Maintain the established grid layout while adding visual interest

## Testing Results

Testing showed:
- Clear visual distinction between different ability types
- Improved readability of the ability grid
- Successful application of type colors to abilities like:
  - Drakarion's "Flame Strike" (fire type)
  - Aqualia's "Tidal Wave" and "Frost Chain" (water type)
  - Sylvanna's "Vine Whip" (nature type)

No visual discrepancies or UI issues were observed during testing across different character selections and team compositions.

## Future Enhancements

This implementation lays the groundwork for potential future enhancements:

1. **Type-Specific Icons**: Small type icons could be added to each ability
2. **Color-Matched Ability Names**: The ability name could be colored to match the type for stronger visual emphasis
3. **Type-Based Animations**: Hover effects specific to each type could be added

These would build upon the current implementation without requiring significant changes to the core approach.

## Implementation Benefits

1. **Enhanced Visual Hierarchy**: Creates a clearer visual relationship between abilities and their types
2. **Improved Readability**: Makes it easier to scan and identify abilities by type at a glance
3. **Consistent Design Language**: Extends the existing type color system to ability representations
4. **Better User Experience**: Provides additional visual information without requiring more text

## Lessons Learned

1. **Leveraging Existing Color Systems**: Using the already established typeColors object ensured consistency across the application
2. **Defensive Programming**: The implementation includes checks to ensure colors exist before applying them
3. **Visual Subtlety**: Light color tints maintain readability while adding useful information
4. **CSS Opacity Notation**: Hexadecimal opacity notation (e.g., `22` for 13% opacity) is more concise than rgba notation in this context

This enhancement provides a foundation for further visual refinements to the ability system while maintaining a clean, readable interface.


===== CHANGELOG_0.6.3.41_TypeColorSystemExpansion =====

# CHANGELOG 0.6.3.41 - Type Color System Expansion

## Issue Description

The game's elemental type system is designed to support 22 distinct element types as defined in the Version 1.0 Vision document. However, the type colors system in the UI code only included a limited set of colors for the initially implemented types (fire, water, nature, dark, light, and air). As we prepare to add new characters with the remaining elemental types, we needed to expand the color system to include all 22 types with consistent colors across all UI components.

## Implementation Approach

We implemented a comprehensive update to standardize type colors across three key files:

1. **TeamBuilderUI.js** - DOM-based team selection screen
2. **BattleUI.js** - DOM-based battle interface
3. **CharacterSprite.js** - Phaser-based character visualization component

The approach focused on maintaining consistency while ensuring each UI system received the appropriate color format for its rendering needs.

## Technical Details

### 1. TeamBuilderUI.js Changes

Added the full set of type colors to the `typeColors` object in the constructor:

```javascript
this.typeColors = {
    fire: '#ff4757',
    water: '#1e90ff',
    nature: '#2ed573',
    electric: '#F7DF1E',
    ice: '#ADD8E6',
    rock: '#8B4513',
    metal: '#C0C0C0',
    air: '#70a1ff',
    light: '#ffd700',
    dark: '#9900cc',
    psychic: '#DA70D6',
    poison: '#8A2BE2',
    physical: '#CD5C5C',
    arcane: '#7B68EE',
    mechanical: '#778899',
    void: '#2F4F4F',
    crystal: '#AFEEEE',
    storm: '#4682B4',
    ethereal: '#E6E6FA',
    blood: '#8B0000',
    plague: '#556B2F',
    gravity: '#36454F'
};
```

These colors are already used by existing code to:
- Color type filter buttons in the hero selection UI
- Color hero card backgrounds with varying opacity
- Style type text in hero cards and detail views
- Color type tags in the hero details panel

### 2. BattleUI.js Changes

Made two key changes to BattleUI.js:

1. Updated the `typeColors` object in the constructor to match TeamBuilderUI.js:

```javascript
this.typeColors = {
    fire: '#ff4757',
    water: '#1e90ff',
    nature: '#2ed573',
    electric: '#F7DF1E',
    ice: '#ADD8E6',
    rock: '#8B4513',
    metal: '#C0C0C0',
    air: '#70a1ff',
    light: '#ffd700',
    dark: '#9900cc',
    psychic: '#DA70D6',
    poison: '#8A2BE2',
    physical: '#CD5C5C',
    arcane: '#7B68EE',
    mechanical: '#778899',
    void: '#2F4F4F',
    crystal: '#AFEEEE',
    storm: '#4682B4',
    ethereal: '#E6E6FA',
    blood: '#8B0000',
    plague: '#556B2F',
    gravity: '#36454F'
};
```

2. Enhanced the CSS classes for type backgrounds in the `addCustomStyles()` method:

```javascript
/* Type colors for backgrounds */
.bg-fire { background-color: #ff4757; }
.bg-water { background-color: #1e90ff; }
.bg-nature { background-color: #2ed573; }
.bg-electric { background-color: #F7DF1E; }
.bg-ice { background-color: #ADD8E6; }
.bg-rock { background-color: #8B4513; }
.bg-metal { background-color: #C0C0C0; }
.bg-air { background-color: #70a1ff; }
.bg-light { background-color: #ffd700; }
.bg-dark { background-color: #9900cc; }
.bg-psychic { background-color: #DA70D6; }
.bg-poison { background-color: #8A2BE2; }
.bg-physical { background-color: #CD5C5C; }
.bg-arcane { background-color: #7B68EE; }
.bg-mechanical { background-color: #778899; }
.bg-void { background-color: #2F4F4F; }
.bg-crystal { background-color: #AFEEEE; }
.bg-storm { background-color: #4682B4; }
.bg-ethereal { background-color: #E6E6FA; }
.bg-blood { background-color: #8B0000; }
.bg-plague { background-color: #556B2F; }
.bg-gravity { background-color: #36454F; }
```

### 3. CharacterSprite.js Changes

Updated the `getTypeColor()` method to use the exact same colors as the DOM-based UI components, but converted to the Phaser-compatible hexadecimal format:

```javascript
getTypeColor(type) {
    const typeColors = {
        fire: 0xFF4757, water: 0x1E90FF, nature: 0x2ED573,
        electric: 0xF7DF1E, ice: 0xADD8E6, rock: 0x8B4513,
        air: 0x70A1FF, light: 0xFFD700, dark: 0x9900CC,
        metal: 0xC0C0C0, psychic: 0xDA70D6, poison: 0x8A2BE2,
        physical: 0xCD5C5C, arcane: 0x7B68EE, mechanical: 0x778899,
        void: 0x2F4F4F, crystal: 0xAFEEEE, storm: 0x4682B4,
        ethereal: 0xE6E6FA, blood: 0x8B0000, plague: 0x556B2F,
        gravity: 0x36454F, neutral: 0xAAAAAA // Added neutral for placeholder
    };
    // Fallback for undefined or null type
    const safeType = typeof type === 'string' ? type.toLowerCase() : 'neutral';
    return typeColors[safeType] || 0xCCCCCC; // Gray fallback
}
```

## Implementation Benefits

1. **Consistency Across UI Systems**: The same colors are now used consistently across all UI components, ensuring a cohesive visual experience.

2. **Framework-Specific Format Handling**: 
   - DOM-based UIs (TeamBuilderUI.js, BattleUI.js) use CSS hex format with # prefix
   - Phaser components (CharacterSprite.js) use the 0x prefix format that Phaser requires

3. **Future-Proofing**: All 22 element types now have defined colors, allowing new characters of any type to be added without further UI updates.

4. **Reduced Technical Debt**: By implementing all colors now, we avoid creating a backlog of UI updates for each new character type introduction.

5. **Design Consistency**: The type colors are now standardized across the codebase, ensuring that each type has one definitive color.

## Testing Considerations

When testing this change, verify:

1. **Existing Character Display**: Ensure existing character types (fire, water, nature, dark, light, air) continue to display correctly with their original colors in both TeamBuilder and Battle UI.

2. **New Type Support**: Confirm that adding new characters with any of the expanded types (electric, ice, rock, etc.) will automatically use the correct type color.

3. **Visual Consistency**: Verify that the same color values are used consistently across all UI components for each type.

4. **CSS Class Functionality**: Test that the CSS classes (e.g., `.bg-electric`) correctly apply the expected background colors.

## Future Enhancements

While this change provides the necessary foundation for all 22 element types, potential future enhancements could include:

1. **Type Icon System**: Add visual icons for each type to complement the color system.

2. **Type Background Patterns**: Implement subtle background patterns specific to each element type.

3. **Type-Based Animations**: Create type-specific particle effects and animations for abilities.

4. **Color Theme Configuration**: Move type colors to a central configuration file that can be imported by all components, further improving maintainability.

## Conclusion

This update successfully implements the full type color system across all UI components, providing a solid foundation for introducing characters with the remaining element types. The consistent color scheme enhances the visual cohesion of the game while supporting the planned 22-type system defined in the Version 1.0 Vision document.


===== CHANGELOG_0.6.3.39_PassiveTriggerTrackerReferenceHotfix =====

# CHANGELOG 0.6.3.39 - PassiveTriggerTracker Reference Hotfix

## Issue Description

When starting a battle, the console consistently displayed the following warning:
```
BattleInitializer.js:31 [BattleInitializer] PassiveTriggerTracker not available for battle reset
```

While this warning did not break functionality due to the graceful handling in the BattleInitializer, it indicated an architectural issue with dependency references that needed to be addressed.

## Root Cause Analysis

The issue stemmed from a timing problem in the initialization process between BattleInitializer and PassiveTriggerTracker:

1. **Reference Capture During Construction**: In the BattleInitializer constructor, it stored a direct reference to `battleManager.passiveTriggerTracker`:
   ```javascript
   constructor(battleManager) {
       this.battleManager = battleManager;
       
       // Store references to dependencies to avoid frequent property access
       this.passiveTriggerTracker = battleManager.passiveTriggerTracker;
   }
   ```

2. **Initialization Order in BattleManager**: BattleManager initialized its components in a specific order, creating BattleInitializer before PassiveTriggerTracker:
   ```javascript
   // 1a. Initialize BattleInitializer (required component)
   if (window.BattleInitializer) {
       this.battleInitializer = new window.BattleInitializer(this);
       console.log('BattleManager: BattleInitializer initialized');
   }
   
   // ...later...
   
   // 7. Initialize passive system components
   if (window.PassiveTriggerTracker) {
       this.passiveTriggerTracker = new window.PassiveTriggerTracker();
       console.log('BattleManager: PassiveTriggerTracker initialized');
   }
   ```

3. **Stale Reference**: When BattleInitializer's `initializeTeamsAndCharacters()` method was called, it tried to use its locally stored reference to `passiveTriggerTracker`, which was still null because it had captured the reference before PassiveTriggerTracker was initialized in BattleManager:
   ```javascript
   if (this.passiveTriggerTracker) {
       this.passiveTriggerTracker.resetBattleTracking();
   } else {
       console.warn("[BattleInitializer] PassiveTriggerTracker not available for battle reset");
   }
   ```

4. **Graceful Degradation**: While BattleInitializer properly handled the null reference with a warning message, it still indicated an architectural flaw in the initialization process.

## Technical Solution

The solution changed how BattleInitializer accesses the PassiveTriggerTracker, ensuring it always uses the current reference from BattleManager rather than a potentially stale local copy:

```javascript
// Modified code in initializeTeamsAndCharacters()
if (this.battleManager.passiveTriggerTracker) {
    this.battleManager.passiveTriggerTracker.resetBattleTracking();
} else {
    console.warn("[BattleInitializer] PassiveTriggerTracker not available for battle reset (accessed via battleManager)");
}
```

This approach ensures BattleInitializer always accesses the most up-to-date reference to PassiveTriggerTracker, regardless of when it was initialized in BattleManager.

## Implementation Benefits

1. **Eliminated Warning**: The warning no longer appears during battle initialization.

2. **Improved Reference Management**: The code now ensures that dependencies are accessed properly even if initialized after the dependent component.

3. **Maintained Graceful Degradation**: The solution preserves the graceful handling of potentially missing dependencies.

4. **No State Update Required**: The local `this.passiveTriggerTracker` reference can remain in the constructor as it's no longer being used in the critical path.

## Testing Verification

Testing should verify:
1. The warning no longer appears in the console when starting a battle
2. Passive abilities continue to function correctly
3. No new errors are introduced

## Lessons Learned

1. **Dynamic Dependency Resolution**: When components have dependencies that might be initialized later, always access them through their source (e.g., `parentObject.dependency`) rather than storing local references at construction time.

2. **Initialization Order Matters**: Component initialization order is critical when using direct references. Consider more robust patterns like:
   - Lazy loading through getter methods
   - Dependency injection with proper lifecycle management
   - Event-based architecture for loosely coupled components

3. **Graceful Degradation Value**: The original warning-and-continue approach allowed the system to function correctly despite the missing dependency, highlighting the value of defensive programming.

4. **Spot Check Harmless Warnings**: Even warnings that don't break functionality should be addressed, as they often point to architectural issues that could cause more serious problems in the future.

This fix resolves the specific warning while maintaining the existing architecture. Future refactoring could consider implementing more robust dependency management patterns.


===== CHANGELOG_0.6.3.39_BattleEndDetectionFix =====

# CHANGELOG 0.6.3.39 - Battle End Detection Fix

## Issue Description

When a battle was intended to finish after all enemies were defeated, it would sometimes continue indefinitely. During these "zombie battles," the console would display many error messages like:

```
[ActionGenerator] AUTO-ATTACK for Vaelgor: No valid enemy targets found!
[TargetingSystem] No valid targets available for Vaelgor
[ActionGenerator] No valid target found for Vaelgor
```

This occurred because enemy characters with 0 HP were not consistently marked with `isDefeated = true`, causing a mismatch between the battle end detection logic and the battle flow controller's target finding logic.

## Root Cause Analysis

The issue stemmed from inconsistent character defeat state management across the code:

1. **Missing isDefeated Assignment**: When a character's HP reached 0, the system detected it was "killed" but didn't always set the `isDefeated` flag:

   ```javascript
   // In DamageCalculator.applyDamage()
   const killed = oldHealth > 0 && target.currentHp <= 0;
   // But never did: target.isDefeated = killed;
   ```

2. **HP vs isDefeated Discrepancy**: The battle end detection checked both `isDefeated` and `currentHp <= 0`:

   ```javascript
   const enemyDefeated = this.battleManager.enemyTeam.filter(char => char.isDefeated || char.currentHp <= 0).length;
   ```

   But other parts of the code would only check `isDefeated` when determining valid targets.

3. **Inconsistent Setters**: There were multiple paths in the code for handling character defeat, not all of which consistently set both `currentHp = 0` and `isDefeated = true`.

4. **Debugging Logs Confirmation**: Battle logs confirmed the issue showing enemies at 0 HP but battle continuing:
   
   ```
   [Turn 4] Lumina (enemy) takes 11 damage! (HP: 0/117)
   [Turn 4] Lumina (enemy) is defeated! âš°ï¸
   ```
   
   Yet many turns later: 
   ```
   [Turn 25] Enemy Team:
   [Turn 25]   Lumina: HP: 0/117
   ```

## Technical Solution

We implemented a two-part solution:

### 1. Fix in BattleFlowController.checkBattleEnd()

Added a pre-check to ensure characters with 0 HP are properly marked as defeated:

```javascript
async checkBattleEnd() {
    // Ensure all characters with 0 HP are properly marked as defeated
    this.battleManager.playerTeam.forEach(char => {
        if (char.currentHp <= 0 && !char.isDefeated) {
            console.log(`[BattleFlowController.checkBattleEnd] Fixing player character ${char.name} with 0 HP but not marked as defeated`);
            char.isDefeated = true;
        }
    });
    
    this.battleManager.enemyTeam.forEach(char => {
        if (char.currentHp <= 0 && !char.isDefeated) {
            console.log(`[BattleFlowController.checkBattleEnd] Fixing enemy character ${char.name} with 0 HP but not marked as defeated`);
            char.isDefeated = true;
        }
    });
    
    // Rest of the method...
}
```

### 2. Fix in DamageCalculator.applyDamage()

Ensured the `isDefeated` flag is properly set when a character is killed:

```javascript
// Determine if character was killed by this damage and set isDefeated
const killed = oldHealth > 0 && target.currentHp <= 0;

// If killed, ensure isDefeated flag is set
if (killed) {
    console.log(`[DamageCalculator] Character ${target.name} is defeated, setting isDefeated to true`);
    target.isDefeated = true;
}
```

## Implementation Benefits

1. **Consistent State Management**: Characters with 0 HP are now always properly marked as defeated, maintaining a consistent state across the system.

2. **Proper Battle End Detection**: Battles now correctly end when all enemies are defeated, preventing endless battles.

3. **Reduced Console Errors**: Eliminated the flood of "No valid targets" error messages that would appear when battles continued past their proper end point.

4. **Preventive Approach**: The solution not only fixes the current issue but also addresses potential similar issues with player characters.

5. **Defensive Programming**: Added diagnostic logging to reveal when the fix is actively working, making future issues easier to identify.

## Testing Verification

Test cases to verify the fix:

1. **Standard Battle**: Ensure battles end properly when all enemy characters reach 0 HP.
2. **Edge Case - 0 HP Characters**: Verify characters with exactly 0 HP are properly marked as defeated.
3. **Mixed Team States**: Test scenarios where some enemies are defeated and others are still alive to ensure battles continue appropriately.
4. **Console Messages**: Check that diagnostic messages appear when the fix is actively correcting defeat status.

## Lessons Learned

1. **State Consistency**: In systems with multiple components referencing the same state (like character defeat), ensure all components set and check that state consistently.

2. **Defensive Guards**: Use defensive programming techniques like redundant state checking to catch potential inconsistencies before they become issues.

3. **Logging Strategy**: Strategic diagnostic logs make it easier to identify where and when state inconsistencies occur.

4. **Comprehensive Fixes**: Address issues at both the direct cause (DamageCalculator) and the detection point (BattleFlowController) for maximum reliability.

5. **Battle Lifecycle Management**: Complex turn-based systems benefit from explicit state validation at key decision points to prevent zombie processes.

This fix ensures battles reliably end when all enemies reach 0 HP, improving the game's stability and user experience.


===== CHANGELOG_0.6.3.38_BattleLogManagerHealingTypeFix =====

# CHANGELOG 0.6.3.38 - BattleLogManager Healing Type Fix

## Issue Description

The game consistently showed a console warning during healing events:
```
BattleLogManager.js:45 [BattleLogManager] Invalid type 'healing', defaulting to 'default'
```

This warning occurs when `BattleLogManager.logMessage()` receives 'healing' as the `type` parameter, but 'healing' is not included in the `validTypes` array defined in the BattleLogManager constructor. While this doesn't cause functional issues in the game (as the system defaults to 'default' type), it creates unnecessary console noise and indicates a mismatch between message creation and validation.

## Investigation Approach

To diagnose the exact source of the 'healing' message type, we added a `console.trace()` in the BattleLogManager.logMessage method:

```javascript
// Ensure type is valid
if (!this.validTypes.includes(type)) {
    console.warn(`[BattleLogManager] Invalid type '${type}', defaulting to 'default'`);
    if (type === 'healing') { console.trace(`[BattleLogManager] Trace for 'healing' type`); }
    type = 'default';
}
```

This allowed us to capture the complete call stack when the 'healing' type was used, leading us directly to the source of the issue.

## Root Cause Analysis

Based on the stack trace, we identified that the root cause was in the `BattleManager.applyHealing()` method, where the code was using the `healType` parameter directly as the message type when calling `logMessage()`:

```javascript
// In BattleManager.applyHealing()
const message = source
    ? `${targetInfo} is healed for ${actualHealing} HP from ${sourceInfo}'s ${healType}! (HP: ${target.currentHp}/${target.stats.hp})`
    : `${targetInfo} is healed for ${actualHealing} HP from ${healType}! (HP: ${target.currentHp}/${target.stats.hp})`;
this.logMessage(message, healType); // Here 'healing' was used as the message type
```

Since the `healType` parameter defaults to 'healing' in `HealingProcessor.applyHealing()`, this value was being propagated all the way to the message type without validation against `validTypes`.

## Technical Solution

We implemented a simple solution by adding 'healing' to the valid message types in BattleLogManager:

```javascript
// In BattleLogManager.js constructor
this.validTypes = ['default', 'info', 'success', 'action', 'error', 'player', 'enemy', 'status', 'healing'];
```

This approach was chosen over modifying all calling code because:
1. It maintains the semantic meaning of "healing" messages
2. It allows for future styling of healing messages differently from other types
3. It's a smaller, less invasive change than modifying multiple call sites
4. It's more extensible for future healing-related UI enhancements

## Implementation Benefits

1. **Eliminated Console Warnings**: The warning no longer appears during healing events, reducing noise in the developer console
2. **Maintained Semantic Intent**: The original intention of having a distinct 'healing' message type is preserved
3. **Future Styling Options**: With 'healing' as a valid type, we have the option to style healing messages differently in future UI enhancements
4. **Documentation Improvement**: The tracing technique used has been documented for future debugging of similar issues

## Testing Verification

Testing should verify:
1. No more "Invalid type 'healing'" warnings appear in the console when healing occurs
2. Healing messages display correctly in the battle log
3. All existing healing functionality continues to work as expected

## Lessons Learned

1. **Type Validation Points**: When implementing validation systems like message type checking, it's important to ensure all potential types are either included in the validation list or normalized before validation
2. **Console.trace() Value**: Using `console.trace()` is a powerful technique for diagnosing the source of issues in event-driven systems where the call path isn't immediately obvious
3. **Parameter Propagation**: Default parameter values (like `healType = 'healing'`) can propagate through multiple method calls, requiring careful tracking when used for validation
4. **Semantic Message Types**: Using semantically meaningful message types (like 'healing' instead of 'success' or 'default') improves code readability and makes future UI enhancements easier

This fix ensures consistency between message creation and validation, eliminating the console warnings while maintaining the semantic intent of the original code.


===== CHANGELOG_0.6.3.37_PassiveBehaviorsStatusEffectRoutingFix =====

# CHANGELOG 0.6.3.37 - PassiveBehaviors Status Effect Routing Fix

## Issue Description

When passive abilities applied status effects, BattleBridge.js displayed console warnings: "BattleBridge: Creating minimal fallback for status effect [status_id]". This indicated that while the effects were being applied, their full definitions weren't being properly propagated to the UI, resulting in potential visual issues with tooltips and icons.

The issue primarily manifested with Lumina's team buff passive at the start of battle (passive_TeamBuffOnBattleStart) and affected all 11 passive behaviors that directly called battleManager.addStatusEffect().

## Root Cause Analysis

The root cause was identified as a disconnect between the v0.6.3.35 fix in StatusEffectManager.js and the way passive abilities applied status effects:

1. **Direct BattleManager Calls**: PassiveBehaviors.js was making direct calls to battleManager.addStatusEffect() instead of routing through StatusEffectManager:
   ```javascript
   // Example from passive_TeamBuffOnBattleStart
   battleManager.addStatusEffect(ally, statusId, actor, effectDuration, 1);
   ```

2. **Architectural Gap**: While the StatusEffectManager had been enhanced in v0.6.3.35 to include full definitions in events (via the dispatchStatusEffectApplied method), this improvement only worked when StatusEffectManager.addStatusEffect() was called directly. The BattleManager.addStatusEffect() method didn't have the same enhancement.

3. **Different Event Paths**: This created two separate event paths:
   - **Proper Path**: Game logic â†’ StatusEffectManager.addStatusEffect â†’ StatusEffectManager.dispatchStatusEffectApplied â†’ BattleBridge (with full definition)
   - **Incomplete Path**: PassiveBehaviors â†’ BattleManager.addStatusEffect â†’ BattleBridge (without definition, requiring fallback)

## Technical Solution

The solution implemented follows the architectural principle that StatusEffectManager should be the consistent point of entry for applying status effects:

1. **Helper Function Creation**: Created a central helper function in PassiveBehaviors.js that routes all status effect applications through StatusEffectManager when available:

```javascript
/**
 * Helper function to apply status effects through StatusEffectManager
 * Falls back to BattleManager.addStatusEffect if StatusEffectManager isn't accessible
 */
function applyStatusEffect(battleManager, character, effectId, source, duration, stacks = 1) {
    // Parameter validation
    if (!battleManager || !character || !effectId) {
        console.warn('[PassiveBehaviors.applyStatusEffect] Missing required parameters', { 
            hasBattleManager: !!battleManager, 
            hasCharacter: !!character, 
            effectId 
        });
        return false;
    }
    
    // Ensure duration is a number
    if (typeof duration !== 'number') {
        console.warn(`[PassiveBehaviors.applyStatusEffect] Invalid duration (${typeof duration}) for ${effectId} - using default 3`);
        duration = 3;
    }
    
    // Try to use StatusEffectManager first
    if (battleManager.statusEffectManager) {
        console.log(`[PassiveBehaviors] Using StatusEffectManager.addStatusEffect for ${effectId}`);
        return battleManager.statusEffectManager.addStatusEffect(character, effectId, source, duration, stacks);
    } else if (typeof battleManager.getStatusEffectManager === 'function') {
        const statusEffectManager = battleManager.getStatusEffectManager();
        if (statusEffectManager) {
            console.log(`[PassiveBehaviors] Using getStatusEffectManager().addStatusEffect for ${effectId}`);
            return statusEffectManager.addStatusEffect(character, effectId, source, duration, stacks);
        }
    }
    
    // Fall back to BattleManager.addStatusEffect
    console.log(`[PassiveBehaviors] StatusEffectManager not accessible, falling back to BattleManager.addStatusEffect for ${effectId}`);
    return battleManager.addStatusEffect(character, effectId, source, duration, stacks);
}
```

2. **Modifying All Direct Calls**: Updated all 11 instances of direct battleManager.addStatusEffect calls in PassiveBehaviors.js to use the new helper function:

```javascript
// Before:
battleManager.addStatusEffect(actor, 'status_crit_up', actor, 2, 1);

// After:
applyStatusEffect(battleManager, actor, 'status_crit_up', actor, 2, 1);
```

3. **Multiple Access Methods**: Implemented fallback mechanisms to handle different ways BattleManager might expose its StatusEffectManager:
   - Direct property access: `battleManager.statusEffectManager`
   - Getter method: `battleManager.getStatusEffectManager()`
   - Fallback to original method if StatusEffectManager isn't accessible

4. **Parameter Validation**: Added comprehensive parameter validation to catch potential issues early and provide helpful error messages.

## Implementation Benefits

1. **Architectural Alignment**: Solution follows the principle that StatusEffectManager should be the single point of entry for status effect management, aligning with the component-based architecture.

2. **Elimination of Warnings**: The "Creating minimal fallback for status effect" warnings no longer appear since all status effects now flow through the proper channel that includes their definitions.

3. **Improved Tooltip Display**: Status effects applied by passive abilities now display proper tooltips with accurate information when hovered over.

4. **Robust Error Handling**: The helper function includes comprehensive parameter validation and fallbacks to prevent errors.

5. **Defensive Programming**: The implementation follows defensive programming patterns with proper validation and graceful degradation.

6. **Backward Compatibility**: The solution maintains backward compatibility through its fallback mechanisms.

## Testing Verification

Testing should verify:
1. No "Creating minimal fallback" warnings appear in the console during battles
2. Status effect tooltips display properly for effects applied by passive abilities
3. Passive abilities that apply status effects continue to function correctly
4. Existing battle mechanics and interactions remain unchanged

## Lessons Learned

1. **Centralized Control Points**: Components like StatusEffectManager should be the sole gateway for their respective domain operations to ensure consistent behavior.

2. **Facade Pattern Value**: The helper function demonstrates the value of facade patterns in ensuring consistent access to subsystems.

3. **Defensive Programming**: Comprehensive validation and fallbacks protect against architectural changes and ensure robust operation.

4. **Event Payload Enrichment**: Components should enrich event payloads with all necessary data before dispatching to avoid downstream workarounds.

5. **Breaking Change Awareness**: The v0.6.3.35 fix created an implicit requirement that StatusEffectManager be used directly, which this change addresses explicitly.

This fix ensures all status effects, regardless of their source, are properly processed and have complete definitions available throughout the system.


===== CHANGELOG_0.6.3.36_DebuggingCleanup =====

# CHANGELOG 0.6.3.36 - Debugging Cleanup

## Issue Description

The game was displaying numerous verbose debugging messages in the console that were tagged as `[DETAILED DEBUG]`. These messages were not causing any functional issues but created unnecessary console spam and potentially impacted performance during battle animations. The debugging outputs were remnants from an unauthorized debugging session (v0.6.3.24) that helped identify and fix the AoE ability text bug, but they were never removed after the fix was implemented.

## Root Cause Analysis

These debug statements were added in v0.6.3.24 as part of an investigation into the AoE ability text display bug, where abilities like "Tidal Wave" or "Frost Chain" were incorrectly showing "Auto Attack" instead of their proper names. While the issue was successfully diagnosed and fixed in v0.6.3.25 and further improved in v0.6.3.26, the debugging code was inadvertently left in the codebase.

The specific debugging statements in question:

1. In `CharacterSprite.js`:
   - Call stack logging in `showActionText()`
   - Detailed ability information logging in `showAttackAnimation()`

2. In `ActionIndicator.js`:
   - Call stack logging in `showAction()`
   - Debug messages in `showAutoAttack()` and `showAbility()`

These statements were marked for removal in the v0.6.3.24 changelog, which stated: "All unauthorized debugging changes should be removed after the investigation is complete."

## Technical Solution

All identified debugging statements were removed from both files:

1. From `CharacterSprite.js`:
   ```javascript
   // Removed from showActionText()
   console.log(`[DETAILED DEBUG] CharacterSprite.showActionText called for ${this.character?.name} with text '${actionText}'`);
   console.log(`[DETAILED DEBUG] Call stack:`, new Error().stack);
   
   // Removed from showAttackAnimation()
   console.log(`[DETAILED DEBUG] CharacterSprite.showAttackAnimation called for ${this.character?.name} targeting ${targetSprite?.character?.name}`);
   console.log(`[DETAILED DEBUG] Character ability info:`, {
       lastUsedAbility: this.character?.lastUsedAbility || 'unknown',
       isAoE: this.character?.lastUsedAbility?.isAoE || false,
       targetType: this.character?.lastUsedAbility?.targetType || 'unknown',
       abilityName: this.character?.lastUsedAbility?.name || 'unknown'
   });
   ```

2. From `ActionIndicator.js`:
   ```javascript
   // Removed from showAction()
   console.log(`[DETAILED DEBUG] ActionIndicator.showAction called with text '${actionText}' for ${this.parent?.character?.name}`);
   console.log(`[DETAILED DEBUG] Call stack:`, new Error().stack);
   
   // Removed from showAutoAttack()
   console.log(`[DETAILED DEBUG] ActionIndicator.showAutoAttack called for ${this.parent?.character?.name}`);
   
   // Removed from showAbility()
   console.log(`[DETAILED DEBUG] ActionIndicator.showAbility called with name '${abilityName}' for ${this.parent?.character?.name}`);
   ```

We kept the normal logging statements (e.g., those prefixed with `CS.showActionText` or controlled by the `window.VERBOSE_LOGGING` flag) as these are part of the standard logging infrastructure.

## Implementation Benefits

1. **Cleaner Console Output**: Removed verbose and redundant debugging messages that were cluttering the console.

2. **Potential Performance Improvement**: Eliminated unnecessary string concatenation and Error stack trace generation that could impact performance during battle animations.

3. **Code Clarity**: Removed code that was specifically marked for removal, bringing the codebase in line with its intended state.

4. **Reduced Network Traffic**: For deployments using remote logging or telemetry, this reduces unnecessary data transmission.

## Testing

Testing should focus on verifying that:

1. The game functions normally after the change
2. The previously noisy `[DETAILED DEBUG]` messages no longer appear in the console
3. Battle animations and action indicators continue to work as expected
4. Standard logging (non-debug) still works correctly

## Lessons Learned

1. **Complete Post-Debugging Cleanup**: After using temporary debugging, ensure all debugging code is removed once the issue is resolved.

2. **Code Review Importance**: Having a code review process that specifically looks for debugging artifacts can prevent them from persisting.

3. **Consistent Logging Strategy**: A well-defined logging strategy with different levels (debug, info, warn, error) can help manage console output more effectively.

4. **Consider Debug Flags**: For future intensive debugging, consider using feature flags (e.g., `window.DEBUG_ACTION_INDICATORS = false`) that can easily disable all related debugging at once.

This cleanup helps maintain code quality and ensures the console remains useful for detecting actual issues rather than being overwhelmed with debugging information from previously resolved issues.


===== CHANGELOG_0.6.3.35_StatusDefinitionPropagationFix =====

# CHANGELOG 0.6.3.35 - Status Effect Definition Propagation Fix

## Issue Description

When passive abilities apply status effects, BattleBridge.js displays console warnings: "BattleBridge: Creating minimal fallback for status effect [status_id]". This indicates that full status effect definitions aren't being propagated properly through the event chain.

## Root Cause Analysis

The issue was identified in how status effect data flows through the component chain:

1. **Data Loss at Source**:
   - Passive behaviors in `PassiveBehaviors.js` call `battleManager.addStatusEffect(ally, statusId, actor, duration, stacks)` with just a status ID but no definition.
   - `StatusEffectManager.addStatusEffect()` correctly retrieves the full definition using `this.definitionLoader.getDefinition(effectId)`.
   - However, it never includes this full definition when dispatching status effect events, causing the definition to be lost in the event flow.

2. **Event Communication Gap**:
   - Events pass through `BattleManager â†’ StatusEffectManager â†’ BattleEventDispatcher â†’ BattleBridge`.
   - While the `BattleEventDispatcher.dispatchStatusEffectAppliedEvent()` method has a parameter for the status definition, it's rarely populated since StatusEffectManager doesn't pass it along.

3. **Fallback Creation in BattleBridge**:
   - When BattleBridge receives a STATUS_EFFECT_APPLIED event without a definition, it attempts multiple fallbacks.
   - When all fallbacks fail, it creates a minimal definition, resulting in the warning messages.

## Technical Solution

The solution directly addresses the root cause by modifying `StatusEffectManager.js` to properly propagate the full status definition it already retrieves:

1. **Added a New Method**: `dispatchStatusEffectApplied(character, statusId, duration, definition, stacks, source)`
   - Specifically designed to dispatch STATUS_EFFECT_APPLIED events with complete status definition data
   - Includes multiple dispatch strategies for maximum compatibility:
     - Direct BattleBridge dispatching
     - BattleManager.dispatchUIEvent fallback
     - BattleEventDispatcher fallback if available

2. **Modified StatusEffectManager.addStatusEffect()**:
   - After successfully creating or updating a status effect, it now calls the new dispatch method
   - Passes the full status definition that was already retrieved earlier in the method
   - Uses appropriate context data (character, stacks, duration, source) for complete event information
   - **Bug Fix**: Fixed variable scope issue for new effects by using conditional dispatch to handle different code paths correctly

## Implementation Details

Added to StatusEffectManager.js:

```javascript
dispatchStatusEffectApplied(character, statusId, duration, definition, stacks = 1, source = null) {
    if (!character || !statusId || !definition) {
        console.warn('[StatusEffectManager] Cannot dispatch STATUS_EFFECT_APPLIED: missing required parameters');
        return;
    }
    
    try {
        // Get bridge instance using correct accessor pattern
        const battleBridge = window.getBattleBridge ? window.getBattleBridge() : window.battleBridge;
        
        if (battleBridge && typeof battleBridge.dispatchEvent === 'function') {
            // Use STATUS_EFFECT_APPLIED event type
            const eventType = battleBridge.eventTypes.STATUS_EFFECT_APPLIED || 'status_effect_applied';
            
            // Dispatch event with full definition included
            battleBridge.dispatchEvent(eventType, {
                character: character,
                statusId: statusId,
                duration: duration,
                stacks: stacks,
                source: source,
                statusDefinition: definition // Include the full definition
            });
            console.log(`[StatusEffectManager] Dispatched STATUS_EFFECT_APPLIED for ${statusId} with full definition`); 
        } else {
            // Fallbacks for other architectural patterns...
        }
    } catch (err) {
        console.error('[StatusEffectManager] Error dispatching STATUS_EFFECT_APPLIED event:', err);
    }
}
```

Modified the existing `addStatusEffect` method to properly handle both existing and new effect code paths:

```javascript
// MODIFIED v0.6.3.35_StatusDefinitionPropagationFix: Dispatch STATUS_EFFECT_APPLIED event with full definition
// Use the appropriate effect object based on which code path was taken
if (existingEffect) {
    // For existing effects, use existingEffect with updated properties
    this.dispatchStatusEffectApplied(character, effectId, existingEffect.duration, definition, existingEffect.stacks || 1, source);
} else {
    // For new effects, we can use duration and stacks directly since we just created it
    // The newEffect variable is scoped inside the else block above and not accessible here
    this.dispatchStatusEffectApplied(character, effectId, duration, definition, stacks, source);
}
```

## Implementation Benefits

1. **Follows Component Responsibility Principle**: The StatusEffectManager, which owns and understands status effects, now properly enriches its events with complete definition data.

2. **No Changes to Callers Required**: Passive behaviors and other code that calls addStatusEffect can continue with their existing parameter pattern - enrichment happens automatically.

3. **Maintains Architectural Integrity**: The fix aligns with the project's event-driven architecture pattern and separation of concerns.

4. **Provides Compatibility**: The implementation includes multiple fallback mechanisms to accommodate different architectural patterns.

5. **Improves UI Integrity**: UI components like tooltips now receive complete status effect data, improving visual feedback.

6. **Eliminates Console Warnings**: The fix removes the "Creating minimal fallback" console warnings by providing proper definitions.

7. **Addresses Variable Scope**: The final implementation correctly handles code path differences without causing variable scope issues.

## Testing Verification

Testing involved:

1. Starting a battle with characters that have passive abilities applying status effects
2. Verifying that no "Creating minimal fallback for status effect" warnings appear in the console
3. Checking that status effect tooltips display properly with complete information
4. Validating that this fix doesn't break existing status effect application logic
5. Testing with different status effect code paths (existing effects vs. new effects)

## Lessons Learned

1. **Component Data Enrichment**: Components should fully enrich data they own before dispatching events.

2. **Event Data Completeness**: Events should include all necessary context data to prevent downstream components from needing to re-acquire information.

3. **Architectural Clarity**: Component responsibilities should be clearly defined - StatusEffectManager should handle all aspects of status effect data, including event payload preparation.

4. **Defensive Coding**: Including thorough validation and multiple fallback mechanisms creates more resilient event-driven systems.

5. **Variable Scope Management**: When working with conditionally created variables in complex methods, always ensure references are valid in all code paths.

6. **Separate Code Paths**: Handle each code path independently to avoid assuming variables defined in one path are available in another.

This fix demonstrates how respecting the architectural principle that "components should enrich data they own before propagating it" leads to more robust and maintainable code.


===== CHANGELOG_0.6.3.34_StatusEffectTooltipFix =====

# CHANGELOG 0.6.3.34 - StatusEffectTooltip Error Fix

## Issue Description

The game was experiencing an intermittent runtime error in the Phaser UI: 
```
Uncaught TypeError: Cannot read properties of null (reading 'cut')
```

The error originated within Phaser's text rendering system but was triggered by our StatusEffectTooltip component when attempting to set text on potentially null text objects. This occurred most frequently during:
- Rapid mouse movements over status effect icons
- Scene transitions or changes that invalidated Phaser text objects
- Status effect application/removal while tooltips were being shown/hidden

## Root Cause Analysis

1. **Missing Null Checks**: The `clearContent()` and `createTooltipContent()` methods were directly operating on Phaser text objects without validating their existence first.

2. **Singleton Pattern Concerns**: As a singleton, the StatusEffectTooltip persisted across operations, but its internal references to scene-specific objects became invalid in certain scenarios.

3. **Invalid Text Objects**: When Phaser tried to access properties (like 'cut' in the minified code) on null text objects, the error occurred.

4. **Scene Transition Vulnerability**: The component had no validation to ensure the scene was still active before attempting operations.

## Technical Solution

### 1. Scene Validity Check in showTooltip()

Added a check at the beginning of the method to verify the scene is valid and active:

```javascript
showTooltip(statusId, definition, position, duration, stacks) {
    // Check if scene is still valid
    if (!this.scene || !this.scene.sys || !this.scene.sys.isActive()) {
        console.warn('[StatusEffectTooltip] Cannot show tooltip, scene is invalid or inactive.');
        return;
    }
    // Rest of method...
}
```

### 2. Robust Null Checks in clearContent()

Added null checks for all object references before attempting operations:

```javascript
clearContent() {
    if (this.titleText) {
        this.titleText.setText('');
    }
    if (this.descText) {
        this.descText.setText('');
    }
    if (this.infoText) {
        this.infoText.setText('');
    }
    if (this.graphics) {
        this.graphics.clear();
    }
}
```

### 3. Defensive Programming in createTooltipContent()

Added comprehensive null checks and fallbacks throughout the method:

```javascript
// Before: this.titleText.setText(formattedTitle);
// After:
if (this.titleText) {
    this.titleText.setText(formattedTitle);
} else {
    console.warn(`[StatusEffectTooltip] Attempted to set text on a null titleText object for statusId: ${title}`);
}
```

Similar checks were added for all text objects and graphics operations.

### 4. Enhanced Lifecycle Management in destroy()

Explicitly nullified references to prevent operations on stale objects:

```javascript
destroy() {
    if (this.currentTween) {
        this.scene.tweens.remove(this.currentTween);
        this.currentTween = null;
    }
    
    if (this.container) {
        this.container.destroy();
        this.container = null;
    }
    
    // Explicitly null out references to child objects
    this.titleText = null;
    this.descText = null;
    this.infoText = null;
    this.graphics = null;
    
    // Remove singleton reference
    if (window.statusEffectTooltip === this) {
        window.statusEffectTooltip = null;
    }
}
```

## Implementation Benefits

1. **Error Prevention**: The code now gracefully handles cases where text objects become null or invalid.

2. **Improved Stability**: Players will no longer encounter the disruptive "Cannot read properties of null" error.

3. **Better Error Diagnostics**: The code now logs specific warnings when it encounters null objects, making debugging easier.

4. **Scene Awareness**: The tooltip now verifies scene validity before attempting operations.

5. **Cleaner Resource Management**: Explicit nullification in destroy() prevents stale references.

## Testing

Testing should focus on scenarios that previously triggered the error:

1. Rapidly moving the mouse over multiple status icons
2. Performing battle actions while hovering over status icons
3. Status effect applications during tooltip display

## Lessons Learned

1. **Defensive Programming is Critical in UI**: User interactions can create unpredictable timing issues, making defensive null checks essential.

2. **Singletons Require Special Care**: When using the singleton pattern, extra attention must be paid to object lifecycle and scene transitions.

3. **Minification Complicates Debugging**: The error referenced 'cut', a minified property name in Phaser, highlighting how minification can obscure the actual issue.

4. **Expect the Unexpected**: Even carefully designed components need to handle edge cases like rapidly triggered events or scene transitions.

5. **Error Logs Provide Clues**: The stack trace revealing StatusEffectTooltip.clearContent was crucial in identifying the source of the issue.

## Future Improvements

Later enhancements could include:

1. A proactive tooltip recreation system that detects and rebuilds missing text objects
2. A formal scene transition handling mechanism for the singleton pattern
3. Event debouncing to prevent rapid tooltip show/hide cycles
4. A more robust approach to singleton management across different scenes


===== CHANGELOG_0.6.3.33_AoEStatResolutionDebugging =====

# CHANGELOG 0.6.3.33 - AoE Stat Resolution Debugging

## Issue Description

After implementing the fix in ActionGenerator.js (v0.6.3.32) to correctly pass damage effects to DamageCalculator, a new issue was revealed: when processing individual targets of AoE abilities like Tidal Wave, the attacker's stats (e.g., Intellect) are resolving to 0 inside DamageCalculator.calculateDamage. This results in the battle log showing correct damage without any stat scaling contribution.

Specifically:

- When DamageCalculator.calculateDamage is called for individual AoE targets, the debug logs show:
  - `[DEBUG-SCALING] PRE-CALCULATION - attackerStat: 0, scaleFactor: 0.5, ability: Tidal Wave, character: Aqualia`
  - `[DEBUG-SCALING] CALCULATION RESULT - statScaling: 0, rounded: 0`

- Despite having the correct:
  - scaling factor (0.5 for Tidal Wave)
  - scaling stat name ("Intellect")
  - character name (Aqualia)

The stat value itself (attackerStat) is 0, which means no additional damage is being added from Aqualia's Intellect.

## Investigation Approach

To diagnose this issue, we've implemented comprehensive debugging in three key areas:

### 1. DamageCalculator.calculateDamage

Enhanced the stat resolution logic with detailed debugging to:
- Log the full attacker object structure
- Check for stat property existence with direct property access
- Try both exact case and case-insensitive matching
- Add detailed warnings when a stat resolves to 0

```javascript
// ADDED DEBUG: Examine attacker object to diagnose stat resolution issues
console.log(`[DamageCalculator DEBUG] Attacker object received:`, JSON.parse(JSON.stringify(attacker)));
console.log(`[DamageCalculator DEBUG] Attacker stats:`, attacker.stats);
console.log(`[DamageCalculator DEBUG] Looking for ${scalingStat} (exact case), and lowercase: ${scalingStat.toLowerCase()}`);

// Check if stat name case sensitivity is causing issues
if (attacker.stats) {
    console.log(`[DamageCalculator DEBUG] Direct property check - attacker.stats.intellect: ${attacker.stats.intellect}`);
    console.log(`[DamageCalculator DEBUG] Direct property check - attacker.stats.strength: ${attacker.stats.strength}`);
    console.log(`[DamageCalculator DEBUG] Direct property check - attacker.stats.spirit: ${attacker.stats.spirit}`);
}
```

### 2. AbilityProcessor.processEffect

Added detailed inspection of the actor object before passing it to DamageCalculator:

```javascript
// Add detailed logging of actor object to diagnose stats issue
console.log(`[AbilityProcessor.processEffect DEBUG] Actor object details:`);
if (actor.stats) {
    console.log(`  - Stats available: true`);
    console.log(`  - Actor.stats.intellect: ${actor.stats.intellect}`);
    console.log(`  - Actor.stats.strength: ${actor.stats.strength}`);
    console.log(`  - Actor.stats.spirit: ${actor.stats.spirit}`);
} else {
    console.log(`  - Stats available: false`);
}
// Check for any team or uniqueId issues
console.log(`  - Actor.team: ${actor.team}`);
console.log(`  - Actor.uniqueId: ${actor.uniqueId}`);
```

### 3. AbilityProcessor.applyActionEffect - AoE Target Processing

Added inspection of the singleAction objects created for individual AoE targets:

```javascript
// DEBUG: Check the actor object in singleAction to diagnose why stats might be missing
console.log(`[AbilityProcessor.applyActionEffect DEBUG] AoE singleAction created:`);
console.log(`  - Actor: ${singleAction.actor?.name}`);
console.log(`  - Actor has stats object: ${!!singleAction.actor?.stats}`);
if (singleAction.actor?.stats) {
    console.log(`  - Actor.stats.intellect: ${singleAction.actor.stats.intellect}`);
    console.log(`  - Actor.stats.strength: ${singleAction.actor.stats.strength}`);
}
console.log(`  - Ability: ${singleAction.ability?.name}`);
console.log(`  - Ability has effects: ${!!singleAction.ability?.effects}`);
```

## Key Improvements

1. **Case-Insensitive Stat Resolution**: 
   - Added case-insensitive matching for stat names
   - Now handles both "Intellect" and "intellect" consistently

2. **Enhanced Object Inspection**:
   - Added full attacker object debugging
   - Explicit property checks rather than just dynamic lookups
   - Chain of verification to pinpoint where data is lost

3. **Clear Warning Messages**:
   - Added explicit warnings when stat resolution fails
   - Shows both the stat name being looked for and the attacker name

4. **AoE Action Object Verification**:
   - Added detailed logging of singleAction objects for AoE targets
   - Verifies both actor stats and ability effects are properly preserved

## Expected Findings

This enhanced debugging should reveal:

1. Whether the actor object passed to DamageCalculator is missing its stats property
2. If there's a case sensitivity issue (e.g., looking for "Intellect" but property is "intellect")
3. If the actor object is somehow different between:
   - Initial action creation in ActionGenerator
   - Individual target processing in AbilityProcessor.applyActionEffect
   - Effect processing in AbilityProcessor.processEffect

Once we identify exactly where and why the attacker's stat information is lost, we can implement a targeted fix to ensure proper stat resolution for all AoE abilities.

## Next Steps After Diagnosis

Based on the debugging results, potential fixes may include:

1. Ensuring proper deep copying of the actor object and its stats when creating singleAction objects
2. Adding normalization of stat names to handle case sensitivity consistently
3. Modifying how actor objects are passed through the ability processing chain

This debugging release is focused on gathering precise diagnostic information to guide the implementation of a permanent fix in the next version.


===== CHANGELOG_0.6.3.32_ActionGeneratorScalingFactorFix =====

# CHANGELOG 0.6.3.32 - ActionGenerator Scaling Factor Fix

## Issue Description

Despite previous fixes to the `DamageCalculator` (v0.6.3.28) to properly handle effect-specific scaling factors, Area of Effect (AoE) abilities like Aqualia's "Frost Chain" were still showing incorrect damage scaling in the battle log. Specifically:

- Frost Chain (which should scale at 40% of Intellect, i.e., `effect.scaleFactor: 0.4`) was showing "(+73 from Intellect)" in the battle log.
- For Aqualia with Intellect 146, this indicated that a 0.5 scaling factor was being used (146 Ã— 0.5 = 73) instead of the intended 0.4 factor (146 Ã— 0.4 = 58.4, rounded to 58).

Despite implementing a proper hierarchical check in DamageCalculator for effect-specific scaling factors, the battle log continued to show incorrect scaling text for AoE abilities.

## Root Cause Analysis

After extensive investigation, the root cause was identified in the `ActionGenerator.js` file:

1. When `ActionGenerator.calculateDamageForAction()` calls `DamageCalculator.calculateDamage()`, it was **only passing three parameters** (attacker, target, ability) and **omitting the crucial fourth parameter** (`effect`):

```javascript
// Before fix - ActionGenerator.calculateDamageForAction()
if (this.damageCalculator) {
    return this.damageCalculator.calculateDamage(attacker, target, ability);
    // Missing fourth 'effect' parameter!
}
```

2. This meant that when initial damage was calculated for an action, the DamageCalculator had no access to the effect-specific scaling factor information and fell back to the default 0.5 scaling factor for spell abilities.

3. The resulting `action.scalingText` property (e.g., "+73 from Intellect") was then propagated throughout the action execution process and ultimately displayed in the battle log, even when processing individual targets of AoE abilities.

4. This issue was particularly problematic for AoE abilities since the initial action's pre-calculated values were being reused for each individual target, causing all targets to display the incorrect scaling factor results.

## Technical Solution

The solution was to modify `ActionGenerator.calculateDamageForAction()` to extract the relevant damage effect from the ability's effects array and pass it as the fourth parameter to DamageCalculator:

```javascript
// Added damage effect extraction
let damageEffect = null;
if (ability && ability.effects && Array.isArray(ability.effects)) {
    // Find the first damage effect in the array
    damageEffect = ability.effects.find(effect => 
        (effect.type === 'Damage' || effect.type === 'damage'));
        
    if (damageEffect) {
        console.log(`[ActionGenerator] Found damage effect for ${ability.name} with scaleFactor: ${damageEffect.scaleFactor}`);
    }
}

// Modified DamageCalculator call to pass the damage effect
if (this.damageCalculator) {
    return this.damageCalculator.calculateDamage(attacker, target, ability, damageEffect);
}
```

This change:
1. Extracts the specific damage effect from the ability's effects array
2. Adds logging to verify the correct scaling factor is found
3. Passes this damage effect to DamageCalculator, allowing it to access the effect-specific scaling factor

## Implementation Benefits

1. **Correct Ability Scaling**: Abilities now use their intended effect-specific scaling factors for damage calculation, ensuring proper balance.

2. **Accurate Battle Log**: The battle log now correctly displays stat contributions (e.g., "+58 from Intellect" for Frost Chain instead of "+73").

3. **Consistent Damage Calculation**: The damage calculation is now consistent with the ability definitions in the character data files.

4. **Maintains Backward Compatibility**: The solution maintains backward compatibility, as the `damageEffect` parameter defaults to `null` in DamageCalculator if no damage effect is found.

5. **Enhanced Debugging Information**: Added helpful logs to verify that damage effects are correctly identified and their scaling factors are properly applied.

## Testing

The changes should be tested by:

1. Starting a battle with Aqualia using "Frost Chain" and "Tidal Wave"
2. Verifying that the battle log shows the correct scaling text:
   - For Frost Chain (with Aqualia's Intellect 146): "+58 from Intellect" instead of "+73"
   - For Tidal Wave (with the same Intellect): "+73 from Intellect" (unchanged, as it should use 0.5 scaling)
3. Confirming that the damage values are calculated accordingly, affecting game balance
4. Testing other AoE abilities to ensure similar accurate scaling

## Lessons Learned

1. **Complete Parameter Chain**: When extracting components and refactoring, ensure all parameters are properly passed through the full call chain.

2. **Effect-Specific Data Propagation**: The AoE ability issue revealed how important it is for effect-specific data to be preserved at each stage of the ability processing pipeline.

3. **Initial Action Creation Impact**: In event-driven systems, data calculated during initial action creation can propagate through the entire system, making upstream errors particularly impactful.

4. **Debugging Technique Value**: The strategic placement of debug logs in earlier versions (0.6.3.29-30) was crucial in identifying this root cause by revealing what was missing from the damage calculation function call.

This fix ensures AoE abilities like Frost Chain now properly respect their defined scaling factors both in actual damage calculation and in the battle log display, improving gameplay balance as originally designed.


===== CHANGELOG_0.6.3.31_TeamBuilderLayoutEnhancement =====

# CHANGELOG 0.6.3.31 - TeamBuilder Layout Enhancement

## Issue Description

The TeamBuilder UI had two significant layout issues:

1. **Overlap between Hero Details and Battle Options**:
   - The hero details section (specifically the abilities display) would overlap with the battle options section when a hero had more than 2 abilities
   - This created a poor visual experience and made it difficult to view all ability information

2. **Unwanted Vertical Scrollbar**:
   - The main UI had a small vertical scrollbar appearing on the right side of the screen
   - This was visually distracting and indicated layout issues in the core UI structure

## Root Cause Analysis

### Overlap Issue Root Causes:
1. **Vertical Layout**: Abilities were being displayed in a single vertical column, consuming too much vertical space
2. **No Defined Boundaries**: There was no clear separation between the hero details and battle options sections
3. **Overflow Handling**: The `#detail-content` div had `overflow-y: hidden` which caused content to be clipped rather than properly accommodated

### Scrollbar Issue Root Causes:
1. **Overflow Settings**: The `.screen` class had `overflow: auto` which allowed scrolling
2. **Height Calculations**: Using `min-height` instead of fixed heights on key containers
3. **Content Overflow**: Content slightly exceeding the viewport height in some cases

## Technical Solution

The solution was implemented in multiple phases:

### Phase 1: Implement 2x2 Grid Layout for Abilities

```css
.detail-abilities {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Create 2 columns */
    grid-gap: 10px; /* Add spacing between grid items */
    margin-bottom: 15px;
}

/* Make the Abilities title span the full grid width */
.detail-abilities h4 {
    grid-column: 1 / -1; /* Span all columns */
}

.ability-box {
    background-color: var(--darker-bg);
    padding: 8px;
    border-radius: 4px;
    margin-bottom: 0; /* Remove bottom margin since grid handles spacing */
    height: 100%; /* Ensure consistent height */
    display: flex;
    flex-direction: column;
}
```

This transformed the abilities display from a single column to a 2x2 grid, significantly reducing the vertical space required.

### Phase 2: Visual Separation Between Sections

```css
#battle-options {
    flex-shrink: 0;
    border-top: 2px solid var(--border);
    padding-top: 15px;
    margin-top: 0;
    background-color: rgba(15, 21, 35, 0.7);
    border-radius: 0 0 8px 8px;
    box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
    overflow-y: visible;
}

/* Add a visible separator between sections */
#battle-options::before {
    content: '';
    display: block;
    width: 90%;
    height: 4px;
    background: linear-gradient(to right, transparent, var(--highlight), transparent);
    margin: -15px auto 15px auto;
    border-radius: 2px;
}
```

These changes added a visual gradient separator and slight background color difference to clearly distinguish the battle options section.

### Phase 3: Battle Options Grid Layout

```css
#battle-modes {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Match the abilities grid */
    grid-gap: 10px;
    margin-bottom: 16px;
}

.battle-mode {
    padding: 10px;
    border-radius: 8px;
    background-color: var(--darker-bg);
    cursor: pointer;
    transition: all 0.3s;
    border: 2px solid transparent;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
```

This made the battle options section use the same grid layout for visual consistency.

### Phase 4: Fix Scrollbar Issue

```css
body {
    margin: 0;
    padding: 0;
    height: 100vh; /* Fixed height instead of min-height */
    width: 100vw;
    background-color: var(--dark-bg);
    color: var(--text);
    font-family: Arial, sans-serif;
    overflow: hidden; /* Prevent scrolling at body level */
}

.screen {
    display: none;
    width: 100%;
    height: 100vh;
    overflow: hidden; /* Prevent scrolling */
}

.main-content {
    display: flex;
    gap: 20px;
    width: 98%;
    max-width: 2000px;
    margin: 0 auto;
    flex: 1;
    height: calc(100vh - 150px); /* Use fixed height instead of min-height */
}
```

These changes fixed the scrollbar by:
1. Using fixed heights instead of minimum heights
2. Setting `overflow: hidden` on key containers
3. Ensuring the layout stays within viewport dimensions

### Phase 5: Add Height Constraint for Detail Content

```css
#detail-content {
    flex-grow: 1;
    max-height: 55vh; /* Constraint for detail content height */
    overflow-y: visible;
    overflow-x: hidden;
    margin-bottom: 15px;
}
```

This final adjustment added a maximum height constraint to the detail content section to ensure it doesn't push the battle options too far down, allowing better balance between sections.

## Implementation Benefits

1. **Efficient Space Usage**: The 2x2 grid layout uses horizontal space more efficiently, allowing display of 4 abilities without overflow
2. **Clear Visual Hierarchy**: The new layout provides clear visual separation between different UI sections
3. **Consistent Design Language**: Grid layouts are used consistently for both abilities and battle options
4. **Eliminated Scrollbar**: Fixed the unwanted scrollbar by properly managing container heights and overflow
5. **Better Balance**: Achieved better vertical balance between hero details and battle options sections

## Testing

Testing the solution involved:
1. Verifying that all 4 abilities are displayed in a 2x2 grid without overlap
2. Confirming no scrollbar appears in the main UI
3. Checking that all battle modes are properly displayed in a matching grid layout
4. Ensuring tooltips and interactive elements still function correctly
5. Testing different heroes to ensure consistent layout across all characters

## Lessons Learned

1. **Grid Layouts for Density**: CSS Grid is excellent for displaying dense information in limited space
2. **Visual Separation**: Clear visual boundaries between functionally different sections improves usability
3. **Fixed vs. Minimum Heights**: Using fixed heights instead of minimum heights provides more predictable layouts
4. **Overflow Control**: Carefully managing overflow at all container levels is critical for preventing unwanted scrollbars
5. **Consistent Patterns**: Using similar layout patterns (like grids) across related UI sections creates visual harmony

This UI enhancement provides a more polished user experience while accommodating the game's expanding content needs, particularly the addition of up to 4 abilities per character.


